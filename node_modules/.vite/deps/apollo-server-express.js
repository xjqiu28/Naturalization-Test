import {
  __commonJS,
  __esm,
  __export,
  __require,
  __toCommonJS
} from "./chunk-35XAPQLS.js";

// ../../../node_modules/apollo-server-env/dist/index.browser.js
var require_index_browser = __commonJS({
  "../../../node_modules/apollo-server-env/dist/index.browser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.URLSearchParams = exports2.URL = exports2.Headers = exports2.Response = exports2.Request = exports2.fetch = void 0;
    if (!global) {
      global = self;
    }
    var { fetch, Request, Response, Headers, URL, URLSearchParams } = global;
    exports2.fetch = fetch;
    exports2.Request = Request;
    exports2.Response = Response;
    exports2.Headers = Headers;
    exports2.URL = URL;
    exports2.URLSearchParams = URLSearchParams;
    exports2.fetch = fetch = fetch.bind(global);
    if (!global.process) {
      global.process = {};
    }
    if (!global.process.env) {
      global.process.env = {
        NODE_ENV: typeof app !== "undefined" ? app.env : "production"
      };
    }
    if (!global.process.version) {
      global.process.version = "";
    }
    if (!global.process.hrtime) {
      global.process.hrtime = function hrtime(previousTimestamp) {
        var clockTime = Date.now() * 1e-3;
        var seconds = Math.floor(clockTime);
        var nanoseconds = Math.floor(clockTime % 1 * 1e9);
        if (previousTimestamp) {
          seconds = seconds - previousTimestamp[0];
          nanoseconds = nanoseconds - previousTimestamp[1];
          if (nanoseconds < 0) {
            seconds--;
            nanoseconds += 1e9;
          }
        }
        return [seconds, nanoseconds];
      };
    }
    if (!global.os) {
      global.os = {};
    }
  }
});

// ../../../node_modules/graphql/version.mjs
var version, versionInfo;
var init_version = __esm({
  "../../../node_modules/graphql/version.mjs"() {
    version = "16.7.1";
    versionInfo = Object.freeze({
      major: 16,
      minor: 7,
      patch: 1,
      preReleaseTag: null
    });
  }
});

// ../../../node_modules/graphql/jsutils/devAssert.mjs
function devAssert(condition, message) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(message);
  }
}
var init_devAssert = __esm({
  "../../../node_modules/graphql/jsutils/devAssert.mjs"() {
  }
});

// ../../../node_modules/graphql/jsutils/isPromise.mjs
function isPromise(value) {
  return typeof (value === null || value === void 0 ? void 0 : value.then) === "function";
}
var init_isPromise = __esm({
  "../../../node_modules/graphql/jsutils/isPromise.mjs"() {
  }
});

// ../../../node_modules/graphql/jsutils/isObjectLike.mjs
function isObjectLike(value) {
  return typeof value == "object" && value !== null;
}
var init_isObjectLike = __esm({
  "../../../node_modules/graphql/jsutils/isObjectLike.mjs"() {
  }
});

// ../../../node_modules/graphql/jsutils/invariant.mjs
function invariant(condition, message) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(
      message != null ? message : "Unexpected invariant triggered."
    );
  }
}
var init_invariant = __esm({
  "../../../node_modules/graphql/jsutils/invariant.mjs"() {
  }
});

// ../../../node_modules/graphql/language/location.mjs
function getLocation(source, position) {
  let lastLineStart = 0;
  let line = 1;
  for (const match of source.body.matchAll(LineRegExp)) {
    typeof match.index === "number" || invariant(false);
    if (match.index >= position) {
      break;
    }
    lastLineStart = match.index + match[0].length;
    line += 1;
  }
  return {
    line,
    column: position + 1 - lastLineStart
  };
}
var LineRegExp;
var init_location = __esm({
  "../../../node_modules/graphql/language/location.mjs"() {
    init_invariant();
    LineRegExp = /\r\n|[\n\r]/g;
  }
});

// ../../../node_modules/graphql/language/printLocation.mjs
function printLocation(location) {
  return printSourceLocation(
    location.source,
    getLocation(location.source, location.start)
  );
}
function printSourceLocation(source, sourceLocation) {
  const firstLineColumnOffset = source.locationOffset.column - 1;
  const body = "".padStart(firstLineColumnOffset) + source.body;
  const lineIndex = sourceLocation.line - 1;
  const lineOffset = source.locationOffset.line - 1;
  const lineNum = sourceLocation.line + lineOffset;
  const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
  const columnNum = sourceLocation.column + columnOffset;
  const locationStr = `${source.name}:${lineNum}:${columnNum}
`;
  const lines = body.split(/\r\n|[\n\r]/g);
  const locationLine = lines[lineIndex];
  if (locationLine.length > 120) {
    const subLineIndex = Math.floor(columnNum / 80);
    const subLineColumnNum = columnNum % 80;
    const subLines = [];
    for (let i = 0; i < locationLine.length; i += 80) {
      subLines.push(locationLine.slice(i, i + 80));
    }
    return locationStr + printPrefixedLines([
      [`${lineNum} |`, subLines[0]],
      ...subLines.slice(1, subLineIndex + 1).map((subLine) => ["|", subLine]),
      ["|", "^".padStart(subLineColumnNum)],
      ["|", subLines[subLineIndex + 1]]
    ]);
  }
  return locationStr + printPrefixedLines([
    // Lines specified like this: ["prefix", "string"],
    [`${lineNum - 1} |`, lines[lineIndex - 1]],
    [`${lineNum} |`, locationLine],
    ["|", "^".padStart(columnNum)],
    [`${lineNum + 1} |`, lines[lineIndex + 1]]
  ]);
}
function printPrefixedLines(lines) {
  const existingLines = lines.filter(([_, line]) => line !== void 0);
  const padLen = Math.max(...existingLines.map(([prefix]) => prefix.length));
  return existingLines.map(([prefix, line]) => prefix.padStart(padLen) + (line ? " " + line : "")).join("\n");
}
var init_printLocation = __esm({
  "../../../node_modules/graphql/language/printLocation.mjs"() {
    init_location();
  }
});

// ../../../node_modules/graphql/error/GraphQLError.mjs
function toNormalizedOptions(args) {
  const firstArg = args[0];
  if (firstArg == null || "kind" in firstArg || "length" in firstArg) {
    return {
      nodes: firstArg,
      source: args[1],
      positions: args[2],
      path: args[3],
      originalError: args[4],
      extensions: args[5]
    };
  }
  return firstArg;
}
function undefinedIfEmpty(array) {
  return array === void 0 || array.length === 0 ? void 0 : array;
}
function printError(error) {
  return error.toString();
}
function formatError(error) {
  return error.toJSON();
}
var GraphQLError;
var init_GraphQLError = __esm({
  "../../../node_modules/graphql/error/GraphQLError.mjs"() {
    init_isObjectLike();
    init_location();
    init_printLocation();
    GraphQLError = class _GraphQLError extends Error {
      /**
       * An array of `{ line, column }` locations within the source GraphQL document
       * which correspond to this error.
       *
       * Errors during validation often contain multiple locations, for example to
       * point out two things with the same name. Errors during execution include a
       * single location, the field which produced the error.
       *
       * Enumerable, and appears in the result of JSON.stringify().
       */
      /**
       * An array describing the JSON-path into the execution response which
       * corresponds to this error. Only included for errors during execution.
       *
       * Enumerable, and appears in the result of JSON.stringify().
       */
      /**
       * An array of GraphQL AST Nodes corresponding to this error.
       */
      /**
       * The source GraphQL document for the first location of this error.
       *
       * Note that if this Error represents more than one node, the source may not
       * represent nodes after the first node.
       */
      /**
       * An array of character offsets within the source GraphQL document
       * which correspond to this error.
       */
      /**
       * The original error thrown from a field resolver during execution.
       */
      /**
       * Extension fields to add to the formatted error.
       */
      /**
       * @deprecated Please use the `GraphQLErrorOptions` constructor overload instead.
       */
      constructor(message, ...rawArgs) {
        var _this$nodes, _nodeLocations$, _ref;
        const { nodes, source, positions, path, originalError, extensions } = toNormalizedOptions(rawArgs);
        super(message);
        this.name = "GraphQLError";
        this.path = path !== null && path !== void 0 ? path : void 0;
        this.originalError = originalError !== null && originalError !== void 0 ? originalError : void 0;
        this.nodes = undefinedIfEmpty(
          Array.isArray(nodes) ? nodes : nodes ? [nodes] : void 0
        );
        const nodeLocations = undefinedIfEmpty(
          (_this$nodes = this.nodes) === null || _this$nodes === void 0 ? void 0 : _this$nodes.map((node) => node.loc).filter((loc) => loc != null)
        );
        this.source = source !== null && source !== void 0 ? source : nodeLocations === null || nodeLocations === void 0 ? void 0 : (_nodeLocations$ = nodeLocations[0]) === null || _nodeLocations$ === void 0 ? void 0 : _nodeLocations$.source;
        this.positions = positions !== null && positions !== void 0 ? positions : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => loc.start);
        this.locations = positions && source ? positions.map((pos) => getLocation(source, pos)) : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => getLocation(loc.source, loc.start));
        const originalExtensions = isObjectLike(
          originalError === null || originalError === void 0 ? void 0 : originalError.extensions
        ) ? originalError === null || originalError === void 0 ? void 0 : originalError.extensions : void 0;
        this.extensions = (_ref = extensions !== null && extensions !== void 0 ? extensions : originalExtensions) !== null && _ref !== void 0 ? _ref : /* @__PURE__ */ Object.create(null);
        Object.defineProperties(this, {
          message: {
            writable: true,
            enumerable: true
          },
          name: {
            enumerable: false
          },
          nodes: {
            enumerable: false
          },
          source: {
            enumerable: false
          },
          positions: {
            enumerable: false
          },
          originalError: {
            enumerable: false
          }
        });
        if (originalError !== null && originalError !== void 0 && originalError.stack) {
          Object.defineProperty(this, "stack", {
            value: originalError.stack,
            writable: true,
            configurable: true
          });
        } else if (Error.captureStackTrace) {
          Error.captureStackTrace(this, _GraphQLError);
        } else {
          Object.defineProperty(this, "stack", {
            value: Error().stack,
            writable: true,
            configurable: true
          });
        }
      }
      get [Symbol.toStringTag]() {
        return "GraphQLError";
      }
      toString() {
        let output = this.message;
        if (this.nodes) {
          for (const node of this.nodes) {
            if (node.loc) {
              output += "\n\n" + printLocation(node.loc);
            }
          }
        } else if (this.source && this.locations) {
          for (const location of this.locations) {
            output += "\n\n" + printSourceLocation(this.source, location);
          }
        }
        return output;
      }
      toJSON() {
        const formattedError = {
          message: this.message
        };
        if (this.locations != null) {
          formattedError.locations = this.locations;
        }
        if (this.path != null) {
          formattedError.path = this.path;
        }
        if (this.extensions != null && Object.keys(this.extensions).length > 0) {
          formattedError.extensions = this.extensions;
        }
        return formattedError;
      }
    };
  }
});

// ../../../node_modules/graphql/error/syntaxError.mjs
function syntaxError(source, position, description) {
  return new GraphQLError(`Syntax Error: ${description}`, {
    source,
    positions: [position]
  });
}
var init_syntaxError = __esm({
  "../../../node_modules/graphql/error/syntaxError.mjs"() {
    init_GraphQLError();
  }
});

// ../../../node_modules/graphql/language/ast.mjs
function isNode(maybeNode) {
  const maybeKind = maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.kind;
  return typeof maybeKind === "string" && kindValues.has(maybeKind);
}
var Location, Token, QueryDocumentKeys, kindValues, OperationTypeNode;
var init_ast = __esm({
  "../../../node_modules/graphql/language/ast.mjs"() {
    Location = class {
      /**
       * The character offset at which this Node begins.
       */
      /**
       * The character offset at which this Node ends.
       */
      /**
       * The Token at which this Node begins.
       */
      /**
       * The Token at which this Node ends.
       */
      /**
       * The Source document the AST represents.
       */
      constructor(startToken, endToken, source) {
        this.start = startToken.start;
        this.end = endToken.end;
        this.startToken = startToken;
        this.endToken = endToken;
        this.source = source;
      }
      get [Symbol.toStringTag]() {
        return "Location";
      }
      toJSON() {
        return {
          start: this.start,
          end: this.end
        };
      }
    };
    Token = class {
      /**
       * The kind of Token.
       */
      /**
       * The character offset at which this Node begins.
       */
      /**
       * The character offset at which this Node ends.
       */
      /**
       * The 1-indexed line number on which this Token appears.
       */
      /**
       * The 1-indexed column number at which this Token begins.
       */
      /**
       * For non-punctuation tokens, represents the interpreted value of the token.
       *
       * Note: is undefined for punctuation tokens, but typed as string for
       * convenience in the parser.
       */
      /**
       * Tokens exist as nodes in a double-linked-list amongst all tokens
       * including ignored tokens. <SOF> is always the first node and <EOF>
       * the last.
       */
      constructor(kind, start, end, line, column, value) {
        this.kind = kind;
        this.start = start;
        this.end = end;
        this.line = line;
        this.column = column;
        this.value = value;
        this.prev = null;
        this.next = null;
      }
      get [Symbol.toStringTag]() {
        return "Token";
      }
      toJSON() {
        return {
          kind: this.kind,
          value: this.value,
          line: this.line,
          column: this.column
        };
      }
    };
    QueryDocumentKeys = {
      Name: [],
      Document: ["definitions"],
      OperationDefinition: [
        "name",
        "variableDefinitions",
        "directives",
        "selectionSet"
      ],
      VariableDefinition: ["variable", "type", "defaultValue", "directives"],
      Variable: ["name"],
      SelectionSet: ["selections"],
      Field: ["alias", "name", "arguments", "directives", "selectionSet"],
      Argument: ["name", "value"],
      FragmentSpread: ["name", "directives"],
      InlineFragment: ["typeCondition", "directives", "selectionSet"],
      FragmentDefinition: [
        "name",
        // Note: fragment variable definitions are deprecated and will removed in v17.0.0
        "variableDefinitions",
        "typeCondition",
        "directives",
        "selectionSet"
      ],
      IntValue: [],
      FloatValue: [],
      StringValue: [],
      BooleanValue: [],
      NullValue: [],
      EnumValue: [],
      ListValue: ["values"],
      ObjectValue: ["fields"],
      ObjectField: ["name", "value"],
      Directive: ["name", "arguments"],
      NamedType: ["name"],
      ListType: ["type"],
      NonNullType: ["type"],
      SchemaDefinition: ["description", "directives", "operationTypes"],
      OperationTypeDefinition: ["type"],
      ScalarTypeDefinition: ["description", "name", "directives"],
      ObjectTypeDefinition: [
        "description",
        "name",
        "interfaces",
        "directives",
        "fields"
      ],
      FieldDefinition: ["description", "name", "arguments", "type", "directives"],
      InputValueDefinition: [
        "description",
        "name",
        "type",
        "defaultValue",
        "directives"
      ],
      InterfaceTypeDefinition: [
        "description",
        "name",
        "interfaces",
        "directives",
        "fields"
      ],
      UnionTypeDefinition: ["description", "name", "directives", "types"],
      EnumTypeDefinition: ["description", "name", "directives", "values"],
      EnumValueDefinition: ["description", "name", "directives"],
      InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
      DirectiveDefinition: ["description", "name", "arguments", "locations"],
      SchemaExtension: ["directives", "operationTypes"],
      ScalarTypeExtension: ["name", "directives"],
      ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
      InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
      UnionTypeExtension: ["name", "directives", "types"],
      EnumTypeExtension: ["name", "directives", "values"],
      InputObjectTypeExtension: ["name", "directives", "fields"]
    };
    kindValues = new Set(Object.keys(QueryDocumentKeys));
    (function(OperationTypeNode2) {
      OperationTypeNode2["QUERY"] = "query";
      OperationTypeNode2["MUTATION"] = "mutation";
      OperationTypeNode2["SUBSCRIPTION"] = "subscription";
    })(OperationTypeNode || (OperationTypeNode = {}));
  }
});

// ../../../node_modules/graphql/language/directiveLocation.mjs
var DirectiveLocation;
var init_directiveLocation = __esm({
  "../../../node_modules/graphql/language/directiveLocation.mjs"() {
    (function(DirectiveLocation2) {
      DirectiveLocation2["QUERY"] = "QUERY";
      DirectiveLocation2["MUTATION"] = "MUTATION";
      DirectiveLocation2["SUBSCRIPTION"] = "SUBSCRIPTION";
      DirectiveLocation2["FIELD"] = "FIELD";
      DirectiveLocation2["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
      DirectiveLocation2["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
      DirectiveLocation2["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
      DirectiveLocation2["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
      DirectiveLocation2["SCHEMA"] = "SCHEMA";
      DirectiveLocation2["SCALAR"] = "SCALAR";
      DirectiveLocation2["OBJECT"] = "OBJECT";
      DirectiveLocation2["FIELD_DEFINITION"] = "FIELD_DEFINITION";
      DirectiveLocation2["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
      DirectiveLocation2["INTERFACE"] = "INTERFACE";
      DirectiveLocation2["UNION"] = "UNION";
      DirectiveLocation2["ENUM"] = "ENUM";
      DirectiveLocation2["ENUM_VALUE"] = "ENUM_VALUE";
      DirectiveLocation2["INPUT_OBJECT"] = "INPUT_OBJECT";
      DirectiveLocation2["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
    })(DirectiveLocation || (DirectiveLocation = {}));
  }
});

// ../../../node_modules/graphql/language/kinds.mjs
var Kind;
var init_kinds = __esm({
  "../../../node_modules/graphql/language/kinds.mjs"() {
    (function(Kind2) {
      Kind2["NAME"] = "Name";
      Kind2["DOCUMENT"] = "Document";
      Kind2["OPERATION_DEFINITION"] = "OperationDefinition";
      Kind2["VARIABLE_DEFINITION"] = "VariableDefinition";
      Kind2["SELECTION_SET"] = "SelectionSet";
      Kind2["FIELD"] = "Field";
      Kind2["ARGUMENT"] = "Argument";
      Kind2["FRAGMENT_SPREAD"] = "FragmentSpread";
      Kind2["INLINE_FRAGMENT"] = "InlineFragment";
      Kind2["FRAGMENT_DEFINITION"] = "FragmentDefinition";
      Kind2["VARIABLE"] = "Variable";
      Kind2["INT"] = "IntValue";
      Kind2["FLOAT"] = "FloatValue";
      Kind2["STRING"] = "StringValue";
      Kind2["BOOLEAN"] = "BooleanValue";
      Kind2["NULL"] = "NullValue";
      Kind2["ENUM"] = "EnumValue";
      Kind2["LIST"] = "ListValue";
      Kind2["OBJECT"] = "ObjectValue";
      Kind2["OBJECT_FIELD"] = "ObjectField";
      Kind2["DIRECTIVE"] = "Directive";
      Kind2["NAMED_TYPE"] = "NamedType";
      Kind2["LIST_TYPE"] = "ListType";
      Kind2["NON_NULL_TYPE"] = "NonNullType";
      Kind2["SCHEMA_DEFINITION"] = "SchemaDefinition";
      Kind2["OPERATION_TYPE_DEFINITION"] = "OperationTypeDefinition";
      Kind2["SCALAR_TYPE_DEFINITION"] = "ScalarTypeDefinition";
      Kind2["OBJECT_TYPE_DEFINITION"] = "ObjectTypeDefinition";
      Kind2["FIELD_DEFINITION"] = "FieldDefinition";
      Kind2["INPUT_VALUE_DEFINITION"] = "InputValueDefinition";
      Kind2["INTERFACE_TYPE_DEFINITION"] = "InterfaceTypeDefinition";
      Kind2["UNION_TYPE_DEFINITION"] = "UnionTypeDefinition";
      Kind2["ENUM_TYPE_DEFINITION"] = "EnumTypeDefinition";
      Kind2["ENUM_VALUE_DEFINITION"] = "EnumValueDefinition";
      Kind2["INPUT_OBJECT_TYPE_DEFINITION"] = "InputObjectTypeDefinition";
      Kind2["DIRECTIVE_DEFINITION"] = "DirectiveDefinition";
      Kind2["SCHEMA_EXTENSION"] = "SchemaExtension";
      Kind2["SCALAR_TYPE_EXTENSION"] = "ScalarTypeExtension";
      Kind2["OBJECT_TYPE_EXTENSION"] = "ObjectTypeExtension";
      Kind2["INTERFACE_TYPE_EXTENSION"] = "InterfaceTypeExtension";
      Kind2["UNION_TYPE_EXTENSION"] = "UnionTypeExtension";
      Kind2["ENUM_TYPE_EXTENSION"] = "EnumTypeExtension";
      Kind2["INPUT_OBJECT_TYPE_EXTENSION"] = "InputObjectTypeExtension";
    })(Kind || (Kind = {}));
  }
});

// ../../../node_modules/graphql/language/characterClasses.mjs
function isWhiteSpace(code) {
  return code === 9 || code === 32;
}
function isDigit(code) {
  return code >= 48 && code <= 57;
}
function isLetter(code) {
  return code >= 97 && code <= 122 || // A-Z
  code >= 65 && code <= 90;
}
function isNameStart(code) {
  return isLetter(code) || code === 95;
}
function isNameContinue(code) {
  return isLetter(code) || isDigit(code) || code === 95;
}
var init_characterClasses = __esm({
  "../../../node_modules/graphql/language/characterClasses.mjs"() {
  }
});

// ../../../node_modules/graphql/language/blockString.mjs
function dedentBlockStringLines(lines) {
  var _firstNonEmptyLine2;
  let commonIndent = Number.MAX_SAFE_INTEGER;
  let firstNonEmptyLine = null;
  let lastNonEmptyLine = -1;
  for (let i = 0; i < lines.length; ++i) {
    var _firstNonEmptyLine;
    const line = lines[i];
    const indent2 = leadingWhitespace(line);
    if (indent2 === line.length) {
      continue;
    }
    firstNonEmptyLine = (_firstNonEmptyLine = firstNonEmptyLine) !== null && _firstNonEmptyLine !== void 0 ? _firstNonEmptyLine : i;
    lastNonEmptyLine = i;
    if (i !== 0 && indent2 < commonIndent) {
      commonIndent = indent2;
    }
  }
  return lines.map((line, i) => i === 0 ? line : line.slice(commonIndent)).slice(
    (_firstNonEmptyLine2 = firstNonEmptyLine) !== null && _firstNonEmptyLine2 !== void 0 ? _firstNonEmptyLine2 : 0,
    lastNonEmptyLine + 1
  );
}
function leadingWhitespace(str) {
  let i = 0;
  while (i < str.length && isWhiteSpace(str.charCodeAt(i))) {
    ++i;
  }
  return i;
}
function isPrintableAsBlockString(value) {
  if (value === "") {
    return true;
  }
  let isEmptyLine = true;
  let hasIndent = false;
  let hasCommonIndent = true;
  let seenNonEmptyLine = false;
  for (let i = 0; i < value.length; ++i) {
    switch (value.codePointAt(i)) {
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
      case 11:
      case 12:
      case 14:
      case 15:
        return false;
      case 13:
        return false;
      case 10:
        if (isEmptyLine && !seenNonEmptyLine) {
          return false;
        }
        seenNonEmptyLine = true;
        isEmptyLine = true;
        hasIndent = false;
        break;
      case 9:
      case 32:
        hasIndent || (hasIndent = isEmptyLine);
        break;
      default:
        hasCommonIndent && (hasCommonIndent = hasIndent);
        isEmptyLine = false;
    }
  }
  if (isEmptyLine) {
    return false;
  }
  if (hasCommonIndent && seenNonEmptyLine) {
    return false;
  }
  return true;
}
function printBlockString(value, options) {
  const escapedValue = value.replace(/"""/g, '\\"""');
  const lines = escapedValue.split(/\r\n|[\n\r]/g);
  const isSingleLine = lines.length === 1;
  const forceLeadingNewLine = lines.length > 1 && lines.slice(1).every((line) => line.length === 0 || isWhiteSpace(line.charCodeAt(0)));
  const hasTrailingTripleQuotes = escapedValue.endsWith('\\"""');
  const hasTrailingQuote = value.endsWith('"') && !hasTrailingTripleQuotes;
  const hasTrailingSlash = value.endsWith("\\");
  const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;
  const printAsMultipleLines = !(options !== null && options !== void 0 && options.minimize) && // add leading and trailing new lines only if it improves readability
  (!isSingleLine || value.length > 70 || forceTrailingNewline || forceLeadingNewLine || hasTrailingTripleQuotes);
  let result = "";
  const skipLeadingNewLine = isSingleLine && isWhiteSpace(value.charCodeAt(0));
  if (printAsMultipleLines && !skipLeadingNewLine || forceLeadingNewLine) {
    result += "\n";
  }
  result += escapedValue;
  if (printAsMultipleLines || forceTrailingNewline) {
    result += "\n";
  }
  return '"""' + result + '"""';
}
var init_blockString = __esm({
  "../../../node_modules/graphql/language/blockString.mjs"() {
    init_characterClasses();
  }
});

// ../../../node_modules/graphql/language/tokenKind.mjs
var TokenKind;
var init_tokenKind = __esm({
  "../../../node_modules/graphql/language/tokenKind.mjs"() {
    (function(TokenKind2) {
      TokenKind2["SOF"] = "<SOF>";
      TokenKind2["EOF"] = "<EOF>";
      TokenKind2["BANG"] = "!";
      TokenKind2["DOLLAR"] = "$";
      TokenKind2["AMP"] = "&";
      TokenKind2["PAREN_L"] = "(";
      TokenKind2["PAREN_R"] = ")";
      TokenKind2["SPREAD"] = "...";
      TokenKind2["COLON"] = ":";
      TokenKind2["EQUALS"] = "=";
      TokenKind2["AT"] = "@";
      TokenKind2["BRACKET_L"] = "[";
      TokenKind2["BRACKET_R"] = "]";
      TokenKind2["BRACE_L"] = "{";
      TokenKind2["PIPE"] = "|";
      TokenKind2["BRACE_R"] = "}";
      TokenKind2["NAME"] = "Name";
      TokenKind2["INT"] = "Int";
      TokenKind2["FLOAT"] = "Float";
      TokenKind2["STRING"] = "String";
      TokenKind2["BLOCK_STRING"] = "BlockString";
      TokenKind2["COMMENT"] = "Comment";
    })(TokenKind || (TokenKind = {}));
  }
});

// ../../../node_modules/graphql/language/lexer.mjs
function isPunctuatorTokenKind(kind) {
  return kind === TokenKind.BANG || kind === TokenKind.DOLLAR || kind === TokenKind.AMP || kind === TokenKind.PAREN_L || kind === TokenKind.PAREN_R || kind === TokenKind.SPREAD || kind === TokenKind.COLON || kind === TokenKind.EQUALS || kind === TokenKind.AT || kind === TokenKind.BRACKET_L || kind === TokenKind.BRACKET_R || kind === TokenKind.BRACE_L || kind === TokenKind.PIPE || kind === TokenKind.BRACE_R;
}
function isUnicodeScalarValue(code) {
  return code >= 0 && code <= 55295 || code >= 57344 && code <= 1114111;
}
function isSupplementaryCodePoint(body, location) {
  return isLeadingSurrogate(body.charCodeAt(location)) && isTrailingSurrogate(body.charCodeAt(location + 1));
}
function isLeadingSurrogate(code) {
  return code >= 55296 && code <= 56319;
}
function isTrailingSurrogate(code) {
  return code >= 56320 && code <= 57343;
}
function printCodePointAt(lexer, location) {
  const code = lexer.source.body.codePointAt(location);
  if (code === void 0) {
    return TokenKind.EOF;
  } else if (code >= 32 && code <= 126) {
    const char = String.fromCodePoint(code);
    return char === '"' ? `'"'` : `"${char}"`;
  }
  return "U+" + code.toString(16).toUpperCase().padStart(4, "0");
}
function createToken(lexer, kind, start, end, value) {
  const line = lexer.line;
  const col = 1 + start - lexer.lineStart;
  return new Token(kind, start, end, line, col, value);
}
function readNextToken(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start;
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    switch (code) {
      case 65279:
      case 9:
      case 32:
      case 44:
        ++position;
        continue;
      case 10:
        ++position;
        ++lexer.line;
        lexer.lineStart = position;
        continue;
      case 13:
        if (body.charCodeAt(position + 1) === 10) {
          position += 2;
        } else {
          ++position;
        }
        ++lexer.line;
        lexer.lineStart = position;
        continue;
      case 35:
        return readComment(lexer, position);
      case 33:
        return createToken(lexer, TokenKind.BANG, position, position + 1);
      case 36:
        return createToken(lexer, TokenKind.DOLLAR, position, position + 1);
      case 38:
        return createToken(lexer, TokenKind.AMP, position, position + 1);
      case 40:
        return createToken(lexer, TokenKind.PAREN_L, position, position + 1);
      case 41:
        return createToken(lexer, TokenKind.PAREN_R, position, position + 1);
      case 46:
        if (body.charCodeAt(position + 1) === 46 && body.charCodeAt(position + 2) === 46) {
          return createToken(lexer, TokenKind.SPREAD, position, position + 3);
        }
        break;
      case 58:
        return createToken(lexer, TokenKind.COLON, position, position + 1);
      case 61:
        return createToken(lexer, TokenKind.EQUALS, position, position + 1);
      case 64:
        return createToken(lexer, TokenKind.AT, position, position + 1);
      case 91:
        return createToken(lexer, TokenKind.BRACKET_L, position, position + 1);
      case 93:
        return createToken(lexer, TokenKind.BRACKET_R, position, position + 1);
      case 123:
        return createToken(lexer, TokenKind.BRACE_L, position, position + 1);
      case 124:
        return createToken(lexer, TokenKind.PIPE, position, position + 1);
      case 125:
        return createToken(lexer, TokenKind.BRACE_R, position, position + 1);
      case 34:
        if (body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
          return readBlockString(lexer, position);
        }
        return readString(lexer, position);
    }
    if (isDigit(code) || code === 45) {
      return readNumber(lexer, position, code);
    }
    if (isNameStart(code)) {
      return readName(lexer, position);
    }
    throw syntaxError(
      lexer.source,
      position,
      code === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (")?` : isUnicodeScalarValue(code) || isSupplementaryCodePoint(body, position) ? `Unexpected character: ${printCodePointAt(lexer, position)}.` : `Invalid character: ${printCodePointAt(lexer, position)}.`
    );
  }
  return createToken(lexer, TokenKind.EOF, bodyLength, bodyLength);
}
function readComment(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start + 1;
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (code === 10 || code === 13) {
      break;
    }
    if (isUnicodeScalarValue(code)) {
      ++position;
    } else if (isSupplementaryCodePoint(body, position)) {
      position += 2;
    } else {
      break;
    }
  }
  return createToken(
    lexer,
    TokenKind.COMMENT,
    start,
    position,
    body.slice(start + 1, position)
  );
}
function readNumber(lexer, start, firstCode) {
  const body = lexer.source.body;
  let position = start;
  let code = firstCode;
  let isFloat = false;
  if (code === 45) {
    code = body.charCodeAt(++position);
  }
  if (code === 48) {
    code = body.charCodeAt(++position);
    if (isDigit(code)) {
      throw syntaxError(
        lexer.source,
        position,
        `Invalid number, unexpected digit after 0: ${printCodePointAt(
          lexer,
          position
        )}.`
      );
    }
  } else {
    position = readDigits(lexer, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 46) {
    isFloat = true;
    code = body.charCodeAt(++position);
    position = readDigits(lexer, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 69 || code === 101) {
    isFloat = true;
    code = body.charCodeAt(++position);
    if (code === 43 || code === 45) {
      code = body.charCodeAt(++position);
    }
    position = readDigits(lexer, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 46 || isNameStart(code)) {
    throw syntaxError(
      lexer.source,
      position,
      `Invalid number, expected digit but got: ${printCodePointAt(
        lexer,
        position
      )}.`
    );
  }
  return createToken(
    lexer,
    isFloat ? TokenKind.FLOAT : TokenKind.INT,
    start,
    position,
    body.slice(start, position)
  );
}
function readDigits(lexer, start, firstCode) {
  if (!isDigit(firstCode)) {
    throw syntaxError(
      lexer.source,
      start,
      `Invalid number, expected digit but got: ${printCodePointAt(
        lexer,
        start
      )}.`
    );
  }
  const body = lexer.source.body;
  let position = start + 1;
  while (isDigit(body.charCodeAt(position))) {
    ++position;
  }
  return position;
}
function readString(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start + 1;
  let chunkStart = position;
  let value = "";
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (code === 34) {
      value += body.slice(chunkStart, position);
      return createToken(lexer, TokenKind.STRING, start, position + 1, value);
    }
    if (code === 92) {
      value += body.slice(chunkStart, position);
      const escape2 = body.charCodeAt(position + 1) === 117 ? body.charCodeAt(position + 2) === 123 ? readEscapedUnicodeVariableWidth(lexer, position) : readEscapedUnicodeFixedWidth(lexer, position) : readEscapedCharacter(lexer, position);
      value += escape2.value;
      position += escape2.size;
      chunkStart = position;
      continue;
    }
    if (code === 10 || code === 13) {
      break;
    }
    if (isUnicodeScalarValue(code)) {
      ++position;
    } else if (isSupplementaryCodePoint(body, position)) {
      position += 2;
    } else {
      throw syntaxError(
        lexer.source,
        position,
        `Invalid character within String: ${printCodePointAt(
          lexer,
          position
        )}.`
      );
    }
  }
  throw syntaxError(lexer.source, position, "Unterminated string.");
}
function readEscapedUnicodeVariableWidth(lexer, position) {
  const body = lexer.source.body;
  let point = 0;
  let size = 3;
  while (size < 12) {
    const code = body.charCodeAt(position + size++);
    if (code === 125) {
      if (size < 5 || !isUnicodeScalarValue(point)) {
        break;
      }
      return {
        value: String.fromCodePoint(point),
        size
      };
    }
    point = point << 4 | readHexDigit(code);
    if (point < 0) {
      break;
    }
  }
  throw syntaxError(
    lexer.source,
    position,
    `Invalid Unicode escape sequence: "${body.slice(
      position,
      position + size
    )}".`
  );
}
function readEscapedUnicodeFixedWidth(lexer, position) {
  const body = lexer.source.body;
  const code = read16BitHexCode(body, position + 2);
  if (isUnicodeScalarValue(code)) {
    return {
      value: String.fromCodePoint(code),
      size: 6
    };
  }
  if (isLeadingSurrogate(code)) {
    if (body.charCodeAt(position + 6) === 92 && body.charCodeAt(position + 7) === 117) {
      const trailingCode = read16BitHexCode(body, position + 8);
      if (isTrailingSurrogate(trailingCode)) {
        return {
          value: String.fromCodePoint(code, trailingCode),
          size: 12
        };
      }
    }
  }
  throw syntaxError(
    lexer.source,
    position,
    `Invalid Unicode escape sequence: "${body.slice(position, position + 6)}".`
  );
}
function read16BitHexCode(body, position) {
  return readHexDigit(body.charCodeAt(position)) << 12 | readHexDigit(body.charCodeAt(position + 1)) << 8 | readHexDigit(body.charCodeAt(position + 2)) << 4 | readHexDigit(body.charCodeAt(position + 3));
}
function readHexDigit(code) {
  return code >= 48 && code <= 57 ? code - 48 : code >= 65 && code <= 70 ? code - 55 : code >= 97 && code <= 102 ? code - 87 : -1;
}
function readEscapedCharacter(lexer, position) {
  const body = lexer.source.body;
  const code = body.charCodeAt(position + 1);
  switch (code) {
    case 34:
      return {
        value: '"',
        size: 2
      };
    case 92:
      return {
        value: "\\",
        size: 2
      };
    case 47:
      return {
        value: "/",
        size: 2
      };
    case 98:
      return {
        value: "\b",
        size: 2
      };
    case 102:
      return {
        value: "\f",
        size: 2
      };
    case 110:
      return {
        value: "\n",
        size: 2
      };
    case 114:
      return {
        value: "\r",
        size: 2
      };
    case 116:
      return {
        value: "	",
        size: 2
      };
  }
  throw syntaxError(
    lexer.source,
    position,
    `Invalid character escape sequence: "${body.slice(
      position,
      position + 2
    )}".`
  );
}
function readBlockString(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let lineStart = lexer.lineStart;
  let position = start + 3;
  let chunkStart = position;
  let currentLine = "";
  const blockLines = [];
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (code === 34 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
      currentLine += body.slice(chunkStart, position);
      blockLines.push(currentLine);
      const token = createToken(
        lexer,
        TokenKind.BLOCK_STRING,
        start,
        position + 3,
        // Return a string of the lines joined with U+000A.
        dedentBlockStringLines(blockLines).join("\n")
      );
      lexer.line += blockLines.length - 1;
      lexer.lineStart = lineStart;
      return token;
    }
    if (code === 92 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34 && body.charCodeAt(position + 3) === 34) {
      currentLine += body.slice(chunkStart, position);
      chunkStart = position + 1;
      position += 4;
      continue;
    }
    if (code === 10 || code === 13) {
      currentLine += body.slice(chunkStart, position);
      blockLines.push(currentLine);
      if (code === 13 && body.charCodeAt(position + 1) === 10) {
        position += 2;
      } else {
        ++position;
      }
      currentLine = "";
      chunkStart = position;
      lineStart = position;
      continue;
    }
    if (isUnicodeScalarValue(code)) {
      ++position;
    } else if (isSupplementaryCodePoint(body, position)) {
      position += 2;
    } else {
      throw syntaxError(
        lexer.source,
        position,
        `Invalid character within String: ${printCodePointAt(
          lexer,
          position
        )}.`
      );
    }
  }
  throw syntaxError(lexer.source, position, "Unterminated string.");
}
function readName(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start + 1;
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (isNameContinue(code)) {
      ++position;
    } else {
      break;
    }
  }
  return createToken(
    lexer,
    TokenKind.NAME,
    start,
    position,
    body.slice(start, position)
  );
}
var Lexer;
var init_lexer = __esm({
  "../../../node_modules/graphql/language/lexer.mjs"() {
    init_syntaxError();
    init_ast();
    init_blockString();
    init_characterClasses();
    init_tokenKind();
    Lexer = class {
      /**
       * The previously focused non-ignored token.
       */
      /**
       * The currently focused non-ignored token.
       */
      /**
       * The (1-indexed) line containing the current token.
       */
      /**
       * The character offset at which the current line begins.
       */
      constructor(source) {
        const startOfFileToken = new Token(TokenKind.SOF, 0, 0, 0, 0);
        this.source = source;
        this.lastToken = startOfFileToken;
        this.token = startOfFileToken;
        this.line = 1;
        this.lineStart = 0;
      }
      get [Symbol.toStringTag]() {
        return "Lexer";
      }
      /**
       * Advances the token stream to the next non-ignored token.
       */
      advance() {
        this.lastToken = this.token;
        const token = this.token = this.lookahead();
        return token;
      }
      /**
       * Looks ahead and returns the next non-ignored token, but does not change
       * the state of Lexer.
       */
      lookahead() {
        let token = this.token;
        if (token.kind !== TokenKind.EOF) {
          do {
            if (token.next) {
              token = token.next;
            } else {
              const nextToken = readNextToken(this, token.end);
              token.next = nextToken;
              nextToken.prev = token;
              token = nextToken;
            }
          } while (token.kind === TokenKind.COMMENT);
        }
        return token;
      }
    };
  }
});

// ../../../node_modules/graphql/jsutils/inspect.mjs
function inspect(value) {
  return formatValue(value, []);
}
function formatValue(value, seenValues) {
  switch (typeof value) {
    case "string":
      return JSON.stringify(value);
    case "function":
      return value.name ? `[function ${value.name}]` : "[function]";
    case "object":
      return formatObjectValue(value, seenValues);
    default:
      return String(value);
  }
}
function formatObjectValue(value, previouslySeenValues) {
  if (value === null) {
    return "null";
  }
  if (previouslySeenValues.includes(value)) {
    return "[Circular]";
  }
  const seenValues = [...previouslySeenValues, value];
  if (isJSONable(value)) {
    const jsonValue = value.toJSON();
    if (jsonValue !== value) {
      return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
    }
  } else if (Array.isArray(value)) {
    return formatArray(value, seenValues);
  }
  return formatObject(value, seenValues);
}
function isJSONable(value) {
  return typeof value.toJSON === "function";
}
function formatObject(object, seenValues) {
  const entries = Object.entries(object);
  if (entries.length === 0) {
    return "{}";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[" + getObjectTag(object) + "]";
  }
  const properties = entries.map(
    ([key, value]) => key + ": " + formatValue(value, seenValues)
  );
  return "{ " + properties.join(", ") + " }";
}
function formatArray(array, seenValues) {
  if (array.length === 0) {
    return "[]";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[Array]";
  }
  const len = Math.min(MAX_ARRAY_LENGTH, array.length);
  const remaining = array.length - len;
  const items = [];
  for (let i = 0; i < len; ++i) {
    items.push(formatValue(array[i], seenValues));
  }
  if (remaining === 1) {
    items.push("... 1 more item");
  } else if (remaining > 1) {
    items.push(`... ${remaining} more items`);
  }
  return "[" + items.join(", ") + "]";
}
function getObjectTag(object) {
  const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
  if (tag === "Object" && typeof object.constructor === "function") {
    const name = object.constructor.name;
    if (typeof name === "string" && name !== "") {
      return name;
    }
  }
  return tag;
}
var MAX_ARRAY_LENGTH, MAX_RECURSIVE_DEPTH;
var init_inspect = __esm({
  "../../../node_modules/graphql/jsutils/inspect.mjs"() {
    MAX_ARRAY_LENGTH = 10;
    MAX_RECURSIVE_DEPTH = 2;
  }
});

// ../../../node_modules/graphql/jsutils/instanceOf.mjs
var instanceOf;
var init_instanceOf = __esm({
  "../../../node_modules/graphql/jsutils/instanceOf.mjs"() {
    init_inspect();
    instanceOf = /* c8 ignore next 6 */
    // FIXME: https://github.com/graphql/graphql-js/issues/2317
    globalThis.process && globalThis.process.env.NODE_ENV === "production" ? function instanceOf2(value, constructor) {
      return value instanceof constructor;
    } : function instanceOf3(value, constructor) {
      if (value instanceof constructor) {
        return true;
      }
      if (typeof value === "object" && value !== null) {
        var _value$constructor;
        const className = constructor.prototype[Symbol.toStringTag];
        const valueClassName = (
          // We still need to support constructor's name to detect conflicts with older versions of this library.
          Symbol.toStringTag in value ? value[Symbol.toStringTag] : (_value$constructor = value.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor.name
        );
        if (className === valueClassName) {
          const stringifiedValue = inspect(value);
          throw new Error(`Cannot use ${className} "${stringifiedValue}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
        }
      }
      return false;
    };
  }
});

// ../../../node_modules/graphql/language/source.mjs
function isSource(source) {
  return instanceOf(source, Source);
}
var Source;
var init_source = __esm({
  "../../../node_modules/graphql/language/source.mjs"() {
    init_devAssert();
    init_inspect();
    init_instanceOf();
    Source = class {
      constructor(body, name = "GraphQL request", locationOffset = {
        line: 1,
        column: 1
      }) {
        typeof body === "string" || devAssert(false, `Body must be a string. Received: ${inspect(body)}.`);
        this.body = body;
        this.name = name;
        this.locationOffset = locationOffset;
        this.locationOffset.line > 0 || devAssert(
          false,
          "line in locationOffset is 1-indexed and must be positive."
        );
        this.locationOffset.column > 0 || devAssert(
          false,
          "column in locationOffset is 1-indexed and must be positive."
        );
      }
      get [Symbol.toStringTag]() {
        return "Source";
      }
    };
  }
});

// ../../../node_modules/graphql/language/parser.mjs
function parse(source, options) {
  const parser = new Parser(source, options);
  return parser.parseDocument();
}
function parseValue(source, options) {
  const parser = new Parser(source, options);
  parser.expectToken(TokenKind.SOF);
  const value = parser.parseValueLiteral(false);
  parser.expectToken(TokenKind.EOF);
  return value;
}
function parseConstValue(source, options) {
  const parser = new Parser(source, options);
  parser.expectToken(TokenKind.SOF);
  const value = parser.parseConstValueLiteral();
  parser.expectToken(TokenKind.EOF);
  return value;
}
function parseType(source, options) {
  const parser = new Parser(source, options);
  parser.expectToken(TokenKind.SOF);
  const type = parser.parseTypeReference();
  parser.expectToken(TokenKind.EOF);
  return type;
}
function getTokenDesc(token) {
  const value = token.value;
  return getTokenKindDesc(token.kind) + (value != null ? ` "${value}"` : "");
}
function getTokenKindDesc(kind) {
  return isPunctuatorTokenKind(kind) ? `"${kind}"` : kind;
}
var Parser;
var init_parser = __esm({
  "../../../node_modules/graphql/language/parser.mjs"() {
    init_syntaxError();
    init_ast();
    init_directiveLocation();
    init_kinds();
    init_lexer();
    init_source();
    init_tokenKind();
    Parser = class {
      constructor(source, options = {}) {
        const sourceObj = isSource(source) ? source : new Source(source);
        this._lexer = new Lexer(sourceObj);
        this._options = options;
        this._tokenCounter = 0;
      }
      /**
       * Converts a name lex token into a name parse node.
       */
      parseName() {
        const token = this.expectToken(TokenKind.NAME);
        return this.node(token, {
          kind: Kind.NAME,
          value: token.value
        });
      }
      // Implements the parsing rules in the Document section.
      /**
       * Document : Definition+
       */
      parseDocument() {
        return this.node(this._lexer.token, {
          kind: Kind.DOCUMENT,
          definitions: this.many(
            TokenKind.SOF,
            this.parseDefinition,
            TokenKind.EOF
          )
        });
      }
      /**
       * Definition :
       *   - ExecutableDefinition
       *   - TypeSystemDefinition
       *   - TypeSystemExtension
       *
       * ExecutableDefinition :
       *   - OperationDefinition
       *   - FragmentDefinition
       *
       * TypeSystemDefinition :
       *   - SchemaDefinition
       *   - TypeDefinition
       *   - DirectiveDefinition
       *
       * TypeDefinition :
       *   - ScalarTypeDefinition
       *   - ObjectTypeDefinition
       *   - InterfaceTypeDefinition
       *   - UnionTypeDefinition
       *   - EnumTypeDefinition
       *   - InputObjectTypeDefinition
       */
      parseDefinition() {
        if (this.peek(TokenKind.BRACE_L)) {
          return this.parseOperationDefinition();
        }
        const hasDescription = this.peekDescription();
        const keywordToken = hasDescription ? this._lexer.lookahead() : this._lexer.token;
        if (keywordToken.kind === TokenKind.NAME) {
          switch (keywordToken.value) {
            case "schema":
              return this.parseSchemaDefinition();
            case "scalar":
              return this.parseScalarTypeDefinition();
            case "type":
              return this.parseObjectTypeDefinition();
            case "interface":
              return this.parseInterfaceTypeDefinition();
            case "union":
              return this.parseUnionTypeDefinition();
            case "enum":
              return this.parseEnumTypeDefinition();
            case "input":
              return this.parseInputObjectTypeDefinition();
            case "directive":
              return this.parseDirectiveDefinition();
          }
          if (hasDescription) {
            throw syntaxError(
              this._lexer.source,
              this._lexer.token.start,
              "Unexpected description, descriptions are supported only on type definitions."
            );
          }
          switch (keywordToken.value) {
            case "query":
            case "mutation":
            case "subscription":
              return this.parseOperationDefinition();
            case "fragment":
              return this.parseFragmentDefinition();
            case "extend":
              return this.parseTypeSystemExtension();
          }
        }
        throw this.unexpected(keywordToken);
      }
      // Implements the parsing rules in the Operations section.
      /**
       * OperationDefinition :
       *  - SelectionSet
       *  - OperationType Name? VariableDefinitions? Directives? SelectionSet
       */
      parseOperationDefinition() {
        const start = this._lexer.token;
        if (this.peek(TokenKind.BRACE_L)) {
          return this.node(start, {
            kind: Kind.OPERATION_DEFINITION,
            operation: OperationTypeNode.QUERY,
            name: void 0,
            variableDefinitions: [],
            directives: [],
            selectionSet: this.parseSelectionSet()
          });
        }
        const operation = this.parseOperationType();
        let name;
        if (this.peek(TokenKind.NAME)) {
          name = this.parseName();
        }
        return this.node(start, {
          kind: Kind.OPERATION_DEFINITION,
          operation,
          name,
          variableDefinitions: this.parseVariableDefinitions(),
          directives: this.parseDirectives(false),
          selectionSet: this.parseSelectionSet()
        });
      }
      /**
       * OperationType : one of query mutation subscription
       */
      parseOperationType() {
        const operationToken = this.expectToken(TokenKind.NAME);
        switch (operationToken.value) {
          case "query":
            return OperationTypeNode.QUERY;
          case "mutation":
            return OperationTypeNode.MUTATION;
          case "subscription":
            return OperationTypeNode.SUBSCRIPTION;
        }
        throw this.unexpected(operationToken);
      }
      /**
       * VariableDefinitions : ( VariableDefinition+ )
       */
      parseVariableDefinitions() {
        return this.optionalMany(
          TokenKind.PAREN_L,
          this.parseVariableDefinition,
          TokenKind.PAREN_R
        );
      }
      /**
       * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?
       */
      parseVariableDefinition() {
        return this.node(this._lexer.token, {
          kind: Kind.VARIABLE_DEFINITION,
          variable: this.parseVariable(),
          type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),
          defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseConstValueLiteral() : void 0,
          directives: this.parseConstDirectives()
        });
      }
      /**
       * Variable : $ Name
       */
      parseVariable() {
        const start = this._lexer.token;
        this.expectToken(TokenKind.DOLLAR);
        return this.node(start, {
          kind: Kind.VARIABLE,
          name: this.parseName()
        });
      }
      /**
       * ```
       * SelectionSet : { Selection+ }
       * ```
       */
      parseSelectionSet() {
        return this.node(this._lexer.token, {
          kind: Kind.SELECTION_SET,
          selections: this.many(
            TokenKind.BRACE_L,
            this.parseSelection,
            TokenKind.BRACE_R
          )
        });
      }
      /**
       * Selection :
       *   - Field
       *   - FragmentSpread
       *   - InlineFragment
       */
      parseSelection() {
        return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
      }
      /**
       * Field : Alias? Name Arguments? Directives? SelectionSet?
       *
       * Alias : Name :
       */
      parseField() {
        const start = this._lexer.token;
        const nameOrAlias = this.parseName();
        let alias;
        let name;
        if (this.expectOptionalToken(TokenKind.COLON)) {
          alias = nameOrAlias;
          name = this.parseName();
        } else {
          name = nameOrAlias;
        }
        return this.node(start, {
          kind: Kind.FIELD,
          alias,
          name,
          arguments: this.parseArguments(false),
          directives: this.parseDirectives(false),
          selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : void 0
        });
      }
      /**
       * Arguments[Const] : ( Argument[?Const]+ )
       */
      parseArguments(isConst) {
        const item = isConst ? this.parseConstArgument : this.parseArgument;
        return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);
      }
      /**
       * Argument[Const] : Name : Value[?Const]
       */
      parseArgument(isConst = false) {
        const start = this._lexer.token;
        const name = this.parseName();
        this.expectToken(TokenKind.COLON);
        return this.node(start, {
          kind: Kind.ARGUMENT,
          name,
          value: this.parseValueLiteral(isConst)
        });
      }
      parseConstArgument() {
        return this.parseArgument(true);
      }
      // Implements the parsing rules in the Fragments section.
      /**
       * Corresponds to both FragmentSpread and InlineFragment in the spec.
       *
       * FragmentSpread : ... FragmentName Directives?
       *
       * InlineFragment : ... TypeCondition? Directives? SelectionSet
       */
      parseFragment() {
        const start = this._lexer.token;
        this.expectToken(TokenKind.SPREAD);
        const hasTypeCondition = this.expectOptionalKeyword("on");
        if (!hasTypeCondition && this.peek(TokenKind.NAME)) {
          return this.node(start, {
            kind: Kind.FRAGMENT_SPREAD,
            name: this.parseFragmentName(),
            directives: this.parseDirectives(false)
          });
        }
        return this.node(start, {
          kind: Kind.INLINE_FRAGMENT,
          typeCondition: hasTypeCondition ? this.parseNamedType() : void 0,
          directives: this.parseDirectives(false),
          selectionSet: this.parseSelectionSet()
        });
      }
      /**
       * FragmentDefinition :
       *   - fragment FragmentName on TypeCondition Directives? SelectionSet
       *
       * TypeCondition : NamedType
       */
      parseFragmentDefinition() {
        const start = this._lexer.token;
        this.expectKeyword("fragment");
        if (this._options.allowLegacyFragmentVariables === true) {
          return this.node(start, {
            kind: Kind.FRAGMENT_DEFINITION,
            name: this.parseFragmentName(),
            variableDefinitions: this.parseVariableDefinitions(),
            typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
            directives: this.parseDirectives(false),
            selectionSet: this.parseSelectionSet()
          });
        }
        return this.node(start, {
          kind: Kind.FRAGMENT_DEFINITION,
          name: this.parseFragmentName(),
          typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
          directives: this.parseDirectives(false),
          selectionSet: this.parseSelectionSet()
        });
      }
      /**
       * FragmentName : Name but not `on`
       */
      parseFragmentName() {
        if (this._lexer.token.value === "on") {
          throw this.unexpected();
        }
        return this.parseName();
      }
      // Implements the parsing rules in the Values section.
      /**
       * Value[Const] :
       *   - [~Const] Variable
       *   - IntValue
       *   - FloatValue
       *   - StringValue
       *   - BooleanValue
       *   - NullValue
       *   - EnumValue
       *   - ListValue[?Const]
       *   - ObjectValue[?Const]
       *
       * BooleanValue : one of `true` `false`
       *
       * NullValue : `null`
       *
       * EnumValue : Name but not `true`, `false` or `null`
       */
      parseValueLiteral(isConst) {
        const token = this._lexer.token;
        switch (token.kind) {
          case TokenKind.BRACKET_L:
            return this.parseList(isConst);
          case TokenKind.BRACE_L:
            return this.parseObject(isConst);
          case TokenKind.INT:
            this.advanceLexer();
            return this.node(token, {
              kind: Kind.INT,
              value: token.value
            });
          case TokenKind.FLOAT:
            this.advanceLexer();
            return this.node(token, {
              kind: Kind.FLOAT,
              value: token.value
            });
          case TokenKind.STRING:
          case TokenKind.BLOCK_STRING:
            return this.parseStringLiteral();
          case TokenKind.NAME:
            this.advanceLexer();
            switch (token.value) {
              case "true":
                return this.node(token, {
                  kind: Kind.BOOLEAN,
                  value: true
                });
              case "false":
                return this.node(token, {
                  kind: Kind.BOOLEAN,
                  value: false
                });
              case "null":
                return this.node(token, {
                  kind: Kind.NULL
                });
              default:
                return this.node(token, {
                  kind: Kind.ENUM,
                  value: token.value
                });
            }
          case TokenKind.DOLLAR:
            if (isConst) {
              this.expectToken(TokenKind.DOLLAR);
              if (this._lexer.token.kind === TokenKind.NAME) {
                const varName = this._lexer.token.value;
                throw syntaxError(
                  this._lexer.source,
                  token.start,
                  `Unexpected variable "$${varName}" in constant value.`
                );
              } else {
                throw this.unexpected(token);
              }
            }
            return this.parseVariable();
          default:
            throw this.unexpected();
        }
      }
      parseConstValueLiteral() {
        return this.parseValueLiteral(true);
      }
      parseStringLiteral() {
        const token = this._lexer.token;
        this.advanceLexer();
        return this.node(token, {
          kind: Kind.STRING,
          value: token.value,
          block: token.kind === TokenKind.BLOCK_STRING
        });
      }
      /**
       * ListValue[Const] :
       *   - [ ]
       *   - [ Value[?Const]+ ]
       */
      parseList(isConst) {
        const item = () => this.parseValueLiteral(isConst);
        return this.node(this._lexer.token, {
          kind: Kind.LIST,
          values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R)
        });
      }
      /**
       * ```
       * ObjectValue[Const] :
       *   - { }
       *   - { ObjectField[?Const]+ }
       * ```
       */
      parseObject(isConst) {
        const item = () => this.parseObjectField(isConst);
        return this.node(this._lexer.token, {
          kind: Kind.OBJECT,
          fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R)
        });
      }
      /**
       * ObjectField[Const] : Name : Value[?Const]
       */
      parseObjectField(isConst) {
        const start = this._lexer.token;
        const name = this.parseName();
        this.expectToken(TokenKind.COLON);
        return this.node(start, {
          kind: Kind.OBJECT_FIELD,
          name,
          value: this.parseValueLiteral(isConst)
        });
      }
      // Implements the parsing rules in the Directives section.
      /**
       * Directives[Const] : Directive[?Const]+
       */
      parseDirectives(isConst) {
        const directives = [];
        while (this.peek(TokenKind.AT)) {
          directives.push(this.parseDirective(isConst));
        }
        return directives;
      }
      parseConstDirectives() {
        return this.parseDirectives(true);
      }
      /**
       * ```
       * Directive[Const] : @ Name Arguments[?Const]?
       * ```
       */
      parseDirective(isConst) {
        const start = this._lexer.token;
        this.expectToken(TokenKind.AT);
        return this.node(start, {
          kind: Kind.DIRECTIVE,
          name: this.parseName(),
          arguments: this.parseArguments(isConst)
        });
      }
      // Implements the parsing rules in the Types section.
      /**
       * Type :
       *   - NamedType
       *   - ListType
       *   - NonNullType
       */
      parseTypeReference() {
        const start = this._lexer.token;
        let type;
        if (this.expectOptionalToken(TokenKind.BRACKET_L)) {
          const innerType = this.parseTypeReference();
          this.expectToken(TokenKind.BRACKET_R);
          type = this.node(start, {
            kind: Kind.LIST_TYPE,
            type: innerType
          });
        } else {
          type = this.parseNamedType();
        }
        if (this.expectOptionalToken(TokenKind.BANG)) {
          return this.node(start, {
            kind: Kind.NON_NULL_TYPE,
            type
          });
        }
        return type;
      }
      /**
       * NamedType : Name
       */
      parseNamedType() {
        return this.node(this._lexer.token, {
          kind: Kind.NAMED_TYPE,
          name: this.parseName()
        });
      }
      // Implements the parsing rules in the Type Definition section.
      peekDescription() {
        return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);
      }
      /**
       * Description : StringValue
       */
      parseDescription() {
        if (this.peekDescription()) {
          return this.parseStringLiteral();
        }
      }
      /**
       * ```
       * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }
       * ```
       */
      parseSchemaDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("schema");
        const directives = this.parseConstDirectives();
        const operationTypes = this.many(
          TokenKind.BRACE_L,
          this.parseOperationTypeDefinition,
          TokenKind.BRACE_R
        );
        return this.node(start, {
          kind: Kind.SCHEMA_DEFINITION,
          description,
          directives,
          operationTypes
        });
      }
      /**
       * OperationTypeDefinition : OperationType : NamedType
       */
      parseOperationTypeDefinition() {
        const start = this._lexer.token;
        const operation = this.parseOperationType();
        this.expectToken(TokenKind.COLON);
        const type = this.parseNamedType();
        return this.node(start, {
          kind: Kind.OPERATION_TYPE_DEFINITION,
          operation,
          type
        });
      }
      /**
       * ScalarTypeDefinition : Description? scalar Name Directives[Const]?
       */
      parseScalarTypeDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("scalar");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        return this.node(start, {
          kind: Kind.SCALAR_TYPE_DEFINITION,
          description,
          name,
          directives
        });
      }
      /**
       * ObjectTypeDefinition :
       *   Description?
       *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?
       */
      parseObjectTypeDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("type");
        const name = this.parseName();
        const interfaces = this.parseImplementsInterfaces();
        const directives = this.parseConstDirectives();
        const fields = this.parseFieldsDefinition();
        return this.node(start, {
          kind: Kind.OBJECT_TYPE_DEFINITION,
          description,
          name,
          interfaces,
          directives,
          fields
        });
      }
      /**
       * ImplementsInterfaces :
       *   - implements `&`? NamedType
       *   - ImplementsInterfaces & NamedType
       */
      parseImplementsInterfaces() {
        return this.expectOptionalKeyword("implements") ? this.delimitedMany(TokenKind.AMP, this.parseNamedType) : [];
      }
      /**
       * ```
       * FieldsDefinition : { FieldDefinition+ }
       * ```
       */
      parseFieldsDefinition() {
        return this.optionalMany(
          TokenKind.BRACE_L,
          this.parseFieldDefinition,
          TokenKind.BRACE_R
        );
      }
      /**
       * FieldDefinition :
       *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?
       */
      parseFieldDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        const name = this.parseName();
        const args = this.parseArgumentDefs();
        this.expectToken(TokenKind.COLON);
        const type = this.parseTypeReference();
        const directives = this.parseConstDirectives();
        return this.node(start, {
          kind: Kind.FIELD_DEFINITION,
          description,
          name,
          arguments: args,
          type,
          directives
        });
      }
      /**
       * ArgumentsDefinition : ( InputValueDefinition+ )
       */
      parseArgumentDefs() {
        return this.optionalMany(
          TokenKind.PAREN_L,
          this.parseInputValueDef,
          TokenKind.PAREN_R
        );
      }
      /**
       * InputValueDefinition :
       *   - Description? Name : Type DefaultValue? Directives[Const]?
       */
      parseInputValueDef() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        const name = this.parseName();
        this.expectToken(TokenKind.COLON);
        const type = this.parseTypeReference();
        let defaultValue;
        if (this.expectOptionalToken(TokenKind.EQUALS)) {
          defaultValue = this.parseConstValueLiteral();
        }
        const directives = this.parseConstDirectives();
        return this.node(start, {
          kind: Kind.INPUT_VALUE_DEFINITION,
          description,
          name,
          type,
          defaultValue,
          directives
        });
      }
      /**
       * InterfaceTypeDefinition :
       *   - Description? interface Name Directives[Const]? FieldsDefinition?
       */
      parseInterfaceTypeDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("interface");
        const name = this.parseName();
        const interfaces = this.parseImplementsInterfaces();
        const directives = this.parseConstDirectives();
        const fields = this.parseFieldsDefinition();
        return this.node(start, {
          kind: Kind.INTERFACE_TYPE_DEFINITION,
          description,
          name,
          interfaces,
          directives,
          fields
        });
      }
      /**
       * UnionTypeDefinition :
       *   - Description? union Name Directives[Const]? UnionMemberTypes?
       */
      parseUnionTypeDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("union");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        const types = this.parseUnionMemberTypes();
        return this.node(start, {
          kind: Kind.UNION_TYPE_DEFINITION,
          description,
          name,
          directives,
          types
        });
      }
      /**
       * UnionMemberTypes :
       *   - = `|`? NamedType
       *   - UnionMemberTypes | NamedType
       */
      parseUnionMemberTypes() {
        return this.expectOptionalToken(TokenKind.EQUALS) ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType) : [];
      }
      /**
       * EnumTypeDefinition :
       *   - Description? enum Name Directives[Const]? EnumValuesDefinition?
       */
      parseEnumTypeDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("enum");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        const values = this.parseEnumValuesDefinition();
        return this.node(start, {
          kind: Kind.ENUM_TYPE_DEFINITION,
          description,
          name,
          directives,
          values
        });
      }
      /**
       * ```
       * EnumValuesDefinition : { EnumValueDefinition+ }
       * ```
       */
      parseEnumValuesDefinition() {
        return this.optionalMany(
          TokenKind.BRACE_L,
          this.parseEnumValueDefinition,
          TokenKind.BRACE_R
        );
      }
      /**
       * EnumValueDefinition : Description? EnumValue Directives[Const]?
       */
      parseEnumValueDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        const name = this.parseEnumValueName();
        const directives = this.parseConstDirectives();
        return this.node(start, {
          kind: Kind.ENUM_VALUE_DEFINITION,
          description,
          name,
          directives
        });
      }
      /**
       * EnumValue : Name but not `true`, `false` or `null`
       */
      parseEnumValueName() {
        if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null") {
          throw syntaxError(
            this._lexer.source,
            this._lexer.token.start,
            `${getTokenDesc(
              this._lexer.token
            )} is reserved and cannot be used for an enum value.`
          );
        }
        return this.parseName();
      }
      /**
       * InputObjectTypeDefinition :
       *   - Description? input Name Directives[Const]? InputFieldsDefinition?
       */
      parseInputObjectTypeDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("input");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        const fields = this.parseInputFieldsDefinition();
        return this.node(start, {
          kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,
          description,
          name,
          directives,
          fields
        });
      }
      /**
       * ```
       * InputFieldsDefinition : { InputValueDefinition+ }
       * ```
       */
      parseInputFieldsDefinition() {
        return this.optionalMany(
          TokenKind.BRACE_L,
          this.parseInputValueDef,
          TokenKind.BRACE_R
        );
      }
      /**
       * TypeSystemExtension :
       *   - SchemaExtension
       *   - TypeExtension
       *
       * TypeExtension :
       *   - ScalarTypeExtension
       *   - ObjectTypeExtension
       *   - InterfaceTypeExtension
       *   - UnionTypeExtension
       *   - EnumTypeExtension
       *   - InputObjectTypeDefinition
       */
      parseTypeSystemExtension() {
        const keywordToken = this._lexer.lookahead();
        if (keywordToken.kind === TokenKind.NAME) {
          switch (keywordToken.value) {
            case "schema":
              return this.parseSchemaExtension();
            case "scalar":
              return this.parseScalarTypeExtension();
            case "type":
              return this.parseObjectTypeExtension();
            case "interface":
              return this.parseInterfaceTypeExtension();
            case "union":
              return this.parseUnionTypeExtension();
            case "enum":
              return this.parseEnumTypeExtension();
            case "input":
              return this.parseInputObjectTypeExtension();
          }
        }
        throw this.unexpected(keywordToken);
      }
      /**
       * ```
       * SchemaExtension :
       *  - extend schema Directives[Const]? { OperationTypeDefinition+ }
       *  - extend schema Directives[Const]
       * ```
       */
      parseSchemaExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("schema");
        const directives = this.parseConstDirectives();
        const operationTypes = this.optionalMany(
          TokenKind.BRACE_L,
          this.parseOperationTypeDefinition,
          TokenKind.BRACE_R
        );
        if (directives.length === 0 && operationTypes.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: Kind.SCHEMA_EXTENSION,
          directives,
          operationTypes
        });
      }
      /**
       * ScalarTypeExtension :
       *   - extend scalar Name Directives[Const]
       */
      parseScalarTypeExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("scalar");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        if (directives.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: Kind.SCALAR_TYPE_EXTENSION,
          name,
          directives
        });
      }
      /**
       * ObjectTypeExtension :
       *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
       *  - extend type Name ImplementsInterfaces? Directives[Const]
       *  - extend type Name ImplementsInterfaces
       */
      parseObjectTypeExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("type");
        const name = this.parseName();
        const interfaces = this.parseImplementsInterfaces();
        const directives = this.parseConstDirectives();
        const fields = this.parseFieldsDefinition();
        if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: Kind.OBJECT_TYPE_EXTENSION,
          name,
          interfaces,
          directives,
          fields
        });
      }
      /**
       * InterfaceTypeExtension :
       *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
       *  - extend interface Name ImplementsInterfaces? Directives[Const]
       *  - extend interface Name ImplementsInterfaces
       */
      parseInterfaceTypeExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("interface");
        const name = this.parseName();
        const interfaces = this.parseImplementsInterfaces();
        const directives = this.parseConstDirectives();
        const fields = this.parseFieldsDefinition();
        if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: Kind.INTERFACE_TYPE_EXTENSION,
          name,
          interfaces,
          directives,
          fields
        });
      }
      /**
       * UnionTypeExtension :
       *   - extend union Name Directives[Const]? UnionMemberTypes
       *   - extend union Name Directives[Const]
       */
      parseUnionTypeExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("union");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        const types = this.parseUnionMemberTypes();
        if (directives.length === 0 && types.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: Kind.UNION_TYPE_EXTENSION,
          name,
          directives,
          types
        });
      }
      /**
       * EnumTypeExtension :
       *   - extend enum Name Directives[Const]? EnumValuesDefinition
       *   - extend enum Name Directives[Const]
       */
      parseEnumTypeExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("enum");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        const values = this.parseEnumValuesDefinition();
        if (directives.length === 0 && values.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: Kind.ENUM_TYPE_EXTENSION,
          name,
          directives,
          values
        });
      }
      /**
       * InputObjectTypeExtension :
       *   - extend input Name Directives[Const]? InputFieldsDefinition
       *   - extend input Name Directives[Const]
       */
      parseInputObjectTypeExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("input");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        const fields = this.parseInputFieldsDefinition();
        if (directives.length === 0 && fields.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,
          name,
          directives,
          fields
        });
      }
      /**
       * ```
       * DirectiveDefinition :
       *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations
       * ```
       */
      parseDirectiveDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("directive");
        this.expectToken(TokenKind.AT);
        const name = this.parseName();
        const args = this.parseArgumentDefs();
        const repeatable = this.expectOptionalKeyword("repeatable");
        this.expectKeyword("on");
        const locations = this.parseDirectiveLocations();
        return this.node(start, {
          kind: Kind.DIRECTIVE_DEFINITION,
          description,
          name,
          arguments: args,
          repeatable,
          locations
        });
      }
      /**
       * DirectiveLocations :
       *   - `|`? DirectiveLocation
       *   - DirectiveLocations | DirectiveLocation
       */
      parseDirectiveLocations() {
        return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);
      }
      /*
       * DirectiveLocation :
       *   - ExecutableDirectiveLocation
       *   - TypeSystemDirectiveLocation
       *
       * ExecutableDirectiveLocation : one of
       *   `QUERY`
       *   `MUTATION`
       *   `SUBSCRIPTION`
       *   `FIELD`
       *   `FRAGMENT_DEFINITION`
       *   `FRAGMENT_SPREAD`
       *   `INLINE_FRAGMENT`
       *
       * TypeSystemDirectiveLocation : one of
       *   `SCHEMA`
       *   `SCALAR`
       *   `OBJECT`
       *   `FIELD_DEFINITION`
       *   `ARGUMENT_DEFINITION`
       *   `INTERFACE`
       *   `UNION`
       *   `ENUM`
       *   `ENUM_VALUE`
       *   `INPUT_OBJECT`
       *   `INPUT_FIELD_DEFINITION`
       */
      parseDirectiveLocation() {
        const start = this._lexer.token;
        const name = this.parseName();
        if (Object.prototype.hasOwnProperty.call(DirectiveLocation, name.value)) {
          return name;
        }
        throw this.unexpected(start);
      }
      // Core parsing utility functions
      /**
       * Returns a node that, if configured to do so, sets a "loc" field as a
       * location object, used to identify the place in the source that created a
       * given parsed object.
       */
      node(startToken, node) {
        if (this._options.noLocation !== true) {
          node.loc = new Location(
            startToken,
            this._lexer.lastToken,
            this._lexer.source
          );
        }
        return node;
      }
      /**
       * Determines if the next token is of a given kind
       */
      peek(kind) {
        return this._lexer.token.kind === kind;
      }
      /**
       * If the next token is of the given kind, return that token after advancing the lexer.
       * Otherwise, do not change the parser state and throw an error.
       */
      expectToken(kind) {
        const token = this._lexer.token;
        if (token.kind === kind) {
          this.advanceLexer();
          return token;
        }
        throw syntaxError(
          this._lexer.source,
          token.start,
          `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token)}.`
        );
      }
      /**
       * If the next token is of the given kind, return "true" after advancing the lexer.
       * Otherwise, do not change the parser state and return "false".
       */
      expectOptionalToken(kind) {
        const token = this._lexer.token;
        if (token.kind === kind) {
          this.advanceLexer();
          return true;
        }
        return false;
      }
      /**
       * If the next token is a given keyword, advance the lexer.
       * Otherwise, do not change the parser state and throw an error.
       */
      expectKeyword(value) {
        const token = this._lexer.token;
        if (token.kind === TokenKind.NAME && token.value === value) {
          this.advanceLexer();
        } else {
          throw syntaxError(
            this._lexer.source,
            token.start,
            `Expected "${value}", found ${getTokenDesc(token)}.`
          );
        }
      }
      /**
       * If the next token is a given keyword, return "true" after advancing the lexer.
       * Otherwise, do not change the parser state and return "false".
       */
      expectOptionalKeyword(value) {
        const token = this._lexer.token;
        if (token.kind === TokenKind.NAME && token.value === value) {
          this.advanceLexer();
          return true;
        }
        return false;
      }
      /**
       * Helper function for creating an error when an unexpected lexed token is encountered.
       */
      unexpected(atToken) {
        const token = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;
        return syntaxError(
          this._lexer.source,
          token.start,
          `Unexpected ${getTokenDesc(token)}.`
        );
      }
      /**
       * Returns a possibly empty list of parse nodes, determined by the parseFn.
       * This list begins with a lex token of openKind and ends with a lex token of closeKind.
       * Advances the parser to the next lex token after the closing token.
       */
      any(openKind, parseFn, closeKind) {
        this.expectToken(openKind);
        const nodes = [];
        while (!this.expectOptionalToken(closeKind)) {
          nodes.push(parseFn.call(this));
        }
        return nodes;
      }
      /**
       * Returns a list of parse nodes, determined by the parseFn.
       * It can be empty only if open token is missing otherwise it will always return non-empty list
       * that begins with a lex token of openKind and ends with a lex token of closeKind.
       * Advances the parser to the next lex token after the closing token.
       */
      optionalMany(openKind, parseFn, closeKind) {
        if (this.expectOptionalToken(openKind)) {
          const nodes = [];
          do {
            nodes.push(parseFn.call(this));
          } while (!this.expectOptionalToken(closeKind));
          return nodes;
        }
        return [];
      }
      /**
       * Returns a non-empty list of parse nodes, determined by the parseFn.
       * This list begins with a lex token of openKind and ends with a lex token of closeKind.
       * Advances the parser to the next lex token after the closing token.
       */
      many(openKind, parseFn, closeKind) {
        this.expectToken(openKind);
        const nodes = [];
        do {
          nodes.push(parseFn.call(this));
        } while (!this.expectOptionalToken(closeKind));
        return nodes;
      }
      /**
       * Returns a non-empty list of parse nodes, determined by the parseFn.
       * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.
       * Advances the parser to the next lex token after last item in the list.
       */
      delimitedMany(delimiterKind, parseFn) {
        this.expectOptionalToken(delimiterKind);
        const nodes = [];
        do {
          nodes.push(parseFn.call(this));
        } while (this.expectOptionalToken(delimiterKind));
        return nodes;
      }
      advanceLexer() {
        const { maxTokens } = this._options;
        const token = this._lexer.advance();
        if (maxTokens !== void 0 && token.kind !== TokenKind.EOF) {
          ++this._tokenCounter;
          if (this._tokenCounter > maxTokens) {
            throw syntaxError(
              this._lexer.source,
              token.start,
              `Document contains more that ${maxTokens} tokens. Parsing aborted.`
            );
          }
        }
      }
    };
  }
});

// ../../../node_modules/graphql/jsutils/didYouMean.mjs
function didYouMean(firstArg, secondArg) {
  const [subMessage, suggestionsArg] = secondArg ? [firstArg, secondArg] : [void 0, firstArg];
  let message = " Did you mean ";
  if (subMessage) {
    message += subMessage + " ";
  }
  const suggestions = suggestionsArg.map((x) => `"${x}"`);
  switch (suggestions.length) {
    case 0:
      return "";
    case 1:
      return message + suggestions[0] + "?";
    case 2:
      return message + suggestions[0] + " or " + suggestions[1] + "?";
  }
  const selected = suggestions.slice(0, MAX_SUGGESTIONS);
  const lastItem = selected.pop();
  return message + selected.join(", ") + ", or " + lastItem + "?";
}
var MAX_SUGGESTIONS;
var init_didYouMean = __esm({
  "../../../node_modules/graphql/jsutils/didYouMean.mjs"() {
    MAX_SUGGESTIONS = 5;
  }
});

// ../../../node_modules/graphql/jsutils/identityFunc.mjs
function identityFunc(x) {
  return x;
}
var init_identityFunc = __esm({
  "../../../node_modules/graphql/jsutils/identityFunc.mjs"() {
  }
});

// ../../../node_modules/graphql/jsutils/keyMap.mjs
function keyMap(list, keyFn) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const item of list) {
    result[keyFn(item)] = item;
  }
  return result;
}
var init_keyMap = __esm({
  "../../../node_modules/graphql/jsutils/keyMap.mjs"() {
  }
});

// ../../../node_modules/graphql/jsutils/keyValMap.mjs
function keyValMap(list, keyFn, valFn) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const item of list) {
    result[keyFn(item)] = valFn(item);
  }
  return result;
}
var init_keyValMap = __esm({
  "../../../node_modules/graphql/jsutils/keyValMap.mjs"() {
  }
});

// ../../../node_modules/graphql/jsutils/mapValue.mjs
function mapValue(map, fn) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const key of Object.keys(map)) {
    result[key] = fn(map[key], key);
  }
  return result;
}
var init_mapValue = __esm({
  "../../../node_modules/graphql/jsutils/mapValue.mjs"() {
  }
});

// ../../../node_modules/graphql/jsutils/naturalCompare.mjs
function naturalCompare(aStr, bStr) {
  let aIndex = 0;
  let bIndex = 0;
  while (aIndex < aStr.length && bIndex < bStr.length) {
    let aChar = aStr.charCodeAt(aIndex);
    let bChar = bStr.charCodeAt(bIndex);
    if (isDigit2(aChar) && isDigit2(bChar)) {
      let aNum = 0;
      do {
        ++aIndex;
        aNum = aNum * 10 + aChar - DIGIT_0;
        aChar = aStr.charCodeAt(aIndex);
      } while (isDigit2(aChar) && aNum > 0);
      let bNum = 0;
      do {
        ++bIndex;
        bNum = bNum * 10 + bChar - DIGIT_0;
        bChar = bStr.charCodeAt(bIndex);
      } while (isDigit2(bChar) && bNum > 0);
      if (aNum < bNum) {
        return -1;
      }
      if (aNum > bNum) {
        return 1;
      }
    } else {
      if (aChar < bChar) {
        return -1;
      }
      if (aChar > bChar) {
        return 1;
      }
      ++aIndex;
      ++bIndex;
    }
  }
  return aStr.length - bStr.length;
}
function isDigit2(code) {
  return !isNaN(code) && DIGIT_0 <= code && code <= DIGIT_9;
}
var DIGIT_0, DIGIT_9;
var init_naturalCompare = __esm({
  "../../../node_modules/graphql/jsutils/naturalCompare.mjs"() {
    DIGIT_0 = 48;
    DIGIT_9 = 57;
  }
});

// ../../../node_modules/graphql/jsutils/suggestionList.mjs
function suggestionList(input, options) {
  const optionsByDistance = /* @__PURE__ */ Object.create(null);
  const lexicalDistance = new LexicalDistance(input);
  const threshold = Math.floor(input.length * 0.4) + 1;
  for (const option of options) {
    const distance = lexicalDistance.measure(option, threshold);
    if (distance !== void 0) {
      optionsByDistance[option] = distance;
    }
  }
  return Object.keys(optionsByDistance).sort((a, b) => {
    const distanceDiff = optionsByDistance[a] - optionsByDistance[b];
    return distanceDiff !== 0 ? distanceDiff : naturalCompare(a, b);
  });
}
function stringToArray(str) {
  const strLength = str.length;
  const array = new Array(strLength);
  for (let i = 0; i < strLength; ++i) {
    array[i] = str.charCodeAt(i);
  }
  return array;
}
var LexicalDistance;
var init_suggestionList = __esm({
  "../../../node_modules/graphql/jsutils/suggestionList.mjs"() {
    init_naturalCompare();
    LexicalDistance = class {
      constructor(input) {
        this._input = input;
        this._inputLowerCase = input.toLowerCase();
        this._inputArray = stringToArray(this._inputLowerCase);
        this._rows = [
          new Array(input.length + 1).fill(0),
          new Array(input.length + 1).fill(0),
          new Array(input.length + 1).fill(0)
        ];
      }
      measure(option, threshold) {
        if (this._input === option) {
          return 0;
        }
        const optionLowerCase = option.toLowerCase();
        if (this._inputLowerCase === optionLowerCase) {
          return 1;
        }
        let a = stringToArray(optionLowerCase);
        let b = this._inputArray;
        if (a.length < b.length) {
          const tmp = a;
          a = b;
          b = tmp;
        }
        const aLength = a.length;
        const bLength = b.length;
        if (aLength - bLength > threshold) {
          return void 0;
        }
        const rows = this._rows;
        for (let j = 0; j <= bLength; j++) {
          rows[0][j] = j;
        }
        for (let i = 1; i <= aLength; i++) {
          const upRow = rows[(i - 1) % 3];
          const currentRow = rows[i % 3];
          let smallestCell = currentRow[0] = i;
          for (let j = 1; j <= bLength; j++) {
            const cost = a[i - 1] === b[j - 1] ? 0 : 1;
            let currentCell = Math.min(
              upRow[j] + 1,
              // delete
              currentRow[j - 1] + 1,
              // insert
              upRow[j - 1] + cost
              // substitute
            );
            if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
              const doubleDiagonalCell = rows[(i - 2) % 3][j - 2];
              currentCell = Math.min(currentCell, doubleDiagonalCell + 1);
            }
            if (currentCell < smallestCell) {
              smallestCell = currentCell;
            }
            currentRow[j] = currentCell;
          }
          if (smallestCell > threshold) {
            return void 0;
          }
        }
        const distance = rows[aLength % 3][bLength];
        return distance <= threshold ? distance : void 0;
      }
    };
  }
});

// ../../../node_modules/graphql/jsutils/toObjMap.mjs
function toObjMap(obj) {
  if (obj == null) {
    return /* @__PURE__ */ Object.create(null);
  }
  if (Object.getPrototypeOf(obj) === null) {
    return obj;
  }
  const map = /* @__PURE__ */ Object.create(null);
  for (const [key, value] of Object.entries(obj)) {
    map[key] = value;
  }
  return map;
}
var init_toObjMap = __esm({
  "../../../node_modules/graphql/jsutils/toObjMap.mjs"() {
  }
});

// ../../../node_modules/graphql/language/printString.mjs
function printString(str) {
  return `"${str.replace(escapedRegExp, escapedReplacer)}"`;
}
function escapedReplacer(str) {
  return escapeSequences[str.charCodeAt(0)];
}
var escapedRegExp, escapeSequences;
var init_printString = __esm({
  "../../../node_modules/graphql/language/printString.mjs"() {
    escapedRegExp = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
    escapeSequences = [
      "\\u0000",
      "\\u0001",
      "\\u0002",
      "\\u0003",
      "\\u0004",
      "\\u0005",
      "\\u0006",
      "\\u0007",
      "\\b",
      "\\t",
      "\\n",
      "\\u000B",
      "\\f",
      "\\r",
      "\\u000E",
      "\\u000F",
      "\\u0010",
      "\\u0011",
      "\\u0012",
      "\\u0013",
      "\\u0014",
      "\\u0015",
      "\\u0016",
      "\\u0017",
      "\\u0018",
      "\\u0019",
      "\\u001A",
      "\\u001B",
      "\\u001C",
      "\\u001D",
      "\\u001E",
      "\\u001F",
      "",
      "",
      '\\"',
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      // 2F
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      // 3F
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      // 4F
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "\\\\",
      "",
      "",
      "",
      // 5F
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      // 6F
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "\\u007F",
      "\\u0080",
      "\\u0081",
      "\\u0082",
      "\\u0083",
      "\\u0084",
      "\\u0085",
      "\\u0086",
      "\\u0087",
      "\\u0088",
      "\\u0089",
      "\\u008A",
      "\\u008B",
      "\\u008C",
      "\\u008D",
      "\\u008E",
      "\\u008F",
      "\\u0090",
      "\\u0091",
      "\\u0092",
      "\\u0093",
      "\\u0094",
      "\\u0095",
      "\\u0096",
      "\\u0097",
      "\\u0098",
      "\\u0099",
      "\\u009A",
      "\\u009B",
      "\\u009C",
      "\\u009D",
      "\\u009E",
      "\\u009F"
    ];
  }
});

// ../../../node_modules/graphql/language/visitor.mjs
function visit(root, visitor, visitorKeys = QueryDocumentKeys) {
  const enterLeaveMap = /* @__PURE__ */ new Map();
  for (const kind of Object.values(Kind)) {
    enterLeaveMap.set(kind, getEnterLeaveForKind(visitor, kind));
  }
  let stack = void 0;
  let inArray = Array.isArray(root);
  let keys = [root];
  let index = -1;
  let edits = [];
  let node = root;
  let key = void 0;
  let parent = void 0;
  const path = [];
  const ancestors = [];
  do {
    index++;
    const isLeaving = index === keys.length;
    const isEdited = isLeaving && edits.length !== 0;
    if (isLeaving) {
      key = ancestors.length === 0 ? void 0 : path[path.length - 1];
      node = parent;
      parent = ancestors.pop();
      if (isEdited) {
        if (inArray) {
          node = node.slice();
          let editOffset = 0;
          for (const [editKey, editValue] of edits) {
            const arrayKey = editKey - editOffset;
            if (editValue === null) {
              node.splice(arrayKey, 1);
              editOffset++;
            } else {
              node[arrayKey] = editValue;
            }
          }
        } else {
          node = Object.defineProperties(
            {},
            Object.getOwnPropertyDescriptors(node)
          );
          for (const [editKey, editValue] of edits) {
            node[editKey] = editValue;
          }
        }
      }
      index = stack.index;
      keys = stack.keys;
      edits = stack.edits;
      inArray = stack.inArray;
      stack = stack.prev;
    } else if (parent) {
      key = inArray ? index : keys[index];
      node = parent[key];
      if (node === null || node === void 0) {
        continue;
      }
      path.push(key);
    }
    let result;
    if (!Array.isArray(node)) {
      var _enterLeaveMap$get, _enterLeaveMap$get2;
      isNode(node) || devAssert(false, `Invalid AST Node: ${inspect(node)}.`);
      const visitFn = isLeaving ? (_enterLeaveMap$get = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get === void 0 ? void 0 : _enterLeaveMap$get.leave : (_enterLeaveMap$get2 = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get2 === void 0 ? void 0 : _enterLeaveMap$get2.enter;
      result = visitFn === null || visitFn === void 0 ? void 0 : visitFn.call(visitor, node, key, parent, path, ancestors);
      if (result === BREAK) {
        break;
      }
      if (result === false) {
        if (!isLeaving) {
          path.pop();
          continue;
        }
      } else if (result !== void 0) {
        edits.push([key, result]);
        if (!isLeaving) {
          if (isNode(result)) {
            node = result;
          } else {
            path.pop();
            continue;
          }
        }
      }
    }
    if (result === void 0 && isEdited) {
      edits.push([key, node]);
    }
    if (isLeaving) {
      path.pop();
    } else {
      var _node$kind;
      stack = {
        inArray,
        index,
        keys,
        edits,
        prev: stack
      };
      inArray = Array.isArray(node);
      keys = inArray ? node : (_node$kind = visitorKeys[node.kind]) !== null && _node$kind !== void 0 ? _node$kind : [];
      index = -1;
      edits = [];
      if (parent) {
        ancestors.push(parent);
      }
      parent = node;
    }
  } while (stack !== void 0);
  if (edits.length !== 0) {
    return edits[edits.length - 1][1];
  }
  return root;
}
function visitInParallel(visitors) {
  const skipping = new Array(visitors.length).fill(null);
  const mergedVisitor = /* @__PURE__ */ Object.create(null);
  for (const kind of Object.values(Kind)) {
    let hasVisitor = false;
    const enterList = new Array(visitors.length).fill(void 0);
    const leaveList = new Array(visitors.length).fill(void 0);
    for (let i = 0; i < visitors.length; ++i) {
      const { enter, leave } = getEnterLeaveForKind(visitors[i], kind);
      hasVisitor || (hasVisitor = enter != null || leave != null);
      enterList[i] = enter;
      leaveList[i] = leave;
    }
    if (!hasVisitor) {
      continue;
    }
    const mergedEnterLeave = {
      enter(...args) {
        const node = args[0];
        for (let i = 0; i < visitors.length; i++) {
          if (skipping[i] === null) {
            var _enterList$i;
            const result = (_enterList$i = enterList[i]) === null || _enterList$i === void 0 ? void 0 : _enterList$i.apply(visitors[i], args);
            if (result === false) {
              skipping[i] = node;
            } else if (result === BREAK) {
              skipping[i] = BREAK;
            } else if (result !== void 0) {
              return result;
            }
          }
        }
      },
      leave(...args) {
        const node = args[0];
        for (let i = 0; i < visitors.length; i++) {
          if (skipping[i] === null) {
            var _leaveList$i;
            const result = (_leaveList$i = leaveList[i]) === null || _leaveList$i === void 0 ? void 0 : _leaveList$i.apply(visitors[i], args);
            if (result === BREAK) {
              skipping[i] = BREAK;
            } else if (result !== void 0 && result !== false) {
              return result;
            }
          } else if (skipping[i] === node) {
            skipping[i] = null;
          }
        }
      }
    };
    mergedVisitor[kind] = mergedEnterLeave;
  }
  return mergedVisitor;
}
function getEnterLeaveForKind(visitor, kind) {
  const kindVisitor = visitor[kind];
  if (typeof kindVisitor === "object") {
    return kindVisitor;
  } else if (typeof kindVisitor === "function") {
    return {
      enter: kindVisitor,
      leave: void 0
    };
  }
  return {
    enter: visitor.enter,
    leave: visitor.leave
  };
}
function getVisitFn(visitor, kind, isLeaving) {
  const { enter, leave } = getEnterLeaveForKind(visitor, kind);
  return isLeaving ? leave : enter;
}
var BREAK;
var init_visitor = __esm({
  "../../../node_modules/graphql/language/visitor.mjs"() {
    init_devAssert();
    init_inspect();
    init_ast();
    init_kinds();
    BREAK = Object.freeze({});
  }
});

// ../../../node_modules/graphql/language/printer.mjs
function print(ast) {
  return visit(ast, printDocASTReducer);
}
function join(maybeArray, separator = "") {
  var _maybeArray$filter$jo;
  return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter((x) => x).join(separator)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : "";
}
function block(array) {
  return wrap("{\n", indent(join(array, "\n")), "\n}");
}
function wrap(start, maybeString, end = "") {
  return maybeString != null && maybeString !== "" ? start + maybeString + end : "";
}
function indent(str) {
  return wrap("  ", str.replace(/\n/g, "\n  "));
}
function hasMultilineItems(maybeArray) {
  var _maybeArray$some;
  return (_maybeArray$some = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes("\n"))) !== null && _maybeArray$some !== void 0 ? _maybeArray$some : false;
}
var MAX_LINE_LENGTH, printDocASTReducer;
var init_printer = __esm({
  "../../../node_modules/graphql/language/printer.mjs"() {
    init_blockString();
    init_printString();
    init_visitor();
    MAX_LINE_LENGTH = 80;
    printDocASTReducer = {
      Name: {
        leave: (node) => node.value
      },
      Variable: {
        leave: (node) => "$" + node.name
      },
      // Document
      Document: {
        leave: (node) => join(node.definitions, "\n\n")
      },
      OperationDefinition: {
        leave(node) {
          const varDefs = wrap("(", join(node.variableDefinitions, ", "), ")");
          const prefix = join(
            [
              node.operation,
              join([node.name, varDefs]),
              join(node.directives, " ")
            ],
            " "
          );
          return (prefix === "query" ? "" : prefix + " ") + node.selectionSet;
        }
      },
      VariableDefinition: {
        leave: ({ variable, type, defaultValue, directives }) => variable + ": " + type + wrap(" = ", defaultValue) + wrap(" ", join(directives, " "))
      },
      SelectionSet: {
        leave: ({ selections }) => block(selections)
      },
      Field: {
        leave({ alias, name, arguments: args, directives, selectionSet }) {
          const prefix = wrap("", alias, ": ") + name;
          let argsLine = prefix + wrap("(", join(args, ", "), ")");
          if (argsLine.length > MAX_LINE_LENGTH) {
            argsLine = prefix + wrap("(\n", indent(join(args, "\n")), "\n)");
          }
          return join([argsLine, join(directives, " "), selectionSet], " ");
        }
      },
      Argument: {
        leave: ({ name, value }) => name + ": " + value
      },
      // Fragments
      FragmentSpread: {
        leave: ({ name, directives }) => "..." + name + wrap(" ", join(directives, " "))
      },
      InlineFragment: {
        leave: ({ typeCondition, directives, selectionSet }) => join(
          [
            "...",
            wrap("on ", typeCondition),
            join(directives, " "),
            selectionSet
          ],
          " "
        )
      },
      FragmentDefinition: {
        leave: ({ name, typeCondition, variableDefinitions, directives, selectionSet }) => (
          // or removed in the future.
          `fragment ${name}${wrap("(", join(variableDefinitions, ", "), ")")} on ${typeCondition} ${wrap("", join(directives, " "), " ")}` + selectionSet
        )
      },
      // Value
      IntValue: {
        leave: ({ value }) => value
      },
      FloatValue: {
        leave: ({ value }) => value
      },
      StringValue: {
        leave: ({ value, block: isBlockString }) => isBlockString ? printBlockString(value) : printString(value)
      },
      BooleanValue: {
        leave: ({ value }) => value ? "true" : "false"
      },
      NullValue: {
        leave: () => "null"
      },
      EnumValue: {
        leave: ({ value }) => value
      },
      ListValue: {
        leave: ({ values }) => "[" + join(values, ", ") + "]"
      },
      ObjectValue: {
        leave: ({ fields }) => "{" + join(fields, ", ") + "}"
      },
      ObjectField: {
        leave: ({ name, value }) => name + ": " + value
      },
      // Directive
      Directive: {
        leave: ({ name, arguments: args }) => "@" + name + wrap("(", join(args, ", "), ")")
      },
      // Type
      NamedType: {
        leave: ({ name }) => name
      },
      ListType: {
        leave: ({ type }) => "[" + type + "]"
      },
      NonNullType: {
        leave: ({ type }) => type + "!"
      },
      // Type System Definitions
      SchemaDefinition: {
        leave: ({ description, directives, operationTypes }) => wrap("", description, "\n") + join(["schema", join(directives, " "), block(operationTypes)], " ")
      },
      OperationTypeDefinition: {
        leave: ({ operation, type }) => operation + ": " + type
      },
      ScalarTypeDefinition: {
        leave: ({ description, name, directives }) => wrap("", description, "\n") + join(["scalar", name, join(directives, " ")], " ")
      },
      ObjectTypeDefinition: {
        leave: ({ description, name, interfaces, directives, fields }) => wrap("", description, "\n") + join(
          [
            "type",
            name,
            wrap("implements ", join(interfaces, " & ")),
            join(directives, " "),
            block(fields)
          ],
          " "
        )
      },
      FieldDefinition: {
        leave: ({ description, name, arguments: args, type, directives }) => wrap("", description, "\n") + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + ": " + type + wrap(" ", join(directives, " "))
      },
      InputValueDefinition: {
        leave: ({ description, name, type, defaultValue, directives }) => wrap("", description, "\n") + join(
          [name + ": " + type, wrap("= ", defaultValue), join(directives, " ")],
          " "
        )
      },
      InterfaceTypeDefinition: {
        leave: ({ description, name, interfaces, directives, fields }) => wrap("", description, "\n") + join(
          [
            "interface",
            name,
            wrap("implements ", join(interfaces, " & ")),
            join(directives, " "),
            block(fields)
          ],
          " "
        )
      },
      UnionTypeDefinition: {
        leave: ({ description, name, directives, types }) => wrap("", description, "\n") + join(
          ["union", name, join(directives, " "), wrap("= ", join(types, " | "))],
          " "
        )
      },
      EnumTypeDefinition: {
        leave: ({ description, name, directives, values }) => wrap("", description, "\n") + join(["enum", name, join(directives, " "), block(values)], " ")
      },
      EnumValueDefinition: {
        leave: ({ description, name, directives }) => wrap("", description, "\n") + join([name, join(directives, " ")], " ")
      },
      InputObjectTypeDefinition: {
        leave: ({ description, name, directives, fields }) => wrap("", description, "\n") + join(["input", name, join(directives, " "), block(fields)], " ")
      },
      DirectiveDefinition: {
        leave: ({ description, name, arguments: args, repeatable, locations }) => wrap("", description, "\n") + "directive @" + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join(locations, " | ")
      },
      SchemaExtension: {
        leave: ({ directives, operationTypes }) => join(
          ["extend schema", join(directives, " "), block(operationTypes)],
          " "
        )
      },
      ScalarTypeExtension: {
        leave: ({ name, directives }) => join(["extend scalar", name, join(directives, " ")], " ")
      },
      ObjectTypeExtension: {
        leave: ({ name, interfaces, directives, fields }) => join(
          [
            "extend type",
            name,
            wrap("implements ", join(interfaces, " & ")),
            join(directives, " "),
            block(fields)
          ],
          " "
        )
      },
      InterfaceTypeExtension: {
        leave: ({ name, interfaces, directives, fields }) => join(
          [
            "extend interface",
            name,
            wrap("implements ", join(interfaces, " & ")),
            join(directives, " "),
            block(fields)
          ],
          " "
        )
      },
      UnionTypeExtension: {
        leave: ({ name, directives, types }) => join(
          [
            "extend union",
            name,
            join(directives, " "),
            wrap("= ", join(types, " | "))
          ],
          " "
        )
      },
      EnumTypeExtension: {
        leave: ({ name, directives, values }) => join(["extend enum", name, join(directives, " "), block(values)], " ")
      },
      InputObjectTypeExtension: {
        leave: ({ name, directives, fields }) => join(["extend input", name, join(directives, " "), block(fields)], " ")
      }
    };
  }
});

// ../../../node_modules/graphql/utilities/valueFromASTUntyped.mjs
function valueFromASTUntyped(valueNode, variables) {
  switch (valueNode.kind) {
    case Kind.NULL:
      return null;
    case Kind.INT:
      return parseInt(valueNode.value, 10);
    case Kind.FLOAT:
      return parseFloat(valueNode.value);
    case Kind.STRING:
    case Kind.ENUM:
    case Kind.BOOLEAN:
      return valueNode.value;
    case Kind.LIST:
      return valueNode.values.map(
        (node) => valueFromASTUntyped(node, variables)
      );
    case Kind.OBJECT:
      return keyValMap(
        valueNode.fields,
        (field) => field.name.value,
        (field) => valueFromASTUntyped(field.value, variables)
      );
    case Kind.VARIABLE:
      return variables === null || variables === void 0 ? void 0 : variables[valueNode.name.value];
  }
}
var init_valueFromASTUntyped = __esm({
  "../../../node_modules/graphql/utilities/valueFromASTUntyped.mjs"() {
    init_keyValMap();
    init_kinds();
  }
});

// ../../../node_modules/graphql/type/assertName.mjs
function assertName(name) {
  name != null || devAssert(false, "Must provide name.");
  typeof name === "string" || devAssert(false, "Expected name to be a string.");
  if (name.length === 0) {
    throw new GraphQLError("Expected name to be a non-empty string.");
  }
  for (let i = 1; i < name.length; ++i) {
    if (!isNameContinue(name.charCodeAt(i))) {
      throw new GraphQLError(
        `Names must only contain [_a-zA-Z0-9] but "${name}" does not.`
      );
    }
  }
  if (!isNameStart(name.charCodeAt(0))) {
    throw new GraphQLError(
      `Names must start with [_a-zA-Z] but "${name}" does not.`
    );
  }
  return name;
}
function assertEnumValueName(name) {
  if (name === "true" || name === "false" || name === "null") {
    throw new GraphQLError(`Enum values cannot be named: ${name}`);
  }
  return assertName(name);
}
var init_assertName = __esm({
  "../../../node_modules/graphql/type/assertName.mjs"() {
    init_devAssert();
    init_GraphQLError();
    init_characterClasses();
  }
});

// ../../../node_modules/graphql/type/definition.mjs
function isType(type) {
  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type) || isListType(type) || isNonNullType(type);
}
function assertType(type) {
  if (!isType(type)) {
    throw new Error(`Expected ${inspect(type)} to be a GraphQL type.`);
  }
  return type;
}
function isScalarType(type) {
  return instanceOf(type, GraphQLScalarType);
}
function assertScalarType(type) {
  if (!isScalarType(type)) {
    throw new Error(`Expected ${inspect(type)} to be a GraphQL Scalar type.`);
  }
  return type;
}
function isObjectType(type) {
  return instanceOf(type, GraphQLObjectType);
}
function assertObjectType(type) {
  if (!isObjectType(type)) {
    throw new Error(`Expected ${inspect(type)} to be a GraphQL Object type.`);
  }
  return type;
}
function isInterfaceType(type) {
  return instanceOf(type, GraphQLInterfaceType);
}
function assertInterfaceType(type) {
  if (!isInterfaceType(type)) {
    throw new Error(
      `Expected ${inspect(type)} to be a GraphQL Interface type.`
    );
  }
  return type;
}
function isUnionType(type) {
  return instanceOf(type, GraphQLUnionType);
}
function assertUnionType(type) {
  if (!isUnionType(type)) {
    throw new Error(`Expected ${inspect(type)} to be a GraphQL Union type.`);
  }
  return type;
}
function isEnumType(type) {
  return instanceOf(type, GraphQLEnumType);
}
function assertEnumType(type) {
  if (!isEnumType(type)) {
    throw new Error(`Expected ${inspect(type)} to be a GraphQL Enum type.`);
  }
  return type;
}
function isInputObjectType(type) {
  return instanceOf(type, GraphQLInputObjectType);
}
function assertInputObjectType(type) {
  if (!isInputObjectType(type)) {
    throw new Error(
      `Expected ${inspect(type)} to be a GraphQL Input Object type.`
    );
  }
  return type;
}
function isListType(type) {
  return instanceOf(type, GraphQLList);
}
function assertListType(type) {
  if (!isListType(type)) {
    throw new Error(`Expected ${inspect(type)} to be a GraphQL List type.`);
  }
  return type;
}
function isNonNullType(type) {
  return instanceOf(type, GraphQLNonNull);
}
function assertNonNullType(type) {
  if (!isNonNullType(type)) {
    throw new Error(`Expected ${inspect(type)} to be a GraphQL Non-Null type.`);
  }
  return type;
}
function isInputType(type) {
  return isScalarType(type) || isEnumType(type) || isInputObjectType(type) || isWrappingType(type) && isInputType(type.ofType);
}
function assertInputType(type) {
  if (!isInputType(type)) {
    throw new Error(`Expected ${inspect(type)} to be a GraphQL input type.`);
  }
  return type;
}
function isOutputType(type) {
  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isWrappingType(type) && isOutputType(type.ofType);
}
function assertOutputType(type) {
  if (!isOutputType(type)) {
    throw new Error(`Expected ${inspect(type)} to be a GraphQL output type.`);
  }
  return type;
}
function isLeafType(type) {
  return isScalarType(type) || isEnumType(type);
}
function assertLeafType(type) {
  if (!isLeafType(type)) {
    throw new Error(`Expected ${inspect(type)} to be a GraphQL leaf type.`);
  }
  return type;
}
function isCompositeType(type) {
  return isObjectType(type) || isInterfaceType(type) || isUnionType(type);
}
function assertCompositeType(type) {
  if (!isCompositeType(type)) {
    throw new Error(
      `Expected ${inspect(type)} to be a GraphQL composite type.`
    );
  }
  return type;
}
function isAbstractType(type) {
  return isInterfaceType(type) || isUnionType(type);
}
function assertAbstractType(type) {
  if (!isAbstractType(type)) {
    throw new Error(`Expected ${inspect(type)} to be a GraphQL abstract type.`);
  }
  return type;
}
function isWrappingType(type) {
  return isListType(type) || isNonNullType(type);
}
function assertWrappingType(type) {
  if (!isWrappingType(type)) {
    throw new Error(`Expected ${inspect(type)} to be a GraphQL wrapping type.`);
  }
  return type;
}
function isNullableType(type) {
  return isType(type) && !isNonNullType(type);
}
function assertNullableType(type) {
  if (!isNullableType(type)) {
    throw new Error(`Expected ${inspect(type)} to be a GraphQL nullable type.`);
  }
  return type;
}
function getNullableType(type) {
  if (type) {
    return isNonNullType(type) ? type.ofType : type;
  }
}
function isNamedType(type) {
  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type);
}
function assertNamedType(type) {
  if (!isNamedType(type)) {
    throw new Error(`Expected ${inspect(type)} to be a GraphQL named type.`);
  }
  return type;
}
function getNamedType(type) {
  if (type) {
    let unwrappedType = type;
    while (isWrappingType(unwrappedType)) {
      unwrappedType = unwrappedType.ofType;
    }
    return unwrappedType;
  }
}
function resolveReadonlyArrayThunk(thunk) {
  return typeof thunk === "function" ? thunk() : thunk;
}
function resolveObjMapThunk(thunk) {
  return typeof thunk === "function" ? thunk() : thunk;
}
function defineInterfaces(config) {
  var _config$interfaces;
  const interfaces = resolveReadonlyArrayThunk(
    (_config$interfaces = config.interfaces) !== null && _config$interfaces !== void 0 ? _config$interfaces : []
  );
  Array.isArray(interfaces) || devAssert(
    false,
    `${config.name} interfaces must be an Array or a function which returns an Array.`
  );
  return interfaces;
}
function defineFieldMap(config) {
  const fieldMap = resolveObjMapThunk(config.fields);
  isPlainObj(fieldMap) || devAssert(
    false,
    `${config.name} fields must be an object with field names as keys or a function which returns such an object.`
  );
  return mapValue(fieldMap, (fieldConfig, fieldName) => {
    var _fieldConfig$args;
    isPlainObj(fieldConfig) || devAssert(
      false,
      `${config.name}.${fieldName} field config must be an object.`
    );
    fieldConfig.resolve == null || typeof fieldConfig.resolve === "function" || devAssert(
      false,
      `${config.name}.${fieldName} field resolver must be a function if provided, but got: ${inspect(fieldConfig.resolve)}.`
    );
    const argsConfig = (_fieldConfig$args = fieldConfig.args) !== null && _fieldConfig$args !== void 0 ? _fieldConfig$args : {};
    isPlainObj(argsConfig) || devAssert(
      false,
      `${config.name}.${fieldName} args must be an object with argument names as keys.`
    );
    return {
      name: assertName(fieldName),
      description: fieldConfig.description,
      type: fieldConfig.type,
      args: defineArguments(argsConfig),
      resolve: fieldConfig.resolve,
      subscribe: fieldConfig.subscribe,
      deprecationReason: fieldConfig.deprecationReason,
      extensions: toObjMap(fieldConfig.extensions),
      astNode: fieldConfig.astNode
    };
  });
}
function defineArguments(config) {
  return Object.entries(config).map(([argName, argConfig]) => ({
    name: assertName(argName),
    description: argConfig.description,
    type: argConfig.type,
    defaultValue: argConfig.defaultValue,
    deprecationReason: argConfig.deprecationReason,
    extensions: toObjMap(argConfig.extensions),
    astNode: argConfig.astNode
  }));
}
function isPlainObj(obj) {
  return isObjectLike(obj) && !Array.isArray(obj);
}
function fieldsToFieldsConfig(fields) {
  return mapValue(fields, (field) => ({
    description: field.description,
    type: field.type,
    args: argsToArgsConfig(field.args),
    resolve: field.resolve,
    subscribe: field.subscribe,
    deprecationReason: field.deprecationReason,
    extensions: field.extensions,
    astNode: field.astNode
  }));
}
function argsToArgsConfig(args) {
  return keyValMap(
    args,
    (arg) => arg.name,
    (arg) => ({
      description: arg.description,
      type: arg.type,
      defaultValue: arg.defaultValue,
      deprecationReason: arg.deprecationReason,
      extensions: arg.extensions,
      astNode: arg.astNode
    })
  );
}
function isRequiredArgument(arg) {
  return isNonNullType(arg.type) && arg.defaultValue === void 0;
}
function defineTypes(config) {
  const types = resolveReadonlyArrayThunk(config.types);
  Array.isArray(types) || devAssert(
    false,
    `Must provide Array of types or a function which returns such an array for Union ${config.name}.`
  );
  return types;
}
function didYouMeanEnumValue(enumType, unknownValueStr) {
  const allNames = enumType.getValues().map((value) => value.name);
  const suggestedValues = suggestionList(unknownValueStr, allNames);
  return didYouMean("the enum value", suggestedValues);
}
function defineEnumValues(typeName, valueMap) {
  isPlainObj(valueMap) || devAssert(
    false,
    `${typeName} values must be an object with value names as keys.`
  );
  return Object.entries(valueMap).map(([valueName, valueConfig]) => {
    isPlainObj(valueConfig) || devAssert(
      false,
      `${typeName}.${valueName} must refer to an object with a "value" key representing an internal value but got: ${inspect(valueConfig)}.`
    );
    return {
      name: assertEnumValueName(valueName),
      description: valueConfig.description,
      value: valueConfig.value !== void 0 ? valueConfig.value : valueName,
      deprecationReason: valueConfig.deprecationReason,
      extensions: toObjMap(valueConfig.extensions),
      astNode: valueConfig.astNode
    };
  });
}
function defineInputFieldMap(config) {
  const fieldMap = resolveObjMapThunk(config.fields);
  isPlainObj(fieldMap) || devAssert(
    false,
    `${config.name} fields must be an object with field names as keys or a function which returns such an object.`
  );
  return mapValue(fieldMap, (fieldConfig, fieldName) => {
    !("resolve" in fieldConfig) || devAssert(
      false,
      `${config.name}.${fieldName} field has a resolve property, but Input Types cannot define resolvers.`
    );
    return {
      name: assertName(fieldName),
      description: fieldConfig.description,
      type: fieldConfig.type,
      defaultValue: fieldConfig.defaultValue,
      deprecationReason: fieldConfig.deprecationReason,
      extensions: toObjMap(fieldConfig.extensions),
      astNode: fieldConfig.astNode
    };
  });
}
function isRequiredInputField(field) {
  return isNonNullType(field.type) && field.defaultValue === void 0;
}
var GraphQLList, GraphQLNonNull, GraphQLScalarType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType;
var init_definition = __esm({
  "../../../node_modules/graphql/type/definition.mjs"() {
    init_devAssert();
    init_didYouMean();
    init_identityFunc();
    init_inspect();
    init_instanceOf();
    init_isObjectLike();
    init_keyMap();
    init_keyValMap();
    init_mapValue();
    init_suggestionList();
    init_toObjMap();
    init_GraphQLError();
    init_kinds();
    init_printer();
    init_valueFromASTUntyped();
    init_assertName();
    GraphQLList = class {
      constructor(ofType) {
        isType(ofType) || devAssert(false, `Expected ${inspect(ofType)} to be a GraphQL type.`);
        this.ofType = ofType;
      }
      get [Symbol.toStringTag]() {
        return "GraphQLList";
      }
      toString() {
        return "[" + String(this.ofType) + "]";
      }
      toJSON() {
        return this.toString();
      }
    };
    GraphQLNonNull = class {
      constructor(ofType) {
        isNullableType(ofType) || devAssert(
          false,
          `Expected ${inspect(ofType)} to be a GraphQL nullable type.`
        );
        this.ofType = ofType;
      }
      get [Symbol.toStringTag]() {
        return "GraphQLNonNull";
      }
      toString() {
        return String(this.ofType) + "!";
      }
      toJSON() {
        return this.toString();
      }
    };
    GraphQLScalarType = class {
      constructor(config) {
        var _config$parseValue, _config$serialize, _config$parseLiteral, _config$extensionASTN;
        const parseValue2 = (_config$parseValue = config.parseValue) !== null && _config$parseValue !== void 0 ? _config$parseValue : identityFunc;
        this.name = assertName(config.name);
        this.description = config.description;
        this.specifiedByURL = config.specifiedByURL;
        this.serialize = (_config$serialize = config.serialize) !== null && _config$serialize !== void 0 ? _config$serialize : identityFunc;
        this.parseValue = parseValue2;
        this.parseLiteral = (_config$parseLiteral = config.parseLiteral) !== null && _config$parseLiteral !== void 0 ? _config$parseLiteral : (node, variables) => parseValue2(valueFromASTUntyped(node, variables));
        this.extensions = toObjMap(config.extensions);
        this.astNode = config.astNode;
        this.extensionASTNodes = (_config$extensionASTN = config.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];
        config.specifiedByURL == null || typeof config.specifiedByURL === "string" || devAssert(
          false,
          `${this.name} must provide "specifiedByURL" as a string, but got: ${inspect(config.specifiedByURL)}.`
        );
        config.serialize == null || typeof config.serialize === "function" || devAssert(
          false,
          `${this.name} must provide "serialize" function. If this custom Scalar is also used as an input type, ensure "parseValue" and "parseLiteral" functions are also provided.`
        );
        if (config.parseLiteral) {
          typeof config.parseValue === "function" && typeof config.parseLiteral === "function" || devAssert(
            false,
            `${this.name} must provide both "parseValue" and "parseLiteral" functions.`
          );
        }
      }
      get [Symbol.toStringTag]() {
        return "GraphQLScalarType";
      }
      toConfig() {
        return {
          name: this.name,
          description: this.description,
          specifiedByURL: this.specifiedByURL,
          serialize: this.serialize,
          parseValue: this.parseValue,
          parseLiteral: this.parseLiteral,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes
        };
      }
      toString() {
        return this.name;
      }
      toJSON() {
        return this.toString();
      }
    };
    GraphQLObjectType = class {
      constructor(config) {
        var _config$extensionASTN2;
        this.name = assertName(config.name);
        this.description = config.description;
        this.isTypeOf = config.isTypeOf;
        this.extensions = toObjMap(config.extensions);
        this.astNode = config.astNode;
        this.extensionASTNodes = (_config$extensionASTN2 = config.extensionASTNodes) !== null && _config$extensionASTN2 !== void 0 ? _config$extensionASTN2 : [];
        this._fields = () => defineFieldMap(config);
        this._interfaces = () => defineInterfaces(config);
        config.isTypeOf == null || typeof config.isTypeOf === "function" || devAssert(
          false,
          `${this.name} must provide "isTypeOf" as a function, but got: ${inspect(config.isTypeOf)}.`
        );
      }
      get [Symbol.toStringTag]() {
        return "GraphQLObjectType";
      }
      getFields() {
        if (typeof this._fields === "function") {
          this._fields = this._fields();
        }
        return this._fields;
      }
      getInterfaces() {
        if (typeof this._interfaces === "function") {
          this._interfaces = this._interfaces();
        }
        return this._interfaces;
      }
      toConfig() {
        return {
          name: this.name,
          description: this.description,
          interfaces: this.getInterfaces(),
          fields: fieldsToFieldsConfig(this.getFields()),
          isTypeOf: this.isTypeOf,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes
        };
      }
      toString() {
        return this.name;
      }
      toJSON() {
        return this.toString();
      }
    };
    GraphQLInterfaceType = class {
      constructor(config) {
        var _config$extensionASTN3;
        this.name = assertName(config.name);
        this.description = config.description;
        this.resolveType = config.resolveType;
        this.extensions = toObjMap(config.extensions);
        this.astNode = config.astNode;
        this.extensionASTNodes = (_config$extensionASTN3 = config.extensionASTNodes) !== null && _config$extensionASTN3 !== void 0 ? _config$extensionASTN3 : [];
        this._fields = defineFieldMap.bind(void 0, config);
        this._interfaces = defineInterfaces.bind(void 0, config);
        config.resolveType == null || typeof config.resolveType === "function" || devAssert(
          false,
          `${this.name} must provide "resolveType" as a function, but got: ${inspect(config.resolveType)}.`
        );
      }
      get [Symbol.toStringTag]() {
        return "GraphQLInterfaceType";
      }
      getFields() {
        if (typeof this._fields === "function") {
          this._fields = this._fields();
        }
        return this._fields;
      }
      getInterfaces() {
        if (typeof this._interfaces === "function") {
          this._interfaces = this._interfaces();
        }
        return this._interfaces;
      }
      toConfig() {
        return {
          name: this.name,
          description: this.description,
          interfaces: this.getInterfaces(),
          fields: fieldsToFieldsConfig(this.getFields()),
          resolveType: this.resolveType,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes
        };
      }
      toString() {
        return this.name;
      }
      toJSON() {
        return this.toString();
      }
    };
    GraphQLUnionType = class {
      constructor(config) {
        var _config$extensionASTN4;
        this.name = assertName(config.name);
        this.description = config.description;
        this.resolveType = config.resolveType;
        this.extensions = toObjMap(config.extensions);
        this.astNode = config.astNode;
        this.extensionASTNodes = (_config$extensionASTN4 = config.extensionASTNodes) !== null && _config$extensionASTN4 !== void 0 ? _config$extensionASTN4 : [];
        this._types = defineTypes.bind(void 0, config);
        config.resolveType == null || typeof config.resolveType === "function" || devAssert(
          false,
          `${this.name} must provide "resolveType" as a function, but got: ${inspect(config.resolveType)}.`
        );
      }
      get [Symbol.toStringTag]() {
        return "GraphQLUnionType";
      }
      getTypes() {
        if (typeof this._types === "function") {
          this._types = this._types();
        }
        return this._types;
      }
      toConfig() {
        return {
          name: this.name,
          description: this.description,
          types: this.getTypes(),
          resolveType: this.resolveType,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes
        };
      }
      toString() {
        return this.name;
      }
      toJSON() {
        return this.toString();
      }
    };
    GraphQLEnumType = class {
      /* <T> */
      constructor(config) {
        var _config$extensionASTN5;
        this.name = assertName(config.name);
        this.description = config.description;
        this.extensions = toObjMap(config.extensions);
        this.astNode = config.astNode;
        this.extensionASTNodes = (_config$extensionASTN5 = config.extensionASTNodes) !== null && _config$extensionASTN5 !== void 0 ? _config$extensionASTN5 : [];
        this._values = defineEnumValues(this.name, config.values);
        this._valueLookup = new Map(
          this._values.map((enumValue) => [enumValue.value, enumValue])
        );
        this._nameLookup = keyMap(this._values, (value) => value.name);
      }
      get [Symbol.toStringTag]() {
        return "GraphQLEnumType";
      }
      getValues() {
        return this._values;
      }
      getValue(name) {
        return this._nameLookup[name];
      }
      serialize(outputValue) {
        const enumValue = this._valueLookup.get(outputValue);
        if (enumValue === void 0) {
          throw new GraphQLError(
            `Enum "${this.name}" cannot represent value: ${inspect(outputValue)}`
          );
        }
        return enumValue.name;
      }
      parseValue(inputValue) {
        if (typeof inputValue !== "string") {
          const valueStr = inspect(inputValue);
          throw new GraphQLError(
            `Enum "${this.name}" cannot represent non-string value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr)
          );
        }
        const enumValue = this.getValue(inputValue);
        if (enumValue == null) {
          throw new GraphQLError(
            `Value "${inputValue}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, inputValue)
          );
        }
        return enumValue.value;
      }
      parseLiteral(valueNode, _variables) {
        if (valueNode.kind !== Kind.ENUM) {
          const valueStr = print(valueNode);
          throw new GraphQLError(
            `Enum "${this.name}" cannot represent non-enum value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr),
            {
              nodes: valueNode
            }
          );
        }
        const enumValue = this.getValue(valueNode.value);
        if (enumValue == null) {
          const valueStr = print(valueNode);
          throw new GraphQLError(
            `Value "${valueStr}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, valueStr),
            {
              nodes: valueNode
            }
          );
        }
        return enumValue.value;
      }
      toConfig() {
        const values = keyValMap(
          this.getValues(),
          (value) => value.name,
          (value) => ({
            description: value.description,
            value: value.value,
            deprecationReason: value.deprecationReason,
            extensions: value.extensions,
            astNode: value.astNode
          })
        );
        return {
          name: this.name,
          description: this.description,
          values,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes
        };
      }
      toString() {
        return this.name;
      }
      toJSON() {
        return this.toString();
      }
    };
    GraphQLInputObjectType = class {
      constructor(config) {
        var _config$extensionASTN6;
        this.name = assertName(config.name);
        this.description = config.description;
        this.extensions = toObjMap(config.extensions);
        this.astNode = config.astNode;
        this.extensionASTNodes = (_config$extensionASTN6 = config.extensionASTNodes) !== null && _config$extensionASTN6 !== void 0 ? _config$extensionASTN6 : [];
        this._fields = defineInputFieldMap.bind(void 0, config);
      }
      get [Symbol.toStringTag]() {
        return "GraphQLInputObjectType";
      }
      getFields() {
        if (typeof this._fields === "function") {
          this._fields = this._fields();
        }
        return this._fields;
      }
      toConfig() {
        const fields = mapValue(this.getFields(), (field) => ({
          description: field.description,
          type: field.type,
          defaultValue: field.defaultValue,
          deprecationReason: field.deprecationReason,
          extensions: field.extensions,
          astNode: field.astNode
        }));
        return {
          name: this.name,
          description: this.description,
          fields,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes
        };
      }
      toString() {
        return this.name;
      }
      toJSON() {
        return this.toString();
      }
    };
  }
});

// ../../../node_modules/graphql/utilities/typeComparators.mjs
function isEqualType(typeA, typeB) {
  if (typeA === typeB) {
    return true;
  }
  if (isNonNullType(typeA) && isNonNullType(typeB)) {
    return isEqualType(typeA.ofType, typeB.ofType);
  }
  if (isListType(typeA) && isListType(typeB)) {
    return isEqualType(typeA.ofType, typeB.ofType);
  }
  return false;
}
function isTypeSubTypeOf(schema, maybeSubType, superType) {
  if (maybeSubType === superType) {
    return true;
  }
  if (isNonNullType(superType)) {
    if (isNonNullType(maybeSubType)) {
      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
    }
    return false;
  }
  if (isNonNullType(maybeSubType)) {
    return isTypeSubTypeOf(schema, maybeSubType.ofType, superType);
  }
  if (isListType(superType)) {
    if (isListType(maybeSubType)) {
      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
    }
    return false;
  }
  if (isListType(maybeSubType)) {
    return false;
  }
  return isAbstractType(superType) && (isInterfaceType(maybeSubType) || isObjectType(maybeSubType)) && schema.isSubType(superType, maybeSubType);
}
function doTypesOverlap(schema, typeA, typeB) {
  if (typeA === typeB) {
    return true;
  }
  if (isAbstractType(typeA)) {
    if (isAbstractType(typeB)) {
      return schema.getPossibleTypes(typeA).some((type) => schema.isSubType(typeB, type));
    }
    return schema.isSubType(typeA, typeB);
  }
  if (isAbstractType(typeB)) {
    return schema.isSubType(typeB, typeA);
  }
  return false;
}
var init_typeComparators = __esm({
  "../../../node_modules/graphql/utilities/typeComparators.mjs"() {
    init_definition();
  }
});

// ../../../node_modules/graphql/type/scalars.mjs
function isSpecifiedScalarType(type) {
  return specifiedScalarTypes.some(({ name }) => type.name === name);
}
function serializeObject(outputValue) {
  if (isObjectLike(outputValue)) {
    if (typeof outputValue.valueOf === "function") {
      const valueOfResult = outputValue.valueOf();
      if (!isObjectLike(valueOfResult)) {
        return valueOfResult;
      }
    }
    if (typeof outputValue.toJSON === "function") {
      return outputValue.toJSON();
    }
  }
  return outputValue;
}
var GRAPHQL_MAX_INT, GRAPHQL_MIN_INT, GraphQLInt, GraphQLFloat, GraphQLString, GraphQLBoolean, GraphQLID, specifiedScalarTypes;
var init_scalars = __esm({
  "../../../node_modules/graphql/type/scalars.mjs"() {
    init_inspect();
    init_isObjectLike();
    init_GraphQLError();
    init_kinds();
    init_printer();
    init_definition();
    GRAPHQL_MAX_INT = 2147483647;
    GRAPHQL_MIN_INT = -2147483648;
    GraphQLInt = new GraphQLScalarType({
      name: "Int",
      description: "The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.",
      serialize(outputValue) {
        const coercedValue = serializeObject(outputValue);
        if (typeof coercedValue === "boolean") {
          return coercedValue ? 1 : 0;
        }
        let num = coercedValue;
        if (typeof coercedValue === "string" && coercedValue !== "") {
          num = Number(coercedValue);
        }
        if (typeof num !== "number" || !Number.isInteger(num)) {
          throw new GraphQLError(
            `Int cannot represent non-integer value: ${inspect(coercedValue)}`
          );
        }
        if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
          throw new GraphQLError(
            "Int cannot represent non 32-bit signed integer value: " + inspect(coercedValue)
          );
        }
        return num;
      },
      parseValue(inputValue) {
        if (typeof inputValue !== "number" || !Number.isInteger(inputValue)) {
          throw new GraphQLError(
            `Int cannot represent non-integer value: ${inspect(inputValue)}`
          );
        }
        if (inputValue > GRAPHQL_MAX_INT || inputValue < GRAPHQL_MIN_INT) {
          throw new GraphQLError(
            `Int cannot represent non 32-bit signed integer value: ${inputValue}`
          );
        }
        return inputValue;
      },
      parseLiteral(valueNode) {
        if (valueNode.kind !== Kind.INT) {
          throw new GraphQLError(
            `Int cannot represent non-integer value: ${print(valueNode)}`,
            {
              nodes: valueNode
            }
          );
        }
        const num = parseInt(valueNode.value, 10);
        if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
          throw new GraphQLError(
            `Int cannot represent non 32-bit signed integer value: ${valueNode.value}`,
            {
              nodes: valueNode
            }
          );
        }
        return num;
      }
    });
    GraphQLFloat = new GraphQLScalarType({
      name: "Float",
      description: "The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).",
      serialize(outputValue) {
        const coercedValue = serializeObject(outputValue);
        if (typeof coercedValue === "boolean") {
          return coercedValue ? 1 : 0;
        }
        let num = coercedValue;
        if (typeof coercedValue === "string" && coercedValue !== "") {
          num = Number(coercedValue);
        }
        if (typeof num !== "number" || !Number.isFinite(num)) {
          throw new GraphQLError(
            `Float cannot represent non numeric value: ${inspect(coercedValue)}`
          );
        }
        return num;
      },
      parseValue(inputValue) {
        if (typeof inputValue !== "number" || !Number.isFinite(inputValue)) {
          throw new GraphQLError(
            `Float cannot represent non numeric value: ${inspect(inputValue)}`
          );
        }
        return inputValue;
      },
      parseLiteral(valueNode) {
        if (valueNode.kind !== Kind.FLOAT && valueNode.kind !== Kind.INT) {
          throw new GraphQLError(
            `Float cannot represent non numeric value: ${print(valueNode)}`,
            valueNode
          );
        }
        return parseFloat(valueNode.value);
      }
    });
    GraphQLString = new GraphQLScalarType({
      name: "String",
      description: "The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.",
      serialize(outputValue) {
        const coercedValue = serializeObject(outputValue);
        if (typeof coercedValue === "string") {
          return coercedValue;
        }
        if (typeof coercedValue === "boolean") {
          return coercedValue ? "true" : "false";
        }
        if (typeof coercedValue === "number" && Number.isFinite(coercedValue)) {
          return coercedValue.toString();
        }
        throw new GraphQLError(
          `String cannot represent value: ${inspect(outputValue)}`
        );
      },
      parseValue(inputValue) {
        if (typeof inputValue !== "string") {
          throw new GraphQLError(
            `String cannot represent a non string value: ${inspect(inputValue)}`
          );
        }
        return inputValue;
      },
      parseLiteral(valueNode) {
        if (valueNode.kind !== Kind.STRING) {
          throw new GraphQLError(
            `String cannot represent a non string value: ${print(valueNode)}`,
            {
              nodes: valueNode
            }
          );
        }
        return valueNode.value;
      }
    });
    GraphQLBoolean = new GraphQLScalarType({
      name: "Boolean",
      description: "The `Boolean` scalar type represents `true` or `false`.",
      serialize(outputValue) {
        const coercedValue = serializeObject(outputValue);
        if (typeof coercedValue === "boolean") {
          return coercedValue;
        }
        if (Number.isFinite(coercedValue)) {
          return coercedValue !== 0;
        }
        throw new GraphQLError(
          `Boolean cannot represent a non boolean value: ${inspect(coercedValue)}`
        );
      },
      parseValue(inputValue) {
        if (typeof inputValue !== "boolean") {
          throw new GraphQLError(
            `Boolean cannot represent a non boolean value: ${inspect(inputValue)}`
          );
        }
        return inputValue;
      },
      parseLiteral(valueNode) {
        if (valueNode.kind !== Kind.BOOLEAN) {
          throw new GraphQLError(
            `Boolean cannot represent a non boolean value: ${print(valueNode)}`,
            {
              nodes: valueNode
            }
          );
        }
        return valueNode.value;
      }
    });
    GraphQLID = new GraphQLScalarType({
      name: "ID",
      description: 'The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.',
      serialize(outputValue) {
        const coercedValue = serializeObject(outputValue);
        if (typeof coercedValue === "string") {
          return coercedValue;
        }
        if (Number.isInteger(coercedValue)) {
          return String(coercedValue);
        }
        throw new GraphQLError(
          `ID cannot represent value: ${inspect(outputValue)}`
        );
      },
      parseValue(inputValue) {
        if (typeof inputValue === "string") {
          return inputValue;
        }
        if (typeof inputValue === "number" && Number.isInteger(inputValue)) {
          return inputValue.toString();
        }
        throw new GraphQLError(`ID cannot represent value: ${inspect(inputValue)}`);
      },
      parseLiteral(valueNode) {
        if (valueNode.kind !== Kind.STRING && valueNode.kind !== Kind.INT) {
          throw new GraphQLError(
            "ID cannot represent a non-string and non-integer value: " + print(valueNode),
            {
              nodes: valueNode
            }
          );
        }
        return valueNode.value;
      }
    });
    specifiedScalarTypes = Object.freeze([
      GraphQLString,
      GraphQLInt,
      GraphQLFloat,
      GraphQLBoolean,
      GraphQLID
    ]);
  }
});

// ../../../node_modules/graphql/type/directives.mjs
function isDirective(directive) {
  return instanceOf(directive, GraphQLDirective);
}
function assertDirective(directive) {
  if (!isDirective(directive)) {
    throw new Error(
      `Expected ${inspect(directive)} to be a GraphQL directive.`
    );
  }
  return directive;
}
function isSpecifiedDirective(directive) {
  return specifiedDirectives.some(({ name }) => name === directive.name);
}
var GraphQLDirective, GraphQLIncludeDirective, GraphQLSkipDirective, DEFAULT_DEPRECATION_REASON, GraphQLDeprecatedDirective, GraphQLSpecifiedByDirective, specifiedDirectives;
var init_directives = __esm({
  "../../../node_modules/graphql/type/directives.mjs"() {
    init_devAssert();
    init_inspect();
    init_instanceOf();
    init_isObjectLike();
    init_toObjMap();
    init_directiveLocation();
    init_assertName();
    init_definition();
    init_scalars();
    GraphQLDirective = class {
      constructor(config) {
        var _config$isRepeatable, _config$args;
        this.name = assertName(config.name);
        this.description = config.description;
        this.locations = config.locations;
        this.isRepeatable = (_config$isRepeatable = config.isRepeatable) !== null && _config$isRepeatable !== void 0 ? _config$isRepeatable : false;
        this.extensions = toObjMap(config.extensions);
        this.astNode = config.astNode;
        Array.isArray(config.locations) || devAssert(false, `@${config.name} locations must be an Array.`);
        const args = (_config$args = config.args) !== null && _config$args !== void 0 ? _config$args : {};
        isObjectLike(args) && !Array.isArray(args) || devAssert(
          false,
          `@${config.name} args must be an object with argument names as keys.`
        );
        this.args = defineArguments(args);
      }
      get [Symbol.toStringTag]() {
        return "GraphQLDirective";
      }
      toConfig() {
        return {
          name: this.name,
          description: this.description,
          locations: this.locations,
          args: argsToArgsConfig(this.args),
          isRepeatable: this.isRepeatable,
          extensions: this.extensions,
          astNode: this.astNode
        };
      }
      toString() {
        return "@" + this.name;
      }
      toJSON() {
        return this.toString();
      }
    };
    GraphQLIncludeDirective = new GraphQLDirective({
      name: "include",
      description: "Directs the executor to include this field or fragment only when the `if` argument is true.",
      locations: [
        DirectiveLocation.FIELD,
        DirectiveLocation.FRAGMENT_SPREAD,
        DirectiveLocation.INLINE_FRAGMENT
      ],
      args: {
        if: {
          type: new GraphQLNonNull(GraphQLBoolean),
          description: "Included when true."
        }
      }
    });
    GraphQLSkipDirective = new GraphQLDirective({
      name: "skip",
      description: "Directs the executor to skip this field or fragment when the `if` argument is true.",
      locations: [
        DirectiveLocation.FIELD,
        DirectiveLocation.FRAGMENT_SPREAD,
        DirectiveLocation.INLINE_FRAGMENT
      ],
      args: {
        if: {
          type: new GraphQLNonNull(GraphQLBoolean),
          description: "Skipped when true."
        }
      }
    });
    DEFAULT_DEPRECATION_REASON = "No longer supported";
    GraphQLDeprecatedDirective = new GraphQLDirective({
      name: "deprecated",
      description: "Marks an element of a GraphQL schema as no longer supported.",
      locations: [
        DirectiveLocation.FIELD_DEFINITION,
        DirectiveLocation.ARGUMENT_DEFINITION,
        DirectiveLocation.INPUT_FIELD_DEFINITION,
        DirectiveLocation.ENUM_VALUE
      ],
      args: {
        reason: {
          type: GraphQLString,
          description: "Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax, as specified by [CommonMark](https://commonmark.org/).",
          defaultValue: DEFAULT_DEPRECATION_REASON
        }
      }
    });
    GraphQLSpecifiedByDirective = new GraphQLDirective({
      name: "specifiedBy",
      description: "Exposes a URL that specifies the behavior of this scalar.",
      locations: [DirectiveLocation.SCALAR],
      args: {
        url: {
          type: new GraphQLNonNull(GraphQLString),
          description: "The URL that specifies the behavior of this scalar."
        }
      }
    });
    specifiedDirectives = Object.freeze([
      GraphQLIncludeDirective,
      GraphQLSkipDirective,
      GraphQLDeprecatedDirective,
      GraphQLSpecifiedByDirective
    ]);
  }
});

// ../../../node_modules/graphql/jsutils/isIterableObject.mjs
function isIterableObject(maybeIterable) {
  return typeof maybeIterable === "object" && typeof (maybeIterable === null || maybeIterable === void 0 ? void 0 : maybeIterable[Symbol.iterator]) === "function";
}
var init_isIterableObject = __esm({
  "../../../node_modules/graphql/jsutils/isIterableObject.mjs"() {
  }
});

// ../../../node_modules/graphql/utilities/astFromValue.mjs
function astFromValue(value, type) {
  if (isNonNullType(type)) {
    const astValue = astFromValue(value, type.ofType);
    if ((astValue === null || astValue === void 0 ? void 0 : astValue.kind) === Kind.NULL) {
      return null;
    }
    return astValue;
  }
  if (value === null) {
    return {
      kind: Kind.NULL
    };
  }
  if (value === void 0) {
    return null;
  }
  if (isListType(type)) {
    const itemType = type.ofType;
    if (isIterableObject(value)) {
      const valuesNodes = [];
      for (const item of value) {
        const itemNode = astFromValue(item, itemType);
        if (itemNode != null) {
          valuesNodes.push(itemNode);
        }
      }
      return {
        kind: Kind.LIST,
        values: valuesNodes
      };
    }
    return astFromValue(value, itemType);
  }
  if (isInputObjectType(type)) {
    if (!isObjectLike(value)) {
      return null;
    }
    const fieldNodes = [];
    for (const field of Object.values(type.getFields())) {
      const fieldValue = astFromValue(value[field.name], field.type);
      if (fieldValue) {
        fieldNodes.push({
          kind: Kind.OBJECT_FIELD,
          name: {
            kind: Kind.NAME,
            value: field.name
          },
          value: fieldValue
        });
      }
    }
    return {
      kind: Kind.OBJECT,
      fields: fieldNodes
    };
  }
  if (isLeafType(type)) {
    const serialized = type.serialize(value);
    if (serialized == null) {
      return null;
    }
    if (typeof serialized === "boolean") {
      return {
        kind: Kind.BOOLEAN,
        value: serialized
      };
    }
    if (typeof serialized === "number" && Number.isFinite(serialized)) {
      const stringNum = String(serialized);
      return integerStringRegExp.test(stringNum) ? {
        kind: Kind.INT,
        value: stringNum
      } : {
        kind: Kind.FLOAT,
        value: stringNum
      };
    }
    if (typeof serialized === "string") {
      if (isEnumType(type)) {
        return {
          kind: Kind.ENUM,
          value: serialized
        };
      }
      if (type === GraphQLID && integerStringRegExp.test(serialized)) {
        return {
          kind: Kind.INT,
          value: serialized
        };
      }
      return {
        kind: Kind.STRING,
        value: serialized
      };
    }
    throw new TypeError(`Cannot convert value to AST: ${inspect(serialized)}.`);
  }
  invariant(false, "Unexpected input type: " + inspect(type));
}
var integerStringRegExp;
var init_astFromValue = __esm({
  "../../../node_modules/graphql/utilities/astFromValue.mjs"() {
    init_inspect();
    init_invariant();
    init_isIterableObject();
    init_isObjectLike();
    init_kinds();
    init_definition();
    init_scalars();
    integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;
  }
});

// ../../../node_modules/graphql/type/introspection.mjs
function isIntrospectionType(type) {
  return introspectionTypes.some(({ name }) => type.name === name);
}
var __Schema, __Directive, __DirectiveLocation, __Type, __Field, __InputValue, __EnumValue, TypeKind, __TypeKind, SchemaMetaFieldDef, TypeMetaFieldDef, TypeNameMetaFieldDef, introspectionTypes;
var init_introspection = __esm({
  "../../../node_modules/graphql/type/introspection.mjs"() {
    init_inspect();
    init_invariant();
    init_directiveLocation();
    init_printer();
    init_astFromValue();
    init_definition();
    init_scalars();
    __Schema = new GraphQLObjectType({
      name: "__Schema",
      description: "A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations.",
      fields: () => ({
        description: {
          type: GraphQLString,
          resolve: (schema) => schema.description
        },
        types: {
          description: "A list of all types supported by this server.",
          type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__Type))),
          resolve(schema) {
            return Object.values(schema.getTypeMap());
          }
        },
        queryType: {
          description: "The type that query operations will be rooted at.",
          type: new GraphQLNonNull(__Type),
          resolve: (schema) => schema.getQueryType()
        },
        mutationType: {
          description: "If this server supports mutation, the type that mutation operations will be rooted at.",
          type: __Type,
          resolve: (schema) => schema.getMutationType()
        },
        subscriptionType: {
          description: "If this server support subscription, the type that subscription operations will be rooted at.",
          type: __Type,
          resolve: (schema) => schema.getSubscriptionType()
        },
        directives: {
          description: "A list of all directives supported by this server.",
          type: new GraphQLNonNull(
            new GraphQLList(new GraphQLNonNull(__Directive))
          ),
          resolve: (schema) => schema.getDirectives()
        }
      })
    });
    __Directive = new GraphQLObjectType({
      name: "__Directive",
      description: "A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.\n\nIn some cases, you need to provide options to alter GraphQL's execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.",
      fields: () => ({
        name: {
          type: new GraphQLNonNull(GraphQLString),
          resolve: (directive) => directive.name
        },
        description: {
          type: GraphQLString,
          resolve: (directive) => directive.description
        },
        isRepeatable: {
          type: new GraphQLNonNull(GraphQLBoolean),
          resolve: (directive) => directive.isRepeatable
        },
        locations: {
          type: new GraphQLNonNull(
            new GraphQLList(new GraphQLNonNull(__DirectiveLocation))
          ),
          resolve: (directive) => directive.locations
        },
        args: {
          type: new GraphQLNonNull(
            new GraphQLList(new GraphQLNonNull(__InputValue))
          ),
          args: {
            includeDeprecated: {
              type: GraphQLBoolean,
              defaultValue: false
            }
          },
          resolve(field, { includeDeprecated }) {
            return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
          }
        }
      })
    });
    __DirectiveLocation = new GraphQLEnumType({
      name: "__DirectiveLocation",
      description: "A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies.",
      values: {
        QUERY: {
          value: DirectiveLocation.QUERY,
          description: "Location adjacent to a query operation."
        },
        MUTATION: {
          value: DirectiveLocation.MUTATION,
          description: "Location adjacent to a mutation operation."
        },
        SUBSCRIPTION: {
          value: DirectiveLocation.SUBSCRIPTION,
          description: "Location adjacent to a subscription operation."
        },
        FIELD: {
          value: DirectiveLocation.FIELD,
          description: "Location adjacent to a field."
        },
        FRAGMENT_DEFINITION: {
          value: DirectiveLocation.FRAGMENT_DEFINITION,
          description: "Location adjacent to a fragment definition."
        },
        FRAGMENT_SPREAD: {
          value: DirectiveLocation.FRAGMENT_SPREAD,
          description: "Location adjacent to a fragment spread."
        },
        INLINE_FRAGMENT: {
          value: DirectiveLocation.INLINE_FRAGMENT,
          description: "Location adjacent to an inline fragment."
        },
        VARIABLE_DEFINITION: {
          value: DirectiveLocation.VARIABLE_DEFINITION,
          description: "Location adjacent to a variable definition."
        },
        SCHEMA: {
          value: DirectiveLocation.SCHEMA,
          description: "Location adjacent to a schema definition."
        },
        SCALAR: {
          value: DirectiveLocation.SCALAR,
          description: "Location adjacent to a scalar definition."
        },
        OBJECT: {
          value: DirectiveLocation.OBJECT,
          description: "Location adjacent to an object type definition."
        },
        FIELD_DEFINITION: {
          value: DirectiveLocation.FIELD_DEFINITION,
          description: "Location adjacent to a field definition."
        },
        ARGUMENT_DEFINITION: {
          value: DirectiveLocation.ARGUMENT_DEFINITION,
          description: "Location adjacent to an argument definition."
        },
        INTERFACE: {
          value: DirectiveLocation.INTERFACE,
          description: "Location adjacent to an interface definition."
        },
        UNION: {
          value: DirectiveLocation.UNION,
          description: "Location adjacent to a union definition."
        },
        ENUM: {
          value: DirectiveLocation.ENUM,
          description: "Location adjacent to an enum definition."
        },
        ENUM_VALUE: {
          value: DirectiveLocation.ENUM_VALUE,
          description: "Location adjacent to an enum value definition."
        },
        INPUT_OBJECT: {
          value: DirectiveLocation.INPUT_OBJECT,
          description: "Location adjacent to an input object type definition."
        },
        INPUT_FIELD_DEFINITION: {
          value: DirectiveLocation.INPUT_FIELD_DEFINITION,
          description: "Location adjacent to an input object field definition."
        }
      }
    });
    __Type = new GraphQLObjectType({
      name: "__Type",
      description: "The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.\n\nDepending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name, description and optional `specifiedByURL`, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types.",
      fields: () => ({
        kind: {
          type: new GraphQLNonNull(__TypeKind),
          resolve(type) {
            if (isScalarType(type)) {
              return TypeKind.SCALAR;
            }
            if (isObjectType(type)) {
              return TypeKind.OBJECT;
            }
            if (isInterfaceType(type)) {
              return TypeKind.INTERFACE;
            }
            if (isUnionType(type)) {
              return TypeKind.UNION;
            }
            if (isEnumType(type)) {
              return TypeKind.ENUM;
            }
            if (isInputObjectType(type)) {
              return TypeKind.INPUT_OBJECT;
            }
            if (isListType(type)) {
              return TypeKind.LIST;
            }
            if (isNonNullType(type)) {
              return TypeKind.NON_NULL;
            }
            invariant(false, `Unexpected type: "${inspect(type)}".`);
          }
        },
        name: {
          type: GraphQLString,
          resolve: (type) => "name" in type ? type.name : void 0
        },
        description: {
          type: GraphQLString,
          resolve: (type) => (
            /* c8 ignore next */
            "description" in type ? type.description : void 0
          )
        },
        specifiedByURL: {
          type: GraphQLString,
          resolve: (obj) => "specifiedByURL" in obj ? obj.specifiedByURL : void 0
        },
        fields: {
          type: new GraphQLList(new GraphQLNonNull(__Field)),
          args: {
            includeDeprecated: {
              type: GraphQLBoolean,
              defaultValue: false
            }
          },
          resolve(type, { includeDeprecated }) {
            if (isObjectType(type) || isInterfaceType(type)) {
              const fields = Object.values(type.getFields());
              return includeDeprecated ? fields : fields.filter((field) => field.deprecationReason == null);
            }
          }
        },
        interfaces: {
          type: new GraphQLList(new GraphQLNonNull(__Type)),
          resolve(type) {
            if (isObjectType(type) || isInterfaceType(type)) {
              return type.getInterfaces();
            }
          }
        },
        possibleTypes: {
          type: new GraphQLList(new GraphQLNonNull(__Type)),
          resolve(type, _args, _context, { schema }) {
            if (isAbstractType(type)) {
              return schema.getPossibleTypes(type);
            }
          }
        },
        enumValues: {
          type: new GraphQLList(new GraphQLNonNull(__EnumValue)),
          args: {
            includeDeprecated: {
              type: GraphQLBoolean,
              defaultValue: false
            }
          },
          resolve(type, { includeDeprecated }) {
            if (isEnumType(type)) {
              const values = type.getValues();
              return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
            }
          }
        },
        inputFields: {
          type: new GraphQLList(new GraphQLNonNull(__InputValue)),
          args: {
            includeDeprecated: {
              type: GraphQLBoolean,
              defaultValue: false
            }
          },
          resolve(type, { includeDeprecated }) {
            if (isInputObjectType(type)) {
              const values = Object.values(type.getFields());
              return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
            }
          }
        },
        ofType: {
          type: __Type,
          resolve: (type) => "ofType" in type ? type.ofType : void 0
        }
      })
    });
    __Field = new GraphQLObjectType({
      name: "__Field",
      description: "Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type.",
      fields: () => ({
        name: {
          type: new GraphQLNonNull(GraphQLString),
          resolve: (field) => field.name
        },
        description: {
          type: GraphQLString,
          resolve: (field) => field.description
        },
        args: {
          type: new GraphQLNonNull(
            new GraphQLList(new GraphQLNonNull(__InputValue))
          ),
          args: {
            includeDeprecated: {
              type: GraphQLBoolean,
              defaultValue: false
            }
          },
          resolve(field, { includeDeprecated }) {
            return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
          }
        },
        type: {
          type: new GraphQLNonNull(__Type),
          resolve: (field) => field.type
        },
        isDeprecated: {
          type: new GraphQLNonNull(GraphQLBoolean),
          resolve: (field) => field.deprecationReason != null
        },
        deprecationReason: {
          type: GraphQLString,
          resolve: (field) => field.deprecationReason
        }
      })
    });
    __InputValue = new GraphQLObjectType({
      name: "__InputValue",
      description: "Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value.",
      fields: () => ({
        name: {
          type: new GraphQLNonNull(GraphQLString),
          resolve: (inputValue) => inputValue.name
        },
        description: {
          type: GraphQLString,
          resolve: (inputValue) => inputValue.description
        },
        type: {
          type: new GraphQLNonNull(__Type),
          resolve: (inputValue) => inputValue.type
        },
        defaultValue: {
          type: GraphQLString,
          description: "A GraphQL-formatted string representing the default value for this input value.",
          resolve(inputValue) {
            const { type, defaultValue } = inputValue;
            const valueAST = astFromValue(defaultValue, type);
            return valueAST ? print(valueAST) : null;
          }
        },
        isDeprecated: {
          type: new GraphQLNonNull(GraphQLBoolean),
          resolve: (field) => field.deprecationReason != null
        },
        deprecationReason: {
          type: GraphQLString,
          resolve: (obj) => obj.deprecationReason
        }
      })
    });
    __EnumValue = new GraphQLObjectType({
      name: "__EnumValue",
      description: "One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string.",
      fields: () => ({
        name: {
          type: new GraphQLNonNull(GraphQLString),
          resolve: (enumValue) => enumValue.name
        },
        description: {
          type: GraphQLString,
          resolve: (enumValue) => enumValue.description
        },
        isDeprecated: {
          type: new GraphQLNonNull(GraphQLBoolean),
          resolve: (enumValue) => enumValue.deprecationReason != null
        },
        deprecationReason: {
          type: GraphQLString,
          resolve: (enumValue) => enumValue.deprecationReason
        }
      })
    });
    (function(TypeKind2) {
      TypeKind2["SCALAR"] = "SCALAR";
      TypeKind2["OBJECT"] = "OBJECT";
      TypeKind2["INTERFACE"] = "INTERFACE";
      TypeKind2["UNION"] = "UNION";
      TypeKind2["ENUM"] = "ENUM";
      TypeKind2["INPUT_OBJECT"] = "INPUT_OBJECT";
      TypeKind2["LIST"] = "LIST";
      TypeKind2["NON_NULL"] = "NON_NULL";
    })(TypeKind || (TypeKind = {}));
    __TypeKind = new GraphQLEnumType({
      name: "__TypeKind",
      description: "An enum describing what kind of type a given `__Type` is.",
      values: {
        SCALAR: {
          value: TypeKind.SCALAR,
          description: "Indicates this type is a scalar."
        },
        OBJECT: {
          value: TypeKind.OBJECT,
          description: "Indicates this type is an object. `fields` and `interfaces` are valid fields."
        },
        INTERFACE: {
          value: TypeKind.INTERFACE,
          description: "Indicates this type is an interface. `fields`, `interfaces`, and `possibleTypes` are valid fields."
        },
        UNION: {
          value: TypeKind.UNION,
          description: "Indicates this type is a union. `possibleTypes` is a valid field."
        },
        ENUM: {
          value: TypeKind.ENUM,
          description: "Indicates this type is an enum. `enumValues` is a valid field."
        },
        INPUT_OBJECT: {
          value: TypeKind.INPUT_OBJECT,
          description: "Indicates this type is an input object. `inputFields` is a valid field."
        },
        LIST: {
          value: TypeKind.LIST,
          description: "Indicates this type is a list. `ofType` is a valid field."
        },
        NON_NULL: {
          value: TypeKind.NON_NULL,
          description: "Indicates this type is a non-null. `ofType` is a valid field."
        }
      }
    });
    SchemaMetaFieldDef = {
      name: "__schema",
      type: new GraphQLNonNull(__Schema),
      description: "Access the current type schema of this server.",
      args: [],
      resolve: (_source, _args, _context, { schema }) => schema,
      deprecationReason: void 0,
      extensions: /* @__PURE__ */ Object.create(null),
      astNode: void 0
    };
    TypeMetaFieldDef = {
      name: "__type",
      type: __Type,
      description: "Request the type information of a single type.",
      args: [
        {
          name: "name",
          description: void 0,
          type: new GraphQLNonNull(GraphQLString),
          defaultValue: void 0,
          deprecationReason: void 0,
          extensions: /* @__PURE__ */ Object.create(null),
          astNode: void 0
        }
      ],
      resolve: (_source, { name }, _context, { schema }) => schema.getType(name),
      deprecationReason: void 0,
      extensions: /* @__PURE__ */ Object.create(null),
      astNode: void 0
    };
    TypeNameMetaFieldDef = {
      name: "__typename",
      type: new GraphQLNonNull(GraphQLString),
      description: "The name of the current Object type at runtime.",
      args: [],
      resolve: (_source, _args, _context, { parentType }) => parentType.name,
      deprecationReason: void 0,
      extensions: /* @__PURE__ */ Object.create(null),
      astNode: void 0
    };
    introspectionTypes = Object.freeze([
      __Schema,
      __Directive,
      __DirectiveLocation,
      __Type,
      __Field,
      __InputValue,
      __EnumValue,
      __TypeKind
    ]);
  }
});

// ../../../node_modules/graphql/type/schema.mjs
function isSchema(schema) {
  return instanceOf(schema, GraphQLSchema);
}
function assertSchema(schema) {
  if (!isSchema(schema)) {
    throw new Error(`Expected ${inspect(schema)} to be a GraphQL schema.`);
  }
  return schema;
}
function collectReferencedTypes(type, typeSet) {
  const namedType = getNamedType(type);
  if (!typeSet.has(namedType)) {
    typeSet.add(namedType);
    if (isUnionType(namedType)) {
      for (const memberType of namedType.getTypes()) {
        collectReferencedTypes(memberType, typeSet);
      }
    } else if (isObjectType(namedType) || isInterfaceType(namedType)) {
      for (const interfaceType of namedType.getInterfaces()) {
        collectReferencedTypes(interfaceType, typeSet);
      }
      for (const field of Object.values(namedType.getFields())) {
        collectReferencedTypes(field.type, typeSet);
        for (const arg of field.args) {
          collectReferencedTypes(arg.type, typeSet);
        }
      }
    } else if (isInputObjectType(namedType)) {
      for (const field of Object.values(namedType.getFields())) {
        collectReferencedTypes(field.type, typeSet);
      }
    }
  }
  return typeSet;
}
var GraphQLSchema;
var init_schema = __esm({
  "../../../node_modules/graphql/type/schema.mjs"() {
    init_devAssert();
    init_inspect();
    init_instanceOf();
    init_isObjectLike();
    init_toObjMap();
    init_ast();
    init_definition();
    init_directives();
    init_introspection();
    GraphQLSchema = class {
      // Used as a cache for validateSchema().
      constructor(config) {
        var _config$extensionASTN, _config$directives;
        this.__validationErrors = config.assumeValid === true ? [] : void 0;
        isObjectLike(config) || devAssert(false, "Must provide configuration object.");
        !config.types || Array.isArray(config.types) || devAssert(
          false,
          `"types" must be Array if provided but got: ${inspect(config.types)}.`
        );
        !config.directives || Array.isArray(config.directives) || devAssert(
          false,
          `"directives" must be Array if provided but got: ${inspect(config.directives)}.`
        );
        this.description = config.description;
        this.extensions = toObjMap(config.extensions);
        this.astNode = config.astNode;
        this.extensionASTNodes = (_config$extensionASTN = config.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];
        this._queryType = config.query;
        this._mutationType = config.mutation;
        this._subscriptionType = config.subscription;
        this._directives = (_config$directives = config.directives) !== null && _config$directives !== void 0 ? _config$directives : specifiedDirectives;
        const allReferencedTypes = new Set(config.types);
        if (config.types != null) {
          for (const type of config.types) {
            allReferencedTypes.delete(type);
            collectReferencedTypes(type, allReferencedTypes);
          }
        }
        if (this._queryType != null) {
          collectReferencedTypes(this._queryType, allReferencedTypes);
        }
        if (this._mutationType != null) {
          collectReferencedTypes(this._mutationType, allReferencedTypes);
        }
        if (this._subscriptionType != null) {
          collectReferencedTypes(this._subscriptionType, allReferencedTypes);
        }
        for (const directive of this._directives) {
          if (isDirective(directive)) {
            for (const arg of directive.args) {
              collectReferencedTypes(arg.type, allReferencedTypes);
            }
          }
        }
        collectReferencedTypes(__Schema, allReferencedTypes);
        this._typeMap = /* @__PURE__ */ Object.create(null);
        this._subTypeMap = /* @__PURE__ */ Object.create(null);
        this._implementationsMap = /* @__PURE__ */ Object.create(null);
        for (const namedType of allReferencedTypes) {
          if (namedType == null) {
            continue;
          }
          const typeName = namedType.name;
          typeName || devAssert(
            false,
            "One of the provided types for building the Schema is missing a name."
          );
          if (this._typeMap[typeName] !== void 0) {
            throw new Error(
              `Schema must contain uniquely named types but contains multiple types named "${typeName}".`
            );
          }
          this._typeMap[typeName] = namedType;
          if (isInterfaceType(namedType)) {
            for (const iface of namedType.getInterfaces()) {
              if (isInterfaceType(iface)) {
                let implementations = this._implementationsMap[iface.name];
                if (implementations === void 0) {
                  implementations = this._implementationsMap[iface.name] = {
                    objects: [],
                    interfaces: []
                  };
                }
                implementations.interfaces.push(namedType);
              }
            }
          } else if (isObjectType(namedType)) {
            for (const iface of namedType.getInterfaces()) {
              if (isInterfaceType(iface)) {
                let implementations = this._implementationsMap[iface.name];
                if (implementations === void 0) {
                  implementations = this._implementationsMap[iface.name] = {
                    objects: [],
                    interfaces: []
                  };
                }
                implementations.objects.push(namedType);
              }
            }
          }
        }
      }
      get [Symbol.toStringTag]() {
        return "GraphQLSchema";
      }
      getQueryType() {
        return this._queryType;
      }
      getMutationType() {
        return this._mutationType;
      }
      getSubscriptionType() {
        return this._subscriptionType;
      }
      getRootType(operation) {
        switch (operation) {
          case OperationTypeNode.QUERY:
            return this.getQueryType();
          case OperationTypeNode.MUTATION:
            return this.getMutationType();
          case OperationTypeNode.SUBSCRIPTION:
            return this.getSubscriptionType();
        }
      }
      getTypeMap() {
        return this._typeMap;
      }
      getType(name) {
        return this.getTypeMap()[name];
      }
      getPossibleTypes(abstractType) {
        return isUnionType(abstractType) ? abstractType.getTypes() : this.getImplementations(abstractType).objects;
      }
      getImplementations(interfaceType) {
        const implementations = this._implementationsMap[interfaceType.name];
        return implementations !== null && implementations !== void 0 ? implementations : {
          objects: [],
          interfaces: []
        };
      }
      isSubType(abstractType, maybeSubType) {
        let map = this._subTypeMap[abstractType.name];
        if (map === void 0) {
          map = /* @__PURE__ */ Object.create(null);
          if (isUnionType(abstractType)) {
            for (const type of abstractType.getTypes()) {
              map[type.name] = true;
            }
          } else {
            const implementations = this.getImplementations(abstractType);
            for (const type of implementations.objects) {
              map[type.name] = true;
            }
            for (const type of implementations.interfaces) {
              map[type.name] = true;
            }
          }
          this._subTypeMap[abstractType.name] = map;
        }
        return map[maybeSubType.name] !== void 0;
      }
      getDirectives() {
        return this._directives;
      }
      getDirective(name) {
        return this.getDirectives().find((directive) => directive.name === name);
      }
      toConfig() {
        return {
          description: this.description,
          query: this.getQueryType(),
          mutation: this.getMutationType(),
          subscription: this.getSubscriptionType(),
          types: Object.values(this.getTypeMap()),
          directives: this.getDirectives(),
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes,
          assumeValid: this.__validationErrors !== void 0
        };
      }
    };
  }
});

// ../../../node_modules/graphql/type/validate.mjs
function validateSchema(schema) {
  assertSchema(schema);
  if (schema.__validationErrors) {
    return schema.__validationErrors;
  }
  const context = new SchemaValidationContext(schema);
  validateRootTypes(context);
  validateDirectives(context);
  validateTypes(context);
  const errors = context.getErrors();
  schema.__validationErrors = errors;
  return errors;
}
function assertValidSchema(schema) {
  const errors = validateSchema(schema);
  if (errors.length !== 0) {
    throw new Error(errors.map((error) => error.message).join("\n\n"));
  }
}
function validateRootTypes(context) {
  const schema = context.schema;
  const queryType = schema.getQueryType();
  if (!queryType) {
    context.reportError("Query root type must be provided.", schema.astNode);
  } else if (!isObjectType(queryType)) {
    var _getOperationTypeNode;
    context.reportError(
      `Query root type must be Object type, it cannot be ${inspect(
        queryType
      )}.`,
      (_getOperationTypeNode = getOperationTypeNode(
        schema,
        OperationTypeNode.QUERY
      )) !== null && _getOperationTypeNode !== void 0 ? _getOperationTypeNode : queryType.astNode
    );
  }
  const mutationType = schema.getMutationType();
  if (mutationType && !isObjectType(mutationType)) {
    var _getOperationTypeNode2;
    context.reportError(
      `Mutation root type must be Object type if provided, it cannot be ${inspect(mutationType)}.`,
      (_getOperationTypeNode2 = getOperationTypeNode(
        schema,
        OperationTypeNode.MUTATION
      )) !== null && _getOperationTypeNode2 !== void 0 ? _getOperationTypeNode2 : mutationType.astNode
    );
  }
  const subscriptionType = schema.getSubscriptionType();
  if (subscriptionType && !isObjectType(subscriptionType)) {
    var _getOperationTypeNode3;
    context.reportError(
      `Subscription root type must be Object type if provided, it cannot be ${inspect(subscriptionType)}.`,
      (_getOperationTypeNode3 = getOperationTypeNode(
        schema,
        OperationTypeNode.SUBSCRIPTION
      )) !== null && _getOperationTypeNode3 !== void 0 ? _getOperationTypeNode3 : subscriptionType.astNode
    );
  }
}
function getOperationTypeNode(schema, operation) {
  var _flatMap$find;
  return (_flatMap$find = [schema.astNode, ...schema.extensionASTNodes].flatMap(
    // FIXME: https://github.com/graphql/graphql-js/issues/2203
    (schemaNode) => {
      var _schemaNode$operation;
      return (
        /* c8 ignore next */
        (_schemaNode$operation = schemaNode === null || schemaNode === void 0 ? void 0 : schemaNode.operationTypes) !== null && _schemaNode$operation !== void 0 ? _schemaNode$operation : []
      );
    }
  ).find((operationNode) => operationNode.operation === operation)) === null || _flatMap$find === void 0 ? void 0 : _flatMap$find.type;
}
function validateDirectives(context) {
  for (const directive of context.schema.getDirectives()) {
    if (!isDirective(directive)) {
      context.reportError(
        `Expected directive but got: ${inspect(directive)}.`,
        directive === null || directive === void 0 ? void 0 : directive.astNode
      );
      continue;
    }
    validateName(context, directive);
    for (const arg of directive.args) {
      validateName(context, arg);
      if (!isInputType(arg.type)) {
        context.reportError(
          `The type of @${directive.name}(${arg.name}:) must be Input Type but got: ${inspect(arg.type)}.`,
          arg.astNode
        );
      }
      if (isRequiredArgument(arg) && arg.deprecationReason != null) {
        var _arg$astNode;
        context.reportError(
          `Required argument @${directive.name}(${arg.name}:) cannot be deprecated.`,
          [
            getDeprecatedDirectiveNode(arg.astNode),
            (_arg$astNode = arg.astNode) === null || _arg$astNode === void 0 ? void 0 : _arg$astNode.type
          ]
        );
      }
    }
  }
}
function validateName(context, node) {
  if (node.name.startsWith("__")) {
    context.reportError(
      `Name "${node.name}" must not begin with "__", which is reserved by GraphQL introspection.`,
      node.astNode
    );
  }
}
function validateTypes(context) {
  const validateInputObjectCircularRefs = createInputObjectCircularRefsValidator(context);
  const typeMap = context.schema.getTypeMap();
  for (const type of Object.values(typeMap)) {
    if (!isNamedType(type)) {
      context.reportError(
        `Expected GraphQL named type but got: ${inspect(type)}.`,
        type.astNode
      );
      continue;
    }
    if (!isIntrospectionType(type)) {
      validateName(context, type);
    }
    if (isObjectType(type)) {
      validateFields(context, type);
      validateInterfaces(context, type);
    } else if (isInterfaceType(type)) {
      validateFields(context, type);
      validateInterfaces(context, type);
    } else if (isUnionType(type)) {
      validateUnionMembers(context, type);
    } else if (isEnumType(type)) {
      validateEnumValues(context, type);
    } else if (isInputObjectType(type)) {
      validateInputFields(context, type);
      validateInputObjectCircularRefs(type);
    }
  }
}
function validateFields(context, type) {
  const fields = Object.values(type.getFields());
  if (fields.length === 0) {
    context.reportError(`Type ${type.name} must define one or more fields.`, [
      type.astNode,
      ...type.extensionASTNodes
    ]);
  }
  for (const field of fields) {
    validateName(context, field);
    if (!isOutputType(field.type)) {
      var _field$astNode;
      context.reportError(
        `The type of ${type.name}.${field.name} must be Output Type but got: ${inspect(field.type)}.`,
        (_field$astNode = field.astNode) === null || _field$astNode === void 0 ? void 0 : _field$astNode.type
      );
    }
    for (const arg of field.args) {
      const argName = arg.name;
      validateName(context, arg);
      if (!isInputType(arg.type)) {
        var _arg$astNode2;
        context.reportError(
          `The type of ${type.name}.${field.name}(${argName}:) must be Input Type but got: ${inspect(arg.type)}.`,
          (_arg$astNode2 = arg.astNode) === null || _arg$astNode2 === void 0 ? void 0 : _arg$astNode2.type
        );
      }
      if (isRequiredArgument(arg) && arg.deprecationReason != null) {
        var _arg$astNode3;
        context.reportError(
          `Required argument ${type.name}.${field.name}(${argName}:) cannot be deprecated.`,
          [
            getDeprecatedDirectiveNode(arg.astNode),
            (_arg$astNode3 = arg.astNode) === null || _arg$astNode3 === void 0 ? void 0 : _arg$astNode3.type
          ]
        );
      }
    }
  }
}
function validateInterfaces(context, type) {
  const ifaceTypeNames = /* @__PURE__ */ Object.create(null);
  for (const iface of type.getInterfaces()) {
    if (!isInterfaceType(iface)) {
      context.reportError(
        `Type ${inspect(type)} must only implement Interface types, it cannot implement ${inspect(iface)}.`,
        getAllImplementsInterfaceNodes(type, iface)
      );
      continue;
    }
    if (type === iface) {
      context.reportError(
        `Type ${type.name} cannot implement itself because it would create a circular reference.`,
        getAllImplementsInterfaceNodes(type, iface)
      );
      continue;
    }
    if (ifaceTypeNames[iface.name]) {
      context.reportError(
        `Type ${type.name} can only implement ${iface.name} once.`,
        getAllImplementsInterfaceNodes(type, iface)
      );
      continue;
    }
    ifaceTypeNames[iface.name] = true;
    validateTypeImplementsAncestors(context, type, iface);
    validateTypeImplementsInterface(context, type, iface);
  }
}
function validateTypeImplementsInterface(context, type, iface) {
  const typeFieldMap = type.getFields();
  for (const ifaceField of Object.values(iface.getFields())) {
    const fieldName = ifaceField.name;
    const typeField = typeFieldMap[fieldName];
    if (!typeField) {
      context.reportError(
        `Interface field ${iface.name}.${fieldName} expected but ${type.name} does not provide it.`,
        [ifaceField.astNode, type.astNode, ...type.extensionASTNodes]
      );
      continue;
    }
    if (!isTypeSubTypeOf(context.schema, typeField.type, ifaceField.type)) {
      var _ifaceField$astNode, _typeField$astNode;
      context.reportError(
        `Interface field ${iface.name}.${fieldName} expects type ${inspect(ifaceField.type)} but ${type.name}.${fieldName} is type ${inspect(typeField.type)}.`,
        [
          (_ifaceField$astNode = ifaceField.astNode) === null || _ifaceField$astNode === void 0 ? void 0 : _ifaceField$astNode.type,
          (_typeField$astNode = typeField.astNode) === null || _typeField$astNode === void 0 ? void 0 : _typeField$astNode.type
        ]
      );
    }
    for (const ifaceArg of ifaceField.args) {
      const argName = ifaceArg.name;
      const typeArg = typeField.args.find((arg) => arg.name === argName);
      if (!typeArg) {
        context.reportError(
          `Interface field argument ${iface.name}.${fieldName}(${argName}:) expected but ${type.name}.${fieldName} does not provide it.`,
          [ifaceArg.astNode, typeField.astNode]
        );
        continue;
      }
      if (!isEqualType(ifaceArg.type, typeArg.type)) {
        var _ifaceArg$astNode, _typeArg$astNode;
        context.reportError(
          `Interface field argument ${iface.name}.${fieldName}(${argName}:) expects type ${inspect(ifaceArg.type)} but ${type.name}.${fieldName}(${argName}:) is type ${inspect(typeArg.type)}.`,
          [
            (_ifaceArg$astNode = ifaceArg.astNode) === null || _ifaceArg$astNode === void 0 ? void 0 : _ifaceArg$astNode.type,
            (_typeArg$astNode = typeArg.astNode) === null || _typeArg$astNode === void 0 ? void 0 : _typeArg$astNode.type
          ]
        );
      }
    }
    for (const typeArg of typeField.args) {
      const argName = typeArg.name;
      const ifaceArg = ifaceField.args.find((arg) => arg.name === argName);
      if (!ifaceArg && isRequiredArgument(typeArg)) {
        context.reportError(
          `Object field ${type.name}.${fieldName} includes required argument ${argName} that is missing from the Interface field ${iface.name}.${fieldName}.`,
          [typeArg.astNode, ifaceField.astNode]
        );
      }
    }
  }
}
function validateTypeImplementsAncestors(context, type, iface) {
  const ifaceInterfaces = type.getInterfaces();
  for (const transitive of iface.getInterfaces()) {
    if (!ifaceInterfaces.includes(transitive)) {
      context.reportError(
        transitive === type ? `Type ${type.name} cannot implement ${iface.name} because it would create a circular reference.` : `Type ${type.name} must implement ${transitive.name} because it is implemented by ${iface.name}.`,
        [
          ...getAllImplementsInterfaceNodes(iface, transitive),
          ...getAllImplementsInterfaceNodes(type, iface)
        ]
      );
    }
  }
}
function validateUnionMembers(context, union) {
  const memberTypes = union.getTypes();
  if (memberTypes.length === 0) {
    context.reportError(
      `Union type ${union.name} must define one or more member types.`,
      [union.astNode, ...union.extensionASTNodes]
    );
  }
  const includedTypeNames = /* @__PURE__ */ Object.create(null);
  for (const memberType of memberTypes) {
    if (includedTypeNames[memberType.name]) {
      context.reportError(
        `Union type ${union.name} can only include type ${memberType.name} once.`,
        getUnionMemberTypeNodes(union, memberType.name)
      );
      continue;
    }
    includedTypeNames[memberType.name] = true;
    if (!isObjectType(memberType)) {
      context.reportError(
        `Union type ${union.name} can only include Object types, it cannot include ${inspect(memberType)}.`,
        getUnionMemberTypeNodes(union, String(memberType))
      );
    }
  }
}
function validateEnumValues(context, enumType) {
  const enumValues = enumType.getValues();
  if (enumValues.length === 0) {
    context.reportError(
      `Enum type ${enumType.name} must define one or more values.`,
      [enumType.astNode, ...enumType.extensionASTNodes]
    );
  }
  for (const enumValue of enumValues) {
    validateName(context, enumValue);
  }
}
function validateInputFields(context, inputObj) {
  const fields = Object.values(inputObj.getFields());
  if (fields.length === 0) {
    context.reportError(
      `Input Object type ${inputObj.name} must define one or more fields.`,
      [inputObj.astNode, ...inputObj.extensionASTNodes]
    );
  }
  for (const field of fields) {
    validateName(context, field);
    if (!isInputType(field.type)) {
      var _field$astNode2;
      context.reportError(
        `The type of ${inputObj.name}.${field.name} must be Input Type but got: ${inspect(field.type)}.`,
        (_field$astNode2 = field.astNode) === null || _field$astNode2 === void 0 ? void 0 : _field$astNode2.type
      );
    }
    if (isRequiredInputField(field) && field.deprecationReason != null) {
      var _field$astNode3;
      context.reportError(
        `Required input field ${inputObj.name}.${field.name} cannot be deprecated.`,
        [
          getDeprecatedDirectiveNode(field.astNode),
          (_field$astNode3 = field.astNode) === null || _field$astNode3 === void 0 ? void 0 : _field$astNode3.type
        ]
      );
    }
  }
}
function createInputObjectCircularRefsValidator(context) {
  const visitedTypes = /* @__PURE__ */ Object.create(null);
  const fieldPath = [];
  const fieldPathIndexByTypeName = /* @__PURE__ */ Object.create(null);
  return detectCycleRecursive;
  function detectCycleRecursive(inputObj) {
    if (visitedTypes[inputObj.name]) {
      return;
    }
    visitedTypes[inputObj.name] = true;
    fieldPathIndexByTypeName[inputObj.name] = fieldPath.length;
    const fields = Object.values(inputObj.getFields());
    for (const field of fields) {
      if (isNonNullType(field.type) && isInputObjectType(field.type.ofType)) {
        const fieldType = field.type.ofType;
        const cycleIndex = fieldPathIndexByTypeName[fieldType.name];
        fieldPath.push(field);
        if (cycleIndex === void 0) {
          detectCycleRecursive(fieldType);
        } else {
          const cyclePath = fieldPath.slice(cycleIndex);
          const pathStr = cyclePath.map((fieldObj) => fieldObj.name).join(".");
          context.reportError(
            `Cannot reference Input Object "${fieldType.name}" within itself through a series of non-null fields: "${pathStr}".`,
            cyclePath.map((fieldObj) => fieldObj.astNode)
          );
        }
        fieldPath.pop();
      }
    }
    fieldPathIndexByTypeName[inputObj.name] = void 0;
  }
}
function getAllImplementsInterfaceNodes(type, iface) {
  const { astNode, extensionASTNodes } = type;
  const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes;
  return nodes.flatMap((typeNode) => {
    var _typeNode$interfaces;
    return (
      /* c8 ignore next */
      (_typeNode$interfaces = typeNode.interfaces) !== null && _typeNode$interfaces !== void 0 ? _typeNode$interfaces : []
    );
  }).filter((ifaceNode) => ifaceNode.name.value === iface.name);
}
function getUnionMemberTypeNodes(union, typeName) {
  const { astNode, extensionASTNodes } = union;
  const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes;
  return nodes.flatMap((unionNode) => {
    var _unionNode$types;
    return (
      /* c8 ignore next */
      (_unionNode$types = unionNode.types) !== null && _unionNode$types !== void 0 ? _unionNode$types : []
    );
  }).filter((typeNode) => typeNode.name.value === typeName);
}
function getDeprecatedDirectiveNode(definitionNode) {
  var _definitionNode$direc;
  return definitionNode === null || definitionNode === void 0 ? void 0 : (_definitionNode$direc = definitionNode.directives) === null || _definitionNode$direc === void 0 ? void 0 : _definitionNode$direc.find(
    (node) => node.name.value === GraphQLDeprecatedDirective.name
  );
}
var SchemaValidationContext;
var init_validate = __esm({
  "../../../node_modules/graphql/type/validate.mjs"() {
    init_inspect();
    init_GraphQLError();
    init_ast();
    init_typeComparators();
    init_definition();
    init_directives();
    init_introspection();
    init_schema();
    SchemaValidationContext = class {
      constructor(schema) {
        this._errors = [];
        this.schema = schema;
      }
      reportError(message, nodes) {
        const _nodes = Array.isArray(nodes) ? nodes.filter(Boolean) : nodes;
        this._errors.push(
          new GraphQLError(message, {
            nodes: _nodes
          })
        );
      }
      getErrors() {
        return this._errors;
      }
    };
  }
});

// ../../../node_modules/graphql/utilities/typeFromAST.mjs
function typeFromAST(schema, typeNode) {
  switch (typeNode.kind) {
    case Kind.LIST_TYPE: {
      const innerType = typeFromAST(schema, typeNode.type);
      return innerType && new GraphQLList(innerType);
    }
    case Kind.NON_NULL_TYPE: {
      const innerType = typeFromAST(schema, typeNode.type);
      return innerType && new GraphQLNonNull(innerType);
    }
    case Kind.NAMED_TYPE:
      return schema.getType(typeNode.name.value);
  }
}
var init_typeFromAST = __esm({
  "../../../node_modules/graphql/utilities/typeFromAST.mjs"() {
    init_kinds();
    init_definition();
  }
});

// ../../../node_modules/graphql/utilities/TypeInfo.mjs
function getFieldDef(schema, parentType, fieldNode) {
  const name = fieldNode.name.value;
  if (name === SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {
    return SchemaMetaFieldDef;
  }
  if (name === TypeMetaFieldDef.name && schema.getQueryType() === parentType) {
    return TypeMetaFieldDef;
  }
  if (name === TypeNameMetaFieldDef.name && isCompositeType(parentType)) {
    return TypeNameMetaFieldDef;
  }
  if (isObjectType(parentType) || isInterfaceType(parentType)) {
    return parentType.getFields()[name];
  }
}
function visitWithTypeInfo(typeInfo, visitor) {
  return {
    enter(...args) {
      const node = args[0];
      typeInfo.enter(node);
      const fn = getEnterLeaveForKind(visitor, node.kind).enter;
      if (fn) {
        const result = fn.apply(visitor, args);
        if (result !== void 0) {
          typeInfo.leave(node);
          if (isNode(result)) {
            typeInfo.enter(result);
          }
        }
        return result;
      }
    },
    leave(...args) {
      const node = args[0];
      const fn = getEnterLeaveForKind(visitor, node.kind).leave;
      let result;
      if (fn) {
        result = fn.apply(visitor, args);
      }
      typeInfo.leave(node);
      return result;
    }
  };
}
var TypeInfo;
var init_TypeInfo = __esm({
  "../../../node_modules/graphql/utilities/TypeInfo.mjs"() {
    init_ast();
    init_kinds();
    init_visitor();
    init_definition();
    init_introspection();
    init_typeFromAST();
    TypeInfo = class {
      constructor(schema, initialType, getFieldDefFn) {
        this._schema = schema;
        this._typeStack = [];
        this._parentTypeStack = [];
        this._inputTypeStack = [];
        this._fieldDefStack = [];
        this._defaultValueStack = [];
        this._directive = null;
        this._argument = null;
        this._enumValue = null;
        this._getFieldDef = getFieldDefFn !== null && getFieldDefFn !== void 0 ? getFieldDefFn : getFieldDef;
        if (initialType) {
          if (isInputType(initialType)) {
            this._inputTypeStack.push(initialType);
          }
          if (isCompositeType(initialType)) {
            this._parentTypeStack.push(initialType);
          }
          if (isOutputType(initialType)) {
            this._typeStack.push(initialType);
          }
        }
      }
      get [Symbol.toStringTag]() {
        return "TypeInfo";
      }
      getType() {
        if (this._typeStack.length > 0) {
          return this._typeStack[this._typeStack.length - 1];
        }
      }
      getParentType() {
        if (this._parentTypeStack.length > 0) {
          return this._parentTypeStack[this._parentTypeStack.length - 1];
        }
      }
      getInputType() {
        if (this._inputTypeStack.length > 0) {
          return this._inputTypeStack[this._inputTypeStack.length - 1];
        }
      }
      getParentInputType() {
        if (this._inputTypeStack.length > 1) {
          return this._inputTypeStack[this._inputTypeStack.length - 2];
        }
      }
      getFieldDef() {
        if (this._fieldDefStack.length > 0) {
          return this._fieldDefStack[this._fieldDefStack.length - 1];
        }
      }
      getDefaultValue() {
        if (this._defaultValueStack.length > 0) {
          return this._defaultValueStack[this._defaultValueStack.length - 1];
        }
      }
      getDirective() {
        return this._directive;
      }
      getArgument() {
        return this._argument;
      }
      getEnumValue() {
        return this._enumValue;
      }
      enter(node) {
        const schema = this._schema;
        switch (node.kind) {
          case Kind.SELECTION_SET: {
            const namedType = getNamedType(this.getType());
            this._parentTypeStack.push(
              isCompositeType(namedType) ? namedType : void 0
            );
            break;
          }
          case Kind.FIELD: {
            const parentType = this.getParentType();
            let fieldDef;
            let fieldType;
            if (parentType) {
              fieldDef = this._getFieldDef(schema, parentType, node);
              if (fieldDef) {
                fieldType = fieldDef.type;
              }
            }
            this._fieldDefStack.push(fieldDef);
            this._typeStack.push(isOutputType(fieldType) ? fieldType : void 0);
            break;
          }
          case Kind.DIRECTIVE:
            this._directive = schema.getDirective(node.name.value);
            break;
          case Kind.OPERATION_DEFINITION: {
            const rootType = schema.getRootType(node.operation);
            this._typeStack.push(isObjectType(rootType) ? rootType : void 0);
            break;
          }
          case Kind.INLINE_FRAGMENT:
          case Kind.FRAGMENT_DEFINITION: {
            const typeConditionAST = node.typeCondition;
            const outputType = typeConditionAST ? typeFromAST(schema, typeConditionAST) : getNamedType(this.getType());
            this._typeStack.push(isOutputType(outputType) ? outputType : void 0);
            break;
          }
          case Kind.VARIABLE_DEFINITION: {
            const inputType = typeFromAST(schema, node.type);
            this._inputTypeStack.push(
              isInputType(inputType) ? inputType : void 0
            );
            break;
          }
          case Kind.ARGUMENT: {
            var _this$getDirective;
            let argDef;
            let argType;
            const fieldOrDirective = (_this$getDirective = this.getDirective()) !== null && _this$getDirective !== void 0 ? _this$getDirective : this.getFieldDef();
            if (fieldOrDirective) {
              argDef = fieldOrDirective.args.find(
                (arg) => arg.name === node.name.value
              );
              if (argDef) {
                argType = argDef.type;
              }
            }
            this._argument = argDef;
            this._defaultValueStack.push(argDef ? argDef.defaultValue : void 0);
            this._inputTypeStack.push(isInputType(argType) ? argType : void 0);
            break;
          }
          case Kind.LIST: {
            const listType = getNullableType(this.getInputType());
            const itemType = isListType(listType) ? listType.ofType : listType;
            this._defaultValueStack.push(void 0);
            this._inputTypeStack.push(isInputType(itemType) ? itemType : void 0);
            break;
          }
          case Kind.OBJECT_FIELD: {
            const objectType = getNamedType(this.getInputType());
            let inputFieldType;
            let inputField;
            if (isInputObjectType(objectType)) {
              inputField = objectType.getFields()[node.name.value];
              if (inputField) {
                inputFieldType = inputField.type;
              }
            }
            this._defaultValueStack.push(
              inputField ? inputField.defaultValue : void 0
            );
            this._inputTypeStack.push(
              isInputType(inputFieldType) ? inputFieldType : void 0
            );
            break;
          }
          case Kind.ENUM: {
            const enumType = getNamedType(this.getInputType());
            let enumValue;
            if (isEnumType(enumType)) {
              enumValue = enumType.getValue(node.value);
            }
            this._enumValue = enumValue;
            break;
          }
          default:
        }
      }
      leave(node) {
        switch (node.kind) {
          case Kind.SELECTION_SET:
            this._parentTypeStack.pop();
            break;
          case Kind.FIELD:
            this._fieldDefStack.pop();
            this._typeStack.pop();
            break;
          case Kind.DIRECTIVE:
            this._directive = null;
            break;
          case Kind.OPERATION_DEFINITION:
          case Kind.INLINE_FRAGMENT:
          case Kind.FRAGMENT_DEFINITION:
            this._typeStack.pop();
            break;
          case Kind.VARIABLE_DEFINITION:
            this._inputTypeStack.pop();
            break;
          case Kind.ARGUMENT:
            this._argument = null;
            this._defaultValueStack.pop();
            this._inputTypeStack.pop();
            break;
          case Kind.LIST:
          case Kind.OBJECT_FIELD:
            this._defaultValueStack.pop();
            this._inputTypeStack.pop();
            break;
          case Kind.ENUM:
            this._enumValue = null;
            break;
          default:
        }
      }
    };
  }
});

// ../../../node_modules/graphql/language/predicates.mjs
function isDefinitionNode(node) {
  return isExecutableDefinitionNode(node) || isTypeSystemDefinitionNode(node) || isTypeSystemExtensionNode(node);
}
function isExecutableDefinitionNode(node) {
  return node.kind === Kind.OPERATION_DEFINITION || node.kind === Kind.FRAGMENT_DEFINITION;
}
function isSelectionNode(node) {
  return node.kind === Kind.FIELD || node.kind === Kind.FRAGMENT_SPREAD || node.kind === Kind.INLINE_FRAGMENT;
}
function isValueNode(node) {
  return node.kind === Kind.VARIABLE || node.kind === Kind.INT || node.kind === Kind.FLOAT || node.kind === Kind.STRING || node.kind === Kind.BOOLEAN || node.kind === Kind.NULL || node.kind === Kind.ENUM || node.kind === Kind.LIST || node.kind === Kind.OBJECT;
}
function isConstValueNode(node) {
  return isValueNode(node) && (node.kind === Kind.LIST ? node.values.some(isConstValueNode) : node.kind === Kind.OBJECT ? node.fields.some((field) => isConstValueNode(field.value)) : node.kind !== Kind.VARIABLE);
}
function isTypeNode(node) {
  return node.kind === Kind.NAMED_TYPE || node.kind === Kind.LIST_TYPE || node.kind === Kind.NON_NULL_TYPE;
}
function isTypeSystemDefinitionNode(node) {
  return node.kind === Kind.SCHEMA_DEFINITION || isTypeDefinitionNode(node) || node.kind === Kind.DIRECTIVE_DEFINITION;
}
function isTypeDefinitionNode(node) {
  return node.kind === Kind.SCALAR_TYPE_DEFINITION || node.kind === Kind.OBJECT_TYPE_DEFINITION || node.kind === Kind.INTERFACE_TYPE_DEFINITION || node.kind === Kind.UNION_TYPE_DEFINITION || node.kind === Kind.ENUM_TYPE_DEFINITION || node.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION;
}
function isTypeSystemExtensionNode(node) {
  return node.kind === Kind.SCHEMA_EXTENSION || isTypeExtensionNode(node);
}
function isTypeExtensionNode(node) {
  return node.kind === Kind.SCALAR_TYPE_EXTENSION || node.kind === Kind.OBJECT_TYPE_EXTENSION || node.kind === Kind.INTERFACE_TYPE_EXTENSION || node.kind === Kind.UNION_TYPE_EXTENSION || node.kind === Kind.ENUM_TYPE_EXTENSION || node.kind === Kind.INPUT_OBJECT_TYPE_EXTENSION;
}
var init_predicates = __esm({
  "../../../node_modules/graphql/language/predicates.mjs"() {
    init_kinds();
  }
});

// ../../../node_modules/graphql/validation/rules/ExecutableDefinitionsRule.mjs
function ExecutableDefinitionsRule(context) {
  return {
    Document(node) {
      for (const definition of node.definitions) {
        if (!isExecutableDefinitionNode(definition)) {
          const defName = definition.kind === Kind.SCHEMA_DEFINITION || definition.kind === Kind.SCHEMA_EXTENSION ? "schema" : '"' + definition.name.value + '"';
          context.reportError(
            new GraphQLError(`The ${defName} definition is not executable.`, {
              nodes: definition
            })
          );
        }
      }
      return false;
    }
  };
}
var init_ExecutableDefinitionsRule = __esm({
  "../../../node_modules/graphql/validation/rules/ExecutableDefinitionsRule.mjs"() {
    init_GraphQLError();
    init_kinds();
    init_predicates();
  }
});

// ../../../node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.mjs
function FieldsOnCorrectTypeRule(context) {
  return {
    Field(node) {
      const type = context.getParentType();
      if (type) {
        const fieldDef = context.getFieldDef();
        if (!fieldDef) {
          const schema = context.getSchema();
          const fieldName = node.name.value;
          let suggestion = didYouMean(
            "to use an inline fragment on",
            getSuggestedTypeNames(schema, type, fieldName)
          );
          if (suggestion === "") {
            suggestion = didYouMean(getSuggestedFieldNames(type, fieldName));
          }
          context.reportError(
            new GraphQLError(
              `Cannot query field "${fieldName}" on type "${type.name}".` + suggestion,
              {
                nodes: node
              }
            )
          );
        }
      }
    }
  };
}
function getSuggestedTypeNames(schema, type, fieldName) {
  if (!isAbstractType(type)) {
    return [];
  }
  const suggestedTypes = /* @__PURE__ */ new Set();
  const usageCount = /* @__PURE__ */ Object.create(null);
  for (const possibleType of schema.getPossibleTypes(type)) {
    if (!possibleType.getFields()[fieldName]) {
      continue;
    }
    suggestedTypes.add(possibleType);
    usageCount[possibleType.name] = 1;
    for (const possibleInterface of possibleType.getInterfaces()) {
      var _usageCount$possibleI;
      if (!possibleInterface.getFields()[fieldName]) {
        continue;
      }
      suggestedTypes.add(possibleInterface);
      usageCount[possibleInterface.name] = ((_usageCount$possibleI = usageCount[possibleInterface.name]) !== null && _usageCount$possibleI !== void 0 ? _usageCount$possibleI : 0) + 1;
    }
  }
  return [...suggestedTypes].sort((typeA, typeB) => {
    const usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];
    if (usageCountDiff !== 0) {
      return usageCountDiff;
    }
    if (isInterfaceType(typeA) && schema.isSubType(typeA, typeB)) {
      return -1;
    }
    if (isInterfaceType(typeB) && schema.isSubType(typeB, typeA)) {
      return 1;
    }
    return naturalCompare(typeA.name, typeB.name);
  }).map((x) => x.name);
}
function getSuggestedFieldNames(type, fieldName) {
  if (isObjectType(type) || isInterfaceType(type)) {
    const possibleFieldNames = Object.keys(type.getFields());
    return suggestionList(fieldName, possibleFieldNames);
  }
  return [];
}
var init_FieldsOnCorrectTypeRule = __esm({
  "../../../node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.mjs"() {
    init_didYouMean();
    init_naturalCompare();
    init_suggestionList();
    init_GraphQLError();
    init_definition();
  }
});

// ../../../node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.mjs
function FragmentsOnCompositeTypesRule(context) {
  return {
    InlineFragment(node) {
      const typeCondition = node.typeCondition;
      if (typeCondition) {
        const type = typeFromAST(context.getSchema(), typeCondition);
        if (type && !isCompositeType(type)) {
          const typeStr = print(typeCondition);
          context.reportError(
            new GraphQLError(
              `Fragment cannot condition on non composite type "${typeStr}".`,
              {
                nodes: typeCondition
              }
            )
          );
        }
      }
    },
    FragmentDefinition(node) {
      const type = typeFromAST(context.getSchema(), node.typeCondition);
      if (type && !isCompositeType(type)) {
        const typeStr = print(node.typeCondition);
        context.reportError(
          new GraphQLError(
            `Fragment "${node.name.value}" cannot condition on non composite type "${typeStr}".`,
            {
              nodes: node.typeCondition
            }
          )
        );
      }
    }
  };
}
var init_FragmentsOnCompositeTypesRule = __esm({
  "../../../node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.mjs"() {
    init_GraphQLError();
    init_printer();
    init_definition();
    init_typeFromAST();
  }
});

// ../../../node_modules/graphql/validation/rules/KnownArgumentNamesRule.mjs
function KnownArgumentNamesRule(context) {
  return {
    // eslint-disable-next-line new-cap
    ...KnownArgumentNamesOnDirectivesRule(context),
    Argument(argNode) {
      const argDef = context.getArgument();
      const fieldDef = context.getFieldDef();
      const parentType = context.getParentType();
      if (!argDef && fieldDef && parentType) {
        const argName = argNode.name.value;
        const knownArgsNames = fieldDef.args.map((arg) => arg.name);
        const suggestions = suggestionList(argName, knownArgsNames);
        context.reportError(
          new GraphQLError(
            `Unknown argument "${argName}" on field "${parentType.name}.${fieldDef.name}".` + didYouMean(suggestions),
            {
              nodes: argNode
            }
          )
        );
      }
    }
  };
}
function KnownArgumentNamesOnDirectivesRule(context) {
  const directiveArgs = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    directiveArgs[directive.name] = directive.args.map((arg) => arg.name);
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      var _def$arguments;
      const argsNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
      directiveArgs[def.name.value] = argsNodes.map((arg) => arg.name.value);
    }
  }
  return {
    Directive(directiveNode) {
      const directiveName = directiveNode.name.value;
      const knownArgs = directiveArgs[directiveName];
      if (directiveNode.arguments && knownArgs) {
        for (const argNode of directiveNode.arguments) {
          const argName = argNode.name.value;
          if (!knownArgs.includes(argName)) {
            const suggestions = suggestionList(argName, knownArgs);
            context.reportError(
              new GraphQLError(
                `Unknown argument "${argName}" on directive "@${directiveName}".` + didYouMean(suggestions),
                {
                  nodes: argNode
                }
              )
            );
          }
        }
      }
      return false;
    }
  };
}
var init_KnownArgumentNamesRule = __esm({
  "../../../node_modules/graphql/validation/rules/KnownArgumentNamesRule.mjs"() {
    init_didYouMean();
    init_suggestionList();
    init_GraphQLError();
    init_kinds();
    init_directives();
  }
});

// ../../../node_modules/graphql/validation/rules/KnownDirectivesRule.mjs
function KnownDirectivesRule(context) {
  const locationsMap = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    locationsMap[directive.name] = directive.locations;
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      locationsMap[def.name.value] = def.locations.map((name) => name.value);
    }
  }
  return {
    Directive(node, _key, _parent, _path, ancestors) {
      const name = node.name.value;
      const locations = locationsMap[name];
      if (!locations) {
        context.reportError(
          new GraphQLError(`Unknown directive "@${name}".`, {
            nodes: node
          })
        );
        return;
      }
      const candidateLocation = getDirectiveLocationForASTPath(ancestors);
      if (candidateLocation && !locations.includes(candidateLocation)) {
        context.reportError(
          new GraphQLError(
            `Directive "@${name}" may not be used on ${candidateLocation}.`,
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}
function getDirectiveLocationForASTPath(ancestors) {
  const appliedTo = ancestors[ancestors.length - 1];
  "kind" in appliedTo || invariant(false);
  switch (appliedTo.kind) {
    case Kind.OPERATION_DEFINITION:
      return getDirectiveLocationForOperation(appliedTo.operation);
    case Kind.FIELD:
      return DirectiveLocation.FIELD;
    case Kind.FRAGMENT_SPREAD:
      return DirectiveLocation.FRAGMENT_SPREAD;
    case Kind.INLINE_FRAGMENT:
      return DirectiveLocation.INLINE_FRAGMENT;
    case Kind.FRAGMENT_DEFINITION:
      return DirectiveLocation.FRAGMENT_DEFINITION;
    case Kind.VARIABLE_DEFINITION:
      return DirectiveLocation.VARIABLE_DEFINITION;
    case Kind.SCHEMA_DEFINITION:
    case Kind.SCHEMA_EXTENSION:
      return DirectiveLocation.SCHEMA;
    case Kind.SCALAR_TYPE_DEFINITION:
    case Kind.SCALAR_TYPE_EXTENSION:
      return DirectiveLocation.SCALAR;
    case Kind.OBJECT_TYPE_DEFINITION:
    case Kind.OBJECT_TYPE_EXTENSION:
      return DirectiveLocation.OBJECT;
    case Kind.FIELD_DEFINITION:
      return DirectiveLocation.FIELD_DEFINITION;
    case Kind.INTERFACE_TYPE_DEFINITION:
    case Kind.INTERFACE_TYPE_EXTENSION:
      return DirectiveLocation.INTERFACE;
    case Kind.UNION_TYPE_DEFINITION:
    case Kind.UNION_TYPE_EXTENSION:
      return DirectiveLocation.UNION;
    case Kind.ENUM_TYPE_DEFINITION:
    case Kind.ENUM_TYPE_EXTENSION:
      return DirectiveLocation.ENUM;
    case Kind.ENUM_VALUE_DEFINITION:
      return DirectiveLocation.ENUM_VALUE;
    case Kind.INPUT_OBJECT_TYPE_DEFINITION:
    case Kind.INPUT_OBJECT_TYPE_EXTENSION:
      return DirectiveLocation.INPUT_OBJECT;
    case Kind.INPUT_VALUE_DEFINITION: {
      const parentNode = ancestors[ancestors.length - 3];
      "kind" in parentNode || invariant(false);
      return parentNode.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION ? DirectiveLocation.INPUT_FIELD_DEFINITION : DirectiveLocation.ARGUMENT_DEFINITION;
    }
    default:
      invariant(false, "Unexpected kind: " + inspect(appliedTo.kind));
  }
}
function getDirectiveLocationForOperation(operation) {
  switch (operation) {
    case OperationTypeNode.QUERY:
      return DirectiveLocation.QUERY;
    case OperationTypeNode.MUTATION:
      return DirectiveLocation.MUTATION;
    case OperationTypeNode.SUBSCRIPTION:
      return DirectiveLocation.SUBSCRIPTION;
  }
}
var init_KnownDirectivesRule = __esm({
  "../../../node_modules/graphql/validation/rules/KnownDirectivesRule.mjs"() {
    init_inspect();
    init_invariant();
    init_GraphQLError();
    init_ast();
    init_directiveLocation();
    init_kinds();
    init_directives();
  }
});

// ../../../node_modules/graphql/validation/rules/KnownFragmentNamesRule.mjs
function KnownFragmentNamesRule(context) {
  return {
    FragmentSpread(node) {
      const fragmentName = node.name.value;
      const fragment = context.getFragment(fragmentName);
      if (!fragment) {
        context.reportError(
          new GraphQLError(`Unknown fragment "${fragmentName}".`, {
            nodes: node.name
          })
        );
      }
    }
  };
}
var init_KnownFragmentNamesRule = __esm({
  "../../../node_modules/graphql/validation/rules/KnownFragmentNamesRule.mjs"() {
    init_GraphQLError();
  }
});

// ../../../node_modules/graphql/validation/rules/KnownTypeNamesRule.mjs
function KnownTypeNamesRule(context) {
  const schema = context.getSchema();
  const existingTypesMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
  const definedTypes = /* @__PURE__ */ Object.create(null);
  for (const def of context.getDocument().definitions) {
    if (isTypeDefinitionNode(def)) {
      definedTypes[def.name.value] = true;
    }
  }
  const typeNames = [
    ...Object.keys(existingTypesMap),
    ...Object.keys(definedTypes)
  ];
  return {
    NamedType(node, _1, parent, _2, ancestors) {
      const typeName = node.name.value;
      if (!existingTypesMap[typeName] && !definedTypes[typeName]) {
        var _ancestors$;
        const definitionNode = (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== void 0 ? _ancestors$ : parent;
        const isSDL = definitionNode != null && isSDLNode(definitionNode);
        if (isSDL && standardTypeNames.includes(typeName)) {
          return;
        }
        const suggestedTypes = suggestionList(
          typeName,
          isSDL ? standardTypeNames.concat(typeNames) : typeNames
        );
        context.reportError(
          new GraphQLError(
            `Unknown type "${typeName}".` + didYouMean(suggestedTypes),
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}
function isSDLNode(value) {
  return "kind" in value && (isTypeSystemDefinitionNode(value) || isTypeSystemExtensionNode(value));
}
var standardTypeNames;
var init_KnownTypeNamesRule = __esm({
  "../../../node_modules/graphql/validation/rules/KnownTypeNamesRule.mjs"() {
    init_didYouMean();
    init_suggestionList();
    init_GraphQLError();
    init_predicates();
    init_introspection();
    init_scalars();
    standardTypeNames = [...specifiedScalarTypes, ...introspectionTypes].map(
      (type) => type.name
    );
  }
});

// ../../../node_modules/graphql/validation/rules/LoneAnonymousOperationRule.mjs
function LoneAnonymousOperationRule(context) {
  let operationCount = 0;
  return {
    Document(node) {
      operationCount = node.definitions.filter(
        (definition) => definition.kind === Kind.OPERATION_DEFINITION
      ).length;
    },
    OperationDefinition(node) {
      if (!node.name && operationCount > 1) {
        context.reportError(
          new GraphQLError(
            "This anonymous operation must be the only defined operation.",
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}
var init_LoneAnonymousOperationRule = __esm({
  "../../../node_modules/graphql/validation/rules/LoneAnonymousOperationRule.mjs"() {
    init_GraphQLError();
    init_kinds();
  }
});

// ../../../node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.mjs
function LoneSchemaDefinitionRule(context) {
  var _ref, _ref2, _oldSchema$astNode;
  const oldSchema = context.getSchema();
  const alreadyDefined = (_ref = (_ref2 = (_oldSchema$astNode = oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.astNode) !== null && _oldSchema$astNode !== void 0 ? _oldSchema$astNode : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getQueryType()) !== null && _ref2 !== void 0 ? _ref2 : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getMutationType()) !== null && _ref !== void 0 ? _ref : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getSubscriptionType();
  let schemaDefinitionsCount = 0;
  return {
    SchemaDefinition(node) {
      if (alreadyDefined) {
        context.reportError(
          new GraphQLError(
            "Cannot define a new schema within a schema extension.",
            {
              nodes: node
            }
          )
        );
        return;
      }
      if (schemaDefinitionsCount > 0) {
        context.reportError(
          new GraphQLError("Must provide only one schema definition.", {
            nodes: node
          })
        );
      }
      ++schemaDefinitionsCount;
    }
  };
}
var init_LoneSchemaDefinitionRule = __esm({
  "../../../node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.mjs"() {
    init_GraphQLError();
  }
});

// ../../../node_modules/graphql/validation/rules/NoFragmentCyclesRule.mjs
function NoFragmentCyclesRule(context) {
  const visitedFrags = /* @__PURE__ */ Object.create(null);
  const spreadPath = [];
  const spreadPathIndexByName = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: () => false,
    FragmentDefinition(node) {
      detectCycleRecursive(node);
      return false;
    }
  };
  function detectCycleRecursive(fragment) {
    if (visitedFrags[fragment.name.value]) {
      return;
    }
    const fragmentName = fragment.name.value;
    visitedFrags[fragmentName] = true;
    const spreadNodes = context.getFragmentSpreads(fragment.selectionSet);
    if (spreadNodes.length === 0) {
      return;
    }
    spreadPathIndexByName[fragmentName] = spreadPath.length;
    for (const spreadNode of spreadNodes) {
      const spreadName = spreadNode.name.value;
      const cycleIndex = spreadPathIndexByName[spreadName];
      spreadPath.push(spreadNode);
      if (cycleIndex === void 0) {
        const spreadFragment = context.getFragment(spreadName);
        if (spreadFragment) {
          detectCycleRecursive(spreadFragment);
        }
      } else {
        const cyclePath = spreadPath.slice(cycleIndex);
        const viaPath = cyclePath.slice(0, -1).map((s) => '"' + s.name.value + '"').join(", ");
        context.reportError(
          new GraphQLError(
            `Cannot spread fragment "${spreadName}" within itself` + (viaPath !== "" ? ` via ${viaPath}.` : "."),
            {
              nodes: cyclePath
            }
          )
        );
      }
      spreadPath.pop();
    }
    spreadPathIndexByName[fragmentName] = void 0;
  }
}
var init_NoFragmentCyclesRule = __esm({
  "../../../node_modules/graphql/validation/rules/NoFragmentCyclesRule.mjs"() {
    init_GraphQLError();
  }
});

// ../../../node_modules/graphql/validation/rules/NoUndefinedVariablesRule.mjs
function NoUndefinedVariablesRule(context) {
  let variableNameDefined = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: {
      enter() {
        variableNameDefined = /* @__PURE__ */ Object.create(null);
      },
      leave(operation) {
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node } of usages) {
          const varName = node.name.value;
          if (variableNameDefined[varName] !== true) {
            context.reportError(
              new GraphQLError(
                operation.name ? `Variable "$${varName}" is not defined by operation "${operation.name.value}".` : `Variable "$${varName}" is not defined.`,
                {
                  nodes: [node, operation]
                }
              )
            );
          }
        }
      }
    },
    VariableDefinition(node) {
      variableNameDefined[node.variable.name.value] = true;
    }
  };
}
var init_NoUndefinedVariablesRule = __esm({
  "../../../node_modules/graphql/validation/rules/NoUndefinedVariablesRule.mjs"() {
    init_GraphQLError();
  }
});

// ../../../node_modules/graphql/validation/rules/NoUnusedFragmentsRule.mjs
function NoUnusedFragmentsRule(context) {
  const operationDefs = [];
  const fragmentDefs = [];
  return {
    OperationDefinition(node) {
      operationDefs.push(node);
      return false;
    },
    FragmentDefinition(node) {
      fragmentDefs.push(node);
      return false;
    },
    Document: {
      leave() {
        const fragmentNameUsed = /* @__PURE__ */ Object.create(null);
        for (const operation of operationDefs) {
          for (const fragment of context.getRecursivelyReferencedFragments(
            operation
          )) {
            fragmentNameUsed[fragment.name.value] = true;
          }
        }
        for (const fragmentDef of fragmentDefs) {
          const fragName = fragmentDef.name.value;
          if (fragmentNameUsed[fragName] !== true) {
            context.reportError(
              new GraphQLError(`Fragment "${fragName}" is never used.`, {
                nodes: fragmentDef
              })
            );
          }
        }
      }
    }
  };
}
var init_NoUnusedFragmentsRule = __esm({
  "../../../node_modules/graphql/validation/rules/NoUnusedFragmentsRule.mjs"() {
    init_GraphQLError();
  }
});

// ../../../node_modules/graphql/validation/rules/NoUnusedVariablesRule.mjs
function NoUnusedVariablesRule(context) {
  let variableDefs = [];
  return {
    OperationDefinition: {
      enter() {
        variableDefs = [];
      },
      leave(operation) {
        const variableNameUsed = /* @__PURE__ */ Object.create(null);
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node } of usages) {
          variableNameUsed[node.name.value] = true;
        }
        for (const variableDef of variableDefs) {
          const variableName = variableDef.variable.name.value;
          if (variableNameUsed[variableName] !== true) {
            context.reportError(
              new GraphQLError(
                operation.name ? `Variable "$${variableName}" is never used in operation "${operation.name.value}".` : `Variable "$${variableName}" is never used.`,
                {
                  nodes: variableDef
                }
              )
            );
          }
        }
      }
    },
    VariableDefinition(def) {
      variableDefs.push(def);
    }
  };
}
var init_NoUnusedVariablesRule = __esm({
  "../../../node_modules/graphql/validation/rules/NoUnusedVariablesRule.mjs"() {
    init_GraphQLError();
  }
});

// ../../../node_modules/graphql/utilities/sortValueNode.mjs
function sortValueNode(valueNode) {
  switch (valueNode.kind) {
    case Kind.OBJECT:
      return { ...valueNode, fields: sortFields(valueNode.fields) };
    case Kind.LIST:
      return { ...valueNode, values: valueNode.values.map(sortValueNode) };
    case Kind.INT:
    case Kind.FLOAT:
    case Kind.STRING:
    case Kind.BOOLEAN:
    case Kind.NULL:
    case Kind.ENUM:
    case Kind.VARIABLE:
      return valueNode;
  }
}
function sortFields(fields) {
  return fields.map((fieldNode) => ({
    ...fieldNode,
    value: sortValueNode(fieldNode.value)
  })).sort(
    (fieldA, fieldB) => naturalCompare(fieldA.name.value, fieldB.name.value)
  );
}
var init_sortValueNode = __esm({
  "../../../node_modules/graphql/utilities/sortValueNode.mjs"() {
    init_naturalCompare();
    init_kinds();
  }
});

// ../../../node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.mjs
function reasonMessage(reason) {
  if (Array.isArray(reason)) {
    return reason.map(
      ([responseName, subReason]) => `subfields "${responseName}" conflict because ` + reasonMessage(subReason)
    ).join(" and ");
  }
  return reason;
}
function OverlappingFieldsCanBeMergedRule(context) {
  const comparedFragmentPairs = new PairSet();
  const cachedFieldsAndFragmentNames = /* @__PURE__ */ new Map();
  return {
    SelectionSet(selectionSet) {
      const conflicts = findConflictsWithinSelectionSet(
        context,
        cachedFieldsAndFragmentNames,
        comparedFragmentPairs,
        context.getParentType(),
        selectionSet
      );
      for (const [[responseName, reason], fields1, fields2] of conflicts) {
        const reasonMsg = reasonMessage(reason);
        context.reportError(
          new GraphQLError(
            `Fields "${responseName}" conflict because ${reasonMsg}. Use different aliases on the fields to fetch both if this was intentional.`,
            {
              nodes: fields1.concat(fields2)
            }
          )
        );
      }
    }
  };
}
function findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentType, selectionSet) {
  const conflicts = [];
  const [fieldMap, fragmentNames] = getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    parentType,
    selectionSet
  );
  collectConflictsWithin(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFragmentPairs,
    fieldMap
  );
  if (fragmentNames.length !== 0) {
    for (let i = 0; i < fragmentNames.length; i++) {
      collectConflictsBetweenFieldsAndFragment(
        context,
        conflicts,
        cachedFieldsAndFragmentNames,
        comparedFragmentPairs,
        false,
        fieldMap,
        fragmentNames[i]
      );
      for (let j = i + 1; j < fragmentNames.length; j++) {
        collectConflictsBetweenFragments(
          context,
          conflicts,
          cachedFieldsAndFragmentNames,
          comparedFragmentPairs,
          false,
          fragmentNames[i],
          fragmentNames[j]
        );
      }
    }
  }
  return conflicts;
}
function collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {
  const fragment = context.getFragment(fragmentName);
  if (!fragment) {
    return;
  }
  const [fieldMap2, referencedFragmentNames] = getReferencedFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragment
  );
  if (fieldMap === fieldMap2) {
    return;
  }
  collectConflictsBetween(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFragmentPairs,
    areMutuallyExclusive,
    fieldMap,
    fieldMap2
  );
  for (const referencedFragmentName of referencedFragmentNames) {
    if (comparedFragmentPairs.has(
      referencedFragmentName,
      fragmentName,
      areMutuallyExclusive
    )) {
      continue;
    }
    comparedFragmentPairs.add(
      referencedFragmentName,
      fragmentName,
      areMutuallyExclusive
    );
    collectConflictsBetweenFieldsAndFragment(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fieldMap,
      referencedFragmentName
    );
  }
}
function collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {
  if (fragmentName1 === fragmentName2) {
    return;
  }
  if (comparedFragmentPairs.has(
    fragmentName1,
    fragmentName2,
    areMutuallyExclusive
  )) {
    return;
  }
  comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);
  const fragment1 = context.getFragment(fragmentName1);
  const fragment2 = context.getFragment(fragmentName2);
  if (!fragment1 || !fragment2) {
    return;
  }
  const [fieldMap1, referencedFragmentNames1] = getReferencedFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragment1
  );
  const [fieldMap2, referencedFragmentNames2] = getReferencedFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragment2
  );
  collectConflictsBetween(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFragmentPairs,
    areMutuallyExclusive,
    fieldMap1,
    fieldMap2
  );
  for (const referencedFragmentName2 of referencedFragmentNames2) {
    collectConflictsBetweenFragments(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fragmentName1,
      referencedFragmentName2
    );
  }
  for (const referencedFragmentName1 of referencedFragmentNames1) {
    collectConflictsBetweenFragments(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      referencedFragmentName1,
      fragmentName2
    );
  }
}
function findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {
  const conflicts = [];
  const [fieldMap1, fragmentNames1] = getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    parentType1,
    selectionSet1
  );
  const [fieldMap2, fragmentNames2] = getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    parentType2,
    selectionSet2
  );
  collectConflictsBetween(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFragmentPairs,
    areMutuallyExclusive,
    fieldMap1,
    fieldMap2
  );
  for (const fragmentName2 of fragmentNames2) {
    collectConflictsBetweenFieldsAndFragment(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fieldMap1,
      fragmentName2
    );
  }
  for (const fragmentName1 of fragmentNames1) {
    collectConflictsBetweenFieldsAndFragment(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fieldMap2,
      fragmentName1
    );
  }
  for (const fragmentName1 of fragmentNames1) {
    for (const fragmentName2 of fragmentNames2) {
      collectConflictsBetweenFragments(
        context,
        conflicts,
        cachedFieldsAndFragmentNames,
        comparedFragmentPairs,
        areMutuallyExclusive,
        fragmentName1,
        fragmentName2
      );
    }
  }
  return conflicts;
}
function collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap) {
  for (const [responseName, fields] of Object.entries(fieldMap)) {
    if (fields.length > 1) {
      for (let i = 0; i < fields.length; i++) {
        for (let j = i + 1; j < fields.length; j++) {
          const conflict = findConflict(
            context,
            cachedFieldsAndFragmentNames,
            comparedFragmentPairs,
            false,
            // within one collection is never mutually exclusive
            responseName,
            fields[i],
            fields[j]
          );
          if (conflict) {
            conflicts.push(conflict);
          }
        }
      }
    }
  }
}
function collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {
  for (const [responseName, fields1] of Object.entries(fieldMap1)) {
    const fields2 = fieldMap2[responseName];
    if (fields2) {
      for (const field1 of fields1) {
        for (const field2 of fields2) {
          const conflict = findConflict(
            context,
            cachedFieldsAndFragmentNames,
            comparedFragmentPairs,
            parentFieldsAreMutuallyExclusive,
            responseName,
            field1,
            field2
          );
          if (conflict) {
            conflicts.push(conflict);
          }
        }
      }
    }
  }
}
function findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {
  const [parentType1, node1, def1] = field1;
  const [parentType2, node2, def2] = field2;
  const areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && isObjectType(parentType1) && isObjectType(parentType2);
  if (!areMutuallyExclusive) {
    const name1 = node1.name.value;
    const name2 = node2.name.value;
    if (name1 !== name2) {
      return [
        [responseName, `"${name1}" and "${name2}" are different fields`],
        [node1],
        [node2]
      ];
    }
    if (stringifyArguments(node1) !== stringifyArguments(node2)) {
      return [
        [responseName, "they have differing arguments"],
        [node1],
        [node2]
      ];
    }
  }
  const type1 = def1 === null || def1 === void 0 ? void 0 : def1.type;
  const type2 = def2 === null || def2 === void 0 ? void 0 : def2.type;
  if (type1 && type2 && doTypesConflict(type1, type2)) {
    return [
      [
        responseName,
        `they return conflicting types "${inspect(type1)}" and "${inspect(
          type2
        )}"`
      ],
      [node1],
      [node2]
    ];
  }
  const selectionSet1 = node1.selectionSet;
  const selectionSet2 = node2.selectionSet;
  if (selectionSet1 && selectionSet2) {
    const conflicts = findConflictsBetweenSubSelectionSets(
      context,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      getNamedType(type1),
      selectionSet1,
      getNamedType(type2),
      selectionSet2
    );
    return subfieldConflicts(conflicts, responseName, node1, node2);
  }
}
function stringifyArguments(fieldNode) {
  var _fieldNode$arguments;
  const args = (
    /* c8 ignore next */
    (_fieldNode$arguments = fieldNode.arguments) !== null && _fieldNode$arguments !== void 0 ? _fieldNode$arguments : []
  );
  const inputObjectWithArgs = {
    kind: Kind.OBJECT,
    fields: args.map((argNode) => ({
      kind: Kind.OBJECT_FIELD,
      name: argNode.name,
      value: argNode.value
    }))
  };
  return print(sortValueNode(inputObjectWithArgs));
}
function doTypesConflict(type1, type2) {
  if (isListType(type1)) {
    return isListType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
  }
  if (isListType(type2)) {
    return true;
  }
  if (isNonNullType(type1)) {
    return isNonNullType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
  }
  if (isNonNullType(type2)) {
    return true;
  }
  if (isLeafType(type1) || isLeafType(type2)) {
    return type1 !== type2;
  }
  return false;
}
function getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet) {
  const cached = cachedFieldsAndFragmentNames.get(selectionSet);
  if (cached) {
    return cached;
  }
  const nodeAndDefs = /* @__PURE__ */ Object.create(null);
  const fragmentNames = /* @__PURE__ */ Object.create(null);
  _collectFieldsAndFragmentNames(
    context,
    parentType,
    selectionSet,
    nodeAndDefs,
    fragmentNames
  );
  const result = [nodeAndDefs, Object.keys(fragmentNames)];
  cachedFieldsAndFragmentNames.set(selectionSet, result);
  return result;
}
function getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment) {
  const cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);
  if (cached) {
    return cached;
  }
  const fragmentType = typeFromAST(context.getSchema(), fragment.typeCondition);
  return getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragmentType,
    fragment.selectionSet
  );
}
function _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames) {
  for (const selection of selectionSet.selections) {
    switch (selection.kind) {
      case Kind.FIELD: {
        const fieldName = selection.name.value;
        let fieldDef;
        if (isObjectType(parentType) || isInterfaceType(parentType)) {
          fieldDef = parentType.getFields()[fieldName];
        }
        const responseName = selection.alias ? selection.alias.value : fieldName;
        if (!nodeAndDefs[responseName]) {
          nodeAndDefs[responseName] = [];
        }
        nodeAndDefs[responseName].push([parentType, selection, fieldDef]);
        break;
      }
      case Kind.FRAGMENT_SPREAD:
        fragmentNames[selection.name.value] = true;
        break;
      case Kind.INLINE_FRAGMENT: {
        const typeCondition = selection.typeCondition;
        const inlineFragmentType = typeCondition ? typeFromAST(context.getSchema(), typeCondition) : parentType;
        _collectFieldsAndFragmentNames(
          context,
          inlineFragmentType,
          selection.selectionSet,
          nodeAndDefs,
          fragmentNames
        );
        break;
      }
    }
  }
}
function subfieldConflicts(conflicts, responseName, node1, node2) {
  if (conflicts.length > 0) {
    return [
      [responseName, conflicts.map(([reason]) => reason)],
      [node1, ...conflicts.map(([, fields1]) => fields1).flat()],
      [node2, ...conflicts.map(([, , fields2]) => fields2).flat()]
    ];
  }
}
var PairSet;
var init_OverlappingFieldsCanBeMergedRule = __esm({
  "../../../node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.mjs"() {
    init_inspect();
    init_GraphQLError();
    init_kinds();
    init_printer();
    init_definition();
    init_sortValueNode();
    init_typeFromAST();
    PairSet = class {
      constructor() {
        this._data = /* @__PURE__ */ new Map();
      }
      has(a, b, areMutuallyExclusive) {
        var _this$_data$get;
        const [key1, key2] = a < b ? [a, b] : [b, a];
        const result = (_this$_data$get = this._data.get(key1)) === null || _this$_data$get === void 0 ? void 0 : _this$_data$get.get(key2);
        if (result === void 0) {
          return false;
        }
        return areMutuallyExclusive ? true : areMutuallyExclusive === result;
      }
      add(a, b, areMutuallyExclusive) {
        const [key1, key2] = a < b ? [a, b] : [b, a];
        const map = this._data.get(key1);
        if (map === void 0) {
          this._data.set(key1, /* @__PURE__ */ new Map([[key2, areMutuallyExclusive]]));
        } else {
          map.set(key2, areMutuallyExclusive);
        }
      }
    };
  }
});

// ../../../node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.mjs
function PossibleFragmentSpreadsRule(context) {
  return {
    InlineFragment(node) {
      const fragType = context.getType();
      const parentType = context.getParentType();
      if (isCompositeType(fragType) && isCompositeType(parentType) && !doTypesOverlap(context.getSchema(), fragType, parentType)) {
        const parentTypeStr = inspect(parentType);
        const fragTypeStr = inspect(fragType);
        context.reportError(
          new GraphQLError(
            `Fragment cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`,
            {
              nodes: node
            }
          )
        );
      }
    },
    FragmentSpread(node) {
      const fragName = node.name.value;
      const fragType = getFragmentType(context, fragName);
      const parentType = context.getParentType();
      if (fragType && parentType && !doTypesOverlap(context.getSchema(), fragType, parentType)) {
        const parentTypeStr = inspect(parentType);
        const fragTypeStr = inspect(fragType);
        context.reportError(
          new GraphQLError(
            `Fragment "${fragName}" cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`,
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}
function getFragmentType(context, name) {
  const frag = context.getFragment(name);
  if (frag) {
    const type = typeFromAST(context.getSchema(), frag.typeCondition);
    if (isCompositeType(type)) {
      return type;
    }
  }
}
var init_PossibleFragmentSpreadsRule = __esm({
  "../../../node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.mjs"() {
    init_inspect();
    init_GraphQLError();
    init_definition();
    init_typeComparators();
    init_typeFromAST();
  }
});

// ../../../node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.mjs
function PossibleTypeExtensionsRule(context) {
  const schema = context.getSchema();
  const definedTypes = /* @__PURE__ */ Object.create(null);
  for (const def of context.getDocument().definitions) {
    if (isTypeDefinitionNode(def)) {
      definedTypes[def.name.value] = def;
    }
  }
  return {
    ScalarTypeExtension: checkExtension,
    ObjectTypeExtension: checkExtension,
    InterfaceTypeExtension: checkExtension,
    UnionTypeExtension: checkExtension,
    EnumTypeExtension: checkExtension,
    InputObjectTypeExtension: checkExtension
  };
  function checkExtension(node) {
    const typeName = node.name.value;
    const defNode = definedTypes[typeName];
    const existingType = schema === null || schema === void 0 ? void 0 : schema.getType(typeName);
    let expectedKind;
    if (defNode) {
      expectedKind = defKindToExtKind[defNode.kind];
    } else if (existingType) {
      expectedKind = typeToExtKind(existingType);
    }
    if (expectedKind) {
      if (expectedKind !== node.kind) {
        const kindStr = extensionKindToTypeName(node.kind);
        context.reportError(
          new GraphQLError(`Cannot extend non-${kindStr} type "${typeName}".`, {
            nodes: defNode ? [defNode, node] : node
          })
        );
      }
    } else {
      const allTypeNames = Object.keys({
        ...definedTypes,
        ...schema === null || schema === void 0 ? void 0 : schema.getTypeMap()
      });
      const suggestedTypes = suggestionList(typeName, allTypeNames);
      context.reportError(
        new GraphQLError(
          `Cannot extend type "${typeName}" because it is not defined.` + didYouMean(suggestedTypes),
          {
            nodes: node.name
          }
        )
      );
    }
  }
}
function typeToExtKind(type) {
  if (isScalarType(type)) {
    return Kind.SCALAR_TYPE_EXTENSION;
  }
  if (isObjectType(type)) {
    return Kind.OBJECT_TYPE_EXTENSION;
  }
  if (isInterfaceType(type)) {
    return Kind.INTERFACE_TYPE_EXTENSION;
  }
  if (isUnionType(type)) {
    return Kind.UNION_TYPE_EXTENSION;
  }
  if (isEnumType(type)) {
    return Kind.ENUM_TYPE_EXTENSION;
  }
  if (isInputObjectType(type)) {
    return Kind.INPUT_OBJECT_TYPE_EXTENSION;
  }
  invariant(false, "Unexpected type: " + inspect(type));
}
function extensionKindToTypeName(kind) {
  switch (kind) {
    case Kind.SCALAR_TYPE_EXTENSION:
      return "scalar";
    case Kind.OBJECT_TYPE_EXTENSION:
      return "object";
    case Kind.INTERFACE_TYPE_EXTENSION:
      return "interface";
    case Kind.UNION_TYPE_EXTENSION:
      return "union";
    case Kind.ENUM_TYPE_EXTENSION:
      return "enum";
    case Kind.INPUT_OBJECT_TYPE_EXTENSION:
      return "input object";
    default:
      invariant(false, "Unexpected kind: " + inspect(kind));
  }
}
var defKindToExtKind;
var init_PossibleTypeExtensionsRule = __esm({
  "../../../node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.mjs"() {
    init_didYouMean();
    init_inspect();
    init_invariant();
    init_suggestionList();
    init_GraphQLError();
    init_kinds();
    init_predicates();
    init_definition();
    defKindToExtKind = {
      [Kind.SCALAR_TYPE_DEFINITION]: Kind.SCALAR_TYPE_EXTENSION,
      [Kind.OBJECT_TYPE_DEFINITION]: Kind.OBJECT_TYPE_EXTENSION,
      [Kind.INTERFACE_TYPE_DEFINITION]: Kind.INTERFACE_TYPE_EXTENSION,
      [Kind.UNION_TYPE_DEFINITION]: Kind.UNION_TYPE_EXTENSION,
      [Kind.ENUM_TYPE_DEFINITION]: Kind.ENUM_TYPE_EXTENSION,
      [Kind.INPUT_OBJECT_TYPE_DEFINITION]: Kind.INPUT_OBJECT_TYPE_EXTENSION
    };
  }
});

// ../../../node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.mjs
function ProvidedRequiredArgumentsRule(context) {
  return {
    // eslint-disable-next-line new-cap
    ...ProvidedRequiredArgumentsOnDirectivesRule(context),
    Field: {
      // Validate on leave to allow for deeper errors to appear first.
      leave(fieldNode) {
        var _fieldNode$arguments;
        const fieldDef = context.getFieldDef();
        if (!fieldDef) {
          return false;
        }
        const providedArgs = new Set(
          // FIXME: https://github.com/graphql/graphql-js/issues/2203
          /* c8 ignore next */
          (_fieldNode$arguments = fieldNode.arguments) === null || _fieldNode$arguments === void 0 ? void 0 : _fieldNode$arguments.map((arg) => arg.name.value)
        );
        for (const argDef of fieldDef.args) {
          if (!providedArgs.has(argDef.name) && isRequiredArgument(argDef)) {
            const argTypeStr = inspect(argDef.type);
            context.reportError(
              new GraphQLError(
                `Field "${fieldDef.name}" argument "${argDef.name}" of type "${argTypeStr}" is required, but it was not provided.`,
                {
                  nodes: fieldNode
                }
              )
            );
          }
        }
      }
    }
  };
}
function ProvidedRequiredArgumentsOnDirectivesRule(context) {
  var _schema$getDirectives;
  const requiredArgsMap = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = (_schema$getDirectives = schema === null || schema === void 0 ? void 0 : schema.getDirectives()) !== null && _schema$getDirectives !== void 0 ? _schema$getDirectives : specifiedDirectives;
  for (const directive of definedDirectives) {
    requiredArgsMap[directive.name] = keyMap(
      directive.args.filter(isRequiredArgument),
      (arg) => arg.name
    );
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      var _def$arguments;
      const argNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
      requiredArgsMap[def.name.value] = keyMap(
        argNodes.filter(isRequiredArgumentNode),
        (arg) => arg.name.value
      );
    }
  }
  return {
    Directive: {
      // Validate on leave to allow for deeper errors to appear first.
      leave(directiveNode) {
        const directiveName = directiveNode.name.value;
        const requiredArgs = requiredArgsMap[directiveName];
        if (requiredArgs) {
          var _directiveNode$argume;
          const argNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
          const argNodeMap = new Set(argNodes.map((arg) => arg.name.value));
          for (const [argName, argDef] of Object.entries(requiredArgs)) {
            if (!argNodeMap.has(argName)) {
              const argType = isType(argDef.type) ? inspect(argDef.type) : print(argDef.type);
              context.reportError(
                new GraphQLError(
                  `Directive "@${directiveName}" argument "${argName}" of type "${argType}" is required, but it was not provided.`,
                  {
                    nodes: directiveNode
                  }
                )
              );
            }
          }
        }
      }
    }
  };
}
function isRequiredArgumentNode(arg) {
  return arg.type.kind === Kind.NON_NULL_TYPE && arg.defaultValue == null;
}
var init_ProvidedRequiredArgumentsRule = __esm({
  "../../../node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.mjs"() {
    init_inspect();
    init_keyMap();
    init_GraphQLError();
    init_kinds();
    init_printer();
    init_definition();
    init_directives();
  }
});

// ../../../node_modules/graphql/validation/rules/ScalarLeafsRule.mjs
function ScalarLeafsRule(context) {
  return {
    Field(node) {
      const type = context.getType();
      const selectionSet = node.selectionSet;
      if (type) {
        if (isLeafType(getNamedType(type))) {
          if (selectionSet) {
            const fieldName = node.name.value;
            const typeStr = inspect(type);
            context.reportError(
              new GraphQLError(
                `Field "${fieldName}" must not have a selection since type "${typeStr}" has no subfields.`,
                {
                  nodes: selectionSet
                }
              )
            );
          }
        } else if (!selectionSet) {
          const fieldName = node.name.value;
          const typeStr = inspect(type);
          context.reportError(
            new GraphQLError(
              `Field "${fieldName}" of type "${typeStr}" must have a selection of subfields. Did you mean "${fieldName} { ... }"?`,
              {
                nodes: node
              }
            )
          );
        }
      }
    }
  };
}
var init_ScalarLeafsRule = __esm({
  "../../../node_modules/graphql/validation/rules/ScalarLeafsRule.mjs"() {
    init_inspect();
    init_GraphQLError();
    init_definition();
  }
});

// ../../../node_modules/graphql/jsutils/printPathArray.mjs
function printPathArray(path) {
  return path.map(
    (key) => typeof key === "number" ? "[" + key.toString() + "]" : "." + key
  ).join("");
}
var init_printPathArray = __esm({
  "../../../node_modules/graphql/jsutils/printPathArray.mjs"() {
  }
});

// ../../../node_modules/graphql/jsutils/Path.mjs
function addPath(prev, key, typename) {
  return {
    prev,
    key,
    typename
  };
}
function pathToArray(path) {
  const flattened = [];
  let curr = path;
  while (curr) {
    flattened.push(curr.key);
    curr = curr.prev;
  }
  return flattened.reverse();
}
var init_Path = __esm({
  "../../../node_modules/graphql/jsutils/Path.mjs"() {
  }
});

// ../../../node_modules/graphql/utilities/coerceInputValue.mjs
function coerceInputValue(inputValue, type, onError = defaultOnError) {
  return coerceInputValueImpl(inputValue, type, onError, void 0);
}
function defaultOnError(path, invalidValue, error) {
  let errorPrefix = "Invalid value " + inspect(invalidValue);
  if (path.length > 0) {
    errorPrefix += ` at "value${printPathArray(path)}"`;
  }
  error.message = errorPrefix + ": " + error.message;
  throw error;
}
function coerceInputValueImpl(inputValue, type, onError, path) {
  if (isNonNullType(type)) {
    if (inputValue != null) {
      return coerceInputValueImpl(inputValue, type.ofType, onError, path);
    }
    onError(
      pathToArray(path),
      inputValue,
      new GraphQLError(
        `Expected non-nullable type "${inspect(type)}" not to be null.`
      )
    );
    return;
  }
  if (inputValue == null) {
    return null;
  }
  if (isListType(type)) {
    const itemType = type.ofType;
    if (isIterableObject(inputValue)) {
      return Array.from(inputValue, (itemValue, index) => {
        const itemPath = addPath(path, index, void 0);
        return coerceInputValueImpl(itemValue, itemType, onError, itemPath);
      });
    }
    return [coerceInputValueImpl(inputValue, itemType, onError, path)];
  }
  if (isInputObjectType(type)) {
    if (!isObjectLike(inputValue)) {
      onError(
        pathToArray(path),
        inputValue,
        new GraphQLError(`Expected type "${type.name}" to be an object.`)
      );
      return;
    }
    const coercedValue = {};
    const fieldDefs = type.getFields();
    for (const field of Object.values(fieldDefs)) {
      const fieldValue = inputValue[field.name];
      if (fieldValue === void 0) {
        if (field.defaultValue !== void 0) {
          coercedValue[field.name] = field.defaultValue;
        } else if (isNonNullType(field.type)) {
          const typeStr = inspect(field.type);
          onError(
            pathToArray(path),
            inputValue,
            new GraphQLError(
              `Field "${field.name}" of required type "${typeStr}" was not provided.`
            )
          );
        }
        continue;
      }
      coercedValue[field.name] = coerceInputValueImpl(
        fieldValue,
        field.type,
        onError,
        addPath(path, field.name, type.name)
      );
    }
    for (const fieldName of Object.keys(inputValue)) {
      if (!fieldDefs[fieldName]) {
        const suggestions = suggestionList(
          fieldName,
          Object.keys(type.getFields())
        );
        onError(
          pathToArray(path),
          inputValue,
          new GraphQLError(
            `Field "${fieldName}" is not defined by type "${type.name}".` + didYouMean(suggestions)
          )
        );
      }
    }
    return coercedValue;
  }
  if (isLeafType(type)) {
    let parseResult;
    try {
      parseResult = type.parseValue(inputValue);
    } catch (error) {
      if (error instanceof GraphQLError) {
        onError(pathToArray(path), inputValue, error);
      } else {
        onError(
          pathToArray(path),
          inputValue,
          new GraphQLError(`Expected type "${type.name}". ` + error.message, {
            originalError: error
          })
        );
      }
      return;
    }
    if (parseResult === void 0) {
      onError(
        pathToArray(path),
        inputValue,
        new GraphQLError(`Expected type "${type.name}".`)
      );
    }
    return parseResult;
  }
  invariant(false, "Unexpected input type: " + inspect(type));
}
var init_coerceInputValue = __esm({
  "../../../node_modules/graphql/utilities/coerceInputValue.mjs"() {
    init_didYouMean();
    init_inspect();
    init_invariant();
    init_isIterableObject();
    init_isObjectLike();
    init_Path();
    init_printPathArray();
    init_suggestionList();
    init_GraphQLError();
    init_definition();
  }
});

// ../../../node_modules/graphql/utilities/valueFromAST.mjs
function valueFromAST(valueNode, type, variables) {
  if (!valueNode) {
    return;
  }
  if (valueNode.kind === Kind.VARIABLE) {
    const variableName = valueNode.name.value;
    if (variables == null || variables[variableName] === void 0) {
      return;
    }
    const variableValue = variables[variableName];
    if (variableValue === null && isNonNullType(type)) {
      return;
    }
    return variableValue;
  }
  if (isNonNullType(type)) {
    if (valueNode.kind === Kind.NULL) {
      return;
    }
    return valueFromAST(valueNode, type.ofType, variables);
  }
  if (valueNode.kind === Kind.NULL) {
    return null;
  }
  if (isListType(type)) {
    const itemType = type.ofType;
    if (valueNode.kind === Kind.LIST) {
      const coercedValues = [];
      for (const itemNode of valueNode.values) {
        if (isMissingVariable(itemNode, variables)) {
          if (isNonNullType(itemType)) {
            return;
          }
          coercedValues.push(null);
        } else {
          const itemValue = valueFromAST(itemNode, itemType, variables);
          if (itemValue === void 0) {
            return;
          }
          coercedValues.push(itemValue);
        }
      }
      return coercedValues;
    }
    const coercedValue = valueFromAST(valueNode, itemType, variables);
    if (coercedValue === void 0) {
      return;
    }
    return [coercedValue];
  }
  if (isInputObjectType(type)) {
    if (valueNode.kind !== Kind.OBJECT) {
      return;
    }
    const coercedObj = /* @__PURE__ */ Object.create(null);
    const fieldNodes = keyMap(valueNode.fields, (field) => field.name.value);
    for (const field of Object.values(type.getFields())) {
      const fieldNode = fieldNodes[field.name];
      if (!fieldNode || isMissingVariable(fieldNode.value, variables)) {
        if (field.defaultValue !== void 0) {
          coercedObj[field.name] = field.defaultValue;
        } else if (isNonNullType(field.type)) {
          return;
        }
        continue;
      }
      const fieldValue = valueFromAST(fieldNode.value, field.type, variables);
      if (fieldValue === void 0) {
        return;
      }
      coercedObj[field.name] = fieldValue;
    }
    return coercedObj;
  }
  if (isLeafType(type)) {
    let result;
    try {
      result = type.parseLiteral(valueNode, variables);
    } catch (_error) {
      return;
    }
    if (result === void 0) {
      return;
    }
    return result;
  }
  invariant(false, "Unexpected input type: " + inspect(type));
}
function isMissingVariable(valueNode, variables) {
  return valueNode.kind === Kind.VARIABLE && (variables == null || variables[valueNode.name.value] === void 0);
}
var init_valueFromAST = __esm({
  "../../../node_modules/graphql/utilities/valueFromAST.mjs"() {
    init_inspect();
    init_invariant();
    init_keyMap();
    init_kinds();
    init_definition();
  }
});

// ../../../node_modules/graphql/execution/values.mjs
function getVariableValues(schema, varDefNodes, inputs, options) {
  const errors = [];
  const maxErrors = options === null || options === void 0 ? void 0 : options.maxErrors;
  try {
    const coerced = coerceVariableValues(
      schema,
      varDefNodes,
      inputs,
      (error) => {
        if (maxErrors != null && errors.length >= maxErrors) {
          throw new GraphQLError(
            "Too many errors processing variables, error limit reached. Execution aborted."
          );
        }
        errors.push(error);
      }
    );
    if (errors.length === 0) {
      return {
        coerced
      };
    }
  } catch (error) {
    errors.push(error);
  }
  return {
    errors
  };
}
function coerceVariableValues(schema, varDefNodes, inputs, onError) {
  const coercedValues = {};
  for (const varDefNode of varDefNodes) {
    const varName = varDefNode.variable.name.value;
    const varType = typeFromAST(schema, varDefNode.type);
    if (!isInputType(varType)) {
      const varTypeStr = print(varDefNode.type);
      onError(
        new GraphQLError(
          `Variable "$${varName}" expected value of type "${varTypeStr}" which cannot be used as an input type.`,
          {
            nodes: varDefNode.type
          }
        )
      );
      continue;
    }
    if (!hasOwnProperty(inputs, varName)) {
      if (varDefNode.defaultValue) {
        coercedValues[varName] = valueFromAST(varDefNode.defaultValue, varType);
      } else if (isNonNullType(varType)) {
        const varTypeStr = inspect(varType);
        onError(
          new GraphQLError(
            `Variable "$${varName}" of required type "${varTypeStr}" was not provided.`,
            {
              nodes: varDefNode
            }
          )
        );
      }
      continue;
    }
    const value = inputs[varName];
    if (value === null && isNonNullType(varType)) {
      const varTypeStr = inspect(varType);
      onError(
        new GraphQLError(
          `Variable "$${varName}" of non-null type "${varTypeStr}" must not be null.`,
          {
            nodes: varDefNode
          }
        )
      );
      continue;
    }
    coercedValues[varName] = coerceInputValue(
      value,
      varType,
      (path, invalidValue, error) => {
        let prefix = `Variable "$${varName}" got invalid value ` + inspect(invalidValue);
        if (path.length > 0) {
          prefix += ` at "${varName}${printPathArray(path)}"`;
        }
        onError(
          new GraphQLError(prefix + "; " + error.message, {
            nodes: varDefNode,
            originalError: error
          })
        );
      }
    );
  }
  return coercedValues;
}
function getArgumentValues(def, node, variableValues) {
  var _node$arguments;
  const coercedValues = {};
  const argumentNodes = (_node$arguments = node.arguments) !== null && _node$arguments !== void 0 ? _node$arguments : [];
  const argNodeMap = keyMap(argumentNodes, (arg) => arg.name.value);
  for (const argDef of def.args) {
    const name = argDef.name;
    const argType = argDef.type;
    const argumentNode = argNodeMap[name];
    if (!argumentNode) {
      if (argDef.defaultValue !== void 0) {
        coercedValues[name] = argDef.defaultValue;
      } else if (isNonNullType(argType)) {
        throw new GraphQLError(
          `Argument "${name}" of required type "${inspect(argType)}" was not provided.`,
          {
            nodes: node
          }
        );
      }
      continue;
    }
    const valueNode = argumentNode.value;
    let isNull = valueNode.kind === Kind.NULL;
    if (valueNode.kind === Kind.VARIABLE) {
      const variableName = valueNode.name.value;
      if (variableValues == null || !hasOwnProperty(variableValues, variableName)) {
        if (argDef.defaultValue !== void 0) {
          coercedValues[name] = argDef.defaultValue;
        } else if (isNonNullType(argType)) {
          throw new GraphQLError(
            `Argument "${name}" of required type "${inspect(argType)}" was provided the variable "$${variableName}" which was not provided a runtime value.`,
            {
              nodes: valueNode
            }
          );
        }
        continue;
      }
      isNull = variableValues[variableName] == null;
    }
    if (isNull && isNonNullType(argType)) {
      throw new GraphQLError(
        `Argument "${name}" of non-null type "${inspect(argType)}" must not be null.`,
        {
          nodes: valueNode
        }
      );
    }
    const coercedValue = valueFromAST(valueNode, argType, variableValues);
    if (coercedValue === void 0) {
      throw new GraphQLError(
        `Argument "${name}" has invalid value ${print(valueNode)}.`,
        {
          nodes: valueNode
        }
      );
    }
    coercedValues[name] = coercedValue;
  }
  return coercedValues;
}
function getDirectiveValues(directiveDef, node, variableValues) {
  var _node$directives;
  const directiveNode = (_node$directives = node.directives) === null || _node$directives === void 0 ? void 0 : _node$directives.find(
    (directive) => directive.name.value === directiveDef.name
  );
  if (directiveNode) {
    return getArgumentValues(directiveDef, directiveNode, variableValues);
  }
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
var init_values = __esm({
  "../../../node_modules/graphql/execution/values.mjs"() {
    init_inspect();
    init_keyMap();
    init_printPathArray();
    init_GraphQLError();
    init_kinds();
    init_printer();
    init_definition();
    init_coerceInputValue();
    init_typeFromAST();
    init_valueFromAST();
  }
});

// ../../../node_modules/graphql/execution/collectFields.mjs
function collectFields(schema, fragments, variableValues, runtimeType, selectionSet) {
  const fields = /* @__PURE__ */ new Map();
  collectFieldsImpl(
    schema,
    fragments,
    variableValues,
    runtimeType,
    selectionSet,
    fields,
    /* @__PURE__ */ new Set()
  );
  return fields;
}
function collectSubfields(schema, fragments, variableValues, returnType, fieldNodes) {
  const subFieldNodes = /* @__PURE__ */ new Map();
  const visitedFragmentNames = /* @__PURE__ */ new Set();
  for (const node of fieldNodes) {
    if (node.selectionSet) {
      collectFieldsImpl(
        schema,
        fragments,
        variableValues,
        returnType,
        node.selectionSet,
        subFieldNodes,
        visitedFragmentNames
      );
    }
  }
  return subFieldNodes;
}
function collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet, fields, visitedFragmentNames) {
  for (const selection of selectionSet.selections) {
    switch (selection.kind) {
      case Kind.FIELD: {
        if (!shouldIncludeNode(variableValues, selection)) {
          continue;
        }
        const name = getFieldEntryKey(selection);
        const fieldList = fields.get(name);
        if (fieldList !== void 0) {
          fieldList.push(selection);
        } else {
          fields.set(name, [selection]);
        }
        break;
      }
      case Kind.INLINE_FRAGMENT: {
        if (!shouldIncludeNode(variableValues, selection) || !doesFragmentConditionMatch(schema, selection, runtimeType)) {
          continue;
        }
        collectFieldsImpl(
          schema,
          fragments,
          variableValues,
          runtimeType,
          selection.selectionSet,
          fields,
          visitedFragmentNames
        );
        break;
      }
      case Kind.FRAGMENT_SPREAD: {
        const fragName = selection.name.value;
        if (visitedFragmentNames.has(fragName) || !shouldIncludeNode(variableValues, selection)) {
          continue;
        }
        visitedFragmentNames.add(fragName);
        const fragment = fragments[fragName];
        if (!fragment || !doesFragmentConditionMatch(schema, fragment, runtimeType)) {
          continue;
        }
        collectFieldsImpl(
          schema,
          fragments,
          variableValues,
          runtimeType,
          fragment.selectionSet,
          fields,
          visitedFragmentNames
        );
        break;
      }
    }
  }
}
function shouldIncludeNode(variableValues, node) {
  const skip = getDirectiveValues(GraphQLSkipDirective, node, variableValues);
  if ((skip === null || skip === void 0 ? void 0 : skip.if) === true) {
    return false;
  }
  const include = getDirectiveValues(
    GraphQLIncludeDirective,
    node,
    variableValues
  );
  if ((include === null || include === void 0 ? void 0 : include.if) === false) {
    return false;
  }
  return true;
}
function doesFragmentConditionMatch(schema, fragment, type) {
  const typeConditionNode = fragment.typeCondition;
  if (!typeConditionNode) {
    return true;
  }
  const conditionalType = typeFromAST(schema, typeConditionNode);
  if (conditionalType === type) {
    return true;
  }
  if (isAbstractType(conditionalType)) {
    return schema.isSubType(conditionalType, type);
  }
  return false;
}
function getFieldEntryKey(node) {
  return node.alias ? node.alias.value : node.name.value;
}
var init_collectFields = __esm({
  "../../../node_modules/graphql/execution/collectFields.mjs"() {
    init_kinds();
    init_definition();
    init_directives();
    init_typeFromAST();
    init_values();
  }
});

// ../../../node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.mjs
function SingleFieldSubscriptionsRule(context) {
  return {
    OperationDefinition(node) {
      if (node.operation === "subscription") {
        const schema = context.getSchema();
        const subscriptionType = schema.getSubscriptionType();
        if (subscriptionType) {
          const operationName = node.name ? node.name.value : null;
          const variableValues = /* @__PURE__ */ Object.create(null);
          const document2 = context.getDocument();
          const fragments = /* @__PURE__ */ Object.create(null);
          for (const definition of document2.definitions) {
            if (definition.kind === Kind.FRAGMENT_DEFINITION) {
              fragments[definition.name.value] = definition;
            }
          }
          const fields = collectFields(
            schema,
            fragments,
            variableValues,
            subscriptionType,
            node.selectionSet
          );
          if (fields.size > 1) {
            const fieldSelectionLists = [...fields.values()];
            const extraFieldSelectionLists = fieldSelectionLists.slice(1);
            const extraFieldSelections = extraFieldSelectionLists.flat();
            context.reportError(
              new GraphQLError(
                operationName != null ? `Subscription "${operationName}" must select only one top level field.` : "Anonymous Subscription must select only one top level field.",
                {
                  nodes: extraFieldSelections
                }
              )
            );
          }
          for (const fieldNodes of fields.values()) {
            const field = fieldNodes[0];
            const fieldName = field.name.value;
            if (fieldName.startsWith("__")) {
              context.reportError(
                new GraphQLError(
                  operationName != null ? `Subscription "${operationName}" must not select an introspection top level field.` : "Anonymous Subscription must not select an introspection top level field.",
                  {
                    nodes: fieldNodes
                  }
                )
              );
            }
          }
        }
      }
    }
  };
}
var init_SingleFieldSubscriptionsRule = __esm({
  "../../../node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.mjs"() {
    init_GraphQLError();
    init_kinds();
    init_collectFields();
  }
});

// ../../../node_modules/graphql/jsutils/groupBy.mjs
function groupBy(list, keyFn) {
  const result = /* @__PURE__ */ new Map();
  for (const item of list) {
    const key = keyFn(item);
    const group = result.get(key);
    if (group === void 0) {
      result.set(key, [item]);
    } else {
      group.push(item);
    }
  }
  return result;
}
var init_groupBy = __esm({
  "../../../node_modules/graphql/jsutils/groupBy.mjs"() {
  }
});

// ../../../node_modules/graphql/validation/rules/UniqueArgumentDefinitionNamesRule.mjs
function UniqueArgumentDefinitionNamesRule(context) {
  return {
    DirectiveDefinition(directiveNode) {
      var _directiveNode$argume;
      const argumentNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
      return checkArgUniqueness(`@${directiveNode.name.value}`, argumentNodes);
    },
    InterfaceTypeDefinition: checkArgUniquenessPerField,
    InterfaceTypeExtension: checkArgUniquenessPerField,
    ObjectTypeDefinition: checkArgUniquenessPerField,
    ObjectTypeExtension: checkArgUniquenessPerField
  };
  function checkArgUniquenessPerField(typeNode) {
    var _typeNode$fields;
    const typeName = typeNode.name.value;
    const fieldNodes = (_typeNode$fields = typeNode.fields) !== null && _typeNode$fields !== void 0 ? _typeNode$fields : [];
    for (const fieldDef of fieldNodes) {
      var _fieldDef$arguments;
      const fieldName = fieldDef.name.value;
      const argumentNodes = (_fieldDef$arguments = fieldDef.arguments) !== null && _fieldDef$arguments !== void 0 ? _fieldDef$arguments : [];
      checkArgUniqueness(`${typeName}.${fieldName}`, argumentNodes);
    }
    return false;
  }
  function checkArgUniqueness(parentName, argumentNodes) {
    const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);
    for (const [argName, argNodes] of seenArgs) {
      if (argNodes.length > 1) {
        context.reportError(
          new GraphQLError(
            `Argument "${parentName}(${argName}:)" can only be defined once.`,
            {
              nodes: argNodes.map((node) => node.name)
            }
          )
        );
      }
    }
    return false;
  }
}
var init_UniqueArgumentDefinitionNamesRule = __esm({
  "../../../node_modules/graphql/validation/rules/UniqueArgumentDefinitionNamesRule.mjs"() {
    init_groupBy();
    init_GraphQLError();
  }
});

// ../../../node_modules/graphql/validation/rules/UniqueArgumentNamesRule.mjs
function UniqueArgumentNamesRule(context) {
  return {
    Field: checkArgUniqueness,
    Directive: checkArgUniqueness
  };
  function checkArgUniqueness(parentNode) {
    var _parentNode$arguments;
    const argumentNodes = (_parentNode$arguments = parentNode.arguments) !== null && _parentNode$arguments !== void 0 ? _parentNode$arguments : [];
    const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);
    for (const [argName, argNodes] of seenArgs) {
      if (argNodes.length > 1) {
        context.reportError(
          new GraphQLError(
            `There can be only one argument named "${argName}".`,
            {
              nodes: argNodes.map((node) => node.name)
            }
          )
        );
      }
    }
  }
}
var init_UniqueArgumentNamesRule = __esm({
  "../../../node_modules/graphql/validation/rules/UniqueArgumentNamesRule.mjs"() {
    init_groupBy();
    init_GraphQLError();
  }
});

// ../../../node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.mjs
function UniqueDirectiveNamesRule(context) {
  const knownDirectiveNames = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  return {
    DirectiveDefinition(node) {
      const directiveName = node.name.value;
      if (schema !== null && schema !== void 0 && schema.getDirective(directiveName)) {
        context.reportError(
          new GraphQLError(
            `Directive "@${directiveName}" already exists in the schema. It cannot be redefined.`,
            {
              nodes: node.name
            }
          )
        );
        return;
      }
      if (knownDirectiveNames[directiveName]) {
        context.reportError(
          new GraphQLError(
            `There can be only one directive named "@${directiveName}".`,
            {
              nodes: [knownDirectiveNames[directiveName], node.name]
            }
          )
        );
      } else {
        knownDirectiveNames[directiveName] = node.name;
      }
      return false;
    }
  };
}
var init_UniqueDirectiveNamesRule = __esm({
  "../../../node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.mjs"() {
    init_GraphQLError();
  }
});

// ../../../node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.mjs
function UniqueDirectivesPerLocationRule(context) {
  const uniqueDirectiveMap = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    uniqueDirectiveMap[directive.name] = !directive.isRepeatable;
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      uniqueDirectiveMap[def.name.value] = !def.repeatable;
    }
  }
  const schemaDirectives = /* @__PURE__ */ Object.create(null);
  const typeDirectivesMap = /* @__PURE__ */ Object.create(null);
  return {
    // Many different AST nodes may contain directives. Rather than listing
    // them all, just listen for entering any node, and check to see if it
    // defines any directives.
    enter(node) {
      if (!("directives" in node) || !node.directives) {
        return;
      }
      let seenDirectives;
      if (node.kind === Kind.SCHEMA_DEFINITION || node.kind === Kind.SCHEMA_EXTENSION) {
        seenDirectives = schemaDirectives;
      } else if (isTypeDefinitionNode(node) || isTypeExtensionNode(node)) {
        const typeName = node.name.value;
        seenDirectives = typeDirectivesMap[typeName];
        if (seenDirectives === void 0) {
          typeDirectivesMap[typeName] = seenDirectives = /* @__PURE__ */ Object.create(null);
        }
      } else {
        seenDirectives = /* @__PURE__ */ Object.create(null);
      }
      for (const directive of node.directives) {
        const directiveName = directive.name.value;
        if (uniqueDirectiveMap[directiveName]) {
          if (seenDirectives[directiveName]) {
            context.reportError(
              new GraphQLError(
                `The directive "@${directiveName}" can only be used once at this location.`,
                {
                  nodes: [seenDirectives[directiveName], directive]
                }
              )
            );
          } else {
            seenDirectives[directiveName] = directive;
          }
        }
      }
    }
  };
}
var init_UniqueDirectivesPerLocationRule = __esm({
  "../../../node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.mjs"() {
    init_GraphQLError();
    init_kinds();
    init_predicates();
    init_directives();
  }
});

// ../../../node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.mjs
function UniqueEnumValueNamesRule(context) {
  const schema = context.getSchema();
  const existingTypeMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
  const knownValueNames = /* @__PURE__ */ Object.create(null);
  return {
    EnumTypeDefinition: checkValueUniqueness,
    EnumTypeExtension: checkValueUniqueness
  };
  function checkValueUniqueness(node) {
    var _node$values;
    const typeName = node.name.value;
    if (!knownValueNames[typeName]) {
      knownValueNames[typeName] = /* @__PURE__ */ Object.create(null);
    }
    const valueNodes = (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : [];
    const valueNames = knownValueNames[typeName];
    for (const valueDef of valueNodes) {
      const valueName = valueDef.name.value;
      const existingType = existingTypeMap[typeName];
      if (isEnumType(existingType) && existingType.getValue(valueName)) {
        context.reportError(
          new GraphQLError(
            `Enum value "${typeName}.${valueName}" already exists in the schema. It cannot also be defined in this type extension.`,
            {
              nodes: valueDef.name
            }
          )
        );
      } else if (valueNames[valueName]) {
        context.reportError(
          new GraphQLError(
            `Enum value "${typeName}.${valueName}" can only be defined once.`,
            {
              nodes: [valueNames[valueName], valueDef.name]
            }
          )
        );
      } else {
        valueNames[valueName] = valueDef.name;
      }
    }
    return false;
  }
}
var init_UniqueEnumValueNamesRule = __esm({
  "../../../node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.mjs"() {
    init_GraphQLError();
    init_definition();
  }
});

// ../../../node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.mjs
function UniqueFieldDefinitionNamesRule(context) {
  const schema = context.getSchema();
  const existingTypeMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
  const knownFieldNames = /* @__PURE__ */ Object.create(null);
  return {
    InputObjectTypeDefinition: checkFieldUniqueness,
    InputObjectTypeExtension: checkFieldUniqueness,
    InterfaceTypeDefinition: checkFieldUniqueness,
    InterfaceTypeExtension: checkFieldUniqueness,
    ObjectTypeDefinition: checkFieldUniqueness,
    ObjectTypeExtension: checkFieldUniqueness
  };
  function checkFieldUniqueness(node) {
    var _node$fields;
    const typeName = node.name.value;
    if (!knownFieldNames[typeName]) {
      knownFieldNames[typeName] = /* @__PURE__ */ Object.create(null);
    }
    const fieldNodes = (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : [];
    const fieldNames = knownFieldNames[typeName];
    for (const fieldDef of fieldNodes) {
      const fieldName = fieldDef.name.value;
      if (hasField(existingTypeMap[typeName], fieldName)) {
        context.reportError(
          new GraphQLError(
            `Field "${typeName}.${fieldName}" already exists in the schema. It cannot also be defined in this type extension.`,
            {
              nodes: fieldDef.name
            }
          )
        );
      } else if (fieldNames[fieldName]) {
        context.reportError(
          new GraphQLError(
            `Field "${typeName}.${fieldName}" can only be defined once.`,
            {
              nodes: [fieldNames[fieldName], fieldDef.name]
            }
          )
        );
      } else {
        fieldNames[fieldName] = fieldDef.name;
      }
    }
    return false;
  }
}
function hasField(type, fieldName) {
  if (isObjectType(type) || isInterfaceType(type) || isInputObjectType(type)) {
    return type.getFields()[fieldName] != null;
  }
  return false;
}
var init_UniqueFieldDefinitionNamesRule = __esm({
  "../../../node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.mjs"() {
    init_GraphQLError();
    init_definition();
  }
});

// ../../../node_modules/graphql/validation/rules/UniqueFragmentNamesRule.mjs
function UniqueFragmentNamesRule(context) {
  const knownFragmentNames = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: () => false,
    FragmentDefinition(node) {
      const fragmentName = node.name.value;
      if (knownFragmentNames[fragmentName]) {
        context.reportError(
          new GraphQLError(
            `There can be only one fragment named "${fragmentName}".`,
            {
              nodes: [knownFragmentNames[fragmentName], node.name]
            }
          )
        );
      } else {
        knownFragmentNames[fragmentName] = node.name;
      }
      return false;
    }
  };
}
var init_UniqueFragmentNamesRule = __esm({
  "../../../node_modules/graphql/validation/rules/UniqueFragmentNamesRule.mjs"() {
    init_GraphQLError();
  }
});

// ../../../node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.mjs
function UniqueInputFieldNamesRule(context) {
  const knownNameStack = [];
  let knownNames = /* @__PURE__ */ Object.create(null);
  return {
    ObjectValue: {
      enter() {
        knownNameStack.push(knownNames);
        knownNames = /* @__PURE__ */ Object.create(null);
      },
      leave() {
        const prevKnownNames = knownNameStack.pop();
        prevKnownNames || invariant(false);
        knownNames = prevKnownNames;
      }
    },
    ObjectField(node) {
      const fieldName = node.name.value;
      if (knownNames[fieldName]) {
        context.reportError(
          new GraphQLError(
            `There can be only one input field named "${fieldName}".`,
            {
              nodes: [knownNames[fieldName], node.name]
            }
          )
        );
      } else {
        knownNames[fieldName] = node.name;
      }
    }
  };
}
var init_UniqueInputFieldNamesRule = __esm({
  "../../../node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.mjs"() {
    init_invariant();
    init_GraphQLError();
  }
});

// ../../../node_modules/graphql/validation/rules/UniqueOperationNamesRule.mjs
function UniqueOperationNamesRule(context) {
  const knownOperationNames = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition(node) {
      const operationName = node.name;
      if (operationName) {
        if (knownOperationNames[operationName.value]) {
          context.reportError(
            new GraphQLError(
              `There can be only one operation named "${operationName.value}".`,
              {
                nodes: [
                  knownOperationNames[operationName.value],
                  operationName
                ]
              }
            )
          );
        } else {
          knownOperationNames[operationName.value] = operationName;
        }
      }
      return false;
    },
    FragmentDefinition: () => false
  };
}
var init_UniqueOperationNamesRule = __esm({
  "../../../node_modules/graphql/validation/rules/UniqueOperationNamesRule.mjs"() {
    init_GraphQLError();
  }
});

// ../../../node_modules/graphql/validation/rules/UniqueOperationTypesRule.mjs
function UniqueOperationTypesRule(context) {
  const schema = context.getSchema();
  const definedOperationTypes = /* @__PURE__ */ Object.create(null);
  const existingOperationTypes = schema ? {
    query: schema.getQueryType(),
    mutation: schema.getMutationType(),
    subscription: schema.getSubscriptionType()
  } : {};
  return {
    SchemaDefinition: checkOperationTypes,
    SchemaExtension: checkOperationTypes
  };
  function checkOperationTypes(node) {
    var _node$operationTypes;
    const operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];
    for (const operationType of operationTypesNodes) {
      const operation = operationType.operation;
      const alreadyDefinedOperationType = definedOperationTypes[operation];
      if (existingOperationTypes[operation]) {
        context.reportError(
          new GraphQLError(
            `Type for ${operation} already defined in the schema. It cannot be redefined.`,
            {
              nodes: operationType
            }
          )
        );
      } else if (alreadyDefinedOperationType) {
        context.reportError(
          new GraphQLError(
            `There can be only one ${operation} type in schema.`,
            {
              nodes: [alreadyDefinedOperationType, operationType]
            }
          )
        );
      } else {
        definedOperationTypes[operation] = operationType;
      }
    }
    return false;
  }
}
var init_UniqueOperationTypesRule = __esm({
  "../../../node_modules/graphql/validation/rules/UniqueOperationTypesRule.mjs"() {
    init_GraphQLError();
  }
});

// ../../../node_modules/graphql/validation/rules/UniqueTypeNamesRule.mjs
function UniqueTypeNamesRule(context) {
  const knownTypeNames = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  return {
    ScalarTypeDefinition: checkTypeName,
    ObjectTypeDefinition: checkTypeName,
    InterfaceTypeDefinition: checkTypeName,
    UnionTypeDefinition: checkTypeName,
    EnumTypeDefinition: checkTypeName,
    InputObjectTypeDefinition: checkTypeName
  };
  function checkTypeName(node) {
    const typeName = node.name.value;
    if (schema !== null && schema !== void 0 && schema.getType(typeName)) {
      context.reportError(
        new GraphQLError(
          `Type "${typeName}" already exists in the schema. It cannot also be defined in this type definition.`,
          {
            nodes: node.name
          }
        )
      );
      return;
    }
    if (knownTypeNames[typeName]) {
      context.reportError(
        new GraphQLError(`There can be only one type named "${typeName}".`, {
          nodes: [knownTypeNames[typeName], node.name]
        })
      );
    } else {
      knownTypeNames[typeName] = node.name;
    }
    return false;
  }
}
var init_UniqueTypeNamesRule = __esm({
  "../../../node_modules/graphql/validation/rules/UniqueTypeNamesRule.mjs"() {
    init_GraphQLError();
  }
});

// ../../../node_modules/graphql/validation/rules/UniqueVariableNamesRule.mjs
function UniqueVariableNamesRule(context) {
  return {
    OperationDefinition(operationNode) {
      var _operationNode$variab;
      const variableDefinitions = (_operationNode$variab = operationNode.variableDefinitions) !== null && _operationNode$variab !== void 0 ? _operationNode$variab : [];
      const seenVariableDefinitions = groupBy(
        variableDefinitions,
        (node) => node.variable.name.value
      );
      for (const [variableName, variableNodes] of seenVariableDefinitions) {
        if (variableNodes.length > 1) {
          context.reportError(
            new GraphQLError(
              `There can be only one variable named "$${variableName}".`,
              {
                nodes: variableNodes.map((node) => node.variable.name)
              }
            )
          );
        }
      }
    }
  };
}
var init_UniqueVariableNamesRule = __esm({
  "../../../node_modules/graphql/validation/rules/UniqueVariableNamesRule.mjs"() {
    init_groupBy();
    init_GraphQLError();
  }
});

// ../../../node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.mjs
function ValuesOfCorrectTypeRule(context) {
  return {
    ListValue(node) {
      const type = getNullableType(context.getParentInputType());
      if (!isListType(type)) {
        isValidValueNode(context, node);
        return false;
      }
    },
    ObjectValue(node) {
      const type = getNamedType(context.getInputType());
      if (!isInputObjectType(type)) {
        isValidValueNode(context, node);
        return false;
      }
      const fieldNodeMap = keyMap(node.fields, (field) => field.name.value);
      for (const fieldDef of Object.values(type.getFields())) {
        const fieldNode = fieldNodeMap[fieldDef.name];
        if (!fieldNode && isRequiredInputField(fieldDef)) {
          const typeStr = inspect(fieldDef.type);
          context.reportError(
            new GraphQLError(
              `Field "${type.name}.${fieldDef.name}" of required type "${typeStr}" was not provided.`,
              {
                nodes: node
              }
            )
          );
        }
      }
    },
    ObjectField(node) {
      const parentType = getNamedType(context.getParentInputType());
      const fieldType = context.getInputType();
      if (!fieldType && isInputObjectType(parentType)) {
        const suggestions = suggestionList(
          node.name.value,
          Object.keys(parentType.getFields())
        );
        context.reportError(
          new GraphQLError(
            `Field "${node.name.value}" is not defined by type "${parentType.name}".` + didYouMean(suggestions),
            {
              nodes: node
            }
          )
        );
      }
    },
    NullValue(node) {
      const type = context.getInputType();
      if (isNonNullType(type)) {
        context.reportError(
          new GraphQLError(
            `Expected value of type "${inspect(type)}", found ${print(node)}.`,
            {
              nodes: node
            }
          )
        );
      }
    },
    EnumValue: (node) => isValidValueNode(context, node),
    IntValue: (node) => isValidValueNode(context, node),
    FloatValue: (node) => isValidValueNode(context, node),
    StringValue: (node) => isValidValueNode(context, node),
    BooleanValue: (node) => isValidValueNode(context, node)
  };
}
function isValidValueNode(context, node) {
  const locationType = context.getInputType();
  if (!locationType) {
    return;
  }
  const type = getNamedType(locationType);
  if (!isLeafType(type)) {
    const typeStr = inspect(locationType);
    context.reportError(
      new GraphQLError(
        `Expected value of type "${typeStr}", found ${print(node)}.`,
        {
          nodes: node
        }
      )
    );
    return;
  }
  try {
    const parseResult = type.parseLiteral(
      node,
      void 0
      /* variables */
    );
    if (parseResult === void 0) {
      const typeStr = inspect(locationType);
      context.reportError(
        new GraphQLError(
          `Expected value of type "${typeStr}", found ${print(node)}.`,
          {
            nodes: node
          }
        )
      );
    }
  } catch (error) {
    const typeStr = inspect(locationType);
    if (error instanceof GraphQLError) {
      context.reportError(error);
    } else {
      context.reportError(
        new GraphQLError(
          `Expected value of type "${typeStr}", found ${print(node)}; ` + error.message,
          {
            nodes: node,
            originalError: error
          }
        )
      );
    }
  }
}
var init_ValuesOfCorrectTypeRule = __esm({
  "../../../node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.mjs"() {
    init_didYouMean();
    init_inspect();
    init_keyMap();
    init_suggestionList();
    init_GraphQLError();
    init_printer();
    init_definition();
  }
});

// ../../../node_modules/graphql/validation/rules/VariablesAreInputTypesRule.mjs
function VariablesAreInputTypesRule(context) {
  return {
    VariableDefinition(node) {
      const type = typeFromAST(context.getSchema(), node.type);
      if (type !== void 0 && !isInputType(type)) {
        const variableName = node.variable.name.value;
        const typeName = print(node.type);
        context.reportError(
          new GraphQLError(
            `Variable "$${variableName}" cannot be non-input type "${typeName}".`,
            {
              nodes: node.type
            }
          )
        );
      }
    }
  };
}
var init_VariablesAreInputTypesRule = __esm({
  "../../../node_modules/graphql/validation/rules/VariablesAreInputTypesRule.mjs"() {
    init_GraphQLError();
    init_printer();
    init_definition();
    init_typeFromAST();
  }
});

// ../../../node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.mjs
function VariablesInAllowedPositionRule(context) {
  let varDefMap = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: {
      enter() {
        varDefMap = /* @__PURE__ */ Object.create(null);
      },
      leave(operation) {
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node, type, defaultValue } of usages) {
          const varName = node.name.value;
          const varDef = varDefMap[varName];
          if (varDef && type) {
            const schema = context.getSchema();
            const varType = typeFromAST(schema, varDef.type);
            if (varType && !allowedVariableUsage(
              schema,
              varType,
              varDef.defaultValue,
              type,
              defaultValue
            )) {
              const varTypeStr = inspect(varType);
              const typeStr = inspect(type);
              context.reportError(
                new GraphQLError(
                  `Variable "$${varName}" of type "${varTypeStr}" used in position expecting type "${typeStr}".`,
                  {
                    nodes: [varDef, node]
                  }
                )
              );
            }
          }
        }
      }
    },
    VariableDefinition(node) {
      varDefMap[node.variable.name.value] = node;
    }
  };
}
function allowedVariableUsage(schema, varType, varDefaultValue, locationType, locationDefaultValue) {
  if (isNonNullType(locationType) && !isNonNullType(varType)) {
    const hasNonNullVariableDefaultValue = varDefaultValue != null && varDefaultValue.kind !== Kind.NULL;
    const hasLocationDefaultValue = locationDefaultValue !== void 0;
    if (!hasNonNullVariableDefaultValue && !hasLocationDefaultValue) {
      return false;
    }
    const nullableLocationType = locationType.ofType;
    return isTypeSubTypeOf(schema, varType, nullableLocationType);
  }
  return isTypeSubTypeOf(schema, varType, locationType);
}
var init_VariablesInAllowedPositionRule = __esm({
  "../../../node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.mjs"() {
    init_inspect();
    init_GraphQLError();
    init_kinds();
    init_definition();
    init_typeComparators();
    init_typeFromAST();
  }
});

// ../../../node_modules/graphql/validation/specifiedRules.mjs
var specifiedRules, specifiedSDLRules;
var init_specifiedRules = __esm({
  "../../../node_modules/graphql/validation/specifiedRules.mjs"() {
    init_ExecutableDefinitionsRule();
    init_FieldsOnCorrectTypeRule();
    init_FragmentsOnCompositeTypesRule();
    init_KnownArgumentNamesRule();
    init_KnownDirectivesRule();
    init_KnownFragmentNamesRule();
    init_KnownTypeNamesRule();
    init_LoneAnonymousOperationRule();
    init_LoneSchemaDefinitionRule();
    init_NoFragmentCyclesRule();
    init_NoUndefinedVariablesRule();
    init_NoUnusedFragmentsRule();
    init_NoUnusedVariablesRule();
    init_OverlappingFieldsCanBeMergedRule();
    init_PossibleFragmentSpreadsRule();
    init_PossibleTypeExtensionsRule();
    init_ProvidedRequiredArgumentsRule();
    init_ScalarLeafsRule();
    init_SingleFieldSubscriptionsRule();
    init_UniqueArgumentDefinitionNamesRule();
    init_UniqueArgumentNamesRule();
    init_UniqueDirectiveNamesRule();
    init_UniqueDirectivesPerLocationRule();
    init_UniqueEnumValueNamesRule();
    init_UniqueFieldDefinitionNamesRule();
    init_UniqueFragmentNamesRule();
    init_UniqueInputFieldNamesRule();
    init_UniqueOperationNamesRule();
    init_UniqueOperationTypesRule();
    init_UniqueTypeNamesRule();
    init_UniqueVariableNamesRule();
    init_ValuesOfCorrectTypeRule();
    init_VariablesAreInputTypesRule();
    init_VariablesInAllowedPositionRule();
    specifiedRules = Object.freeze([
      ExecutableDefinitionsRule,
      UniqueOperationNamesRule,
      LoneAnonymousOperationRule,
      SingleFieldSubscriptionsRule,
      KnownTypeNamesRule,
      FragmentsOnCompositeTypesRule,
      VariablesAreInputTypesRule,
      ScalarLeafsRule,
      FieldsOnCorrectTypeRule,
      UniqueFragmentNamesRule,
      KnownFragmentNamesRule,
      NoUnusedFragmentsRule,
      PossibleFragmentSpreadsRule,
      NoFragmentCyclesRule,
      UniqueVariableNamesRule,
      NoUndefinedVariablesRule,
      NoUnusedVariablesRule,
      KnownDirectivesRule,
      UniqueDirectivesPerLocationRule,
      KnownArgumentNamesRule,
      UniqueArgumentNamesRule,
      ValuesOfCorrectTypeRule,
      ProvidedRequiredArgumentsRule,
      VariablesInAllowedPositionRule,
      OverlappingFieldsCanBeMergedRule,
      UniqueInputFieldNamesRule
    ]);
    specifiedSDLRules = Object.freeze([
      LoneSchemaDefinitionRule,
      UniqueOperationTypesRule,
      UniqueTypeNamesRule,
      UniqueEnumValueNamesRule,
      UniqueFieldDefinitionNamesRule,
      UniqueArgumentDefinitionNamesRule,
      UniqueDirectiveNamesRule,
      KnownTypeNamesRule,
      KnownDirectivesRule,
      UniqueDirectivesPerLocationRule,
      PossibleTypeExtensionsRule,
      KnownArgumentNamesOnDirectivesRule,
      UniqueArgumentNamesRule,
      UniqueInputFieldNamesRule,
      ProvidedRequiredArgumentsOnDirectivesRule
    ]);
  }
});

// ../../../node_modules/graphql/validation/ValidationContext.mjs
var ASTValidationContext, SDLValidationContext, ValidationContext;
var init_ValidationContext = __esm({
  "../../../node_modules/graphql/validation/ValidationContext.mjs"() {
    init_kinds();
    init_visitor();
    init_TypeInfo();
    ASTValidationContext = class {
      constructor(ast, onError) {
        this._ast = ast;
        this._fragments = void 0;
        this._fragmentSpreads = /* @__PURE__ */ new Map();
        this._recursivelyReferencedFragments = /* @__PURE__ */ new Map();
        this._onError = onError;
      }
      get [Symbol.toStringTag]() {
        return "ASTValidationContext";
      }
      reportError(error) {
        this._onError(error);
      }
      getDocument() {
        return this._ast;
      }
      getFragment(name) {
        let fragments;
        if (this._fragments) {
          fragments = this._fragments;
        } else {
          fragments = /* @__PURE__ */ Object.create(null);
          for (const defNode of this.getDocument().definitions) {
            if (defNode.kind === Kind.FRAGMENT_DEFINITION) {
              fragments[defNode.name.value] = defNode;
            }
          }
          this._fragments = fragments;
        }
        return fragments[name];
      }
      getFragmentSpreads(node) {
        let spreads = this._fragmentSpreads.get(node);
        if (!spreads) {
          spreads = [];
          const setsToVisit = [node];
          let set;
          while (set = setsToVisit.pop()) {
            for (const selection of set.selections) {
              if (selection.kind === Kind.FRAGMENT_SPREAD) {
                spreads.push(selection);
              } else if (selection.selectionSet) {
                setsToVisit.push(selection.selectionSet);
              }
            }
          }
          this._fragmentSpreads.set(node, spreads);
        }
        return spreads;
      }
      getRecursivelyReferencedFragments(operation) {
        let fragments = this._recursivelyReferencedFragments.get(operation);
        if (!fragments) {
          fragments = [];
          const collectedNames = /* @__PURE__ */ Object.create(null);
          const nodesToVisit = [operation.selectionSet];
          let node;
          while (node = nodesToVisit.pop()) {
            for (const spread of this.getFragmentSpreads(node)) {
              const fragName = spread.name.value;
              if (collectedNames[fragName] !== true) {
                collectedNames[fragName] = true;
                const fragment = this.getFragment(fragName);
                if (fragment) {
                  fragments.push(fragment);
                  nodesToVisit.push(fragment.selectionSet);
                }
              }
            }
          }
          this._recursivelyReferencedFragments.set(operation, fragments);
        }
        return fragments;
      }
    };
    SDLValidationContext = class extends ASTValidationContext {
      constructor(ast, schema, onError) {
        super(ast, onError);
        this._schema = schema;
      }
      get [Symbol.toStringTag]() {
        return "SDLValidationContext";
      }
      getSchema() {
        return this._schema;
      }
    };
    ValidationContext = class extends ASTValidationContext {
      constructor(schema, ast, typeInfo, onError) {
        super(ast, onError);
        this._schema = schema;
        this._typeInfo = typeInfo;
        this._variableUsages = /* @__PURE__ */ new Map();
        this._recursiveVariableUsages = /* @__PURE__ */ new Map();
      }
      get [Symbol.toStringTag]() {
        return "ValidationContext";
      }
      getSchema() {
        return this._schema;
      }
      getVariableUsages(node) {
        let usages = this._variableUsages.get(node);
        if (!usages) {
          const newUsages = [];
          const typeInfo = new TypeInfo(this._schema);
          visit(
            node,
            visitWithTypeInfo(typeInfo, {
              VariableDefinition: () => false,
              Variable(variable) {
                newUsages.push({
                  node: variable,
                  type: typeInfo.getInputType(),
                  defaultValue: typeInfo.getDefaultValue()
                });
              }
            })
          );
          usages = newUsages;
          this._variableUsages.set(node, usages);
        }
        return usages;
      }
      getRecursiveVariableUsages(operation) {
        let usages = this._recursiveVariableUsages.get(operation);
        if (!usages) {
          usages = this.getVariableUsages(operation);
          for (const frag of this.getRecursivelyReferencedFragments(operation)) {
            usages = usages.concat(this.getVariableUsages(frag));
          }
          this._recursiveVariableUsages.set(operation, usages);
        }
        return usages;
      }
      getType() {
        return this._typeInfo.getType();
      }
      getParentType() {
        return this._typeInfo.getParentType();
      }
      getInputType() {
        return this._typeInfo.getInputType();
      }
      getParentInputType() {
        return this._typeInfo.getParentInputType();
      }
      getFieldDef() {
        return this._typeInfo.getFieldDef();
      }
      getDirective() {
        return this._typeInfo.getDirective();
      }
      getArgument() {
        return this._typeInfo.getArgument();
      }
      getEnumValue() {
        return this._typeInfo.getEnumValue();
      }
    };
  }
});

// ../../../node_modules/graphql/validation/validate.mjs
function validate(schema, documentAST, rules = specifiedRules, options, typeInfo = new TypeInfo(schema)) {
  var _options$maxErrors;
  const maxErrors = (_options$maxErrors = options === null || options === void 0 ? void 0 : options.maxErrors) !== null && _options$maxErrors !== void 0 ? _options$maxErrors : 100;
  documentAST || devAssert(false, "Must provide document.");
  assertValidSchema(schema);
  const abortObj = Object.freeze({});
  const errors = [];
  const context = new ValidationContext(
    schema,
    documentAST,
    typeInfo,
    (error) => {
      if (errors.length >= maxErrors) {
        errors.push(
          new GraphQLError(
            "Too many validation errors, error limit reached. Validation aborted."
          )
        );
        throw abortObj;
      }
      errors.push(error);
    }
  );
  const visitor = visitInParallel(rules.map((rule) => rule(context)));
  try {
    visit(documentAST, visitWithTypeInfo(typeInfo, visitor));
  } catch (e) {
    if (e !== abortObj) {
      throw e;
    }
  }
  return errors;
}
function validateSDL(documentAST, schemaToExtend, rules = specifiedSDLRules) {
  const errors = [];
  const context = new SDLValidationContext(
    documentAST,
    schemaToExtend,
    (error) => {
      errors.push(error);
    }
  );
  const visitors = rules.map((rule) => rule(context));
  visit(documentAST, visitInParallel(visitors));
  return errors;
}
function assertValidSDL(documentAST) {
  const errors = validateSDL(documentAST);
  if (errors.length !== 0) {
    throw new Error(errors.map((error) => error.message).join("\n\n"));
  }
}
function assertValidSDLExtension(documentAST, schema) {
  const errors = validateSDL(documentAST, schema);
  if (errors.length !== 0) {
    throw new Error(errors.map((error) => error.message).join("\n\n"));
  }
}
var init_validate2 = __esm({
  "../../../node_modules/graphql/validation/validate.mjs"() {
    init_devAssert();
    init_GraphQLError();
    init_visitor();
    init_validate();
    init_TypeInfo();
    init_specifiedRules();
    init_ValidationContext();
  }
});

// ../../../node_modules/graphql/jsutils/memoize3.mjs
function memoize3(fn) {
  let cache0;
  return function memoized(a1, a2, a3) {
    if (cache0 === void 0) {
      cache0 = /* @__PURE__ */ new WeakMap();
    }
    let cache1 = cache0.get(a1);
    if (cache1 === void 0) {
      cache1 = /* @__PURE__ */ new WeakMap();
      cache0.set(a1, cache1);
    }
    let cache2 = cache1.get(a2);
    if (cache2 === void 0) {
      cache2 = /* @__PURE__ */ new WeakMap();
      cache1.set(a2, cache2);
    }
    let fnResult = cache2.get(a3);
    if (fnResult === void 0) {
      fnResult = fn(a1, a2, a3);
      cache2.set(a3, fnResult);
    }
    return fnResult;
  };
}
var init_memoize3 = __esm({
  "../../../node_modules/graphql/jsutils/memoize3.mjs"() {
  }
});

// ../../../node_modules/graphql/jsutils/promiseForObject.mjs
function promiseForObject(object) {
  return Promise.all(Object.values(object)).then((resolvedValues) => {
    const resolvedObject = /* @__PURE__ */ Object.create(null);
    for (const [i, key] of Object.keys(object).entries()) {
      resolvedObject[key] = resolvedValues[i];
    }
    return resolvedObject;
  });
}
var init_promiseForObject = __esm({
  "../../../node_modules/graphql/jsutils/promiseForObject.mjs"() {
  }
});

// ../../../node_modules/graphql/jsutils/promiseReduce.mjs
function promiseReduce(values, callbackFn, initialValue) {
  let accumulator = initialValue;
  for (const value of values) {
    accumulator = isPromise(accumulator) ? accumulator.then((resolved) => callbackFn(resolved, value)) : callbackFn(accumulator, value);
  }
  return accumulator;
}
var init_promiseReduce = __esm({
  "../../../node_modules/graphql/jsutils/promiseReduce.mjs"() {
    init_isPromise();
  }
});

// ../../../node_modules/graphql/jsutils/toError.mjs
function toError(thrownValue) {
  return thrownValue instanceof Error ? thrownValue : new NonErrorThrown(thrownValue);
}
var NonErrorThrown;
var init_toError = __esm({
  "../../../node_modules/graphql/jsutils/toError.mjs"() {
    init_inspect();
    NonErrorThrown = class extends Error {
      constructor(thrownValue) {
        super("Unexpected error value: " + inspect(thrownValue));
        this.name = "NonErrorThrown";
        this.thrownValue = thrownValue;
      }
    };
  }
});

// ../../../node_modules/graphql/error/locatedError.mjs
function locatedError(rawOriginalError, nodes, path) {
  var _nodes;
  const originalError = toError(rawOriginalError);
  if (isLocatedGraphQLError(originalError)) {
    return originalError;
  }
  return new GraphQLError(originalError.message, {
    nodes: (_nodes = originalError.nodes) !== null && _nodes !== void 0 ? _nodes : nodes,
    source: originalError.source,
    positions: originalError.positions,
    path,
    originalError
  });
}
function isLocatedGraphQLError(error) {
  return Array.isArray(error.path);
}
var init_locatedError = __esm({
  "../../../node_modules/graphql/error/locatedError.mjs"() {
    init_toError();
    init_GraphQLError();
  }
});

// ../../../node_modules/graphql/execution/execute.mjs
function execute(args) {
  arguments.length < 2 || devAssert(
    false,
    "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead."
  );
  const { schema, document: document2, variableValues, rootValue } = args;
  assertValidExecutionArguments(schema, document2, variableValues);
  const exeContext = buildExecutionContext(args);
  if (!("schema" in exeContext)) {
    return {
      errors: exeContext
    };
  }
  try {
    const { operation } = exeContext;
    const result = executeOperation(exeContext, operation, rootValue);
    if (isPromise(result)) {
      return result.then(
        (data) => buildResponse(data, exeContext.errors),
        (error) => {
          exeContext.errors.push(error);
          return buildResponse(null, exeContext.errors);
        }
      );
    }
    return buildResponse(result, exeContext.errors);
  } catch (error) {
    exeContext.errors.push(error);
    return buildResponse(null, exeContext.errors);
  }
}
function executeSync(args) {
  const result = execute(args);
  if (isPromise(result)) {
    throw new Error("GraphQL execution failed to complete synchronously.");
  }
  return result;
}
function buildResponse(data, errors) {
  return errors.length === 0 ? {
    data
  } : {
    errors,
    data
  };
}
function assertValidExecutionArguments(schema, document2, rawVariableValues) {
  document2 || devAssert(false, "Must provide document.");
  assertValidSchema(schema);
  rawVariableValues == null || isObjectLike(rawVariableValues) || devAssert(
    false,
    "Variables must be provided as an Object where each property is a variable value. Perhaps look to see if an unparsed JSON string was provided."
  );
}
function buildExecutionContext(args) {
  var _definition$name, _operation$variableDe;
  const {
    schema,
    document: document2,
    rootValue,
    contextValue,
    variableValues: rawVariableValues,
    operationName,
    fieldResolver,
    typeResolver,
    subscribeFieldResolver
  } = args;
  let operation;
  const fragments = /* @__PURE__ */ Object.create(null);
  for (const definition of document2.definitions) {
    switch (definition.kind) {
      case Kind.OPERATION_DEFINITION:
        if (operationName == null) {
          if (operation !== void 0) {
            return [
              new GraphQLError(
                "Must provide operation name if query contains multiple operations."
              )
            ];
          }
          operation = definition;
        } else if (((_definition$name = definition.name) === null || _definition$name === void 0 ? void 0 : _definition$name.value) === operationName) {
          operation = definition;
        }
        break;
      case Kind.FRAGMENT_DEFINITION:
        fragments[definition.name.value] = definition;
        break;
      default:
    }
  }
  if (!operation) {
    if (operationName != null) {
      return [new GraphQLError(`Unknown operation named "${operationName}".`)];
    }
    return [new GraphQLError("Must provide an operation.")];
  }
  const variableDefinitions = (_operation$variableDe = operation.variableDefinitions) !== null && _operation$variableDe !== void 0 ? _operation$variableDe : [];
  const coercedVariableValues = getVariableValues(
    schema,
    variableDefinitions,
    rawVariableValues !== null && rawVariableValues !== void 0 ? rawVariableValues : {},
    {
      maxErrors: 50
    }
  );
  if (coercedVariableValues.errors) {
    return coercedVariableValues.errors;
  }
  return {
    schema,
    fragments,
    rootValue,
    contextValue,
    operation,
    variableValues: coercedVariableValues.coerced,
    fieldResolver: fieldResolver !== null && fieldResolver !== void 0 ? fieldResolver : defaultFieldResolver,
    typeResolver: typeResolver !== null && typeResolver !== void 0 ? typeResolver : defaultTypeResolver,
    subscribeFieldResolver: subscribeFieldResolver !== null && subscribeFieldResolver !== void 0 ? subscribeFieldResolver : defaultFieldResolver,
    errors: []
  };
}
function executeOperation(exeContext, operation, rootValue) {
  const rootType = exeContext.schema.getRootType(operation.operation);
  if (rootType == null) {
    throw new GraphQLError(
      `Schema is not configured to execute ${operation.operation} operation.`,
      {
        nodes: operation
      }
    );
  }
  const rootFields = collectFields(
    exeContext.schema,
    exeContext.fragments,
    exeContext.variableValues,
    rootType,
    operation.selectionSet
  );
  const path = void 0;
  switch (operation.operation) {
    case OperationTypeNode.QUERY:
      return executeFields(exeContext, rootType, rootValue, path, rootFields);
    case OperationTypeNode.MUTATION:
      return executeFieldsSerially(
        exeContext,
        rootType,
        rootValue,
        path,
        rootFields
      );
    case OperationTypeNode.SUBSCRIPTION:
      return executeFields(exeContext, rootType, rootValue, path, rootFields);
  }
}
function executeFieldsSerially(exeContext, parentType, sourceValue, path, fields) {
  return promiseReduce(
    fields.entries(),
    (results, [responseName, fieldNodes]) => {
      const fieldPath = addPath(path, responseName, parentType.name);
      const result = executeField(
        exeContext,
        parentType,
        sourceValue,
        fieldNodes,
        fieldPath
      );
      if (result === void 0) {
        return results;
      }
      if (isPromise(result)) {
        return result.then((resolvedResult) => {
          results[responseName] = resolvedResult;
          return results;
        });
      }
      results[responseName] = result;
      return results;
    },
    /* @__PURE__ */ Object.create(null)
  );
}
function executeFields(exeContext, parentType, sourceValue, path, fields) {
  const results = /* @__PURE__ */ Object.create(null);
  let containsPromise = false;
  try {
    for (const [responseName, fieldNodes] of fields.entries()) {
      const fieldPath = addPath(path, responseName, parentType.name);
      const result = executeField(
        exeContext,
        parentType,
        sourceValue,
        fieldNodes,
        fieldPath
      );
      if (result !== void 0) {
        results[responseName] = result;
        if (isPromise(result)) {
          containsPromise = true;
        }
      }
    }
  } catch (error) {
    if (containsPromise) {
      return promiseForObject(results).finally(() => {
        throw error;
      });
    }
    throw error;
  }
  if (!containsPromise) {
    return results;
  }
  return promiseForObject(results);
}
function executeField(exeContext, parentType, source, fieldNodes, path) {
  var _fieldDef$resolve;
  const fieldDef = getFieldDef2(exeContext.schema, parentType, fieldNodes[0]);
  if (!fieldDef) {
    return;
  }
  const returnType = fieldDef.type;
  const resolveFn = (_fieldDef$resolve = fieldDef.resolve) !== null && _fieldDef$resolve !== void 0 ? _fieldDef$resolve : exeContext.fieldResolver;
  const info = buildResolveInfo(
    exeContext,
    fieldDef,
    fieldNodes,
    parentType,
    path
  );
  try {
    const args = getArgumentValues(
      fieldDef,
      fieldNodes[0],
      exeContext.variableValues
    );
    const contextValue = exeContext.contextValue;
    const result = resolveFn(source, args, contextValue, info);
    let completed;
    if (isPromise(result)) {
      completed = result.then(
        (resolved) => completeValue(exeContext, returnType, fieldNodes, info, path, resolved)
      );
    } else {
      completed = completeValue(
        exeContext,
        returnType,
        fieldNodes,
        info,
        path,
        result
      );
    }
    if (isPromise(completed)) {
      return completed.then(void 0, (rawError) => {
        const error = locatedError(rawError, fieldNodes, pathToArray(path));
        return handleFieldError(error, returnType, exeContext);
      });
    }
    return completed;
  } catch (rawError) {
    const error = locatedError(rawError, fieldNodes, pathToArray(path));
    return handleFieldError(error, returnType, exeContext);
  }
}
function buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path) {
  return {
    fieldName: fieldDef.name,
    fieldNodes,
    returnType: fieldDef.type,
    parentType,
    path,
    schema: exeContext.schema,
    fragments: exeContext.fragments,
    rootValue: exeContext.rootValue,
    operation: exeContext.operation,
    variableValues: exeContext.variableValues
  };
}
function handleFieldError(error, returnType, exeContext) {
  if (isNonNullType(returnType)) {
    throw error;
  }
  exeContext.errors.push(error);
  return null;
}
function completeValue(exeContext, returnType, fieldNodes, info, path, result) {
  if (result instanceof Error) {
    throw result;
  }
  if (isNonNullType(returnType)) {
    const completed = completeValue(
      exeContext,
      returnType.ofType,
      fieldNodes,
      info,
      path,
      result
    );
    if (completed === null) {
      throw new Error(
        `Cannot return null for non-nullable field ${info.parentType.name}.${info.fieldName}.`
      );
    }
    return completed;
  }
  if (result == null) {
    return null;
  }
  if (isListType(returnType)) {
    return completeListValue(
      exeContext,
      returnType,
      fieldNodes,
      info,
      path,
      result
    );
  }
  if (isLeafType(returnType)) {
    return completeLeafValue(returnType, result);
  }
  if (isAbstractType(returnType)) {
    return completeAbstractValue(
      exeContext,
      returnType,
      fieldNodes,
      info,
      path,
      result
    );
  }
  if (isObjectType(returnType)) {
    return completeObjectValue(
      exeContext,
      returnType,
      fieldNodes,
      info,
      path,
      result
    );
  }
  invariant(
    false,
    "Cannot complete value of unexpected output type: " + inspect(returnType)
  );
}
function completeListValue(exeContext, returnType, fieldNodes, info, path, result) {
  if (!isIterableObject(result)) {
    throw new GraphQLError(
      `Expected Iterable, but did not find one for field "${info.parentType.name}.${info.fieldName}".`
    );
  }
  const itemType = returnType.ofType;
  let containsPromise = false;
  const completedResults = Array.from(result, (item, index) => {
    const itemPath = addPath(path, index, void 0);
    try {
      let completedItem;
      if (isPromise(item)) {
        completedItem = item.then(
          (resolved) => completeValue(
            exeContext,
            itemType,
            fieldNodes,
            info,
            itemPath,
            resolved
          )
        );
      } else {
        completedItem = completeValue(
          exeContext,
          itemType,
          fieldNodes,
          info,
          itemPath,
          item
        );
      }
      if (isPromise(completedItem)) {
        containsPromise = true;
        return completedItem.then(void 0, (rawError) => {
          const error = locatedError(
            rawError,
            fieldNodes,
            pathToArray(itemPath)
          );
          return handleFieldError(error, itemType, exeContext);
        });
      }
      return completedItem;
    } catch (rawError) {
      const error = locatedError(rawError, fieldNodes, pathToArray(itemPath));
      return handleFieldError(error, itemType, exeContext);
    }
  });
  return containsPromise ? Promise.all(completedResults) : completedResults;
}
function completeLeafValue(returnType, result) {
  const serializedResult = returnType.serialize(result);
  if (serializedResult == null) {
    throw new Error(
      `Expected \`${inspect(returnType)}.serialize(${inspect(result)})\` to return non-nullable value, returned: ${inspect(serializedResult)}`
    );
  }
  return serializedResult;
}
function completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result) {
  var _returnType$resolveTy;
  const resolveTypeFn = (_returnType$resolveTy = returnType.resolveType) !== null && _returnType$resolveTy !== void 0 ? _returnType$resolveTy : exeContext.typeResolver;
  const contextValue = exeContext.contextValue;
  const runtimeType = resolveTypeFn(result, contextValue, info, returnType);
  if (isPromise(runtimeType)) {
    return runtimeType.then(
      (resolvedRuntimeType) => completeObjectValue(
        exeContext,
        ensureValidRuntimeType(
          resolvedRuntimeType,
          exeContext,
          returnType,
          fieldNodes,
          info,
          result
        ),
        fieldNodes,
        info,
        path,
        result
      )
    );
  }
  return completeObjectValue(
    exeContext,
    ensureValidRuntimeType(
      runtimeType,
      exeContext,
      returnType,
      fieldNodes,
      info,
      result
    ),
    fieldNodes,
    info,
    path,
    result
  );
}
function ensureValidRuntimeType(runtimeTypeName, exeContext, returnType, fieldNodes, info, result) {
  if (runtimeTypeName == null) {
    throw new GraphQLError(
      `Abstract type "${returnType.name}" must resolve to an Object type at runtime for field "${info.parentType.name}.${info.fieldName}". Either the "${returnType.name}" type should provide a "resolveType" function or each possible type should provide an "isTypeOf" function.`,
      fieldNodes
    );
  }
  if (isObjectType(runtimeTypeName)) {
    throw new GraphQLError(
      "Support for returning GraphQLObjectType from resolveType was removed in graphql-js@16.0.0 please return type name instead."
    );
  }
  if (typeof runtimeTypeName !== "string") {
    throw new GraphQLError(
      `Abstract type "${returnType.name}" must resolve to an Object type at runtime for field "${info.parentType.name}.${info.fieldName}" with value ${inspect(result)}, received "${inspect(runtimeTypeName)}".`
    );
  }
  const runtimeType = exeContext.schema.getType(runtimeTypeName);
  if (runtimeType == null) {
    throw new GraphQLError(
      `Abstract type "${returnType.name}" was resolved to a type "${runtimeTypeName}" that does not exist inside the schema.`,
      {
        nodes: fieldNodes
      }
    );
  }
  if (!isObjectType(runtimeType)) {
    throw new GraphQLError(
      `Abstract type "${returnType.name}" was resolved to a non-object type "${runtimeTypeName}".`,
      {
        nodes: fieldNodes
      }
    );
  }
  if (!exeContext.schema.isSubType(returnType, runtimeType)) {
    throw new GraphQLError(
      `Runtime Object type "${runtimeType.name}" is not a possible type for "${returnType.name}".`,
      {
        nodes: fieldNodes
      }
    );
  }
  return runtimeType;
}
function completeObjectValue(exeContext, returnType, fieldNodes, info, path, result) {
  const subFieldNodes = collectSubfields2(exeContext, returnType, fieldNodes);
  if (returnType.isTypeOf) {
    const isTypeOf = returnType.isTypeOf(result, exeContext.contextValue, info);
    if (isPromise(isTypeOf)) {
      return isTypeOf.then((resolvedIsTypeOf) => {
        if (!resolvedIsTypeOf) {
          throw invalidReturnTypeError(returnType, result, fieldNodes);
        }
        return executeFields(
          exeContext,
          returnType,
          result,
          path,
          subFieldNodes
        );
      });
    }
    if (!isTypeOf) {
      throw invalidReturnTypeError(returnType, result, fieldNodes);
    }
  }
  return executeFields(exeContext, returnType, result, path, subFieldNodes);
}
function invalidReturnTypeError(returnType, result, fieldNodes) {
  return new GraphQLError(
    `Expected value of type "${returnType.name}" but got: ${inspect(result)}.`,
    {
      nodes: fieldNodes
    }
  );
}
function getFieldDef2(schema, parentType, fieldNode) {
  const fieldName = fieldNode.name.value;
  if (fieldName === SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {
    return SchemaMetaFieldDef;
  } else if (fieldName === TypeMetaFieldDef.name && schema.getQueryType() === parentType) {
    return TypeMetaFieldDef;
  } else if (fieldName === TypeNameMetaFieldDef.name) {
    return TypeNameMetaFieldDef;
  }
  return parentType.getFields()[fieldName];
}
var collectSubfields2, defaultTypeResolver, defaultFieldResolver;
var init_execute = __esm({
  "../../../node_modules/graphql/execution/execute.mjs"() {
    init_devAssert();
    init_inspect();
    init_invariant();
    init_isIterableObject();
    init_isObjectLike();
    init_isPromise();
    init_memoize3();
    init_Path();
    init_promiseForObject();
    init_promiseReduce();
    init_GraphQLError();
    init_locatedError();
    init_ast();
    init_kinds();
    init_definition();
    init_introspection();
    init_validate();
    init_collectFields();
    init_values();
    collectSubfields2 = memoize3(
      (exeContext, returnType, fieldNodes) => collectSubfields(
        exeContext.schema,
        exeContext.fragments,
        exeContext.variableValues,
        returnType,
        fieldNodes
      )
    );
    defaultTypeResolver = function(value, contextValue, info, abstractType) {
      if (isObjectLike(value) && typeof value.__typename === "string") {
        return value.__typename;
      }
      const possibleTypes = info.schema.getPossibleTypes(abstractType);
      const promisedIsTypeOfResults = [];
      for (let i = 0; i < possibleTypes.length; i++) {
        const type = possibleTypes[i];
        if (type.isTypeOf) {
          const isTypeOfResult = type.isTypeOf(value, contextValue, info);
          if (isPromise(isTypeOfResult)) {
            promisedIsTypeOfResults[i] = isTypeOfResult;
          } else if (isTypeOfResult) {
            return type.name;
          }
        }
      }
      if (promisedIsTypeOfResults.length) {
        return Promise.all(promisedIsTypeOfResults).then((isTypeOfResults) => {
          for (let i = 0; i < isTypeOfResults.length; i++) {
            if (isTypeOfResults[i]) {
              return possibleTypes[i].name;
            }
          }
        });
      }
    };
    defaultFieldResolver = function(source, args, contextValue, info) {
      if (isObjectLike(source) || typeof source === "function") {
        const property = source[info.fieldName];
        if (typeof property === "function") {
          return source[info.fieldName](args, contextValue, info);
        }
        return property;
      }
    };
  }
});

// ../../../node_modules/graphql/graphql.mjs
function graphql(args) {
  return new Promise((resolve) => resolve(graphqlImpl(args)));
}
function graphqlSync(args) {
  const result = graphqlImpl(args);
  if (isPromise(result)) {
    throw new Error("GraphQL execution failed to complete synchronously.");
  }
  return result;
}
function graphqlImpl(args) {
  arguments.length < 2 || devAssert(
    false,
    "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead."
  );
  const {
    schema,
    source,
    rootValue,
    contextValue,
    variableValues,
    operationName,
    fieldResolver,
    typeResolver
  } = args;
  const schemaValidationErrors = validateSchema(schema);
  if (schemaValidationErrors.length > 0) {
    return {
      errors: schemaValidationErrors
    };
  }
  let document2;
  try {
    document2 = parse(source);
  } catch (syntaxError2) {
    return {
      errors: [syntaxError2]
    };
  }
  const validationErrors = validate(schema, document2);
  if (validationErrors.length > 0) {
    return {
      errors: validationErrors
    };
  }
  return execute({
    schema,
    document: document2,
    rootValue,
    contextValue,
    variableValues,
    operationName,
    fieldResolver,
    typeResolver
  });
}
var init_graphql = __esm({
  "../../../node_modules/graphql/graphql.mjs"() {
    init_devAssert();
    init_isPromise();
    init_parser();
    init_validate();
    init_validate2();
    init_execute();
  }
});

// ../../../node_modules/graphql/type/index.mjs
var type_exports = {};
__export(type_exports, {
  DEFAULT_DEPRECATION_REASON: () => DEFAULT_DEPRECATION_REASON,
  GRAPHQL_MAX_INT: () => GRAPHQL_MAX_INT,
  GRAPHQL_MIN_INT: () => GRAPHQL_MIN_INT,
  GraphQLBoolean: () => GraphQLBoolean,
  GraphQLDeprecatedDirective: () => GraphQLDeprecatedDirective,
  GraphQLDirective: () => GraphQLDirective,
  GraphQLEnumType: () => GraphQLEnumType,
  GraphQLFloat: () => GraphQLFloat,
  GraphQLID: () => GraphQLID,
  GraphQLIncludeDirective: () => GraphQLIncludeDirective,
  GraphQLInputObjectType: () => GraphQLInputObjectType,
  GraphQLInt: () => GraphQLInt,
  GraphQLInterfaceType: () => GraphQLInterfaceType,
  GraphQLList: () => GraphQLList,
  GraphQLNonNull: () => GraphQLNonNull,
  GraphQLObjectType: () => GraphQLObjectType,
  GraphQLScalarType: () => GraphQLScalarType,
  GraphQLSchema: () => GraphQLSchema,
  GraphQLSkipDirective: () => GraphQLSkipDirective,
  GraphQLSpecifiedByDirective: () => GraphQLSpecifiedByDirective,
  GraphQLString: () => GraphQLString,
  GraphQLUnionType: () => GraphQLUnionType,
  SchemaMetaFieldDef: () => SchemaMetaFieldDef,
  TypeKind: () => TypeKind,
  TypeMetaFieldDef: () => TypeMetaFieldDef,
  TypeNameMetaFieldDef: () => TypeNameMetaFieldDef,
  __Directive: () => __Directive,
  __DirectiveLocation: () => __DirectiveLocation,
  __EnumValue: () => __EnumValue,
  __Field: () => __Field,
  __InputValue: () => __InputValue,
  __Schema: () => __Schema,
  __Type: () => __Type,
  __TypeKind: () => __TypeKind,
  assertAbstractType: () => assertAbstractType,
  assertCompositeType: () => assertCompositeType,
  assertDirective: () => assertDirective,
  assertEnumType: () => assertEnumType,
  assertEnumValueName: () => assertEnumValueName,
  assertInputObjectType: () => assertInputObjectType,
  assertInputType: () => assertInputType,
  assertInterfaceType: () => assertInterfaceType,
  assertLeafType: () => assertLeafType,
  assertListType: () => assertListType,
  assertName: () => assertName,
  assertNamedType: () => assertNamedType,
  assertNonNullType: () => assertNonNullType,
  assertNullableType: () => assertNullableType,
  assertObjectType: () => assertObjectType,
  assertOutputType: () => assertOutputType,
  assertScalarType: () => assertScalarType,
  assertSchema: () => assertSchema,
  assertType: () => assertType,
  assertUnionType: () => assertUnionType,
  assertValidSchema: () => assertValidSchema,
  assertWrappingType: () => assertWrappingType,
  getNamedType: () => getNamedType,
  getNullableType: () => getNullableType,
  introspectionTypes: () => introspectionTypes,
  isAbstractType: () => isAbstractType,
  isCompositeType: () => isCompositeType,
  isDirective: () => isDirective,
  isEnumType: () => isEnumType,
  isInputObjectType: () => isInputObjectType,
  isInputType: () => isInputType,
  isInterfaceType: () => isInterfaceType,
  isIntrospectionType: () => isIntrospectionType,
  isLeafType: () => isLeafType,
  isListType: () => isListType,
  isNamedType: () => isNamedType,
  isNonNullType: () => isNonNullType,
  isNullableType: () => isNullableType,
  isObjectType: () => isObjectType,
  isOutputType: () => isOutputType,
  isRequiredArgument: () => isRequiredArgument,
  isRequiredInputField: () => isRequiredInputField,
  isScalarType: () => isScalarType,
  isSchema: () => isSchema,
  isSpecifiedDirective: () => isSpecifiedDirective,
  isSpecifiedScalarType: () => isSpecifiedScalarType,
  isType: () => isType,
  isUnionType: () => isUnionType,
  isWrappingType: () => isWrappingType,
  resolveObjMapThunk: () => resolveObjMapThunk,
  resolveReadonlyArrayThunk: () => resolveReadonlyArrayThunk,
  specifiedDirectives: () => specifiedDirectives,
  specifiedScalarTypes: () => specifiedScalarTypes,
  validateSchema: () => validateSchema
});
var init_type = __esm({
  "../../../node_modules/graphql/type/index.mjs"() {
    init_schema();
    init_definition();
    init_directives();
    init_scalars();
    init_introspection();
    init_validate();
    init_assertName();
  }
});

// ../../../node_modules/graphql/language/index.mjs
var language_exports = {};
__export(language_exports, {
  BREAK: () => BREAK,
  DirectiveLocation: () => DirectiveLocation,
  Kind: () => Kind,
  Lexer: () => Lexer,
  Location: () => Location,
  OperationTypeNode: () => OperationTypeNode,
  Source: () => Source,
  Token: () => Token,
  TokenKind: () => TokenKind,
  getEnterLeaveForKind: () => getEnterLeaveForKind,
  getLocation: () => getLocation,
  getVisitFn: () => getVisitFn,
  isConstValueNode: () => isConstValueNode,
  isDefinitionNode: () => isDefinitionNode,
  isExecutableDefinitionNode: () => isExecutableDefinitionNode,
  isSelectionNode: () => isSelectionNode,
  isTypeDefinitionNode: () => isTypeDefinitionNode,
  isTypeExtensionNode: () => isTypeExtensionNode,
  isTypeNode: () => isTypeNode,
  isTypeSystemDefinitionNode: () => isTypeSystemDefinitionNode,
  isTypeSystemExtensionNode: () => isTypeSystemExtensionNode,
  isValueNode: () => isValueNode,
  parse: () => parse,
  parseConstValue: () => parseConstValue,
  parseType: () => parseType,
  parseValue: () => parseValue,
  print: () => print,
  printLocation: () => printLocation,
  printSourceLocation: () => printSourceLocation,
  visit: () => visit,
  visitInParallel: () => visitInParallel
});
var init_language = __esm({
  "../../../node_modules/graphql/language/index.mjs"() {
    init_source();
    init_location();
    init_printLocation();
    init_kinds();
    init_tokenKind();
    init_lexer();
    init_parser();
    init_printer();
    init_visitor();
    init_ast();
    init_predicates();
    init_directiveLocation();
  }
});

// ../../../node_modules/graphql/jsutils/isAsyncIterable.mjs
function isAsyncIterable(maybeAsyncIterable) {
  return typeof (maybeAsyncIterable === null || maybeAsyncIterable === void 0 ? void 0 : maybeAsyncIterable[Symbol.asyncIterator]) === "function";
}
var init_isAsyncIterable = __esm({
  "../../../node_modules/graphql/jsutils/isAsyncIterable.mjs"() {
  }
});

// ../../../node_modules/graphql/execution/mapAsyncIterator.mjs
function mapAsyncIterator(iterable, callback) {
  const iterator = iterable[Symbol.asyncIterator]();
  async function mapResult(result) {
    if (result.done) {
      return result;
    }
    try {
      return {
        value: await callback(result.value),
        done: false
      };
    } catch (error) {
      if (typeof iterator.return === "function") {
        try {
          await iterator.return();
        } catch (_e) {
        }
      }
      throw error;
    }
  }
  return {
    async next() {
      return mapResult(await iterator.next());
    },
    async return() {
      return typeof iterator.return === "function" ? mapResult(await iterator.return()) : {
        value: void 0,
        done: true
      };
    },
    async throw(error) {
      if (typeof iterator.throw === "function") {
        return mapResult(await iterator.throw(error));
      }
      throw error;
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
var init_mapAsyncIterator = __esm({
  "../../../node_modules/graphql/execution/mapAsyncIterator.mjs"() {
  }
});

// ../../../node_modules/graphql/execution/subscribe.mjs
async function subscribe(args) {
  arguments.length < 2 || devAssert(
    false,
    "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead."
  );
  const resultOrStream = await createSourceEventStream(args);
  if (!isAsyncIterable(resultOrStream)) {
    return resultOrStream;
  }
  const mapSourceToResponse = (payload) => execute({ ...args, rootValue: payload });
  return mapAsyncIterator(resultOrStream, mapSourceToResponse);
}
function toNormalizedArgs(args) {
  const firstArg = args[0];
  if (firstArg && "document" in firstArg) {
    return firstArg;
  }
  return {
    schema: firstArg,
    // FIXME: when underlying TS bug fixed, see https://github.com/microsoft/TypeScript/issues/31613
    document: args[1],
    rootValue: args[2],
    contextValue: args[3],
    variableValues: args[4],
    operationName: args[5],
    subscribeFieldResolver: args[6]
  };
}
async function createSourceEventStream(...rawArgs) {
  const args = toNormalizedArgs(rawArgs);
  const { schema, document: document2, variableValues } = args;
  assertValidExecutionArguments(schema, document2, variableValues);
  const exeContext = buildExecutionContext(args);
  if (!("schema" in exeContext)) {
    return {
      errors: exeContext
    };
  }
  try {
    const eventStream = await executeSubscription(exeContext);
    if (!isAsyncIterable(eventStream)) {
      throw new Error(
        `Subscription field must return Async Iterable. Received: ${inspect(eventStream)}.`
      );
    }
    return eventStream;
  } catch (error) {
    if (error instanceof GraphQLError) {
      return {
        errors: [error]
      };
    }
    throw error;
  }
}
async function executeSubscription(exeContext) {
  const { schema, fragments, operation, variableValues, rootValue } = exeContext;
  const rootType = schema.getSubscriptionType();
  if (rootType == null) {
    throw new GraphQLError(
      "Schema is not configured to execute subscription operation.",
      {
        nodes: operation
      }
    );
  }
  const rootFields = collectFields(
    schema,
    fragments,
    variableValues,
    rootType,
    operation.selectionSet
  );
  const [responseName, fieldNodes] = [...rootFields.entries()][0];
  const fieldDef = getFieldDef2(schema, rootType, fieldNodes[0]);
  if (!fieldDef) {
    const fieldName = fieldNodes[0].name.value;
    throw new GraphQLError(
      `The subscription field "${fieldName}" is not defined.`,
      {
        nodes: fieldNodes
      }
    );
  }
  const path = addPath(void 0, responseName, rootType.name);
  const info = buildResolveInfo(
    exeContext,
    fieldDef,
    fieldNodes,
    rootType,
    path
  );
  try {
    var _fieldDef$subscribe;
    const args = getArgumentValues(fieldDef, fieldNodes[0], variableValues);
    const contextValue = exeContext.contextValue;
    const resolveFn = (_fieldDef$subscribe = fieldDef.subscribe) !== null && _fieldDef$subscribe !== void 0 ? _fieldDef$subscribe : exeContext.subscribeFieldResolver;
    const eventStream = await resolveFn(rootValue, args, contextValue, info);
    if (eventStream instanceof Error) {
      throw eventStream;
    }
    return eventStream;
  } catch (error) {
    throw locatedError(error, fieldNodes, pathToArray(path));
  }
}
var init_subscribe = __esm({
  "../../../node_modules/graphql/execution/subscribe.mjs"() {
    init_devAssert();
    init_inspect();
    init_isAsyncIterable();
    init_Path();
    init_GraphQLError();
    init_locatedError();
    init_collectFields();
    init_execute();
    init_mapAsyncIterator();
    init_values();
  }
});

// ../../../node_modules/graphql/execution/index.mjs
var execution_exports = {};
__export(execution_exports, {
  createSourceEventStream: () => createSourceEventStream,
  defaultFieldResolver: () => defaultFieldResolver,
  defaultTypeResolver: () => defaultTypeResolver,
  execute: () => execute,
  executeSync: () => executeSync,
  getArgumentValues: () => getArgumentValues,
  getDirectiveValues: () => getDirectiveValues,
  getVariableValues: () => getVariableValues,
  responsePathAsArray: () => pathToArray,
  subscribe: () => subscribe
});
var init_execution = __esm({
  "../../../node_modules/graphql/execution/index.mjs"() {
    init_Path();
    init_execute();
    init_subscribe();
    init_values();
  }
});

// ../../../node_modules/graphql/validation/rules/custom/NoDeprecatedCustomRule.mjs
function NoDeprecatedCustomRule(context) {
  return {
    Field(node) {
      const fieldDef = context.getFieldDef();
      const deprecationReason = fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.deprecationReason;
      if (fieldDef && deprecationReason != null) {
        const parentType = context.getParentType();
        parentType != null || invariant(false);
        context.reportError(
          new GraphQLError(
            `The field ${parentType.name}.${fieldDef.name} is deprecated. ${deprecationReason}`,
            {
              nodes: node
            }
          )
        );
      }
    },
    Argument(node) {
      const argDef = context.getArgument();
      const deprecationReason = argDef === null || argDef === void 0 ? void 0 : argDef.deprecationReason;
      if (argDef && deprecationReason != null) {
        const directiveDef = context.getDirective();
        if (directiveDef != null) {
          context.reportError(
            new GraphQLError(
              `Directive "@${directiveDef.name}" argument "${argDef.name}" is deprecated. ${deprecationReason}`,
              {
                nodes: node
              }
            )
          );
        } else {
          const parentType = context.getParentType();
          const fieldDef = context.getFieldDef();
          parentType != null && fieldDef != null || invariant(false);
          context.reportError(
            new GraphQLError(
              `Field "${parentType.name}.${fieldDef.name}" argument "${argDef.name}" is deprecated. ${deprecationReason}`,
              {
                nodes: node
              }
            )
          );
        }
      }
    },
    ObjectField(node) {
      const inputObjectDef = getNamedType(context.getParentInputType());
      if (isInputObjectType(inputObjectDef)) {
        const inputFieldDef = inputObjectDef.getFields()[node.name.value];
        const deprecationReason = inputFieldDef === null || inputFieldDef === void 0 ? void 0 : inputFieldDef.deprecationReason;
        if (deprecationReason != null) {
          context.reportError(
            new GraphQLError(
              `The input field ${inputObjectDef.name}.${inputFieldDef.name} is deprecated. ${deprecationReason}`,
              {
                nodes: node
              }
            )
          );
        }
      }
    },
    EnumValue(node) {
      const enumValueDef = context.getEnumValue();
      const deprecationReason = enumValueDef === null || enumValueDef === void 0 ? void 0 : enumValueDef.deprecationReason;
      if (enumValueDef && deprecationReason != null) {
        const enumTypeDef = getNamedType(context.getInputType());
        enumTypeDef != null || invariant(false);
        context.reportError(
          new GraphQLError(
            `The enum value "${enumTypeDef.name}.${enumValueDef.name}" is deprecated. ${deprecationReason}`,
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}
var init_NoDeprecatedCustomRule = __esm({
  "../../../node_modules/graphql/validation/rules/custom/NoDeprecatedCustomRule.mjs"() {
    init_invariant();
    init_GraphQLError();
    init_definition();
  }
});

// ../../../node_modules/graphql/validation/rules/custom/NoSchemaIntrospectionCustomRule.mjs
function NoSchemaIntrospectionCustomRule(context) {
  return {
    Field(node) {
      const type = getNamedType(context.getType());
      if (type && isIntrospectionType(type)) {
        context.reportError(
          new GraphQLError(
            `GraphQL introspection has been disabled, but the requested query contained the field "${node.name.value}".`,
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}
var init_NoSchemaIntrospectionCustomRule = __esm({
  "../../../node_modules/graphql/validation/rules/custom/NoSchemaIntrospectionCustomRule.mjs"() {
    init_GraphQLError();
    init_definition();
    init_introspection();
  }
});

// ../../../node_modules/graphql/validation/index.mjs
var init_validation = __esm({
  "../../../node_modules/graphql/validation/index.mjs"() {
    init_validate2();
    init_ValidationContext();
    init_specifiedRules();
    init_ExecutableDefinitionsRule();
    init_FieldsOnCorrectTypeRule();
    init_FragmentsOnCompositeTypesRule();
    init_KnownArgumentNamesRule();
    init_KnownDirectivesRule();
    init_KnownFragmentNamesRule();
    init_KnownTypeNamesRule();
    init_LoneAnonymousOperationRule();
    init_NoFragmentCyclesRule();
    init_NoUndefinedVariablesRule();
    init_NoUnusedFragmentsRule();
    init_NoUnusedVariablesRule();
    init_OverlappingFieldsCanBeMergedRule();
    init_PossibleFragmentSpreadsRule();
    init_ProvidedRequiredArgumentsRule();
    init_ScalarLeafsRule();
    init_SingleFieldSubscriptionsRule();
    init_UniqueArgumentNamesRule();
    init_UniqueDirectivesPerLocationRule();
    init_UniqueFragmentNamesRule();
    init_UniqueInputFieldNamesRule();
    init_UniqueOperationNamesRule();
    init_UniqueVariableNamesRule();
    init_ValuesOfCorrectTypeRule();
    init_VariablesAreInputTypesRule();
    init_VariablesInAllowedPositionRule();
    init_LoneSchemaDefinitionRule();
    init_UniqueOperationTypesRule();
    init_UniqueTypeNamesRule();
    init_UniqueEnumValueNamesRule();
    init_UniqueFieldDefinitionNamesRule();
    init_UniqueArgumentDefinitionNamesRule();
    init_UniqueDirectiveNamesRule();
    init_PossibleTypeExtensionsRule();
    init_NoDeprecatedCustomRule();
    init_NoSchemaIntrospectionCustomRule();
  }
});

// ../../../node_modules/graphql/error/index.mjs
var init_error = __esm({
  "../../../node_modules/graphql/error/index.mjs"() {
    init_GraphQLError();
    init_syntaxError();
    init_locatedError();
  }
});

// ../../../node_modules/graphql/utilities/getIntrospectionQuery.mjs
function getIntrospectionQuery(options) {
  const optionsWithDefault = {
    descriptions: true,
    specifiedByUrl: false,
    directiveIsRepeatable: false,
    schemaDescription: false,
    inputValueDeprecation: false,
    ...options
  };
  const descriptions = optionsWithDefault.descriptions ? "description" : "";
  const specifiedByUrl = optionsWithDefault.specifiedByUrl ? "specifiedByURL" : "";
  const directiveIsRepeatable = optionsWithDefault.directiveIsRepeatable ? "isRepeatable" : "";
  const schemaDescription = optionsWithDefault.schemaDescription ? descriptions : "";
  function inputDeprecation(str) {
    return optionsWithDefault.inputValueDeprecation ? str : "";
  }
  return `
    query IntrospectionQuery {
      __schema {
        ${schemaDescription}
        queryType { name }
        mutationType { name }
        subscriptionType { name }
        types {
          ...FullType
        }
        directives {
          name
          ${descriptions}
          ${directiveIsRepeatable}
          locations
          args${inputDeprecation("(includeDeprecated: true)")} {
            ...InputValue
          }
        }
      }
    }

    fragment FullType on __Type {
      kind
      name
      ${descriptions}
      ${specifiedByUrl}
      fields(includeDeprecated: true) {
        name
        ${descriptions}
        args${inputDeprecation("(includeDeprecated: true)")} {
          ...InputValue
        }
        type {
          ...TypeRef
        }
        isDeprecated
        deprecationReason
      }
      inputFields${inputDeprecation("(includeDeprecated: true)")} {
        ...InputValue
      }
      interfaces {
        ...TypeRef
      }
      enumValues(includeDeprecated: true) {
        name
        ${descriptions}
        isDeprecated
        deprecationReason
      }
      possibleTypes {
        ...TypeRef
      }
    }

    fragment InputValue on __InputValue {
      name
      ${descriptions}
      type { ...TypeRef }
      defaultValue
      ${inputDeprecation("isDeprecated")}
      ${inputDeprecation("deprecationReason")}
    }

    fragment TypeRef on __Type {
      kind
      name
      ofType {
        kind
        name
        ofType {
          kind
          name
          ofType {
            kind
            name
            ofType {
              kind
              name
              ofType {
                kind
                name
                ofType {
                  kind
                  name
                  ofType {
                    kind
                    name
                  }
                }
              }
            }
          }
        }
      }
    }
  `;
}
var init_getIntrospectionQuery = __esm({
  "../../../node_modules/graphql/utilities/getIntrospectionQuery.mjs"() {
  }
});

// ../../../node_modules/graphql/utilities/getOperationAST.mjs
function getOperationAST(documentAST, operationName) {
  let operation = null;
  for (const definition of documentAST.definitions) {
    if (definition.kind === Kind.OPERATION_DEFINITION) {
      var _definition$name;
      if (operationName == null) {
        if (operation) {
          return null;
        }
        operation = definition;
      } else if (((_definition$name = definition.name) === null || _definition$name === void 0 ? void 0 : _definition$name.value) === operationName) {
        return definition;
      }
    }
  }
  return operation;
}
var init_getOperationAST = __esm({
  "../../../node_modules/graphql/utilities/getOperationAST.mjs"() {
    init_kinds();
  }
});

// ../../../node_modules/graphql/utilities/getOperationRootType.mjs
function getOperationRootType(schema, operation) {
  if (operation.operation === "query") {
    const queryType = schema.getQueryType();
    if (!queryType) {
      throw new GraphQLError(
        "Schema does not define the required query root type.",
        {
          nodes: operation
        }
      );
    }
    return queryType;
  }
  if (operation.operation === "mutation") {
    const mutationType = schema.getMutationType();
    if (!mutationType) {
      throw new GraphQLError("Schema is not configured for mutations.", {
        nodes: operation
      });
    }
    return mutationType;
  }
  if (operation.operation === "subscription") {
    const subscriptionType = schema.getSubscriptionType();
    if (!subscriptionType) {
      throw new GraphQLError("Schema is not configured for subscriptions.", {
        nodes: operation
      });
    }
    return subscriptionType;
  }
  throw new GraphQLError(
    "Can only have query, mutation and subscription operations.",
    {
      nodes: operation
    }
  );
}
var init_getOperationRootType = __esm({
  "../../../node_modules/graphql/utilities/getOperationRootType.mjs"() {
    init_GraphQLError();
  }
});

// ../../../node_modules/graphql/utilities/introspectionFromSchema.mjs
function introspectionFromSchema(schema, options) {
  const optionsWithDefaults = {
    specifiedByUrl: true,
    directiveIsRepeatable: true,
    schemaDescription: true,
    inputValueDeprecation: true,
    ...options
  };
  const document2 = parse(getIntrospectionQuery(optionsWithDefaults));
  const result = executeSync({
    schema,
    document: document2
  });
  !result.errors && result.data || invariant(false);
  return result.data;
}
var init_introspectionFromSchema = __esm({
  "../../../node_modules/graphql/utilities/introspectionFromSchema.mjs"() {
    init_invariant();
    init_parser();
    init_execute();
    init_getIntrospectionQuery();
  }
});

// ../../../node_modules/graphql/utilities/buildClientSchema.mjs
function buildClientSchema(introspection, options) {
  isObjectLike(introspection) && isObjectLike(introspection.__schema) || devAssert(
    false,
    `Invalid or incomplete introspection result. Ensure that you are passing "data" property of introspection response and no "errors" was returned alongside: ${inspect(
      introspection
    )}.`
  );
  const schemaIntrospection = introspection.__schema;
  const typeMap = keyValMap(
    schemaIntrospection.types,
    (typeIntrospection) => typeIntrospection.name,
    (typeIntrospection) => buildType(typeIntrospection)
  );
  for (const stdType of [...specifiedScalarTypes, ...introspectionTypes]) {
    if (typeMap[stdType.name]) {
      typeMap[stdType.name] = stdType;
    }
  }
  const queryType = schemaIntrospection.queryType ? getObjectType(schemaIntrospection.queryType) : null;
  const mutationType = schemaIntrospection.mutationType ? getObjectType(schemaIntrospection.mutationType) : null;
  const subscriptionType = schemaIntrospection.subscriptionType ? getObjectType(schemaIntrospection.subscriptionType) : null;
  const directives = schemaIntrospection.directives ? schemaIntrospection.directives.map(buildDirective) : [];
  return new GraphQLSchema({
    description: schemaIntrospection.description,
    query: queryType,
    mutation: mutationType,
    subscription: subscriptionType,
    types: Object.values(typeMap),
    directives,
    assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid
  });
  function getType(typeRef) {
    if (typeRef.kind === TypeKind.LIST) {
      const itemRef = typeRef.ofType;
      if (!itemRef) {
        throw new Error("Decorated type deeper than introspection query.");
      }
      return new GraphQLList(getType(itemRef));
    }
    if (typeRef.kind === TypeKind.NON_NULL) {
      const nullableRef = typeRef.ofType;
      if (!nullableRef) {
        throw new Error("Decorated type deeper than introspection query.");
      }
      const nullableType = getType(nullableRef);
      return new GraphQLNonNull(assertNullableType(nullableType));
    }
    return getNamedType2(typeRef);
  }
  function getNamedType2(typeRef) {
    const typeName = typeRef.name;
    if (!typeName) {
      throw new Error(`Unknown type reference: ${inspect(typeRef)}.`);
    }
    const type = typeMap[typeName];
    if (!type) {
      throw new Error(
        `Invalid or incomplete schema, unknown type: ${typeName}. Ensure that a full introspection query is used in order to build a client schema.`
      );
    }
    return type;
  }
  function getObjectType(typeRef) {
    return assertObjectType(getNamedType2(typeRef));
  }
  function getInterfaceType(typeRef) {
    return assertInterfaceType(getNamedType2(typeRef));
  }
  function buildType(type) {
    if (type != null && type.name != null && type.kind != null) {
      switch (type.kind) {
        case TypeKind.SCALAR:
          return buildScalarDef(type);
        case TypeKind.OBJECT:
          return buildObjectDef(type);
        case TypeKind.INTERFACE:
          return buildInterfaceDef(type);
        case TypeKind.UNION:
          return buildUnionDef(type);
        case TypeKind.ENUM:
          return buildEnumDef(type);
        case TypeKind.INPUT_OBJECT:
          return buildInputObjectDef(type);
      }
    }
    const typeStr = inspect(type);
    throw new Error(
      `Invalid or incomplete introspection result. Ensure that a full introspection query is used in order to build a client schema: ${typeStr}.`
    );
  }
  function buildScalarDef(scalarIntrospection) {
    return new GraphQLScalarType({
      name: scalarIntrospection.name,
      description: scalarIntrospection.description,
      specifiedByURL: scalarIntrospection.specifiedByURL
    });
  }
  function buildImplementationsList(implementingIntrospection) {
    if (implementingIntrospection.interfaces === null && implementingIntrospection.kind === TypeKind.INTERFACE) {
      return [];
    }
    if (!implementingIntrospection.interfaces) {
      const implementingIntrospectionStr = inspect(implementingIntrospection);
      throw new Error(
        `Introspection result missing interfaces: ${implementingIntrospectionStr}.`
      );
    }
    return implementingIntrospection.interfaces.map(getInterfaceType);
  }
  function buildObjectDef(objectIntrospection) {
    return new GraphQLObjectType({
      name: objectIntrospection.name,
      description: objectIntrospection.description,
      interfaces: () => buildImplementationsList(objectIntrospection),
      fields: () => buildFieldDefMap(objectIntrospection)
    });
  }
  function buildInterfaceDef(interfaceIntrospection) {
    return new GraphQLInterfaceType({
      name: interfaceIntrospection.name,
      description: interfaceIntrospection.description,
      interfaces: () => buildImplementationsList(interfaceIntrospection),
      fields: () => buildFieldDefMap(interfaceIntrospection)
    });
  }
  function buildUnionDef(unionIntrospection) {
    if (!unionIntrospection.possibleTypes) {
      const unionIntrospectionStr = inspect(unionIntrospection);
      throw new Error(
        `Introspection result missing possibleTypes: ${unionIntrospectionStr}.`
      );
    }
    return new GraphQLUnionType({
      name: unionIntrospection.name,
      description: unionIntrospection.description,
      types: () => unionIntrospection.possibleTypes.map(getObjectType)
    });
  }
  function buildEnumDef(enumIntrospection) {
    if (!enumIntrospection.enumValues) {
      const enumIntrospectionStr = inspect(enumIntrospection);
      throw new Error(
        `Introspection result missing enumValues: ${enumIntrospectionStr}.`
      );
    }
    return new GraphQLEnumType({
      name: enumIntrospection.name,
      description: enumIntrospection.description,
      values: keyValMap(
        enumIntrospection.enumValues,
        (valueIntrospection) => valueIntrospection.name,
        (valueIntrospection) => ({
          description: valueIntrospection.description,
          deprecationReason: valueIntrospection.deprecationReason
        })
      )
    });
  }
  function buildInputObjectDef(inputObjectIntrospection) {
    if (!inputObjectIntrospection.inputFields) {
      const inputObjectIntrospectionStr = inspect(inputObjectIntrospection);
      throw new Error(
        `Introspection result missing inputFields: ${inputObjectIntrospectionStr}.`
      );
    }
    return new GraphQLInputObjectType({
      name: inputObjectIntrospection.name,
      description: inputObjectIntrospection.description,
      fields: () => buildInputValueDefMap(inputObjectIntrospection.inputFields)
    });
  }
  function buildFieldDefMap(typeIntrospection) {
    if (!typeIntrospection.fields) {
      throw new Error(
        `Introspection result missing fields: ${inspect(typeIntrospection)}.`
      );
    }
    return keyValMap(
      typeIntrospection.fields,
      (fieldIntrospection) => fieldIntrospection.name,
      buildField
    );
  }
  function buildField(fieldIntrospection) {
    const type = getType(fieldIntrospection.type);
    if (!isOutputType(type)) {
      const typeStr = inspect(type);
      throw new Error(
        `Introspection must provide output type for fields, but received: ${typeStr}.`
      );
    }
    if (!fieldIntrospection.args) {
      const fieldIntrospectionStr = inspect(fieldIntrospection);
      throw new Error(
        `Introspection result missing field args: ${fieldIntrospectionStr}.`
      );
    }
    return {
      description: fieldIntrospection.description,
      deprecationReason: fieldIntrospection.deprecationReason,
      type,
      args: buildInputValueDefMap(fieldIntrospection.args)
    };
  }
  function buildInputValueDefMap(inputValueIntrospections) {
    return keyValMap(
      inputValueIntrospections,
      (inputValue) => inputValue.name,
      buildInputValue
    );
  }
  function buildInputValue(inputValueIntrospection) {
    const type = getType(inputValueIntrospection.type);
    if (!isInputType(type)) {
      const typeStr = inspect(type);
      throw new Error(
        `Introspection must provide input type for arguments, but received: ${typeStr}.`
      );
    }
    const defaultValue = inputValueIntrospection.defaultValue != null ? valueFromAST(parseValue(inputValueIntrospection.defaultValue), type) : void 0;
    return {
      description: inputValueIntrospection.description,
      type,
      defaultValue,
      deprecationReason: inputValueIntrospection.deprecationReason
    };
  }
  function buildDirective(directiveIntrospection) {
    if (!directiveIntrospection.args) {
      const directiveIntrospectionStr = inspect(directiveIntrospection);
      throw new Error(
        `Introspection result missing directive args: ${directiveIntrospectionStr}.`
      );
    }
    if (!directiveIntrospection.locations) {
      const directiveIntrospectionStr = inspect(directiveIntrospection);
      throw new Error(
        `Introspection result missing directive locations: ${directiveIntrospectionStr}.`
      );
    }
    return new GraphQLDirective({
      name: directiveIntrospection.name,
      description: directiveIntrospection.description,
      isRepeatable: directiveIntrospection.isRepeatable,
      locations: directiveIntrospection.locations.slice(),
      args: buildInputValueDefMap(directiveIntrospection.args)
    });
  }
}
var init_buildClientSchema = __esm({
  "../../../node_modules/graphql/utilities/buildClientSchema.mjs"() {
    init_devAssert();
    init_inspect();
    init_isObjectLike();
    init_keyValMap();
    init_parser();
    init_definition();
    init_directives();
    init_introspection();
    init_scalars();
    init_schema();
    init_valueFromAST();
  }
});

// ../../../node_modules/graphql/utilities/extendSchema.mjs
function extendSchema(schema, documentAST, options) {
  assertSchema(schema);
  documentAST != null && documentAST.kind === Kind.DOCUMENT || devAssert(false, "Must provide valid Document AST.");
  if ((options === null || options === void 0 ? void 0 : options.assumeValid) !== true && (options === null || options === void 0 ? void 0 : options.assumeValidSDL) !== true) {
    assertValidSDLExtension(documentAST, schema);
  }
  const schemaConfig = schema.toConfig();
  const extendedConfig = extendSchemaImpl(schemaConfig, documentAST, options);
  return schemaConfig === extendedConfig ? schema : new GraphQLSchema(extendedConfig);
}
function extendSchemaImpl(schemaConfig, documentAST, options) {
  var _schemaDef, _schemaDef$descriptio, _schemaDef2, _options$assumeValid;
  const typeDefs = [];
  const typeExtensionsMap = /* @__PURE__ */ Object.create(null);
  const directiveDefs = [];
  let schemaDef;
  const schemaExtensions = [];
  for (const def of documentAST.definitions) {
    if (def.kind === Kind.SCHEMA_DEFINITION) {
      schemaDef = def;
    } else if (def.kind === Kind.SCHEMA_EXTENSION) {
      schemaExtensions.push(def);
    } else if (isTypeDefinitionNode(def)) {
      typeDefs.push(def);
    } else if (isTypeExtensionNode(def)) {
      const extendedTypeName = def.name.value;
      const existingTypeExtensions = typeExtensionsMap[extendedTypeName];
      typeExtensionsMap[extendedTypeName] = existingTypeExtensions ? existingTypeExtensions.concat([def]) : [def];
    } else if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      directiveDefs.push(def);
    }
  }
  if (Object.keys(typeExtensionsMap).length === 0 && typeDefs.length === 0 && directiveDefs.length === 0 && schemaExtensions.length === 0 && schemaDef == null) {
    return schemaConfig;
  }
  const typeMap = /* @__PURE__ */ Object.create(null);
  for (const existingType of schemaConfig.types) {
    typeMap[existingType.name] = extendNamedType(existingType);
  }
  for (const typeNode of typeDefs) {
    var _stdTypeMap$name;
    const name = typeNode.name.value;
    typeMap[name] = (_stdTypeMap$name = stdTypeMap[name]) !== null && _stdTypeMap$name !== void 0 ? _stdTypeMap$name : buildType(typeNode);
  }
  const operationTypes = {
    // Get the extended root operation types.
    query: schemaConfig.query && replaceNamedType(schemaConfig.query),
    mutation: schemaConfig.mutation && replaceNamedType(schemaConfig.mutation),
    subscription: schemaConfig.subscription && replaceNamedType(schemaConfig.subscription),
    // Then, incorporate schema definition and all schema extensions.
    ...schemaDef && getOperationTypes([schemaDef]),
    ...getOperationTypes(schemaExtensions)
  };
  return {
    description: (_schemaDef = schemaDef) === null || _schemaDef === void 0 ? void 0 : (_schemaDef$descriptio = _schemaDef.description) === null || _schemaDef$descriptio === void 0 ? void 0 : _schemaDef$descriptio.value,
    ...operationTypes,
    types: Object.values(typeMap),
    directives: [
      ...schemaConfig.directives.map(replaceDirective),
      ...directiveDefs.map(buildDirective)
    ],
    extensions: /* @__PURE__ */ Object.create(null),
    astNode: (_schemaDef2 = schemaDef) !== null && _schemaDef2 !== void 0 ? _schemaDef2 : schemaConfig.astNode,
    extensionASTNodes: schemaConfig.extensionASTNodes.concat(schemaExtensions),
    assumeValid: (_options$assumeValid = options === null || options === void 0 ? void 0 : options.assumeValid) !== null && _options$assumeValid !== void 0 ? _options$assumeValid : false
  };
  function replaceType(type) {
    if (isListType(type)) {
      return new GraphQLList(replaceType(type.ofType));
    }
    if (isNonNullType(type)) {
      return new GraphQLNonNull(replaceType(type.ofType));
    }
    return replaceNamedType(type);
  }
  function replaceNamedType(type) {
    return typeMap[type.name];
  }
  function replaceDirective(directive) {
    const config = directive.toConfig();
    return new GraphQLDirective({
      ...config,
      args: mapValue(config.args, extendArg)
    });
  }
  function extendNamedType(type) {
    if (isIntrospectionType(type) || isSpecifiedScalarType(type)) {
      return type;
    }
    if (isScalarType(type)) {
      return extendScalarType(type);
    }
    if (isObjectType(type)) {
      return extendObjectType(type);
    }
    if (isInterfaceType(type)) {
      return extendInterfaceType(type);
    }
    if (isUnionType(type)) {
      return extendUnionType(type);
    }
    if (isEnumType(type)) {
      return extendEnumType(type);
    }
    if (isInputObjectType(type)) {
      return extendInputObjectType(type);
    }
    invariant(false, "Unexpected type: " + inspect(type));
  }
  function extendInputObjectType(type) {
    var _typeExtensionsMap$co;
    const config = type.toConfig();
    const extensions = (_typeExtensionsMap$co = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co !== void 0 ? _typeExtensionsMap$co : [];
    return new GraphQLInputObjectType({
      ...config,
      fields: () => ({
        ...mapValue(config.fields, (field) => ({
          ...field,
          type: replaceType(field.type)
        })),
        ...buildInputFieldMap(extensions)
      }),
      extensionASTNodes: config.extensionASTNodes.concat(extensions)
    });
  }
  function extendEnumType(type) {
    var _typeExtensionsMap$ty;
    const config = type.toConfig();
    const extensions = (_typeExtensionsMap$ty = typeExtensionsMap[type.name]) !== null && _typeExtensionsMap$ty !== void 0 ? _typeExtensionsMap$ty : [];
    return new GraphQLEnumType({
      ...config,
      values: { ...config.values, ...buildEnumValueMap(extensions) },
      extensionASTNodes: config.extensionASTNodes.concat(extensions)
    });
  }
  function extendScalarType(type) {
    var _typeExtensionsMap$co2;
    const config = type.toConfig();
    const extensions = (_typeExtensionsMap$co2 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co2 !== void 0 ? _typeExtensionsMap$co2 : [];
    let specifiedByURL = config.specifiedByURL;
    for (const extensionNode of extensions) {
      var _getSpecifiedByURL;
      specifiedByURL = (_getSpecifiedByURL = getSpecifiedByURL(extensionNode)) !== null && _getSpecifiedByURL !== void 0 ? _getSpecifiedByURL : specifiedByURL;
    }
    return new GraphQLScalarType({
      ...config,
      specifiedByURL,
      extensionASTNodes: config.extensionASTNodes.concat(extensions)
    });
  }
  function extendObjectType(type) {
    var _typeExtensionsMap$co3;
    const config = type.toConfig();
    const extensions = (_typeExtensionsMap$co3 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co3 !== void 0 ? _typeExtensionsMap$co3 : [];
    return new GraphQLObjectType({
      ...config,
      interfaces: () => [
        ...type.getInterfaces().map(replaceNamedType),
        ...buildInterfaces(extensions)
      ],
      fields: () => ({
        ...mapValue(config.fields, extendField),
        ...buildFieldMap(extensions)
      }),
      extensionASTNodes: config.extensionASTNodes.concat(extensions)
    });
  }
  function extendInterfaceType(type) {
    var _typeExtensionsMap$co4;
    const config = type.toConfig();
    const extensions = (_typeExtensionsMap$co4 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co4 !== void 0 ? _typeExtensionsMap$co4 : [];
    return new GraphQLInterfaceType({
      ...config,
      interfaces: () => [
        ...type.getInterfaces().map(replaceNamedType),
        ...buildInterfaces(extensions)
      ],
      fields: () => ({
        ...mapValue(config.fields, extendField),
        ...buildFieldMap(extensions)
      }),
      extensionASTNodes: config.extensionASTNodes.concat(extensions)
    });
  }
  function extendUnionType(type) {
    var _typeExtensionsMap$co5;
    const config = type.toConfig();
    const extensions = (_typeExtensionsMap$co5 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co5 !== void 0 ? _typeExtensionsMap$co5 : [];
    return new GraphQLUnionType({
      ...config,
      types: () => [
        ...type.getTypes().map(replaceNamedType),
        ...buildUnionTypes(extensions)
      ],
      extensionASTNodes: config.extensionASTNodes.concat(extensions)
    });
  }
  function extendField(field) {
    return {
      ...field,
      type: replaceType(field.type),
      args: field.args && mapValue(field.args, extendArg)
    };
  }
  function extendArg(arg) {
    return { ...arg, type: replaceType(arg.type) };
  }
  function getOperationTypes(nodes) {
    const opTypes = {};
    for (const node of nodes) {
      var _node$operationTypes;
      const operationTypesNodes = (
        /* c8 ignore next */
        (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : []
      );
      for (const operationType of operationTypesNodes) {
        opTypes[operationType.operation] = getNamedType2(operationType.type);
      }
    }
    return opTypes;
  }
  function getNamedType2(node) {
    var _stdTypeMap$name2;
    const name = node.name.value;
    const type = (_stdTypeMap$name2 = stdTypeMap[name]) !== null && _stdTypeMap$name2 !== void 0 ? _stdTypeMap$name2 : typeMap[name];
    if (type === void 0) {
      throw new Error(`Unknown type: "${name}".`);
    }
    return type;
  }
  function getWrappedType(node) {
    if (node.kind === Kind.LIST_TYPE) {
      return new GraphQLList(getWrappedType(node.type));
    }
    if (node.kind === Kind.NON_NULL_TYPE) {
      return new GraphQLNonNull(getWrappedType(node.type));
    }
    return getNamedType2(node);
  }
  function buildDirective(node) {
    var _node$description;
    return new GraphQLDirective({
      name: node.name.value,
      description: (_node$description = node.description) === null || _node$description === void 0 ? void 0 : _node$description.value,
      // @ts-expect-error
      locations: node.locations.map(({ value }) => value),
      isRepeatable: node.repeatable,
      args: buildArgumentMap(node.arguments),
      astNode: node
    });
  }
  function buildFieldMap(nodes) {
    const fieldConfigMap = /* @__PURE__ */ Object.create(null);
    for (const node of nodes) {
      var _node$fields;
      const nodeFields = (
        /* c8 ignore next */
        (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : []
      );
      for (const field of nodeFields) {
        var _field$description;
        fieldConfigMap[field.name.value] = {
          // Note: While this could make assertions to get the correctly typed
          // value, that would throw immediately while type system validation
          // with validateSchema() will produce more actionable results.
          type: getWrappedType(field.type),
          description: (_field$description = field.description) === null || _field$description === void 0 ? void 0 : _field$description.value,
          args: buildArgumentMap(field.arguments),
          deprecationReason: getDeprecationReason(field),
          astNode: field
        };
      }
    }
    return fieldConfigMap;
  }
  function buildArgumentMap(args) {
    const argsNodes = (
      /* c8 ignore next */
      args !== null && args !== void 0 ? args : []
    );
    const argConfigMap = /* @__PURE__ */ Object.create(null);
    for (const arg of argsNodes) {
      var _arg$description;
      const type = getWrappedType(arg.type);
      argConfigMap[arg.name.value] = {
        type,
        description: (_arg$description = arg.description) === null || _arg$description === void 0 ? void 0 : _arg$description.value,
        defaultValue: valueFromAST(arg.defaultValue, type),
        deprecationReason: getDeprecationReason(arg),
        astNode: arg
      };
    }
    return argConfigMap;
  }
  function buildInputFieldMap(nodes) {
    const inputFieldMap = /* @__PURE__ */ Object.create(null);
    for (const node of nodes) {
      var _node$fields2;
      const fieldsNodes = (
        /* c8 ignore next */
        (_node$fields2 = node.fields) !== null && _node$fields2 !== void 0 ? _node$fields2 : []
      );
      for (const field of fieldsNodes) {
        var _field$description2;
        const type = getWrappedType(field.type);
        inputFieldMap[field.name.value] = {
          type,
          description: (_field$description2 = field.description) === null || _field$description2 === void 0 ? void 0 : _field$description2.value,
          defaultValue: valueFromAST(field.defaultValue, type),
          deprecationReason: getDeprecationReason(field),
          astNode: field
        };
      }
    }
    return inputFieldMap;
  }
  function buildEnumValueMap(nodes) {
    const enumValueMap = /* @__PURE__ */ Object.create(null);
    for (const node of nodes) {
      var _node$values;
      const valuesNodes = (
        /* c8 ignore next */
        (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : []
      );
      for (const value of valuesNodes) {
        var _value$description;
        enumValueMap[value.name.value] = {
          description: (_value$description = value.description) === null || _value$description === void 0 ? void 0 : _value$description.value,
          deprecationReason: getDeprecationReason(value),
          astNode: value
        };
      }
    }
    return enumValueMap;
  }
  function buildInterfaces(nodes) {
    return nodes.flatMap(
      // FIXME: https://github.com/graphql/graphql-js/issues/2203
      (node) => {
        var _node$interfaces$map, _node$interfaces;
        return (
          /* c8 ignore next */
          (_node$interfaces$map = (_node$interfaces = node.interfaces) === null || _node$interfaces === void 0 ? void 0 : _node$interfaces.map(getNamedType2)) !== null && _node$interfaces$map !== void 0 ? _node$interfaces$map : []
        );
      }
    );
  }
  function buildUnionTypes(nodes) {
    return nodes.flatMap(
      // FIXME: https://github.com/graphql/graphql-js/issues/2203
      (node) => {
        var _node$types$map, _node$types;
        return (
          /* c8 ignore next */
          (_node$types$map = (_node$types = node.types) === null || _node$types === void 0 ? void 0 : _node$types.map(getNamedType2)) !== null && _node$types$map !== void 0 ? _node$types$map : []
        );
      }
    );
  }
  function buildType(astNode) {
    var _typeExtensionsMap$na;
    const name = astNode.name.value;
    const extensionASTNodes = (_typeExtensionsMap$na = typeExtensionsMap[name]) !== null && _typeExtensionsMap$na !== void 0 ? _typeExtensionsMap$na : [];
    switch (astNode.kind) {
      case Kind.OBJECT_TYPE_DEFINITION: {
        var _astNode$description;
        const allNodes = [astNode, ...extensionASTNodes];
        return new GraphQLObjectType({
          name,
          description: (_astNode$description = astNode.description) === null || _astNode$description === void 0 ? void 0 : _astNode$description.value,
          interfaces: () => buildInterfaces(allNodes),
          fields: () => buildFieldMap(allNodes),
          astNode,
          extensionASTNodes
        });
      }
      case Kind.INTERFACE_TYPE_DEFINITION: {
        var _astNode$description2;
        const allNodes = [astNode, ...extensionASTNodes];
        return new GraphQLInterfaceType({
          name,
          description: (_astNode$description2 = astNode.description) === null || _astNode$description2 === void 0 ? void 0 : _astNode$description2.value,
          interfaces: () => buildInterfaces(allNodes),
          fields: () => buildFieldMap(allNodes),
          astNode,
          extensionASTNodes
        });
      }
      case Kind.ENUM_TYPE_DEFINITION: {
        var _astNode$description3;
        const allNodes = [astNode, ...extensionASTNodes];
        return new GraphQLEnumType({
          name,
          description: (_astNode$description3 = astNode.description) === null || _astNode$description3 === void 0 ? void 0 : _astNode$description3.value,
          values: buildEnumValueMap(allNodes),
          astNode,
          extensionASTNodes
        });
      }
      case Kind.UNION_TYPE_DEFINITION: {
        var _astNode$description4;
        const allNodes = [astNode, ...extensionASTNodes];
        return new GraphQLUnionType({
          name,
          description: (_astNode$description4 = astNode.description) === null || _astNode$description4 === void 0 ? void 0 : _astNode$description4.value,
          types: () => buildUnionTypes(allNodes),
          astNode,
          extensionASTNodes
        });
      }
      case Kind.SCALAR_TYPE_DEFINITION: {
        var _astNode$description5;
        return new GraphQLScalarType({
          name,
          description: (_astNode$description5 = astNode.description) === null || _astNode$description5 === void 0 ? void 0 : _astNode$description5.value,
          specifiedByURL: getSpecifiedByURL(astNode),
          astNode,
          extensionASTNodes
        });
      }
      case Kind.INPUT_OBJECT_TYPE_DEFINITION: {
        var _astNode$description6;
        const allNodes = [astNode, ...extensionASTNodes];
        return new GraphQLInputObjectType({
          name,
          description: (_astNode$description6 = astNode.description) === null || _astNode$description6 === void 0 ? void 0 : _astNode$description6.value,
          fields: () => buildInputFieldMap(allNodes),
          astNode,
          extensionASTNodes
        });
      }
    }
  }
}
function getDeprecationReason(node) {
  const deprecated = getDirectiveValues(GraphQLDeprecatedDirective, node);
  return deprecated === null || deprecated === void 0 ? void 0 : deprecated.reason;
}
function getSpecifiedByURL(node) {
  const specifiedBy = getDirectiveValues(GraphQLSpecifiedByDirective, node);
  return specifiedBy === null || specifiedBy === void 0 ? void 0 : specifiedBy.url;
}
var stdTypeMap;
var init_extendSchema = __esm({
  "../../../node_modules/graphql/utilities/extendSchema.mjs"() {
    init_devAssert();
    init_inspect();
    init_invariant();
    init_keyMap();
    init_mapValue();
    init_kinds();
    init_predicates();
    init_definition();
    init_directives();
    init_introspection();
    init_scalars();
    init_schema();
    init_validate2();
    init_values();
    init_valueFromAST();
    stdTypeMap = keyMap(
      [...specifiedScalarTypes, ...introspectionTypes],
      (type) => type.name
    );
  }
});

// ../../../node_modules/graphql/utilities/buildASTSchema.mjs
function buildASTSchema(documentAST, options) {
  documentAST != null && documentAST.kind === Kind.DOCUMENT || devAssert(false, "Must provide valid Document AST.");
  if ((options === null || options === void 0 ? void 0 : options.assumeValid) !== true && (options === null || options === void 0 ? void 0 : options.assumeValidSDL) !== true) {
    assertValidSDL(documentAST);
  }
  const emptySchemaConfig = {
    description: void 0,
    types: [],
    directives: [],
    extensions: /* @__PURE__ */ Object.create(null),
    extensionASTNodes: [],
    assumeValid: false
  };
  const config = extendSchemaImpl(emptySchemaConfig, documentAST, options);
  if (config.astNode == null) {
    for (const type of config.types) {
      switch (type.name) {
        case "Query":
          config.query = type;
          break;
        case "Mutation":
          config.mutation = type;
          break;
        case "Subscription":
          config.subscription = type;
          break;
      }
    }
  }
  const directives = [
    ...config.directives,
    // If specified directives were not explicitly declared, add them.
    ...specifiedDirectives.filter(
      (stdDirective) => config.directives.every(
        (directive) => directive.name !== stdDirective.name
      )
    )
  ];
  return new GraphQLSchema({ ...config, directives });
}
function buildSchema(source, options) {
  const document2 = parse(source, {
    noLocation: options === null || options === void 0 ? void 0 : options.noLocation,
    allowLegacyFragmentVariables: options === null || options === void 0 ? void 0 : options.allowLegacyFragmentVariables
  });
  return buildASTSchema(document2, {
    assumeValidSDL: options === null || options === void 0 ? void 0 : options.assumeValidSDL,
    assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid
  });
}
var init_buildASTSchema = __esm({
  "../../../node_modules/graphql/utilities/buildASTSchema.mjs"() {
    init_devAssert();
    init_kinds();
    init_parser();
    init_directives();
    init_schema();
    init_validate2();
    init_extendSchema();
  }
});

// ../../../node_modules/graphql/utilities/lexicographicSortSchema.mjs
function lexicographicSortSchema(schema) {
  const schemaConfig = schema.toConfig();
  const typeMap = keyValMap(
    sortByName(schemaConfig.types),
    (type) => type.name,
    sortNamedType
  );
  return new GraphQLSchema({
    ...schemaConfig,
    types: Object.values(typeMap),
    directives: sortByName(schemaConfig.directives).map(sortDirective),
    query: replaceMaybeType(schemaConfig.query),
    mutation: replaceMaybeType(schemaConfig.mutation),
    subscription: replaceMaybeType(schemaConfig.subscription)
  });
  function replaceType(type) {
    if (isListType(type)) {
      return new GraphQLList(replaceType(type.ofType));
    } else if (isNonNullType(type)) {
      return new GraphQLNonNull(replaceType(type.ofType));
    }
    return replaceNamedType(type);
  }
  function replaceNamedType(type) {
    return typeMap[type.name];
  }
  function replaceMaybeType(maybeType) {
    return maybeType && replaceNamedType(maybeType);
  }
  function sortDirective(directive) {
    const config = directive.toConfig();
    return new GraphQLDirective({
      ...config,
      locations: sortBy(config.locations, (x) => x),
      args: sortArgs(config.args)
    });
  }
  function sortArgs(args) {
    return sortObjMap(args, (arg) => ({ ...arg, type: replaceType(arg.type) }));
  }
  function sortFields2(fieldsMap) {
    return sortObjMap(fieldsMap, (field) => ({
      ...field,
      type: replaceType(field.type),
      args: field.args && sortArgs(field.args)
    }));
  }
  function sortInputFields(fieldsMap) {
    return sortObjMap(fieldsMap, (field) => ({
      ...field,
      type: replaceType(field.type)
    }));
  }
  function sortTypes(array) {
    return sortByName(array).map(replaceNamedType);
  }
  function sortNamedType(type) {
    if (isScalarType(type) || isIntrospectionType(type)) {
      return type;
    }
    if (isObjectType(type)) {
      const config = type.toConfig();
      return new GraphQLObjectType({
        ...config,
        interfaces: () => sortTypes(config.interfaces),
        fields: () => sortFields2(config.fields)
      });
    }
    if (isInterfaceType(type)) {
      const config = type.toConfig();
      return new GraphQLInterfaceType({
        ...config,
        interfaces: () => sortTypes(config.interfaces),
        fields: () => sortFields2(config.fields)
      });
    }
    if (isUnionType(type)) {
      const config = type.toConfig();
      return new GraphQLUnionType({
        ...config,
        types: () => sortTypes(config.types)
      });
    }
    if (isEnumType(type)) {
      const config = type.toConfig();
      return new GraphQLEnumType({
        ...config,
        values: sortObjMap(config.values, (value) => value)
      });
    }
    if (isInputObjectType(type)) {
      const config = type.toConfig();
      return new GraphQLInputObjectType({
        ...config,
        fields: () => sortInputFields(config.fields)
      });
    }
    invariant(false, "Unexpected type: " + inspect(type));
  }
}
function sortObjMap(map, sortValueFn) {
  const sortedMap = /* @__PURE__ */ Object.create(null);
  for (const key of Object.keys(map).sort(naturalCompare)) {
    sortedMap[key] = sortValueFn(map[key]);
  }
  return sortedMap;
}
function sortByName(array) {
  return sortBy(array, (obj) => obj.name);
}
function sortBy(array, mapToKey) {
  return array.slice().sort((obj1, obj2) => {
    const key1 = mapToKey(obj1);
    const key2 = mapToKey(obj2);
    return naturalCompare(key1, key2);
  });
}
var init_lexicographicSortSchema = __esm({
  "../../../node_modules/graphql/utilities/lexicographicSortSchema.mjs"() {
    init_inspect();
    init_invariant();
    init_keyValMap();
    init_naturalCompare();
    init_definition();
    init_directives();
    init_introspection();
    init_schema();
  }
});

// ../../../node_modules/graphql/utilities/printSchema.mjs
function printSchema(schema) {
  return printFilteredSchema(
    schema,
    (n) => !isSpecifiedDirective(n),
    isDefinedType
  );
}
function printIntrospectionSchema(schema) {
  return printFilteredSchema(schema, isSpecifiedDirective, isIntrospectionType);
}
function isDefinedType(type) {
  return !isSpecifiedScalarType(type) && !isIntrospectionType(type);
}
function printFilteredSchema(schema, directiveFilter, typeFilter) {
  const directives = schema.getDirectives().filter(directiveFilter);
  const types = Object.values(schema.getTypeMap()).filter(typeFilter);
  return [
    printSchemaDefinition(schema),
    ...directives.map((directive) => printDirective(directive)),
    ...types.map((type) => printType(type))
  ].filter(Boolean).join("\n\n");
}
function printSchemaDefinition(schema) {
  if (schema.description == null && isSchemaOfCommonNames(schema)) {
    return;
  }
  const operationTypes = [];
  const queryType = schema.getQueryType();
  if (queryType) {
    operationTypes.push(`  query: ${queryType.name}`);
  }
  const mutationType = schema.getMutationType();
  if (mutationType) {
    operationTypes.push(`  mutation: ${mutationType.name}`);
  }
  const subscriptionType = schema.getSubscriptionType();
  if (subscriptionType) {
    operationTypes.push(`  subscription: ${subscriptionType.name}`);
  }
  return printDescription(schema) + `schema {
${operationTypes.join("\n")}
}`;
}
function isSchemaOfCommonNames(schema) {
  const queryType = schema.getQueryType();
  if (queryType && queryType.name !== "Query") {
    return false;
  }
  const mutationType = schema.getMutationType();
  if (mutationType && mutationType.name !== "Mutation") {
    return false;
  }
  const subscriptionType = schema.getSubscriptionType();
  if (subscriptionType && subscriptionType.name !== "Subscription") {
    return false;
  }
  return true;
}
function printType(type) {
  if (isScalarType(type)) {
    return printScalar(type);
  }
  if (isObjectType(type)) {
    return printObject(type);
  }
  if (isInterfaceType(type)) {
    return printInterface(type);
  }
  if (isUnionType(type)) {
    return printUnion(type);
  }
  if (isEnumType(type)) {
    return printEnum(type);
  }
  if (isInputObjectType(type)) {
    return printInputObject(type);
  }
  invariant(false, "Unexpected type: " + inspect(type));
}
function printScalar(type) {
  return printDescription(type) + `scalar ${type.name}` + printSpecifiedByURL(type);
}
function printImplementedInterfaces(type) {
  const interfaces = type.getInterfaces();
  return interfaces.length ? " implements " + interfaces.map((i) => i.name).join(" & ") : "";
}
function printObject(type) {
  return printDescription(type) + `type ${type.name}` + printImplementedInterfaces(type) + printFields(type);
}
function printInterface(type) {
  return printDescription(type) + `interface ${type.name}` + printImplementedInterfaces(type) + printFields(type);
}
function printUnion(type) {
  const types = type.getTypes();
  const possibleTypes = types.length ? " = " + types.join(" | ") : "";
  return printDescription(type) + "union " + type.name + possibleTypes;
}
function printEnum(type) {
  const values = type.getValues().map(
    (value, i) => printDescription(value, "  ", !i) + "  " + value.name + printDeprecated(value.deprecationReason)
  );
  return printDescription(type) + `enum ${type.name}` + printBlock(values);
}
function printInputObject(type) {
  const fields = Object.values(type.getFields()).map(
    (f, i) => printDescription(f, "  ", !i) + "  " + printInputValue(f)
  );
  return printDescription(type) + `input ${type.name}` + printBlock(fields);
}
function printFields(type) {
  const fields = Object.values(type.getFields()).map(
    (f, i) => printDescription(f, "  ", !i) + "  " + f.name + printArgs(f.args, "  ") + ": " + String(f.type) + printDeprecated(f.deprecationReason)
  );
  return printBlock(fields);
}
function printBlock(items) {
  return items.length !== 0 ? " {\n" + items.join("\n") + "\n}" : "";
}
function printArgs(args, indentation = "") {
  if (args.length === 0) {
    return "";
  }
  if (args.every((arg) => !arg.description)) {
    return "(" + args.map(printInputValue).join(", ") + ")";
  }
  return "(\n" + args.map(
    (arg, i) => printDescription(arg, "  " + indentation, !i) + "  " + indentation + printInputValue(arg)
  ).join("\n") + "\n" + indentation + ")";
}
function printInputValue(arg) {
  const defaultAST = astFromValue(arg.defaultValue, arg.type);
  let argDecl = arg.name + ": " + String(arg.type);
  if (defaultAST) {
    argDecl += ` = ${print(defaultAST)}`;
  }
  return argDecl + printDeprecated(arg.deprecationReason);
}
function printDirective(directive) {
  return printDescription(directive) + "directive @" + directive.name + printArgs(directive.args) + (directive.isRepeatable ? " repeatable" : "") + " on " + directive.locations.join(" | ");
}
function printDeprecated(reason) {
  if (reason == null) {
    return "";
  }
  if (reason !== DEFAULT_DEPRECATION_REASON) {
    const astValue = print({
      kind: Kind.STRING,
      value: reason
    });
    return ` @deprecated(reason: ${astValue})`;
  }
  return " @deprecated";
}
function printSpecifiedByURL(scalar) {
  if (scalar.specifiedByURL == null) {
    return "";
  }
  const astValue = print({
    kind: Kind.STRING,
    value: scalar.specifiedByURL
  });
  return ` @specifiedBy(url: ${astValue})`;
}
function printDescription(def, indentation = "", firstInBlock = true) {
  const { description } = def;
  if (description == null) {
    return "";
  }
  const blockString = print({
    kind: Kind.STRING,
    value: description,
    block: isPrintableAsBlockString(description)
  });
  const prefix = indentation && !firstInBlock ? "\n" + indentation : indentation;
  return prefix + blockString.replace(/\n/g, "\n" + indentation) + "\n";
}
var init_printSchema = __esm({
  "../../../node_modules/graphql/utilities/printSchema.mjs"() {
    init_inspect();
    init_invariant();
    init_blockString();
    init_kinds();
    init_printer();
    init_definition();
    init_directives();
    init_introspection();
    init_scalars();
    init_astFromValue();
  }
});

// ../../../node_modules/graphql/utilities/concatAST.mjs
function concatAST(documents) {
  const definitions = [];
  for (const doc of documents) {
    definitions.push(...doc.definitions);
  }
  return {
    kind: Kind.DOCUMENT,
    definitions
  };
}
var init_concatAST = __esm({
  "../../../node_modules/graphql/utilities/concatAST.mjs"() {
    init_kinds();
  }
});

// ../../../node_modules/graphql/utilities/separateOperations.mjs
function separateOperations(documentAST) {
  const operations = [];
  const depGraph = /* @__PURE__ */ Object.create(null);
  for (const definitionNode of documentAST.definitions) {
    switch (definitionNode.kind) {
      case Kind.OPERATION_DEFINITION:
        operations.push(definitionNode);
        break;
      case Kind.FRAGMENT_DEFINITION:
        depGraph[definitionNode.name.value] = collectDependencies(
          definitionNode.selectionSet
        );
        break;
      default:
    }
  }
  const separatedDocumentASTs = /* @__PURE__ */ Object.create(null);
  for (const operation of operations) {
    const dependencies = /* @__PURE__ */ new Set();
    for (const fragmentName of collectDependencies(operation.selectionSet)) {
      collectTransitiveDependencies(dependencies, depGraph, fragmentName);
    }
    const operationName = operation.name ? operation.name.value : "";
    separatedDocumentASTs[operationName] = {
      kind: Kind.DOCUMENT,
      definitions: documentAST.definitions.filter(
        (node) => node === operation || node.kind === Kind.FRAGMENT_DEFINITION && dependencies.has(node.name.value)
      )
    };
  }
  return separatedDocumentASTs;
}
function collectTransitiveDependencies(collected, depGraph, fromName) {
  if (!collected.has(fromName)) {
    collected.add(fromName);
    const immediateDeps = depGraph[fromName];
    if (immediateDeps !== void 0) {
      for (const toName of immediateDeps) {
        collectTransitiveDependencies(collected, depGraph, toName);
      }
    }
  }
}
function collectDependencies(selectionSet) {
  const dependencies = [];
  visit(selectionSet, {
    FragmentSpread(node) {
      dependencies.push(node.name.value);
    }
  });
  return dependencies;
}
var init_separateOperations = __esm({
  "../../../node_modules/graphql/utilities/separateOperations.mjs"() {
    init_kinds();
    init_visitor();
  }
});

// ../../../node_modules/graphql/utilities/stripIgnoredCharacters.mjs
function stripIgnoredCharacters(source) {
  const sourceObj = isSource(source) ? source : new Source(source);
  const body = sourceObj.body;
  const lexer = new Lexer(sourceObj);
  let strippedBody = "";
  let wasLastAddedTokenNonPunctuator = false;
  while (lexer.advance().kind !== TokenKind.EOF) {
    const currentToken = lexer.token;
    const tokenKind = currentToken.kind;
    const isNonPunctuator = !isPunctuatorTokenKind(currentToken.kind);
    if (wasLastAddedTokenNonPunctuator) {
      if (isNonPunctuator || currentToken.kind === TokenKind.SPREAD) {
        strippedBody += " ";
      }
    }
    const tokenBody = body.slice(currentToken.start, currentToken.end);
    if (tokenKind === TokenKind.BLOCK_STRING) {
      strippedBody += printBlockString(currentToken.value, {
        minimize: true
      });
    } else {
      strippedBody += tokenBody;
    }
    wasLastAddedTokenNonPunctuator = isNonPunctuator;
  }
  return strippedBody;
}
var init_stripIgnoredCharacters = __esm({
  "../../../node_modules/graphql/utilities/stripIgnoredCharacters.mjs"() {
    init_blockString();
    init_lexer();
    init_source();
    init_tokenKind();
  }
});

// ../../../node_modules/graphql/utilities/assertValidName.mjs
function assertValidName(name) {
  const error = isValidNameError(name);
  if (error) {
    throw error;
  }
  return name;
}
function isValidNameError(name) {
  typeof name === "string" || devAssert(false, "Expected name to be a string.");
  if (name.startsWith("__")) {
    return new GraphQLError(
      `Name "${name}" must not begin with "__", which is reserved by GraphQL introspection.`
    );
  }
  try {
    assertName(name);
  } catch (error) {
    return error;
  }
}
var init_assertValidName = __esm({
  "../../../node_modules/graphql/utilities/assertValidName.mjs"() {
    init_devAssert();
    init_GraphQLError();
    init_assertName();
  }
});

// ../../../node_modules/graphql/utilities/findBreakingChanges.mjs
function findBreakingChanges(oldSchema, newSchema) {
  return findSchemaChanges(oldSchema, newSchema).filter(
    (change) => change.type in BreakingChangeType
  );
}
function findDangerousChanges(oldSchema, newSchema) {
  return findSchemaChanges(oldSchema, newSchema).filter(
    (change) => change.type in DangerousChangeType
  );
}
function findSchemaChanges(oldSchema, newSchema) {
  return [
    ...findTypeChanges(oldSchema, newSchema),
    ...findDirectiveChanges(oldSchema, newSchema)
  ];
}
function findDirectiveChanges(oldSchema, newSchema) {
  const schemaChanges = [];
  const directivesDiff = diff(
    oldSchema.getDirectives(),
    newSchema.getDirectives()
  );
  for (const oldDirective of directivesDiff.removed) {
    schemaChanges.push({
      type: BreakingChangeType.DIRECTIVE_REMOVED,
      description: `${oldDirective.name} was removed.`
    });
  }
  for (const [oldDirective, newDirective] of directivesDiff.persisted) {
    const argsDiff = diff(oldDirective.args, newDirective.args);
    for (const newArg of argsDiff.added) {
      if (isRequiredArgument(newArg)) {
        schemaChanges.push({
          type: BreakingChangeType.REQUIRED_DIRECTIVE_ARG_ADDED,
          description: `A required arg ${newArg.name} on directive ${oldDirective.name} was added.`
        });
      }
    }
    for (const oldArg of argsDiff.removed) {
      schemaChanges.push({
        type: BreakingChangeType.DIRECTIVE_ARG_REMOVED,
        description: `${oldArg.name} was removed from ${oldDirective.name}.`
      });
    }
    if (oldDirective.isRepeatable && !newDirective.isRepeatable) {
      schemaChanges.push({
        type: BreakingChangeType.DIRECTIVE_REPEATABLE_REMOVED,
        description: `Repeatable flag was removed from ${oldDirective.name}.`
      });
    }
    for (const location of oldDirective.locations) {
      if (!newDirective.locations.includes(location)) {
        schemaChanges.push({
          type: BreakingChangeType.DIRECTIVE_LOCATION_REMOVED,
          description: `${location} was removed from ${oldDirective.name}.`
        });
      }
    }
  }
  return schemaChanges;
}
function findTypeChanges(oldSchema, newSchema) {
  const schemaChanges = [];
  const typesDiff = diff(
    Object.values(oldSchema.getTypeMap()),
    Object.values(newSchema.getTypeMap())
  );
  for (const oldType of typesDiff.removed) {
    schemaChanges.push({
      type: BreakingChangeType.TYPE_REMOVED,
      description: isSpecifiedScalarType(oldType) ? `Standard scalar ${oldType.name} was removed because it is not referenced anymore.` : `${oldType.name} was removed.`
    });
  }
  for (const [oldType, newType] of typesDiff.persisted) {
    if (isEnumType(oldType) && isEnumType(newType)) {
      schemaChanges.push(...findEnumTypeChanges(oldType, newType));
    } else if (isUnionType(oldType) && isUnionType(newType)) {
      schemaChanges.push(...findUnionTypeChanges(oldType, newType));
    } else if (isInputObjectType(oldType) && isInputObjectType(newType)) {
      schemaChanges.push(...findInputObjectTypeChanges(oldType, newType));
    } else if (isObjectType(oldType) && isObjectType(newType)) {
      schemaChanges.push(
        ...findFieldChanges(oldType, newType),
        ...findImplementedInterfacesChanges(oldType, newType)
      );
    } else if (isInterfaceType(oldType) && isInterfaceType(newType)) {
      schemaChanges.push(
        ...findFieldChanges(oldType, newType),
        ...findImplementedInterfacesChanges(oldType, newType)
      );
    } else if (oldType.constructor !== newType.constructor) {
      schemaChanges.push({
        type: BreakingChangeType.TYPE_CHANGED_KIND,
        description: `${oldType.name} changed from ${typeKindName(oldType)} to ${typeKindName(newType)}.`
      });
    }
  }
  return schemaChanges;
}
function findInputObjectTypeChanges(oldType, newType) {
  const schemaChanges = [];
  const fieldsDiff = diff(
    Object.values(oldType.getFields()),
    Object.values(newType.getFields())
  );
  for (const newField of fieldsDiff.added) {
    if (isRequiredInputField(newField)) {
      schemaChanges.push({
        type: BreakingChangeType.REQUIRED_INPUT_FIELD_ADDED,
        description: `A required field ${newField.name} on input type ${oldType.name} was added.`
      });
    } else {
      schemaChanges.push({
        type: DangerousChangeType.OPTIONAL_INPUT_FIELD_ADDED,
        description: `An optional field ${newField.name} on input type ${oldType.name} was added.`
      });
    }
  }
  for (const oldField of fieldsDiff.removed) {
    schemaChanges.push({
      type: BreakingChangeType.FIELD_REMOVED,
      description: `${oldType.name}.${oldField.name} was removed.`
    });
  }
  for (const [oldField, newField] of fieldsDiff.persisted) {
    const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(
      oldField.type,
      newField.type
    );
    if (!isSafe) {
      schemaChanges.push({
        type: BreakingChangeType.FIELD_CHANGED_KIND,
        description: `${oldType.name}.${oldField.name} changed type from ${String(oldField.type)} to ${String(newField.type)}.`
      });
    }
  }
  return schemaChanges;
}
function findUnionTypeChanges(oldType, newType) {
  const schemaChanges = [];
  const possibleTypesDiff = diff(oldType.getTypes(), newType.getTypes());
  for (const newPossibleType of possibleTypesDiff.added) {
    schemaChanges.push({
      type: DangerousChangeType.TYPE_ADDED_TO_UNION,
      description: `${newPossibleType.name} was added to union type ${oldType.name}.`
    });
  }
  for (const oldPossibleType of possibleTypesDiff.removed) {
    schemaChanges.push({
      type: BreakingChangeType.TYPE_REMOVED_FROM_UNION,
      description: `${oldPossibleType.name} was removed from union type ${oldType.name}.`
    });
  }
  return schemaChanges;
}
function findEnumTypeChanges(oldType, newType) {
  const schemaChanges = [];
  const valuesDiff = diff(oldType.getValues(), newType.getValues());
  for (const newValue of valuesDiff.added) {
    schemaChanges.push({
      type: DangerousChangeType.VALUE_ADDED_TO_ENUM,
      description: `${newValue.name} was added to enum type ${oldType.name}.`
    });
  }
  for (const oldValue of valuesDiff.removed) {
    schemaChanges.push({
      type: BreakingChangeType.VALUE_REMOVED_FROM_ENUM,
      description: `${oldValue.name} was removed from enum type ${oldType.name}.`
    });
  }
  return schemaChanges;
}
function findImplementedInterfacesChanges(oldType, newType) {
  const schemaChanges = [];
  const interfacesDiff = diff(oldType.getInterfaces(), newType.getInterfaces());
  for (const newInterface of interfacesDiff.added) {
    schemaChanges.push({
      type: DangerousChangeType.IMPLEMENTED_INTERFACE_ADDED,
      description: `${newInterface.name} added to interfaces implemented by ${oldType.name}.`
    });
  }
  for (const oldInterface of interfacesDiff.removed) {
    schemaChanges.push({
      type: BreakingChangeType.IMPLEMENTED_INTERFACE_REMOVED,
      description: `${oldType.name} no longer implements interface ${oldInterface.name}.`
    });
  }
  return schemaChanges;
}
function findFieldChanges(oldType, newType) {
  const schemaChanges = [];
  const fieldsDiff = diff(
    Object.values(oldType.getFields()),
    Object.values(newType.getFields())
  );
  for (const oldField of fieldsDiff.removed) {
    schemaChanges.push({
      type: BreakingChangeType.FIELD_REMOVED,
      description: `${oldType.name}.${oldField.name} was removed.`
    });
  }
  for (const [oldField, newField] of fieldsDiff.persisted) {
    schemaChanges.push(...findArgChanges(oldType, oldField, newField));
    const isSafe = isChangeSafeForObjectOrInterfaceField(
      oldField.type,
      newField.type
    );
    if (!isSafe) {
      schemaChanges.push({
        type: BreakingChangeType.FIELD_CHANGED_KIND,
        description: `${oldType.name}.${oldField.name} changed type from ${String(oldField.type)} to ${String(newField.type)}.`
      });
    }
  }
  return schemaChanges;
}
function findArgChanges(oldType, oldField, newField) {
  const schemaChanges = [];
  const argsDiff = diff(oldField.args, newField.args);
  for (const oldArg of argsDiff.removed) {
    schemaChanges.push({
      type: BreakingChangeType.ARG_REMOVED,
      description: `${oldType.name}.${oldField.name} arg ${oldArg.name} was removed.`
    });
  }
  for (const [oldArg, newArg] of argsDiff.persisted) {
    const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(
      oldArg.type,
      newArg.type
    );
    if (!isSafe) {
      schemaChanges.push({
        type: BreakingChangeType.ARG_CHANGED_KIND,
        description: `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed type from ${String(oldArg.type)} to ${String(newArg.type)}.`
      });
    } else if (oldArg.defaultValue !== void 0) {
      if (newArg.defaultValue === void 0) {
        schemaChanges.push({
          type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,
          description: `${oldType.name}.${oldField.name} arg ${oldArg.name} defaultValue was removed.`
        });
      } else {
        const oldValueStr = stringifyValue(oldArg.defaultValue, oldArg.type);
        const newValueStr = stringifyValue(newArg.defaultValue, newArg.type);
        if (oldValueStr !== newValueStr) {
          schemaChanges.push({
            type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,
            description: `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed defaultValue from ${oldValueStr} to ${newValueStr}.`
          });
        }
      }
    }
  }
  for (const newArg of argsDiff.added) {
    if (isRequiredArgument(newArg)) {
      schemaChanges.push({
        type: BreakingChangeType.REQUIRED_ARG_ADDED,
        description: `A required arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`
      });
    } else {
      schemaChanges.push({
        type: DangerousChangeType.OPTIONAL_ARG_ADDED,
        description: `An optional arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`
      });
    }
  }
  return schemaChanges;
}
function isChangeSafeForObjectOrInterfaceField(oldType, newType) {
  if (isListType(oldType)) {
    return (
      // if they're both lists, make sure the underlying types are compatible
      isListType(newType) && isChangeSafeForObjectOrInterfaceField(
        oldType.ofType,
        newType.ofType
      ) || // moving from nullable to non-null of the same underlying type is safe
      isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)
    );
  }
  if (isNonNullType(oldType)) {
    return isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType);
  }
  return (
    // if they're both named types, see if their names are equivalent
    isNamedType(newType) && oldType.name === newType.name || // moving from nullable to non-null of the same underlying type is safe
    isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)
  );
}
function isChangeSafeForInputObjectFieldOrFieldArg(oldType, newType) {
  if (isListType(oldType)) {
    return isListType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType);
  }
  if (isNonNullType(oldType)) {
    return (
      // if they're both non-null, make sure the underlying types are
      // compatible
      isNonNullType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(
        oldType.ofType,
        newType.ofType
      ) || // moving from non-null to nullable of the same underlying type is safe
      !isNonNullType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType)
    );
  }
  return isNamedType(newType) && oldType.name === newType.name;
}
function typeKindName(type) {
  if (isScalarType(type)) {
    return "a Scalar type";
  }
  if (isObjectType(type)) {
    return "an Object type";
  }
  if (isInterfaceType(type)) {
    return "an Interface type";
  }
  if (isUnionType(type)) {
    return "a Union type";
  }
  if (isEnumType(type)) {
    return "an Enum type";
  }
  if (isInputObjectType(type)) {
    return "an Input type";
  }
  invariant(false, "Unexpected type: " + inspect(type));
}
function stringifyValue(value, type) {
  const ast = astFromValue(value, type);
  ast != null || invariant(false);
  return print(sortValueNode(ast));
}
function diff(oldArray, newArray) {
  const added = [];
  const removed = [];
  const persisted = [];
  const oldMap = keyMap(oldArray, ({ name }) => name);
  const newMap = keyMap(newArray, ({ name }) => name);
  for (const oldItem of oldArray) {
    const newItem = newMap[oldItem.name];
    if (newItem === void 0) {
      removed.push(oldItem);
    } else {
      persisted.push([oldItem, newItem]);
    }
  }
  for (const newItem of newArray) {
    if (oldMap[newItem.name] === void 0) {
      added.push(newItem);
    }
  }
  return {
    added,
    persisted,
    removed
  };
}
var BreakingChangeType, DangerousChangeType;
var init_findBreakingChanges = __esm({
  "../../../node_modules/graphql/utilities/findBreakingChanges.mjs"() {
    init_inspect();
    init_invariant();
    init_keyMap();
    init_printer();
    init_definition();
    init_scalars();
    init_astFromValue();
    init_sortValueNode();
    (function(BreakingChangeType2) {
      BreakingChangeType2["TYPE_REMOVED"] = "TYPE_REMOVED";
      BreakingChangeType2["TYPE_CHANGED_KIND"] = "TYPE_CHANGED_KIND";
      BreakingChangeType2["TYPE_REMOVED_FROM_UNION"] = "TYPE_REMOVED_FROM_UNION";
      BreakingChangeType2["VALUE_REMOVED_FROM_ENUM"] = "VALUE_REMOVED_FROM_ENUM";
      BreakingChangeType2["REQUIRED_INPUT_FIELD_ADDED"] = "REQUIRED_INPUT_FIELD_ADDED";
      BreakingChangeType2["IMPLEMENTED_INTERFACE_REMOVED"] = "IMPLEMENTED_INTERFACE_REMOVED";
      BreakingChangeType2["FIELD_REMOVED"] = "FIELD_REMOVED";
      BreakingChangeType2["FIELD_CHANGED_KIND"] = "FIELD_CHANGED_KIND";
      BreakingChangeType2["REQUIRED_ARG_ADDED"] = "REQUIRED_ARG_ADDED";
      BreakingChangeType2["ARG_REMOVED"] = "ARG_REMOVED";
      BreakingChangeType2["ARG_CHANGED_KIND"] = "ARG_CHANGED_KIND";
      BreakingChangeType2["DIRECTIVE_REMOVED"] = "DIRECTIVE_REMOVED";
      BreakingChangeType2["DIRECTIVE_ARG_REMOVED"] = "DIRECTIVE_ARG_REMOVED";
      BreakingChangeType2["REQUIRED_DIRECTIVE_ARG_ADDED"] = "REQUIRED_DIRECTIVE_ARG_ADDED";
      BreakingChangeType2["DIRECTIVE_REPEATABLE_REMOVED"] = "DIRECTIVE_REPEATABLE_REMOVED";
      BreakingChangeType2["DIRECTIVE_LOCATION_REMOVED"] = "DIRECTIVE_LOCATION_REMOVED";
    })(BreakingChangeType || (BreakingChangeType = {}));
    (function(DangerousChangeType2) {
      DangerousChangeType2["VALUE_ADDED_TO_ENUM"] = "VALUE_ADDED_TO_ENUM";
      DangerousChangeType2["TYPE_ADDED_TO_UNION"] = "TYPE_ADDED_TO_UNION";
      DangerousChangeType2["OPTIONAL_INPUT_FIELD_ADDED"] = "OPTIONAL_INPUT_FIELD_ADDED";
      DangerousChangeType2["OPTIONAL_ARG_ADDED"] = "OPTIONAL_ARG_ADDED";
      DangerousChangeType2["IMPLEMENTED_INTERFACE_ADDED"] = "IMPLEMENTED_INTERFACE_ADDED";
      DangerousChangeType2["ARG_DEFAULT_VALUE_CHANGE"] = "ARG_DEFAULT_VALUE_CHANGE";
    })(DangerousChangeType || (DangerousChangeType = {}));
  }
});

// ../../../node_modules/graphql/utilities/index.mjs
var utilities_exports = {};
__export(utilities_exports, {
  BreakingChangeType: () => BreakingChangeType,
  DangerousChangeType: () => DangerousChangeType,
  TypeInfo: () => TypeInfo,
  assertValidName: () => assertValidName,
  astFromValue: () => astFromValue,
  buildASTSchema: () => buildASTSchema,
  buildClientSchema: () => buildClientSchema,
  buildSchema: () => buildSchema,
  coerceInputValue: () => coerceInputValue,
  concatAST: () => concatAST,
  doTypesOverlap: () => doTypesOverlap,
  extendSchema: () => extendSchema,
  findBreakingChanges: () => findBreakingChanges,
  findDangerousChanges: () => findDangerousChanges,
  getIntrospectionQuery: () => getIntrospectionQuery,
  getOperationAST: () => getOperationAST,
  getOperationRootType: () => getOperationRootType,
  introspectionFromSchema: () => introspectionFromSchema,
  isEqualType: () => isEqualType,
  isTypeSubTypeOf: () => isTypeSubTypeOf,
  isValidNameError: () => isValidNameError,
  lexicographicSortSchema: () => lexicographicSortSchema,
  printIntrospectionSchema: () => printIntrospectionSchema,
  printSchema: () => printSchema,
  printType: () => printType,
  separateOperations: () => separateOperations,
  stripIgnoredCharacters: () => stripIgnoredCharacters,
  typeFromAST: () => typeFromAST,
  valueFromAST: () => valueFromAST,
  valueFromASTUntyped: () => valueFromASTUntyped,
  visitWithTypeInfo: () => visitWithTypeInfo
});
var init_utilities = __esm({
  "../../../node_modules/graphql/utilities/index.mjs"() {
    init_getIntrospectionQuery();
    init_getOperationAST();
    init_getOperationRootType();
    init_introspectionFromSchema();
    init_buildClientSchema();
    init_buildASTSchema();
    init_extendSchema();
    init_lexicographicSortSchema();
    init_printSchema();
    init_typeFromAST();
    init_valueFromAST();
    init_valueFromASTUntyped();
    init_astFromValue();
    init_TypeInfo();
    init_coerceInputValue();
    init_concatAST();
    init_separateOperations();
    init_stripIgnoredCharacters();
    init_typeComparators();
    init_assertValidName();
    init_findBreakingChanges();
  }
});

// ../../../node_modules/graphql/index.mjs
var graphql_exports = {};
__export(graphql_exports, {
  BREAK: () => BREAK,
  BreakingChangeType: () => BreakingChangeType,
  DEFAULT_DEPRECATION_REASON: () => DEFAULT_DEPRECATION_REASON,
  DangerousChangeType: () => DangerousChangeType,
  DirectiveLocation: () => DirectiveLocation,
  ExecutableDefinitionsRule: () => ExecutableDefinitionsRule,
  FieldsOnCorrectTypeRule: () => FieldsOnCorrectTypeRule,
  FragmentsOnCompositeTypesRule: () => FragmentsOnCompositeTypesRule,
  GRAPHQL_MAX_INT: () => GRAPHQL_MAX_INT,
  GRAPHQL_MIN_INT: () => GRAPHQL_MIN_INT,
  GraphQLBoolean: () => GraphQLBoolean,
  GraphQLDeprecatedDirective: () => GraphQLDeprecatedDirective,
  GraphQLDirective: () => GraphQLDirective,
  GraphQLEnumType: () => GraphQLEnumType,
  GraphQLError: () => GraphQLError,
  GraphQLFloat: () => GraphQLFloat,
  GraphQLID: () => GraphQLID,
  GraphQLIncludeDirective: () => GraphQLIncludeDirective,
  GraphQLInputObjectType: () => GraphQLInputObjectType,
  GraphQLInt: () => GraphQLInt,
  GraphQLInterfaceType: () => GraphQLInterfaceType,
  GraphQLList: () => GraphQLList,
  GraphQLNonNull: () => GraphQLNonNull,
  GraphQLObjectType: () => GraphQLObjectType,
  GraphQLScalarType: () => GraphQLScalarType,
  GraphQLSchema: () => GraphQLSchema,
  GraphQLSkipDirective: () => GraphQLSkipDirective,
  GraphQLSpecifiedByDirective: () => GraphQLSpecifiedByDirective,
  GraphQLString: () => GraphQLString,
  GraphQLUnionType: () => GraphQLUnionType,
  Kind: () => Kind,
  KnownArgumentNamesRule: () => KnownArgumentNamesRule,
  KnownDirectivesRule: () => KnownDirectivesRule,
  KnownFragmentNamesRule: () => KnownFragmentNamesRule,
  KnownTypeNamesRule: () => KnownTypeNamesRule,
  Lexer: () => Lexer,
  Location: () => Location,
  LoneAnonymousOperationRule: () => LoneAnonymousOperationRule,
  LoneSchemaDefinitionRule: () => LoneSchemaDefinitionRule,
  NoDeprecatedCustomRule: () => NoDeprecatedCustomRule,
  NoFragmentCyclesRule: () => NoFragmentCyclesRule,
  NoSchemaIntrospectionCustomRule: () => NoSchemaIntrospectionCustomRule,
  NoUndefinedVariablesRule: () => NoUndefinedVariablesRule,
  NoUnusedFragmentsRule: () => NoUnusedFragmentsRule,
  NoUnusedVariablesRule: () => NoUnusedVariablesRule,
  OperationTypeNode: () => OperationTypeNode,
  OverlappingFieldsCanBeMergedRule: () => OverlappingFieldsCanBeMergedRule,
  PossibleFragmentSpreadsRule: () => PossibleFragmentSpreadsRule,
  PossibleTypeExtensionsRule: () => PossibleTypeExtensionsRule,
  ProvidedRequiredArgumentsRule: () => ProvidedRequiredArgumentsRule,
  ScalarLeafsRule: () => ScalarLeafsRule,
  SchemaMetaFieldDef: () => SchemaMetaFieldDef,
  SingleFieldSubscriptionsRule: () => SingleFieldSubscriptionsRule,
  Source: () => Source,
  Token: () => Token,
  TokenKind: () => TokenKind,
  TypeInfo: () => TypeInfo,
  TypeKind: () => TypeKind,
  TypeMetaFieldDef: () => TypeMetaFieldDef,
  TypeNameMetaFieldDef: () => TypeNameMetaFieldDef,
  UniqueArgumentDefinitionNamesRule: () => UniqueArgumentDefinitionNamesRule,
  UniqueArgumentNamesRule: () => UniqueArgumentNamesRule,
  UniqueDirectiveNamesRule: () => UniqueDirectiveNamesRule,
  UniqueDirectivesPerLocationRule: () => UniqueDirectivesPerLocationRule,
  UniqueEnumValueNamesRule: () => UniqueEnumValueNamesRule,
  UniqueFieldDefinitionNamesRule: () => UniqueFieldDefinitionNamesRule,
  UniqueFragmentNamesRule: () => UniqueFragmentNamesRule,
  UniqueInputFieldNamesRule: () => UniqueInputFieldNamesRule,
  UniqueOperationNamesRule: () => UniqueOperationNamesRule,
  UniqueOperationTypesRule: () => UniqueOperationTypesRule,
  UniqueTypeNamesRule: () => UniqueTypeNamesRule,
  UniqueVariableNamesRule: () => UniqueVariableNamesRule,
  ValidationContext: () => ValidationContext,
  ValuesOfCorrectTypeRule: () => ValuesOfCorrectTypeRule,
  VariablesAreInputTypesRule: () => VariablesAreInputTypesRule,
  VariablesInAllowedPositionRule: () => VariablesInAllowedPositionRule,
  __Directive: () => __Directive,
  __DirectiveLocation: () => __DirectiveLocation,
  __EnumValue: () => __EnumValue,
  __Field: () => __Field,
  __InputValue: () => __InputValue,
  __Schema: () => __Schema,
  __Type: () => __Type,
  __TypeKind: () => __TypeKind,
  assertAbstractType: () => assertAbstractType,
  assertCompositeType: () => assertCompositeType,
  assertDirective: () => assertDirective,
  assertEnumType: () => assertEnumType,
  assertEnumValueName: () => assertEnumValueName,
  assertInputObjectType: () => assertInputObjectType,
  assertInputType: () => assertInputType,
  assertInterfaceType: () => assertInterfaceType,
  assertLeafType: () => assertLeafType,
  assertListType: () => assertListType,
  assertName: () => assertName,
  assertNamedType: () => assertNamedType,
  assertNonNullType: () => assertNonNullType,
  assertNullableType: () => assertNullableType,
  assertObjectType: () => assertObjectType,
  assertOutputType: () => assertOutputType,
  assertScalarType: () => assertScalarType,
  assertSchema: () => assertSchema,
  assertType: () => assertType,
  assertUnionType: () => assertUnionType,
  assertValidName: () => assertValidName,
  assertValidSchema: () => assertValidSchema,
  assertWrappingType: () => assertWrappingType,
  astFromValue: () => astFromValue,
  buildASTSchema: () => buildASTSchema,
  buildClientSchema: () => buildClientSchema,
  buildSchema: () => buildSchema,
  coerceInputValue: () => coerceInputValue,
  concatAST: () => concatAST,
  createSourceEventStream: () => createSourceEventStream,
  defaultFieldResolver: () => defaultFieldResolver,
  defaultTypeResolver: () => defaultTypeResolver,
  doTypesOverlap: () => doTypesOverlap,
  execute: () => execute,
  executeSync: () => executeSync,
  extendSchema: () => extendSchema,
  findBreakingChanges: () => findBreakingChanges,
  findDangerousChanges: () => findDangerousChanges,
  formatError: () => formatError,
  getArgumentValues: () => getArgumentValues,
  getDirectiveValues: () => getDirectiveValues,
  getEnterLeaveForKind: () => getEnterLeaveForKind,
  getIntrospectionQuery: () => getIntrospectionQuery,
  getLocation: () => getLocation,
  getNamedType: () => getNamedType,
  getNullableType: () => getNullableType,
  getOperationAST: () => getOperationAST,
  getOperationRootType: () => getOperationRootType,
  getVariableValues: () => getVariableValues,
  getVisitFn: () => getVisitFn,
  graphql: () => graphql,
  graphqlSync: () => graphqlSync,
  introspectionFromSchema: () => introspectionFromSchema,
  introspectionTypes: () => introspectionTypes,
  isAbstractType: () => isAbstractType,
  isCompositeType: () => isCompositeType,
  isConstValueNode: () => isConstValueNode,
  isDefinitionNode: () => isDefinitionNode,
  isDirective: () => isDirective,
  isEnumType: () => isEnumType,
  isEqualType: () => isEqualType,
  isExecutableDefinitionNode: () => isExecutableDefinitionNode,
  isInputObjectType: () => isInputObjectType,
  isInputType: () => isInputType,
  isInterfaceType: () => isInterfaceType,
  isIntrospectionType: () => isIntrospectionType,
  isLeafType: () => isLeafType,
  isListType: () => isListType,
  isNamedType: () => isNamedType,
  isNonNullType: () => isNonNullType,
  isNullableType: () => isNullableType,
  isObjectType: () => isObjectType,
  isOutputType: () => isOutputType,
  isRequiredArgument: () => isRequiredArgument,
  isRequiredInputField: () => isRequiredInputField,
  isScalarType: () => isScalarType,
  isSchema: () => isSchema,
  isSelectionNode: () => isSelectionNode,
  isSpecifiedDirective: () => isSpecifiedDirective,
  isSpecifiedScalarType: () => isSpecifiedScalarType,
  isType: () => isType,
  isTypeDefinitionNode: () => isTypeDefinitionNode,
  isTypeExtensionNode: () => isTypeExtensionNode,
  isTypeNode: () => isTypeNode,
  isTypeSubTypeOf: () => isTypeSubTypeOf,
  isTypeSystemDefinitionNode: () => isTypeSystemDefinitionNode,
  isTypeSystemExtensionNode: () => isTypeSystemExtensionNode,
  isUnionType: () => isUnionType,
  isValidNameError: () => isValidNameError,
  isValueNode: () => isValueNode,
  isWrappingType: () => isWrappingType,
  lexicographicSortSchema: () => lexicographicSortSchema,
  locatedError: () => locatedError,
  parse: () => parse,
  parseConstValue: () => parseConstValue,
  parseType: () => parseType,
  parseValue: () => parseValue,
  print: () => print,
  printError: () => printError,
  printIntrospectionSchema: () => printIntrospectionSchema,
  printLocation: () => printLocation,
  printSchema: () => printSchema,
  printSourceLocation: () => printSourceLocation,
  printType: () => printType,
  resolveObjMapThunk: () => resolveObjMapThunk,
  resolveReadonlyArrayThunk: () => resolveReadonlyArrayThunk,
  responsePathAsArray: () => pathToArray,
  separateOperations: () => separateOperations,
  specifiedDirectives: () => specifiedDirectives,
  specifiedRules: () => specifiedRules,
  specifiedScalarTypes: () => specifiedScalarTypes,
  stripIgnoredCharacters: () => stripIgnoredCharacters,
  subscribe: () => subscribe,
  syntaxError: () => syntaxError,
  typeFromAST: () => typeFromAST,
  validate: () => validate,
  validateSchema: () => validateSchema,
  valueFromAST: () => valueFromAST,
  valueFromASTUntyped: () => valueFromASTUntyped,
  version: () => version,
  versionInfo: () => versionInfo,
  visit: () => visit,
  visitInParallel: () => visitInParallel,
  visitWithTypeInfo: () => visitWithTypeInfo
});
var init_graphql2 = __esm({
  "../../../node_modules/graphql/index.mjs"() {
    init_version();
    init_graphql();
    init_type();
    init_language();
    init_execution();
    init_validation();
    init_error();
    init_utilities();
  }
});

// ../../../node_modules/apollo-server-errors/dist/index.js
var require_dist = __commonJS({
  "../../../node_modules/apollo-server-errors/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.formatApolloErrors = exports2.UserInputError = exports2.PersistedQueryNotSupportedError = exports2.PersistedQueryNotFoundError = exports2.ForbiddenError = exports2.AuthenticationError = exports2.ValidationError = exports2.SyntaxError = exports2.fromGraphQLError = exports2.toApolloError = exports2.ApolloError = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var ApolloError = class extends Error {
      constructor(message, code, extensions) {
        super(message);
        if (!this.name) {
          Object.defineProperty(this, "name", { value: "ApolloError" });
        }
        if (extensions === null || extensions === void 0 ? void 0 : extensions.extensions) {
          throw Error("Pass extensions directly as the third argument of the ApolloError constructor: `new ApolloError(message, code, {myExt: value})`, not `new ApolloError(message, code, {extensions: {myExt: value}})`");
        }
        this.extensions = { ...extensions, code };
      }
      toJSON() {
        return (0, graphql_1.formatError)(toGraphQLError(this));
      }
      toString() {
        return (0, graphql_1.printError)(toGraphQLError(this));
      }
      get [Symbol.toStringTag]() {
        return this.name;
      }
    };
    exports2.ApolloError = ApolloError;
    function toGraphQLError(error) {
      return new graphql_1.GraphQLError(error.message, error.nodes, error.source, error.positions, error.path, error.originalError, error.extensions);
    }
    function enrichError(error, debug = false) {
      var _a, _b, _c;
      const expanded = Object.create(Object.getPrototypeOf(error), {
        name: {
          value: error.name
        },
        message: {
          value: error.message,
          enumerable: true,
          writable: true
        },
        locations: {
          value: error.locations || void 0,
          enumerable: true
        },
        path: {
          value: error.path || void 0,
          enumerable: true
        },
        nodes: {
          value: error.nodes || void 0
        },
        source: {
          value: error.source || void 0
        },
        positions: {
          value: error.positions || void 0
        },
        originalError: {
          value: error.originalError
        }
      });
      expanded.extensions = {
        ...error.extensions,
        code: ((_a = error.extensions) === null || _a === void 0 ? void 0 : _a.code) || "INTERNAL_SERVER_ERROR",
        exception: {
          ...(_b = error.extensions) === null || _b === void 0 ? void 0 : _b.exception,
          ...error.originalError
        }
      };
      delete expanded.extensions.exception.extensions;
      if (debug && !expanded.extensions.exception.stacktrace) {
        const stack = ((_c = error.originalError) === null || _c === void 0 ? void 0 : _c.stack) || error.stack;
        expanded.extensions.exception.stacktrace = stack === null || stack === void 0 ? void 0 : stack.split("\n");
      }
      if (Object.keys(expanded.extensions.exception).length === 0) {
        delete expanded.extensions.exception;
      }
      return expanded;
    }
    function toApolloError(error, code = "INTERNAL_SERVER_ERROR") {
      let err = error;
      if (err.extensions) {
        err.extensions.code = code;
      } else {
        err.extensions = { code };
      }
      return err;
    }
    exports2.toApolloError = toApolloError;
    function fromGraphQLError(error, options) {
      const copy = (options === null || options === void 0 ? void 0 : options.errorClass) ? new options.errorClass(error.message) : new ApolloError(error.message);
      Object.entries(error).forEach(([key, value]) => {
        if (key === "extensions") {
          return;
        }
        copy[key] = value;
      });
      copy.extensions = {
        ...copy.extensions,
        ...error.extensions
      };
      if (!copy.extensions.code) {
        copy.extensions.code = (options === null || options === void 0 ? void 0 : options.code) || "INTERNAL_SERVER_ERROR";
      }
      Object.defineProperty(copy, "originalError", { value: {} });
      Object.getOwnPropertyNames(error).forEach((key) => {
        Object.defineProperty(copy.originalError, key, {
          value: error[key]
        });
      });
      return copy;
    }
    exports2.fromGraphQLError = fromGraphQLError;
    var SyntaxError2 = class extends ApolloError {
      constructor(message) {
        super(message, "GRAPHQL_PARSE_FAILED");
        Object.defineProperty(this, "name", { value: "SyntaxError" });
      }
    };
    exports2.SyntaxError = SyntaxError2;
    var ValidationError = class extends ApolloError {
      constructor(message) {
        super(message, "GRAPHQL_VALIDATION_FAILED");
        Object.defineProperty(this, "name", { value: "ValidationError" });
      }
    };
    exports2.ValidationError = ValidationError;
    var AuthenticationError = class extends ApolloError {
      constructor(message, extensions) {
        super(message, "UNAUTHENTICATED", extensions);
        Object.defineProperty(this, "name", { value: "AuthenticationError" });
      }
    };
    exports2.AuthenticationError = AuthenticationError;
    var ForbiddenError = class extends ApolloError {
      constructor(message, extensions) {
        super(message, "FORBIDDEN", extensions);
        Object.defineProperty(this, "name", { value: "ForbiddenError" });
      }
    };
    exports2.ForbiddenError = ForbiddenError;
    var PersistedQueryNotFoundError = class extends ApolloError {
      constructor() {
        super("PersistedQueryNotFound", "PERSISTED_QUERY_NOT_FOUND");
        Object.defineProperty(this, "name", {
          value: "PersistedQueryNotFoundError"
        });
      }
    };
    exports2.PersistedQueryNotFoundError = PersistedQueryNotFoundError;
    var PersistedQueryNotSupportedError = class extends ApolloError {
      constructor() {
        super("PersistedQueryNotSupported", "PERSISTED_QUERY_NOT_SUPPORTED");
        Object.defineProperty(this, "name", {
          value: "PersistedQueryNotSupportedError"
        });
      }
    };
    exports2.PersistedQueryNotSupportedError = PersistedQueryNotSupportedError;
    var UserInputError = class extends ApolloError {
      constructor(message, extensions) {
        super(message, "BAD_USER_INPUT", extensions);
        Object.defineProperty(this, "name", { value: "UserInputError" });
      }
    };
    exports2.UserInputError = UserInputError;
    function formatApolloErrors(errors, options) {
      if (!options) {
        return errors.map((error) => enrichError(error));
      }
      const { formatter, debug } = options;
      const enrichedErrors = errors.map((error) => enrichError(error, debug));
      const makePrintable = (error) => {
        if (error instanceof Error) {
          const graphQLError = error;
          return {
            message: graphQLError.message,
            ...graphQLError.locations && { locations: graphQLError.locations },
            ...graphQLError.path && { path: graphQLError.path },
            ...graphQLError.extensions && { extensions: graphQLError.extensions }
          };
        }
        return error;
      };
      if (!formatter) {
        return enrichedErrors;
      }
      return enrichedErrors.map((error) => {
        try {
          return makePrintable(formatter(error));
        } catch (err) {
          if (debug) {
            return enrichError(err, debug);
          } else {
            const newError = fromGraphQLError(new graphql_1.GraphQLError("Internal server error"));
            return enrichError(newError, debug);
          }
        }
      });
    }
    exports2.formatApolloErrors = formatApolloErrors;
  }
});

// ../../../node_modules/whatwg-mimetype/lib/utils.js
var require_utils = __commonJS({
  "../../../node_modules/whatwg-mimetype/lib/utils.js"(exports2) {
    "use strict";
    exports2.removeLeadingAndTrailingHTTPWhitespace = (string) => {
      return string.replace(/^[ \t\n\r]+/u, "").replace(/[ \t\n\r]+$/u, "");
    };
    exports2.removeTrailingHTTPWhitespace = (string) => {
      return string.replace(/[ \t\n\r]+$/u, "");
    };
    exports2.isHTTPWhitespaceChar = (char) => {
      return char === " " || char === "	" || char === "\n" || char === "\r";
    };
    exports2.solelyContainsHTTPTokenCodePoints = (string) => {
      return /^[-!#$%&'*+.^_`|~A-Za-z0-9]*$/u.test(string);
    };
    exports2.soleyContainsHTTPQuotedStringTokenCodePoints = (string) => {
      return /^[\t\u0020-\u007E\u0080-\u00FF]*$/u.test(string);
    };
    exports2.asciiLowercase = (string) => {
      return string.replace(/[A-Z]/ug, (l) => l.toLowerCase());
    };
    exports2.collectAnHTTPQuotedString = (input, position) => {
      let value = "";
      position++;
      while (true) {
        while (position < input.length && input[position] !== '"' && input[position] !== "\\") {
          value += input[position];
          ++position;
        }
        if (position >= input.length) {
          break;
        }
        const quoteOrBackslash = input[position];
        ++position;
        if (quoteOrBackslash === "\\") {
          if (position >= input.length) {
            value += "\\";
            break;
          }
          value += input[position];
          ++position;
        } else {
          break;
        }
      }
      return [value, position];
    };
  }
});

// ../../../node_modules/whatwg-mimetype/lib/mime-type-parameters.js
var require_mime_type_parameters = __commonJS({
  "../../../node_modules/whatwg-mimetype/lib/mime-type-parameters.js"(exports2, module2) {
    "use strict";
    var {
      asciiLowercase,
      solelyContainsHTTPTokenCodePoints,
      soleyContainsHTTPQuotedStringTokenCodePoints
    } = require_utils();
    module2.exports = class MIMETypeParameters {
      constructor(map) {
        this._map = map;
      }
      get size() {
        return this._map.size;
      }
      get(name) {
        name = asciiLowercase(String(name));
        return this._map.get(name);
      }
      has(name) {
        name = asciiLowercase(String(name));
        return this._map.has(name);
      }
      set(name, value) {
        name = asciiLowercase(String(name));
        value = String(value);
        if (!solelyContainsHTTPTokenCodePoints(name)) {
          throw new Error(`Invalid MIME type parameter name "${name}": only HTTP token code points are valid.`);
        }
        if (!soleyContainsHTTPQuotedStringTokenCodePoints(value)) {
          throw new Error(`Invalid MIME type parameter value "${value}": only HTTP quoted-string token code points are valid.`);
        }
        return this._map.set(name, value);
      }
      clear() {
        this._map.clear();
      }
      delete(name) {
        name = asciiLowercase(String(name));
        return this._map.delete(name);
      }
      forEach(callbackFn, thisArg) {
        this._map.forEach(callbackFn, thisArg);
      }
      keys() {
        return this._map.keys();
      }
      values() {
        return this._map.values();
      }
      entries() {
        return this._map.entries();
      }
      [Symbol.iterator]() {
        return this._map[Symbol.iterator]();
      }
    };
  }
});

// ../../../node_modules/whatwg-mimetype/lib/parser.js
var require_parser = __commonJS({
  "../../../node_modules/whatwg-mimetype/lib/parser.js"(exports2, module2) {
    "use strict";
    var {
      removeLeadingAndTrailingHTTPWhitespace,
      removeTrailingHTTPWhitespace,
      isHTTPWhitespaceChar,
      solelyContainsHTTPTokenCodePoints,
      soleyContainsHTTPQuotedStringTokenCodePoints,
      asciiLowercase,
      collectAnHTTPQuotedString
    } = require_utils();
    module2.exports = (input) => {
      input = removeLeadingAndTrailingHTTPWhitespace(input);
      let position = 0;
      let type = "";
      while (position < input.length && input[position] !== "/") {
        type += input[position];
        ++position;
      }
      if (type.length === 0 || !solelyContainsHTTPTokenCodePoints(type)) {
        return null;
      }
      if (position >= input.length) {
        return null;
      }
      ++position;
      let subtype = "";
      while (position < input.length && input[position] !== ";") {
        subtype += input[position];
        ++position;
      }
      subtype = removeTrailingHTTPWhitespace(subtype);
      if (subtype.length === 0 || !solelyContainsHTTPTokenCodePoints(subtype)) {
        return null;
      }
      const mimeType = {
        type: asciiLowercase(type),
        subtype: asciiLowercase(subtype),
        parameters: /* @__PURE__ */ new Map()
      };
      while (position < input.length) {
        ++position;
        while (isHTTPWhitespaceChar(input[position])) {
          ++position;
        }
        let parameterName = "";
        while (position < input.length && input[position] !== ";" && input[position] !== "=") {
          parameterName += input[position];
          ++position;
        }
        parameterName = asciiLowercase(parameterName);
        if (position < input.length) {
          if (input[position] === ";") {
            continue;
          }
          ++position;
        }
        let parameterValue = null;
        if (input[position] === '"') {
          [parameterValue, position] = collectAnHTTPQuotedString(input, position);
          while (position < input.length && input[position] !== ";") {
            ++position;
          }
        } else {
          parameterValue = "";
          while (position < input.length && input[position] !== ";") {
            parameterValue += input[position];
            ++position;
          }
          parameterValue = removeTrailingHTTPWhitespace(parameterValue);
          if (parameterValue === "") {
            continue;
          }
        }
        if (parameterName.length > 0 && solelyContainsHTTPTokenCodePoints(parameterName) && soleyContainsHTTPQuotedStringTokenCodePoints(parameterValue) && !mimeType.parameters.has(parameterName)) {
          mimeType.parameters.set(parameterName, parameterValue);
        }
      }
      return mimeType;
    };
  }
});

// ../../../node_modules/whatwg-mimetype/lib/serializer.js
var require_serializer = __commonJS({
  "../../../node_modules/whatwg-mimetype/lib/serializer.js"(exports2, module2) {
    "use strict";
    var { solelyContainsHTTPTokenCodePoints } = require_utils();
    module2.exports = (mimeType) => {
      let serialization = `${mimeType.type}/${mimeType.subtype}`;
      if (mimeType.parameters.size === 0) {
        return serialization;
      }
      for (let [name, value] of mimeType.parameters) {
        serialization += ";";
        serialization += name;
        serialization += "=";
        if (!solelyContainsHTTPTokenCodePoints(value) || value.length === 0) {
          value = value.replace(/(["\\])/ug, "\\$1");
          value = `"${value}"`;
        }
        serialization += value;
      }
      return serialization;
    };
  }
});

// ../../../node_modules/whatwg-mimetype/lib/mime-type.js
var require_mime_type = __commonJS({
  "../../../node_modules/whatwg-mimetype/lib/mime-type.js"(exports2, module2) {
    "use strict";
    var MIMETypeParameters = require_mime_type_parameters();
    var parse2 = require_parser();
    var serialize = require_serializer();
    var {
      asciiLowercase,
      solelyContainsHTTPTokenCodePoints
    } = require_utils();
    module2.exports = class MIMEType {
      constructor(string) {
        string = String(string);
        const result = parse2(string);
        if (result === null) {
          throw new Error(`Could not parse MIME type string "${string}"`);
        }
        this._type = result.type;
        this._subtype = result.subtype;
        this._parameters = new MIMETypeParameters(result.parameters);
      }
      static parse(string) {
        try {
          return new this(string);
        } catch (e) {
          return null;
        }
      }
      get essence() {
        return `${this.type}/${this.subtype}`;
      }
      get type() {
        return this._type;
      }
      set type(value) {
        value = asciiLowercase(String(value));
        if (value.length === 0) {
          throw new Error("Invalid type: must be a non-empty string");
        }
        if (!solelyContainsHTTPTokenCodePoints(value)) {
          throw new Error(`Invalid type ${value}: must contain only HTTP token code points`);
        }
        this._type = value;
      }
      get subtype() {
        return this._subtype;
      }
      set subtype(value) {
        value = asciiLowercase(String(value));
        if (value.length === 0) {
          throw new Error("Invalid subtype: must be a non-empty string");
        }
        if (!solelyContainsHTTPTokenCodePoints(value)) {
          throw new Error(`Invalid subtype ${value}: must contain only HTTP token code points`);
        }
        this._subtype = value;
      }
      get parameters() {
        return this._parameters;
      }
      toString() {
        return serialize(this);
      }
      isJavaScript({ prohibitParameters = false } = {}) {
        switch (this._type) {
          case "text": {
            switch (this._subtype) {
              case "ecmascript":
              case "javascript":
              case "javascript1.0":
              case "javascript1.1":
              case "javascript1.2":
              case "javascript1.3":
              case "javascript1.4":
              case "javascript1.5":
              case "jscript":
              case "livescript":
              case "x-ecmascript":
              case "x-javascript": {
                return !prohibitParameters || this._parameters.size === 0;
              }
              default: {
                return false;
              }
            }
          }
          case "application": {
            switch (this._subtype) {
              case "ecmascript":
              case "javascript":
              case "x-ecmascript":
              case "x-javascript": {
                return !prohibitParameters || this._parameters.size === 0;
              }
              default: {
                return false;
              }
            }
          }
          default: {
            return false;
          }
        }
      }
      isXML() {
        return this._subtype === "xml" && (this._type === "text" || this._type === "application") || this._subtype.endsWith("+xml");
      }
      isHTML() {
        return this._subtype === "html" && this._type === "text";
      }
    };
  }
});

// ../../../node_modules/apollo-server-types/dist/index.js
var require_dist2 = __commonJS({
  "../../../node_modules/apollo-server-types/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CacheScope = void 0;
    var CacheScope;
    (function(CacheScope2) {
      CacheScope2["Public"] = "PUBLIC";
      CacheScope2["Private"] = "PRIVATE";
    })(CacheScope = exports2.CacheScope || (exports2.CacheScope = {}));
  }
});

// ../../../node_modules/apollo-server-core/dist/cachePolicy.js
var require_cachePolicy = __commonJS({
  "../../../node_modules/apollo-server-core/dist/cachePolicy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.newCachePolicy = void 0;
    var apollo_server_types_1 = require_dist2();
    function newCachePolicy() {
      return {
        maxAge: void 0,
        scope: void 0,
        restrict(hint) {
          if (hint.maxAge !== void 0 && (this.maxAge === void 0 || hint.maxAge < this.maxAge)) {
            this.maxAge = hint.maxAge;
          }
          if (hint.scope !== void 0 && this.scope !== apollo_server_types_1.CacheScope.Private) {
            this.scope = hint.scope;
          }
        },
        replace(hint) {
          if (hint.maxAge !== void 0) {
            this.maxAge = hint.maxAge;
          }
          if (hint.scope !== void 0) {
            this.scope = hint.scope;
          }
        },
        policyIfCacheable() {
          var _a;
          if (this.maxAge === void 0 || this.maxAge === 0) {
            return null;
          }
          return { maxAge: this.maxAge, scope: (_a = this.scope) !== null && _a !== void 0 ? _a : apollo_server_types_1.CacheScope.Public };
        }
      };
    }
    exports2.newCachePolicy = newCachePolicy;
  }
});

// ../../../node_modules/apollo-server-core/dist/graphqlOptions.js
var require_graphqlOptions = __commonJS({
  "../../../node_modules/apollo-server-core/dist/graphqlOptions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolveGraphqlOptions = void 0;
    async function resolveGraphqlOptions(options, ...args) {
      if (typeof options === "function") {
        return await options(...args);
      } else {
        return options;
      }
    }
    exports2.resolveGraphqlOptions = resolveGraphqlOptions;
  }
});

// ../../../node_modules/apollo-server-core/dist/utils/schemaInstrumentation.js
var require_schemaInstrumentation = __commonJS({
  "../../../node_modules/apollo-server-core/dist/utils/schemaInstrumentation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.whenResultIsFinished = exports2.pluginsEnabledForSchemaResolvers = exports2.enablePluginsForSchemaResolvers = exports2.symbolUserFieldResolver = exports2.symbolExecutionDispatcherWillResolveField = void 0;
    var type_1 = (init_type(), __toCommonJS(type_exports));
    var execution_1 = (init_execution(), __toCommonJS(execution_exports));
    exports2.symbolExecutionDispatcherWillResolveField = Symbol("apolloServerExecutionDispatcherWillResolveField");
    exports2.symbolUserFieldResolver = Symbol("apolloServerUserFieldResolver");
    var symbolPluginsEnabled = Symbol("apolloServerPluginsEnabled");
    function enablePluginsForSchemaResolvers(schema) {
      if (pluginsEnabledForSchemaResolvers(schema)) {
        return schema;
      }
      Object.defineProperty(schema, symbolPluginsEnabled, {
        value: true
      });
      forEachField(schema, wrapField);
      return schema;
    }
    exports2.enablePluginsForSchemaResolvers = enablePluginsForSchemaResolvers;
    function pluginsEnabledForSchemaResolvers(schema) {
      return !!schema[symbolPluginsEnabled];
    }
    exports2.pluginsEnabledForSchemaResolvers = pluginsEnabledForSchemaResolvers;
    function wrapField(field) {
      const originalFieldResolve = field.resolve;
      field.resolve = (source, args, context, info) => {
        const parentPath = info.path.prev;
        const willResolveField = context === null || context === void 0 ? void 0 : context[exports2.symbolExecutionDispatcherWillResolveField];
        const userFieldResolver = context === null || context === void 0 ? void 0 : context[exports2.symbolUserFieldResolver];
        const didResolveField = typeof willResolveField === "function" && willResolveField({ source, args, context, info });
        const resolveObject = info.parentType.resolveObject;
        let whenObjectResolved;
        if (parentPath && resolveObject) {
          if (!parentPath.__fields) {
            parentPath.__fields = {};
          }
          parentPath.__fields[info.fieldName] = info.fieldNodes;
          whenObjectResolved = parentPath.__whenObjectResolved;
          if (!whenObjectResolved) {
            whenObjectResolved = Promise.resolve().then(() => {
              return resolveObject(source, parentPath.__fields, context, info);
            });
            parentPath.__whenObjectResolved = whenObjectResolved;
          }
        }
        const fieldResolver = originalFieldResolve || userFieldResolver || execution_1.defaultFieldResolver;
        try {
          let result;
          if (whenObjectResolved) {
            result = whenObjectResolved.then((resolvedObject) => {
              return fieldResolver(resolvedObject, args, context, info);
            });
          } else {
            result = fieldResolver(source, args, context, info);
          }
          if (typeof didResolveField === "function") {
            whenResultIsFinished(result, didResolveField);
          }
          return result;
        } catch (error) {
          if (typeof didResolveField === "function") {
            didResolveField(error);
          }
          throw error;
        }
      };
    }
    function isPromise2(x) {
      return x && typeof x.then === "function";
    }
    function whenResultIsFinished(result, callback) {
      if (isPromise2(result)) {
        result.then((r) => callback(null, r), (err) => callback(err));
      } else if (Array.isArray(result)) {
        if (result.some(isPromise2)) {
          Promise.all(result).then((r) => callback(null, r), (err) => callback(err));
        } else {
          callback(null, result);
        }
      } else {
        callback(null, result);
      }
    }
    exports2.whenResultIsFinished = whenResultIsFinished;
    function forEachField(schema, fn) {
      const typeMap = schema.getTypeMap();
      Object.entries(typeMap).forEach(([typeName, type]) => {
        if (!(0, type_1.getNamedType)(type).name.startsWith("__") && type instanceof type_1.GraphQLObjectType) {
          const fields = type.getFields();
          Object.entries(fields).forEach(([fieldName, field]) => {
            fn(field, typeName, fieldName);
          });
        }
      });
    }
  }
});

// ../../../node_modules/apollo-server-core/dist/utils/dispatcher.js
var require_dispatcher = __commonJS({
  "../../../node_modules/apollo-server-core/dist/utils/dispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Dispatcher = void 0;
    var Dispatcher = class {
      constructor(targets) {
        this.targets = targets;
      }
      callTargets(methodName, ...args) {
        return this.targets.map((target) => {
          const method = target[methodName];
          if (typeof method === "function") {
            return method.apply(target, args);
          }
        });
      }
      hasHook(methodName) {
        return this.targets.some((target) => typeof target[methodName] === "function");
      }
      async invokeHook(methodName, ...args) {
        return Promise.all(this.callTargets(methodName, ...args));
      }
      async invokeHooksUntilNonNull(methodName, ...args) {
        for (const target of this.targets) {
          const method = target[methodName];
          if (typeof method !== "function") {
            continue;
          }
          const value = await method.apply(target, args);
          if (value !== null) {
            return value;
          }
        }
        return null;
      }
      async invokeDidStartHook(methodName, ...args) {
        const hookReturnValues = await Promise.all(this.callTargets(methodName, ...args));
        const didEndHooks = hookReturnValues.filter((hook) => !!hook);
        didEndHooks.reverse();
        return async (...args2) => {
          await Promise.all(didEndHooks.map((hook) => hook(...args2)));
        };
      }
      invokeSyncDidStartHook(methodName, ...args) {
        const didEndHooks = [];
        for (const target of this.targets) {
          const method = target[methodName];
          if (typeof method === "function") {
            const didEndHook = method.apply(target, args);
            if (didEndHook) {
              didEndHooks.push(didEndHook);
            }
          }
        }
        didEndHooks.reverse();
        return (...args2) => {
          for (const didEndHook of didEndHooks) {
            didEndHook(...args2);
          }
        };
      }
    };
    exports2.Dispatcher = Dispatcher;
  }
});

// ../../../node_modules/@apollo/utils.keyvaluecache/dist/PrefixingKeyValueCache.js
var require_PrefixingKeyValueCache = __commonJS({
  "../../../node_modules/@apollo/utils.keyvaluecache/dist/PrefixingKeyValueCache.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PrefixingKeyValueCache = void 0;
    var PrefixingKeyValueCache = class {
      constructor(wrapped, prefix) {
        this.wrapped = wrapped;
        this.prefix = prefix;
      }
      get(key) {
        return this.wrapped.get(this.prefix + key);
      }
      set(key, value, options) {
        return this.wrapped.set(this.prefix + key, value, options);
      }
      delete(key) {
        return this.wrapped.delete(this.prefix + key);
      }
    };
    exports2.PrefixingKeyValueCache = PrefixingKeyValueCache;
  }
});

// ../../../node_modules/@apollo/utils.keyvaluecache/node_modules/lru-cache/index.js
var require_lru_cache = __commonJS({
  "../../../node_modules/@apollo/utils.keyvaluecache/node_modules/lru-cache/index.js"(exports2, module2) {
    var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
    var hasAbortController = typeof AbortController === "function";
    var AC = hasAbortController ? AbortController : class AbortController {
      constructor() {
        this.signal = new AS();
      }
      abort() {
        this.signal.dispatchEvent("abort");
      }
    };
    var hasAbortSignal = typeof AbortSignal === "function";
    var hasACAbortSignal = typeof AC.AbortSignal === "function";
    var AS = hasAbortSignal ? AbortSignal : hasACAbortSignal ? AC.AbortController : class AbortSignal {
      constructor() {
        this.aborted = false;
        this._listeners = [];
      }
      dispatchEvent(type) {
        if (type === "abort") {
          this.aborted = true;
          const e = { type, target: this };
          this.onabort(e);
          this._listeners.forEach((f) => f(e), this);
        }
      }
      onabort() {
      }
      addEventListener(ev, fn) {
        if (ev === "abort") {
          this._listeners.push(fn);
        }
      }
      removeEventListener(ev, fn) {
        if (ev === "abort") {
          this._listeners = this._listeners.filter((f) => f !== fn);
        }
      }
    };
    var warned = /* @__PURE__ */ new Set();
    var deprecatedOption = (opt, instead) => {
      const code = `LRU_CACHE_OPTION_${opt}`;
      if (shouldWarn(code)) {
        warn(code, `${opt} option`, `options.${instead}`, LRUCache);
      }
    };
    var deprecatedMethod = (method, instead) => {
      const code = `LRU_CACHE_METHOD_${method}`;
      if (shouldWarn(code)) {
        const { prototype } = LRUCache;
        const { get } = Object.getOwnPropertyDescriptor(prototype, method);
        warn(code, `${method} method`, `cache.${instead}()`, get);
      }
    };
    var deprecatedProperty = (field, instead) => {
      const code = `LRU_CACHE_PROPERTY_${field}`;
      if (shouldWarn(code)) {
        const { prototype } = LRUCache;
        const { get } = Object.getOwnPropertyDescriptor(prototype, field);
        warn(code, `${field} property`, `cache.${instead}`, get);
      }
    };
    var emitWarning = (...a) => {
      typeof process === "object" && process && typeof process.emitWarning === "function" ? process.emitWarning(...a) : console.error(...a);
    };
    var shouldWarn = (code) => !warned.has(code);
    var warn = (code, what, instead, fn) => {
      warned.add(code);
      const msg = `The ${what} is deprecated. Please use ${instead} instead.`;
      emitWarning(msg, "DeprecationWarning", code, fn);
    };
    var isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
    var getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
    var ZeroArray = class extends Array {
      constructor(size) {
        super(size);
        this.fill(0);
      }
    };
    var Stack = class {
      constructor(max) {
        if (max === 0) {
          return [];
        }
        const UintArray = getUintArray(max);
        this.heap = new UintArray(max);
        this.length = 0;
      }
      push(n) {
        this.heap[this.length++] = n;
      }
      pop() {
        return this.heap[--this.length];
      }
    };
    var LRUCache = class _LRUCache {
      constructor(options = {}) {
        const {
          max = 0,
          ttl,
          ttlResolution = 1,
          ttlAutopurge,
          updateAgeOnGet,
          updateAgeOnHas,
          allowStale,
          dispose,
          disposeAfter,
          noDisposeOnSet,
          noUpdateTTL,
          maxSize = 0,
          sizeCalculation,
          fetchMethod,
          fetchContext,
          noDeleteOnFetchRejection,
          noDeleteOnStaleGet
        } = options;
        const { length, maxAge, stale } = options instanceof _LRUCache ? {} : options;
        if (max !== 0 && !isPosInt(max)) {
          throw new TypeError("max option must be a nonnegative integer");
        }
        const UintArray = max ? getUintArray(max) : Array;
        if (!UintArray) {
          throw new Error("invalid max value: " + max);
        }
        this.max = max;
        this.maxSize = maxSize;
        this.sizeCalculation = sizeCalculation || length;
        if (this.sizeCalculation) {
          if (!this.maxSize) {
            throw new TypeError(
              "cannot set sizeCalculation without setting maxSize"
            );
          }
          if (typeof this.sizeCalculation !== "function") {
            throw new TypeError("sizeCalculation set to non-function");
          }
        }
        this.fetchMethod = fetchMethod || null;
        if (this.fetchMethod && typeof this.fetchMethod !== "function") {
          throw new TypeError(
            "fetchMethod must be a function if specified"
          );
        }
        this.fetchContext = fetchContext;
        if (!this.fetchMethod && fetchContext !== void 0) {
          throw new TypeError(
            "cannot set fetchContext without fetchMethod"
          );
        }
        this.keyMap = /* @__PURE__ */ new Map();
        this.keyList = new Array(max).fill(null);
        this.valList = new Array(max).fill(null);
        this.next = new UintArray(max);
        this.prev = new UintArray(max);
        this.head = 0;
        this.tail = 0;
        this.free = new Stack(max);
        this.initialFill = 1;
        this.size = 0;
        if (typeof dispose === "function") {
          this.dispose = dispose;
        }
        if (typeof disposeAfter === "function") {
          this.disposeAfter = disposeAfter;
          this.disposed = [];
        } else {
          this.disposeAfter = null;
          this.disposed = null;
        }
        this.noDisposeOnSet = !!noDisposeOnSet;
        this.noUpdateTTL = !!noUpdateTTL;
        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
        if (this.maxSize !== 0) {
          if (!isPosInt(this.maxSize)) {
            throw new TypeError(
              "maxSize must be a positive integer if specified"
            );
          }
          this.initializeSizeTracking();
        }
        this.allowStale = !!allowStale || !!stale;
        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
        this.updateAgeOnGet = !!updateAgeOnGet;
        this.updateAgeOnHas = !!updateAgeOnHas;
        this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
        this.ttlAutopurge = !!ttlAutopurge;
        this.ttl = ttl || maxAge || 0;
        if (this.ttl) {
          if (!isPosInt(this.ttl)) {
            throw new TypeError(
              "ttl must be a positive integer if specified"
            );
          }
          this.initializeTTLTracking();
        }
        if (this.max === 0 && this.ttl === 0 && this.maxSize === 0) {
          throw new TypeError(
            "At least one of max, maxSize, or ttl is required"
          );
        }
        if (!this.ttlAutopurge && !this.max && !this.maxSize) {
          const code = "LRU_CACHE_UNBOUNDED";
          if (shouldWarn(code)) {
            warned.add(code);
            const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
            emitWarning(msg, "UnboundedCacheWarning", code, _LRUCache);
          }
        }
        if (stale) {
          deprecatedOption("stale", "allowStale");
        }
        if (maxAge) {
          deprecatedOption("maxAge", "ttl");
        }
        if (length) {
          deprecatedOption("length", "sizeCalculation");
        }
      }
      getRemainingTTL(key) {
        return this.has(key, { updateAgeOnHas: false }) ? Infinity : 0;
      }
      initializeTTLTracking() {
        this.ttls = new ZeroArray(this.max);
        this.starts = new ZeroArray(this.max);
        this.setItemTTL = (index, ttl, start = perf.now()) => {
          this.starts[index] = ttl !== 0 ? start : 0;
          this.ttls[index] = ttl;
          if (ttl !== 0 && this.ttlAutopurge) {
            const t = setTimeout(() => {
              if (this.isStale(index)) {
                this.delete(this.keyList[index]);
              }
            }, ttl + 1);
            if (t.unref) {
              t.unref();
            }
          }
        };
        this.updateItemAge = (index) => {
          this.starts[index] = this.ttls[index] !== 0 ? perf.now() : 0;
        };
        let cachedNow = 0;
        const getNow = () => {
          const n = perf.now();
          if (this.ttlResolution > 0) {
            cachedNow = n;
            const t = setTimeout(
              () => cachedNow = 0,
              this.ttlResolution
            );
            if (t.unref) {
              t.unref();
            }
          }
          return n;
        };
        this.getRemainingTTL = (key) => {
          const index = this.keyMap.get(key);
          if (index === void 0) {
            return 0;
          }
          return this.ttls[index] === 0 || this.starts[index] === 0 ? Infinity : this.starts[index] + this.ttls[index] - (cachedNow || getNow());
        };
        this.isStale = (index) => {
          return this.ttls[index] !== 0 && this.starts[index] !== 0 && (cachedNow || getNow()) - this.starts[index] > this.ttls[index];
        };
      }
      updateItemAge(index) {
      }
      setItemTTL(index, ttl, start) {
      }
      isStale(index) {
        return false;
      }
      initializeSizeTracking() {
        this.calculatedSize = 0;
        this.sizes = new ZeroArray(this.max);
        this.removeItemSize = (index) => {
          this.calculatedSize -= this.sizes[index];
          this.sizes[index] = 0;
        };
        this.requireSize = (k, v, size, sizeCalculation) => {
          if (!isPosInt(size)) {
            if (sizeCalculation) {
              if (typeof sizeCalculation !== "function") {
                throw new TypeError("sizeCalculation must be a function");
              }
              size = sizeCalculation(v, k);
              if (!isPosInt(size)) {
                throw new TypeError(
                  "sizeCalculation return invalid (expect positive integer)"
                );
              }
            } else {
              throw new TypeError(
                "invalid size value (must be positive integer)"
              );
            }
          }
          return size;
        };
        this.addItemSize = (index, size) => {
          this.sizes[index] = size;
          const maxSize = this.maxSize - this.sizes[index];
          while (this.calculatedSize > maxSize) {
            this.evict(true);
          }
          this.calculatedSize += this.sizes[index];
        };
      }
      removeItemSize(index) {
      }
      addItemSize(index, size) {
      }
      requireSize(k, v, size, sizeCalculation) {
        if (size || sizeCalculation) {
          throw new TypeError(
            "cannot set size without setting maxSize on cache"
          );
        }
      }
      *indexes({ allowStale = this.allowStale } = {}) {
        if (this.size) {
          for (let i = this.tail; true; ) {
            if (!this.isValidIndex(i)) {
              break;
            }
            if (allowStale || !this.isStale(i)) {
              yield i;
            }
            if (i === this.head) {
              break;
            } else {
              i = this.prev[i];
            }
          }
        }
      }
      *rindexes({ allowStale = this.allowStale } = {}) {
        if (this.size) {
          for (let i = this.head; true; ) {
            if (!this.isValidIndex(i)) {
              break;
            }
            if (allowStale || !this.isStale(i)) {
              yield i;
            }
            if (i === this.tail) {
              break;
            } else {
              i = this.next[i];
            }
          }
        }
      }
      isValidIndex(index) {
        return this.keyMap.get(this.keyList[index]) === index;
      }
      *entries() {
        for (const i of this.indexes()) {
          yield [this.keyList[i], this.valList[i]];
        }
      }
      *rentries() {
        for (const i of this.rindexes()) {
          yield [this.keyList[i], this.valList[i]];
        }
      }
      *keys() {
        for (const i of this.indexes()) {
          yield this.keyList[i];
        }
      }
      *rkeys() {
        for (const i of this.rindexes()) {
          yield this.keyList[i];
        }
      }
      *values() {
        for (const i of this.indexes()) {
          yield this.valList[i];
        }
      }
      *rvalues() {
        for (const i of this.rindexes()) {
          yield this.valList[i];
        }
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      find(fn, getOptions = {}) {
        for (const i of this.indexes()) {
          if (fn(this.valList[i], this.keyList[i], this)) {
            return this.get(this.keyList[i], getOptions);
          }
        }
      }
      forEach(fn, thisp = this) {
        for (const i of this.indexes()) {
          fn.call(thisp, this.valList[i], this.keyList[i], this);
        }
      }
      rforEach(fn, thisp = this) {
        for (const i of this.rindexes()) {
          fn.call(thisp, this.valList[i], this.keyList[i], this);
        }
      }
      get prune() {
        deprecatedMethod("prune", "purgeStale");
        return this.purgeStale;
      }
      purgeStale() {
        let deleted = false;
        for (const i of this.rindexes({ allowStale: true })) {
          if (this.isStale(i)) {
            this.delete(this.keyList[i]);
            deleted = true;
          }
        }
        return deleted;
      }
      dump() {
        const arr = [];
        for (const i of this.indexes({ allowStale: true })) {
          const key = this.keyList[i];
          const v = this.valList[i];
          const value = this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;
          const entry = { value };
          if (this.ttls) {
            entry.ttl = this.ttls[i];
            const age = perf.now() - this.starts[i];
            entry.start = Math.floor(Date.now() - age);
          }
          if (this.sizes) {
            entry.size = this.sizes[i];
          }
          arr.unshift([key, entry]);
        }
        return arr;
      }
      load(arr) {
        this.clear();
        for (const [key, entry] of arr) {
          if (entry.start) {
            const age = Date.now() - entry.start;
            entry.start = perf.now() - age;
          }
          this.set(key, entry.value, entry);
        }
      }
      dispose(v, k, reason) {
      }
      set(k, v, {
        ttl = this.ttl,
        start,
        noDisposeOnSet = this.noDisposeOnSet,
        size = 0,
        sizeCalculation = this.sizeCalculation,
        noUpdateTTL = this.noUpdateTTL
      } = {}) {
        size = this.requireSize(k, v, size, sizeCalculation);
        if (this.maxSize && size > this.maxSize) {
          return this;
        }
        let index = this.size === 0 ? void 0 : this.keyMap.get(k);
        if (index === void 0) {
          index = this.newIndex();
          this.keyList[index] = k;
          this.valList[index] = v;
          this.keyMap.set(k, index);
          this.next[this.tail] = index;
          this.prev[index] = this.tail;
          this.tail = index;
          this.size++;
          this.addItemSize(index, size);
          noUpdateTTL = false;
        } else {
          const oldVal = this.valList[index];
          if (v !== oldVal) {
            if (this.isBackgroundFetch(oldVal)) {
              oldVal.__abortController.abort();
            } else {
              if (!noDisposeOnSet) {
                this.dispose(oldVal, k, "set");
                if (this.disposeAfter) {
                  this.disposed.push([oldVal, k, "set"]);
                }
              }
            }
            this.removeItemSize(index);
            this.valList[index] = v;
            this.addItemSize(index, size);
          }
          this.moveToTail(index);
        }
        if (ttl !== 0 && this.ttl === 0 && !this.ttls) {
          this.initializeTTLTracking();
        }
        if (!noUpdateTTL) {
          this.setItemTTL(index, ttl, start);
        }
        if (this.disposeAfter) {
          while (this.disposed.length) {
            this.disposeAfter(...this.disposed.shift());
          }
        }
        return this;
      }
      newIndex() {
        if (this.size === 0) {
          return this.tail;
        }
        if (this.size === this.max && this.max !== 0) {
          return this.evict(false);
        }
        if (this.free.length !== 0) {
          return this.free.pop();
        }
        return this.initialFill++;
      }
      pop() {
        if (this.size) {
          const val = this.valList[this.head];
          this.evict(true);
          return val;
        }
      }
      evict(free) {
        const head = this.head;
        const k = this.keyList[head];
        const v = this.valList[head];
        if (this.isBackgroundFetch(v)) {
          v.__abortController.abort();
        } else {
          this.dispose(v, k, "evict");
          if (this.disposeAfter) {
            this.disposed.push([v, k, "evict"]);
          }
        }
        this.removeItemSize(head);
        if (free) {
          this.keyList[head] = null;
          this.valList[head] = null;
          this.free.push(head);
        }
        this.head = this.next[head];
        this.keyMap.delete(k);
        this.size--;
        return head;
      }
      has(k, { updateAgeOnHas = this.updateAgeOnHas } = {}) {
        const index = this.keyMap.get(k);
        if (index !== void 0) {
          if (!this.isStale(index)) {
            if (updateAgeOnHas) {
              this.updateItemAge(index);
            }
            return true;
          }
        }
        return false;
      }
      // like get(), but without any LRU updating or TTL expiration
      peek(k, { allowStale = this.allowStale } = {}) {
        const index = this.keyMap.get(k);
        if (index !== void 0 && (allowStale || !this.isStale(index))) {
          const v = this.valList[index];
          return this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        }
      }
      backgroundFetch(k, index, options, context) {
        const v = index === void 0 ? void 0 : this.valList[index];
        if (this.isBackgroundFetch(v)) {
          return v;
        }
        const ac = new AC();
        const fetchOpts = {
          signal: ac.signal,
          options,
          context
        };
        const cb = (v2) => {
          if (!ac.signal.aborted) {
            this.set(k, v2, fetchOpts.options);
          }
          return v2;
        };
        const eb = (er) => {
          if (this.valList[index] === p) {
            const del = !options.noDeleteOnFetchRejection || p.__staleWhileFetching === void 0;
            if (del) {
              this.delete(k);
            } else {
              this.valList[index] = p.__staleWhileFetching;
            }
          }
          if (p.__returned === p) {
            throw er;
          }
        };
        const pcall = (res) => res(this.fetchMethod(k, v, fetchOpts));
        const p = new Promise(pcall).then(cb, eb);
        p.__abortController = ac;
        p.__staleWhileFetching = v;
        p.__returned = null;
        if (index === void 0) {
          this.set(k, p, fetchOpts.options);
          index = this.keyMap.get(k);
        } else {
          this.valList[index] = p;
        }
        return p;
      }
      isBackgroundFetch(p) {
        return p && typeof p === "object" && typeof p.then === "function" && Object.prototype.hasOwnProperty.call(
          p,
          "__staleWhileFetching"
        ) && Object.prototype.hasOwnProperty.call(p, "__returned") && (p.__returned === p || p.__returned === null);
      }
      // this takes the union of get() and set() opts, because it does both
      async fetch(k, {
        // get options
        allowStale = this.allowStale,
        updateAgeOnGet = this.updateAgeOnGet,
        noDeleteOnStaleGet = this.noDeleteOnStaleGet,
        // set options
        ttl = this.ttl,
        noDisposeOnSet = this.noDisposeOnSet,
        size = 0,
        sizeCalculation = this.sizeCalculation,
        noUpdateTTL = this.noUpdateTTL,
        // fetch exclusive options
        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
        fetchContext = this.fetchContext,
        forceRefresh = false
      } = {}) {
        if (!this.fetchMethod) {
          return this.get(k, {
            allowStale,
            updateAgeOnGet,
            noDeleteOnStaleGet
          });
        }
        const options = {
          allowStale,
          updateAgeOnGet,
          noDeleteOnStaleGet,
          ttl,
          noDisposeOnSet,
          size,
          sizeCalculation,
          noUpdateTTL,
          noDeleteOnFetchRejection
        };
        let index = this.keyMap.get(k);
        if (index === void 0) {
          const p = this.backgroundFetch(k, index, options, fetchContext);
          return p.__returned = p;
        } else {
          const v = this.valList[index];
          if (this.isBackgroundFetch(v)) {
            return allowStale && v.__staleWhileFetching !== void 0 ? v.__staleWhileFetching : v.__returned = v;
          }
          if (!forceRefresh && !this.isStale(index)) {
            this.moveToTail(index);
            if (updateAgeOnGet) {
              this.updateItemAge(index);
            }
            return v;
          }
          const p = this.backgroundFetch(k, index, options, fetchContext);
          return allowStale && p.__staleWhileFetching !== void 0 ? p.__staleWhileFetching : p.__returned = p;
        }
      }
      get(k, {
        allowStale = this.allowStale,
        updateAgeOnGet = this.updateAgeOnGet,
        noDeleteOnStaleGet = this.noDeleteOnStaleGet
      } = {}) {
        const index = this.keyMap.get(k);
        if (index !== void 0) {
          const value = this.valList[index];
          const fetching = this.isBackgroundFetch(value);
          if (this.isStale(index)) {
            if (!fetching) {
              if (!noDeleteOnStaleGet) {
                this.delete(k);
              }
              return allowStale ? value : void 0;
            } else {
              return allowStale ? value.__staleWhileFetching : void 0;
            }
          } else {
            if (fetching) {
              return void 0;
            }
            this.moveToTail(index);
            if (updateAgeOnGet) {
              this.updateItemAge(index);
            }
            return value;
          }
        }
      }
      connect(p, n) {
        this.prev[n] = p;
        this.next[p] = n;
      }
      moveToTail(index) {
        if (index !== this.tail) {
          if (index === this.head) {
            this.head = this.next[index];
          } else {
            this.connect(this.prev[index], this.next[index]);
          }
          this.connect(this.tail, index);
          this.tail = index;
        }
      }
      get del() {
        deprecatedMethod("del", "delete");
        return this.delete;
      }
      delete(k) {
        let deleted = false;
        if (this.size !== 0) {
          const index = this.keyMap.get(k);
          if (index !== void 0) {
            deleted = true;
            if (this.size === 1) {
              this.clear();
            } else {
              this.removeItemSize(index);
              const v = this.valList[index];
              if (this.isBackgroundFetch(v)) {
                v.__abortController.abort();
              } else {
                this.dispose(v, k, "delete");
                if (this.disposeAfter) {
                  this.disposed.push([v, k, "delete"]);
                }
              }
              this.keyMap.delete(k);
              this.keyList[index] = null;
              this.valList[index] = null;
              if (index === this.tail) {
                this.tail = this.prev[index];
              } else if (index === this.head) {
                this.head = this.next[index];
              } else {
                this.next[this.prev[index]] = this.next[index];
                this.prev[this.next[index]] = this.prev[index];
              }
              this.size--;
              this.free.push(index);
            }
          }
        }
        if (this.disposed) {
          while (this.disposed.length) {
            this.disposeAfter(...this.disposed.shift());
          }
        }
        return deleted;
      }
      clear() {
        for (const index of this.rindexes({ allowStale: true })) {
          const v = this.valList[index];
          if (this.isBackgroundFetch(v)) {
            v.__abortController.abort();
          } else {
            const k = this.keyList[index];
            this.dispose(v, k, "delete");
            if (this.disposeAfter) {
              this.disposed.push([v, k, "delete"]);
            }
          }
        }
        this.keyMap.clear();
        this.valList.fill(null);
        this.keyList.fill(null);
        if (this.ttls) {
          this.ttls.fill(0);
          this.starts.fill(0);
        }
        if (this.sizes) {
          this.sizes.fill(0);
        }
        this.head = 0;
        this.tail = 0;
        this.initialFill = 1;
        this.free.length = 0;
        this.calculatedSize = 0;
        this.size = 0;
        if (this.disposed) {
          while (this.disposed.length) {
            this.disposeAfter(...this.disposed.shift());
          }
        }
      }
      get reset() {
        deprecatedMethod("reset", "clear");
        return this.clear;
      }
      get length() {
        deprecatedProperty("length", "size");
        return this.size;
      }
      static get AbortController() {
        return AC;
      }
      static get AbortSignal() {
        return AS;
      }
    };
    module2.exports = LRUCache;
  }
});

// ../../../node_modules/@apollo/utils.keyvaluecache/dist/InMemoryLRUCache.js
var require_InMemoryLRUCache = __commonJS({
  "../../../node_modules/@apollo/utils.keyvaluecache/dist/InMemoryLRUCache.js"(exports2) {
    "use strict";
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InMemoryLRUCache = void 0;
    var lru_cache_1 = __importDefault2(require_lru_cache());
    var InMemoryLRUCache = class _InMemoryLRUCache {
      constructor(lruCacheOpts) {
        this.cache = new lru_cache_1.default({
          sizeCalculation: _InMemoryLRUCache.sizeCalculation,
          maxSize: Math.pow(2, 20) * 30,
          ...lruCacheOpts
        });
      }
      static sizeCalculation(item) {
        if (typeof item === "string") {
          return item.length;
        }
        if (typeof item === "object") {
          return Buffer.byteLength(JSON.stringify(item), "utf8");
        }
        return 1;
      }
      async set(key, value, options) {
        if (options === null || options === void 0 ? void 0 : options.ttl) {
          this.cache.set(key, value, { ttl: options.ttl * 1e3 });
        } else {
          this.cache.set(key, value);
        }
      }
      async get(key) {
        return this.cache.get(key);
      }
      async delete(key) {
        return this.cache.delete(key);
      }
      clear() {
        this.cache.clear();
      }
      keys() {
        return [...this.cache.keys()];
      }
    };
    exports2.InMemoryLRUCache = InMemoryLRUCache;
  }
});

// ../../../node_modules/@apollo/utils.keyvaluecache/dist/ErrorsAreMissesCache.js
var require_ErrorsAreMissesCache = __commonJS({
  "../../../node_modules/@apollo/utils.keyvaluecache/dist/ErrorsAreMissesCache.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ErrorsAreMissesCache = void 0;
    var ErrorsAreMissesCache = class {
      constructor(cache, logger) {
        this.cache = cache;
        this.logger = logger;
      }
      async get(key) {
        try {
          return await this.cache.get(key);
        } catch (e) {
          if (this.logger) {
            if (e instanceof Error) {
              this.logger.error(e.message);
            } else {
              this.logger.error(e);
            }
          }
          return void 0;
        }
      }
      async set(key, value, opts) {
        return this.cache.set(key, value, opts);
      }
      async delete(key) {
        return this.cache.delete(key);
      }
    };
    exports2.ErrorsAreMissesCache = ErrorsAreMissesCache;
  }
});

// ../../../node_modules/@apollo/utils.keyvaluecache/dist/index.js
var require_dist3 = __commonJS({
  "../../../node_modules/@apollo/utils.keyvaluecache/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ErrorsAreMissesCache = exports2.InMemoryLRUCache = exports2.PrefixingKeyValueCache = void 0;
    var PrefixingKeyValueCache_1 = require_PrefixingKeyValueCache();
    Object.defineProperty(exports2, "PrefixingKeyValueCache", { enumerable: true, get: function() {
      return PrefixingKeyValueCache_1.PrefixingKeyValueCache;
    } });
    var InMemoryLRUCache_1 = require_InMemoryLRUCache();
    Object.defineProperty(exports2, "InMemoryLRUCache", { enumerable: true, get: function() {
      return InMemoryLRUCache_1.InMemoryLRUCache;
    } });
    var ErrorsAreMissesCache_1 = require_ErrorsAreMissesCache();
    Object.defineProperty(exports2, "ErrorsAreMissesCache", { enumerable: true, get: function() {
      return ErrorsAreMissesCache_1.ErrorsAreMissesCache;
    } });
  }
});

// ../../../node_modules/apollo-server-core/dist/utils/isNodeLike.js
var require_isNodeLike = __commonJS({
  "../../../node_modules/apollo-server-core/dist/utils/isNodeLike.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = typeof process === "object" && process && process.release && process.versions && typeof process.versions.node === "string";
  }
});

// browser-external:crypto
var require_crypto = __commonJS({
  "browser-external:crypto"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "crypto" has been externalized for browser compatibility. Cannot access "crypto.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// ../../../node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "../../../node_modules/inherits/inherits_browser.js"(exports2, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// browser-external:buffer
var require_buffer = __commonJS({
  "browser-external:buffer"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "buffer" has been externalized for browser compatibility. Cannot access "buffer.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// ../../../node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "../../../node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer = require_buffer();
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// ../../../node_modules/sha.js/hash.js
var require_hash = __commonJS({
  "../../../node_modules/sha.js/hash.js"(exports2, module2) {
    var Buffer2 = require_safe_buffer().Buffer;
    function Hash(blockSize, finalSize) {
      this._block = Buffer2.alloc(blockSize);
      this._finalSize = finalSize;
      this._blockSize = blockSize;
      this._len = 0;
    }
    Hash.prototype.update = function(data, enc) {
      if (typeof data === "string") {
        enc = enc || "utf8";
        data = Buffer2.from(data, enc);
      }
      var block2 = this._block;
      var blockSize = this._blockSize;
      var length = data.length;
      var accum = this._len;
      for (var offset = 0; offset < length; ) {
        var assigned = accum % blockSize;
        var remainder = Math.min(length - offset, blockSize - assigned);
        for (var i = 0; i < remainder; i++) {
          block2[assigned + i] = data[offset + i];
        }
        accum += remainder;
        offset += remainder;
        if (accum % blockSize === 0) {
          this._update(block2);
        }
      }
      this._len += length;
      return this;
    };
    Hash.prototype.digest = function(enc) {
      var rem = this._len % this._blockSize;
      this._block[rem] = 128;
      this._block.fill(0, rem + 1);
      if (rem >= this._finalSize) {
        this._update(this._block);
        this._block.fill(0);
      }
      var bits = this._len * 8;
      if (bits <= 4294967295) {
        this._block.writeUInt32BE(bits, this._blockSize - 4);
      } else {
        var lowBits = (bits & 4294967295) >>> 0;
        var highBits = (bits - lowBits) / 4294967296;
        this._block.writeUInt32BE(highBits, this._blockSize - 8);
        this._block.writeUInt32BE(lowBits, this._blockSize - 4);
      }
      this._update(this._block);
      var hash = this._hash();
      return enc ? hash.toString(enc) : hash;
    };
    Hash.prototype._update = function() {
      throw new Error("_update must be implemented by subclass");
    };
    module2.exports = Hash;
  }
});

// ../../../node_modules/sha.js/sha.js
var require_sha = __commonJS({
  "../../../node_modules/sha.js/sha.js"(exports2, module2) {
    var inherits = require_inherits_browser();
    var Hash = require_hash();
    var Buffer2 = require_safe_buffer().Buffer;
    var K = [
      1518500249,
      1859775393,
      2400959708 | 0,
      3395469782 | 0
    ];
    var W = new Array(80);
    function Sha() {
      this.init();
      this._w = W;
      Hash.call(this, 64, 56);
    }
    inherits(Sha, Hash);
    Sha.prototype.init = function() {
      this._a = 1732584193;
      this._b = 4023233417;
      this._c = 2562383102;
      this._d = 271733878;
      this._e = 3285377520;
      return this;
    };
    function rotl5(num) {
      return num << 5 | num >>> 27;
    }
    function rotl30(num) {
      return num << 30 | num >>> 2;
    }
    function ft(s, b, c, d) {
      if (s === 0)
        return b & c | ~b & d;
      if (s === 2)
        return b & c | b & d | c & d;
      return b ^ c ^ d;
    }
    Sha.prototype._update = function(M) {
      var W2 = this._w;
      var a = this._a | 0;
      var b = this._b | 0;
      var c = this._c | 0;
      var d = this._d | 0;
      var e = this._e | 0;
      for (var i = 0; i < 16; ++i)
        W2[i] = M.readInt32BE(i * 4);
      for (; i < 80; ++i)
        W2[i] = W2[i - 3] ^ W2[i - 8] ^ W2[i - 14] ^ W2[i - 16];
      for (var j = 0; j < 80; ++j) {
        var s = ~~(j / 20);
        var t = rotl5(a) + ft(s, b, c, d) + e + W2[j] + K[s] | 0;
        e = d;
        d = c;
        c = rotl30(b);
        b = a;
        a = t;
      }
      this._a = a + this._a | 0;
      this._b = b + this._b | 0;
      this._c = c + this._c | 0;
      this._d = d + this._d | 0;
      this._e = e + this._e | 0;
    };
    Sha.prototype._hash = function() {
      var H = Buffer2.allocUnsafe(20);
      H.writeInt32BE(this._a | 0, 0);
      H.writeInt32BE(this._b | 0, 4);
      H.writeInt32BE(this._c | 0, 8);
      H.writeInt32BE(this._d | 0, 12);
      H.writeInt32BE(this._e | 0, 16);
      return H;
    };
    module2.exports = Sha;
  }
});

// ../../../node_modules/sha.js/sha1.js
var require_sha1 = __commonJS({
  "../../../node_modules/sha.js/sha1.js"(exports2, module2) {
    var inherits = require_inherits_browser();
    var Hash = require_hash();
    var Buffer2 = require_safe_buffer().Buffer;
    var K = [
      1518500249,
      1859775393,
      2400959708 | 0,
      3395469782 | 0
    ];
    var W = new Array(80);
    function Sha1() {
      this.init();
      this._w = W;
      Hash.call(this, 64, 56);
    }
    inherits(Sha1, Hash);
    Sha1.prototype.init = function() {
      this._a = 1732584193;
      this._b = 4023233417;
      this._c = 2562383102;
      this._d = 271733878;
      this._e = 3285377520;
      return this;
    };
    function rotl1(num) {
      return num << 1 | num >>> 31;
    }
    function rotl5(num) {
      return num << 5 | num >>> 27;
    }
    function rotl30(num) {
      return num << 30 | num >>> 2;
    }
    function ft(s, b, c, d) {
      if (s === 0)
        return b & c | ~b & d;
      if (s === 2)
        return b & c | b & d | c & d;
      return b ^ c ^ d;
    }
    Sha1.prototype._update = function(M) {
      var W2 = this._w;
      var a = this._a | 0;
      var b = this._b | 0;
      var c = this._c | 0;
      var d = this._d | 0;
      var e = this._e | 0;
      for (var i = 0; i < 16; ++i)
        W2[i] = M.readInt32BE(i * 4);
      for (; i < 80; ++i)
        W2[i] = rotl1(W2[i - 3] ^ W2[i - 8] ^ W2[i - 14] ^ W2[i - 16]);
      for (var j = 0; j < 80; ++j) {
        var s = ~~(j / 20);
        var t = rotl5(a) + ft(s, b, c, d) + e + W2[j] + K[s] | 0;
        e = d;
        d = c;
        c = rotl30(b);
        b = a;
        a = t;
      }
      this._a = a + this._a | 0;
      this._b = b + this._b | 0;
      this._c = c + this._c | 0;
      this._d = d + this._d | 0;
      this._e = e + this._e | 0;
    };
    Sha1.prototype._hash = function() {
      var H = Buffer2.allocUnsafe(20);
      H.writeInt32BE(this._a | 0, 0);
      H.writeInt32BE(this._b | 0, 4);
      H.writeInt32BE(this._c | 0, 8);
      H.writeInt32BE(this._d | 0, 12);
      H.writeInt32BE(this._e | 0, 16);
      return H;
    };
    module2.exports = Sha1;
  }
});

// ../../../node_modules/sha.js/sha256.js
var require_sha256 = __commonJS({
  "../../../node_modules/sha.js/sha256.js"(exports2, module2) {
    var inherits = require_inherits_browser();
    var Hash = require_hash();
    var Buffer2 = require_safe_buffer().Buffer;
    var K = [
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ];
    var W = new Array(64);
    function Sha256() {
      this.init();
      this._w = W;
      Hash.call(this, 64, 56);
    }
    inherits(Sha256, Hash);
    Sha256.prototype.init = function() {
      this._a = 1779033703;
      this._b = 3144134277;
      this._c = 1013904242;
      this._d = 2773480762;
      this._e = 1359893119;
      this._f = 2600822924;
      this._g = 528734635;
      this._h = 1541459225;
      return this;
    };
    function ch(x, y, z) {
      return z ^ x & (y ^ z);
    }
    function maj(x, y, z) {
      return x & y | z & (x | y);
    }
    function sigma0(x) {
      return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10);
    }
    function sigma1(x) {
      return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7);
    }
    function gamma0(x) {
      return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ x >>> 3;
    }
    function gamma1(x) {
      return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ x >>> 10;
    }
    Sha256.prototype._update = function(M) {
      var W2 = this._w;
      var a = this._a | 0;
      var b = this._b | 0;
      var c = this._c | 0;
      var d = this._d | 0;
      var e = this._e | 0;
      var f = this._f | 0;
      var g = this._g | 0;
      var h = this._h | 0;
      for (var i = 0; i < 16; ++i)
        W2[i] = M.readInt32BE(i * 4);
      for (; i < 64; ++i)
        W2[i] = gamma1(W2[i - 2]) + W2[i - 7] + gamma0(W2[i - 15]) + W2[i - 16] | 0;
      for (var j = 0; j < 64; ++j) {
        var T1 = h + sigma1(e) + ch(e, f, g) + K[j] + W2[j] | 0;
        var T2 = sigma0(a) + maj(a, b, c) | 0;
        h = g;
        g = f;
        f = e;
        e = d + T1 | 0;
        d = c;
        c = b;
        b = a;
        a = T1 + T2 | 0;
      }
      this._a = a + this._a | 0;
      this._b = b + this._b | 0;
      this._c = c + this._c | 0;
      this._d = d + this._d | 0;
      this._e = e + this._e | 0;
      this._f = f + this._f | 0;
      this._g = g + this._g | 0;
      this._h = h + this._h | 0;
    };
    Sha256.prototype._hash = function() {
      var H = Buffer2.allocUnsafe(32);
      H.writeInt32BE(this._a, 0);
      H.writeInt32BE(this._b, 4);
      H.writeInt32BE(this._c, 8);
      H.writeInt32BE(this._d, 12);
      H.writeInt32BE(this._e, 16);
      H.writeInt32BE(this._f, 20);
      H.writeInt32BE(this._g, 24);
      H.writeInt32BE(this._h, 28);
      return H;
    };
    module2.exports = Sha256;
  }
});

// ../../../node_modules/sha.js/sha224.js
var require_sha224 = __commonJS({
  "../../../node_modules/sha.js/sha224.js"(exports2, module2) {
    var inherits = require_inherits_browser();
    var Sha256 = require_sha256();
    var Hash = require_hash();
    var Buffer2 = require_safe_buffer().Buffer;
    var W = new Array(64);
    function Sha224() {
      this.init();
      this._w = W;
      Hash.call(this, 64, 56);
    }
    inherits(Sha224, Sha256);
    Sha224.prototype.init = function() {
      this._a = 3238371032;
      this._b = 914150663;
      this._c = 812702999;
      this._d = 4144912697;
      this._e = 4290775857;
      this._f = 1750603025;
      this._g = 1694076839;
      this._h = 3204075428;
      return this;
    };
    Sha224.prototype._hash = function() {
      var H = Buffer2.allocUnsafe(28);
      H.writeInt32BE(this._a, 0);
      H.writeInt32BE(this._b, 4);
      H.writeInt32BE(this._c, 8);
      H.writeInt32BE(this._d, 12);
      H.writeInt32BE(this._e, 16);
      H.writeInt32BE(this._f, 20);
      H.writeInt32BE(this._g, 24);
      return H;
    };
    module2.exports = Sha224;
  }
});

// ../../../node_modules/sha.js/sha512.js
var require_sha512 = __commonJS({
  "../../../node_modules/sha.js/sha512.js"(exports2, module2) {
    var inherits = require_inherits_browser();
    var Hash = require_hash();
    var Buffer2 = require_safe_buffer().Buffer;
    var K = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    var W = new Array(160);
    function Sha512() {
      this.init();
      this._w = W;
      Hash.call(this, 128, 112);
    }
    inherits(Sha512, Hash);
    Sha512.prototype.init = function() {
      this._ah = 1779033703;
      this._bh = 3144134277;
      this._ch = 1013904242;
      this._dh = 2773480762;
      this._eh = 1359893119;
      this._fh = 2600822924;
      this._gh = 528734635;
      this._hh = 1541459225;
      this._al = 4089235720;
      this._bl = 2227873595;
      this._cl = 4271175723;
      this._dl = 1595750129;
      this._el = 2917565137;
      this._fl = 725511199;
      this._gl = 4215389547;
      this._hl = 327033209;
      return this;
    };
    function Ch(x, y, z) {
      return z ^ x & (y ^ z);
    }
    function maj(x, y, z) {
      return x & y | z & (x | y);
    }
    function sigma0(x, xl) {
      return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25);
    }
    function sigma1(x, xl) {
      return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23);
    }
    function Gamma0(x, xl) {
      return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ x >>> 7;
    }
    function Gamma0l(x, xl) {
      return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25);
    }
    function Gamma1(x, xl) {
      return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ x >>> 6;
    }
    function Gamma1l(x, xl) {
      return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26);
    }
    function getCarry(a, b) {
      return a >>> 0 < b >>> 0 ? 1 : 0;
    }
    Sha512.prototype._update = function(M) {
      var W2 = this._w;
      var ah = this._ah | 0;
      var bh = this._bh | 0;
      var ch = this._ch | 0;
      var dh = this._dh | 0;
      var eh = this._eh | 0;
      var fh = this._fh | 0;
      var gh = this._gh | 0;
      var hh = this._hh | 0;
      var al = this._al | 0;
      var bl = this._bl | 0;
      var cl = this._cl | 0;
      var dl = this._dl | 0;
      var el = this._el | 0;
      var fl = this._fl | 0;
      var gl = this._gl | 0;
      var hl = this._hl | 0;
      for (var i = 0; i < 32; i += 2) {
        W2[i] = M.readInt32BE(i * 4);
        W2[i + 1] = M.readInt32BE(i * 4 + 4);
      }
      for (; i < 160; i += 2) {
        var xh = W2[i - 15 * 2];
        var xl = W2[i - 15 * 2 + 1];
        var gamma0 = Gamma0(xh, xl);
        var gamma0l = Gamma0l(xl, xh);
        xh = W2[i - 2 * 2];
        xl = W2[i - 2 * 2 + 1];
        var gamma1 = Gamma1(xh, xl);
        var gamma1l = Gamma1l(xl, xh);
        var Wi7h = W2[i - 7 * 2];
        var Wi7l = W2[i - 7 * 2 + 1];
        var Wi16h = W2[i - 16 * 2];
        var Wi16l = W2[i - 16 * 2 + 1];
        var Wil = gamma0l + Wi7l | 0;
        var Wih = gamma0 + Wi7h + getCarry(Wil, gamma0l) | 0;
        Wil = Wil + gamma1l | 0;
        Wih = Wih + gamma1 + getCarry(Wil, gamma1l) | 0;
        Wil = Wil + Wi16l | 0;
        Wih = Wih + Wi16h + getCarry(Wil, Wi16l) | 0;
        W2[i] = Wih;
        W2[i + 1] = Wil;
      }
      for (var j = 0; j < 160; j += 2) {
        Wih = W2[j];
        Wil = W2[j + 1];
        var majh = maj(ah, bh, ch);
        var majl = maj(al, bl, cl);
        var sigma0h = sigma0(ah, al);
        var sigma0l = sigma0(al, ah);
        var sigma1h = sigma1(eh, el);
        var sigma1l = sigma1(el, eh);
        var Kih = K[j];
        var Kil = K[j + 1];
        var chh = Ch(eh, fh, gh);
        var chl = Ch(el, fl, gl);
        var t1l = hl + sigma1l | 0;
        var t1h = hh + sigma1h + getCarry(t1l, hl) | 0;
        t1l = t1l + chl | 0;
        t1h = t1h + chh + getCarry(t1l, chl) | 0;
        t1l = t1l + Kil | 0;
        t1h = t1h + Kih + getCarry(t1l, Kil) | 0;
        t1l = t1l + Wil | 0;
        t1h = t1h + Wih + getCarry(t1l, Wil) | 0;
        var t2l = sigma0l + majl | 0;
        var t2h = sigma0h + majh + getCarry(t2l, sigma0l) | 0;
        hh = gh;
        hl = gl;
        gh = fh;
        gl = fl;
        fh = eh;
        fl = el;
        el = dl + t1l | 0;
        eh = dh + t1h + getCarry(el, dl) | 0;
        dh = ch;
        dl = cl;
        ch = bh;
        cl = bl;
        bh = ah;
        bl = al;
        al = t1l + t2l | 0;
        ah = t1h + t2h + getCarry(al, t1l) | 0;
      }
      this._al = this._al + al | 0;
      this._bl = this._bl + bl | 0;
      this._cl = this._cl + cl | 0;
      this._dl = this._dl + dl | 0;
      this._el = this._el + el | 0;
      this._fl = this._fl + fl | 0;
      this._gl = this._gl + gl | 0;
      this._hl = this._hl + hl | 0;
      this._ah = this._ah + ah + getCarry(this._al, al) | 0;
      this._bh = this._bh + bh + getCarry(this._bl, bl) | 0;
      this._ch = this._ch + ch + getCarry(this._cl, cl) | 0;
      this._dh = this._dh + dh + getCarry(this._dl, dl) | 0;
      this._eh = this._eh + eh + getCarry(this._el, el) | 0;
      this._fh = this._fh + fh + getCarry(this._fl, fl) | 0;
      this._gh = this._gh + gh + getCarry(this._gl, gl) | 0;
      this._hh = this._hh + hh + getCarry(this._hl, hl) | 0;
    };
    Sha512.prototype._hash = function() {
      var H = Buffer2.allocUnsafe(64);
      function writeInt64BE(h, l, offset) {
        H.writeInt32BE(h, offset);
        H.writeInt32BE(l, offset + 4);
      }
      writeInt64BE(this._ah, this._al, 0);
      writeInt64BE(this._bh, this._bl, 8);
      writeInt64BE(this._ch, this._cl, 16);
      writeInt64BE(this._dh, this._dl, 24);
      writeInt64BE(this._eh, this._el, 32);
      writeInt64BE(this._fh, this._fl, 40);
      writeInt64BE(this._gh, this._gl, 48);
      writeInt64BE(this._hh, this._hl, 56);
      return H;
    };
    module2.exports = Sha512;
  }
});

// ../../../node_modules/sha.js/sha384.js
var require_sha384 = __commonJS({
  "../../../node_modules/sha.js/sha384.js"(exports2, module2) {
    var inherits = require_inherits_browser();
    var SHA512 = require_sha512();
    var Hash = require_hash();
    var Buffer2 = require_safe_buffer().Buffer;
    var W = new Array(160);
    function Sha384() {
      this.init();
      this._w = W;
      Hash.call(this, 128, 112);
    }
    inherits(Sha384, SHA512);
    Sha384.prototype.init = function() {
      this._ah = 3418070365;
      this._bh = 1654270250;
      this._ch = 2438529370;
      this._dh = 355462360;
      this._eh = 1731405415;
      this._fh = 2394180231;
      this._gh = 3675008525;
      this._hh = 1203062813;
      this._al = 3238371032;
      this._bl = 914150663;
      this._cl = 812702999;
      this._dl = 4144912697;
      this._el = 4290775857;
      this._fl = 1750603025;
      this._gl = 1694076839;
      this._hl = 3204075428;
      return this;
    };
    Sha384.prototype._hash = function() {
      var H = Buffer2.allocUnsafe(48);
      function writeInt64BE(h, l, offset) {
        H.writeInt32BE(h, offset);
        H.writeInt32BE(l, offset + 4);
      }
      writeInt64BE(this._ah, this._al, 0);
      writeInt64BE(this._bh, this._bl, 8);
      writeInt64BE(this._ch, this._cl, 16);
      writeInt64BE(this._dh, this._dl, 24);
      writeInt64BE(this._eh, this._el, 32);
      writeInt64BE(this._fh, this._fl, 40);
      return H;
    };
    module2.exports = Sha384;
  }
});

// ../../../node_modules/sha.js/index.js
var require_sha2 = __commonJS({
  "../../../node_modules/sha.js/index.js"(exports2, module2) {
    var exports2 = module2.exports = function SHA(algorithm) {
      algorithm = algorithm.toLowerCase();
      var Algorithm = exports2[algorithm];
      if (!Algorithm)
        throw new Error(algorithm + " is not supported (we accept pull requests)");
      return new Algorithm();
    };
    exports2.sha = require_sha();
    exports2.sha1 = require_sha1();
    exports2.sha224 = require_sha224();
    exports2.sha256 = require_sha256();
    exports2.sha384 = require_sha384();
    exports2.sha512 = require_sha512();
  }
});

// ../../../node_modules/apollo-server-core/dist/utils/createSHA.js
var require_createSHA = __commonJS({
  "../../../node_modules/apollo-server-core/dist/utils/createSHA.js"(exports2) {
    "use strict";
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var isNodeLike_1 = __importDefault2(require_isNodeLike());
    function default_1(kind) {
      if (isNodeLike_1.default) {
        return require_crypto().createHash(kind);
      }
      return require_sha2()(kind);
    }
    exports2.default = default_1;
  }
});

// ../../../node_modules/apollo-server-core/dist/requestPipeline.js
var require_requestPipeline = __commonJS({
  "../../../node_modules/apollo-server-core/dist/requestPipeline.js"(exports2) {
    "use strict";
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.processGraphQLRequest = exports2.APQ_CACHE_PREFIX = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var schemaInstrumentation_1 = require_schemaInstrumentation();
    var apollo_server_errors_1 = require_dist();
    var dispatcher_1 = require_dispatcher();
    var utils_keyvaluecache_1 = require_dist3();
    var createSHA_1 = __importDefault2(require_createSHA());
    var runHttpQuery_1 = require_runHttpQuery();
    var apollo_server_env_1 = require_index_browser();
    exports2.APQ_CACHE_PREFIX = "apq:";
    function computeQueryHash(query) {
      return (0, createSHA_1.default)("sha256").update(query).digest("hex");
    }
    function isBadUserInputGraphQLError(error) {
      var _a;
      return ((_a = error.nodes) === null || _a === void 0 ? void 0 : _a.length) === 1 && error.nodes[0].kind === graphql_1.Kind.VARIABLE_DEFINITION && (error.message.startsWith(`Variable "$${error.nodes[0].variable.name.value}" got invalid value `) || error.message.startsWith(`Variable "$${error.nodes[0].variable.name.value}" of required type `) || error.message.startsWith(`Variable "$${error.nodes[0].variable.name.value}" of non-null type `));
    }
    async function processGraphQLRequest(config, requestContext) {
      var _a, _b;
      const logger = requestContext.logger || console;
      const metrics = requestContext.metrics = requestContext.metrics || /* @__PURE__ */ Object.create(null);
      const dispatcher = await initializeRequestListenerDispatcher();
      await initializeDataSources();
      const request = requestContext.request;
      let { query, extensions } = request;
      let queryHash;
      let persistedQueryCache;
      metrics.persistedQueryHit = false;
      metrics.persistedQueryRegister = false;
      if (extensions === null || extensions === void 0 ? void 0 : extensions.persistedQuery) {
        if (!config.persistedQueries || !config.persistedQueries.cache) {
          return await sendErrorResponse(new apollo_server_errors_1.PersistedQueryNotSupportedError());
        } else if (extensions.persistedQuery.version !== 1) {
          return await sendErrorResponse(new graphql_1.GraphQLError("Unsupported persisted query version"));
        }
        persistedQueryCache = config.persistedQueries.cache;
        if (!(persistedQueryCache instanceof utils_keyvaluecache_1.PrefixingKeyValueCache)) {
          persistedQueryCache = new utils_keyvaluecache_1.PrefixingKeyValueCache(persistedQueryCache, exports2.APQ_CACHE_PREFIX);
        }
        queryHash = extensions.persistedQuery.sha256Hash;
        if (query === void 0) {
          query = await persistedQueryCache.get(queryHash);
          if (query) {
            metrics.persistedQueryHit = true;
          } else {
            return await sendErrorResponse(new apollo_server_errors_1.PersistedQueryNotFoundError());
          }
        } else {
          const computedQueryHash = computeQueryHash(query);
          if (queryHash !== computedQueryHash) {
            return await sendErrorResponse(new graphql_1.GraphQLError("provided sha does not match query"));
          }
          metrics.persistedQueryRegister = true;
        }
      } else if (query) {
        queryHash = computeQueryHash(query);
      } else {
        return await sendErrorResponse(new graphql_1.GraphQLError("GraphQL operations must contain a non-empty `query` or a `persistedQuery` extension."));
      }
      requestContext.queryHash = queryHash;
      requestContext.source = query;
      await dispatcher.invokeHook("didResolveSource", requestContext);
      if (config.documentStore) {
        try {
          requestContext.document = await config.documentStore.get(queryHash);
        } catch (err) {
          logger.warn("An error occurred while attempting to read from the documentStore. " + (err === null || err === void 0 ? void 0 : err.message) || err);
        }
      }
      if (!requestContext.document) {
        const parsingDidEnd = await dispatcher.invokeDidStartHook("parsingDidStart", requestContext);
        try {
          requestContext.document = parse2(query, config.parseOptions);
          await parsingDidEnd();
        } catch (syntaxError2) {
          await parsingDidEnd(syntaxError2);
          return await sendErrorResponse(syntaxError2, apollo_server_errors_1.SyntaxError);
        }
        const validationDidEnd = await dispatcher.invokeDidStartHook("validationDidStart", requestContext);
        const validationErrors = validate2(requestContext.document);
        if (validationErrors.length === 0) {
          await validationDidEnd();
        } else {
          await validationDidEnd(validationErrors);
          return await sendErrorResponse(validationErrors, apollo_server_errors_1.ValidationError);
        }
        if (config.documentStore) {
          Promise.resolve(config.documentStore.set(queryHash, requestContext.document)).catch((err) => logger.warn("Could not store validated document. " + (err === null || err === void 0 ? void 0 : err.message) || err));
        }
      }
      const operation = (0, graphql_1.getOperationAST)(requestContext.document, request.operationName);
      requestContext.operation = operation || void 0;
      requestContext.operationName = ((_a = operation === null || operation === void 0 ? void 0 : operation.name) === null || _a === void 0 ? void 0 : _a.value) || null;
      try {
        await dispatcher.invokeHook("didResolveOperation", requestContext);
      } catch (err) {
        return await sendErrorResponse(err);
      }
      if (metrics.persistedQueryRegister && persistedQueryCache) {
        Promise.resolve(persistedQueryCache.set(queryHash, query, config.persistedQueries && typeof config.persistedQueries.ttl !== "undefined" ? {
          ttl: config.persistedQueries.ttl
        } : /* @__PURE__ */ Object.create(null))).catch(logger.warn);
      }
      let response = await dispatcher.invokeHooksUntilNonNull("responseForOperation", requestContext);
      if (response == null) {
        const executionListeners = [];
        (await dispatcher.invokeHook("executionDidStart", requestContext)).forEach((executionListener) => {
          if (executionListener) {
            executionListeners.push(executionListener);
          }
        });
        executionListeners.reverse();
        const executionDispatcher = new dispatcher_1.Dispatcher(executionListeners);
        if (executionDispatcher.hasHook("willResolveField")) {
          const invokeWillResolveField = (...args) => executionDispatcher.invokeSyncDidStartHook("willResolveField", ...args);
          Object.defineProperty(requestContext.context, schemaInstrumentation_1.symbolExecutionDispatcherWillResolveField, { value: invokeWillResolveField });
          if (config.fieldResolver) {
            Object.defineProperty(requestContext.context, schemaInstrumentation_1.symbolUserFieldResolver, {
              value: config.fieldResolver
            });
          }
          (0, schemaInstrumentation_1.enablePluginsForSchemaResolvers)(config.schema);
        }
        try {
          const result = await execute2(requestContext);
          const resultErrors = (_b = result.errors) === null || _b === void 0 ? void 0 : _b.map((e) => {
            if (isBadUserInputGraphQLError(e)) {
              return (0, apollo_server_errors_1.fromGraphQLError)(e, {
                errorClass: apollo_server_errors_1.UserInputError
              });
            }
            return e;
          });
          if (resultErrors) {
            await didEncounterErrors(resultErrors);
          }
          response = {
            ...result,
            errors: resultErrors ? formatErrors(resultErrors) : void 0
          };
          await executionDispatcher.invokeHook("executionDidEnd");
        } catch (executionError) {
          await executionDispatcher.invokeHook("executionDidEnd", executionError);
          return await sendErrorResponse(executionError);
        }
      }
      if (config.formatResponse) {
        const formattedResponse = config.formatResponse(response, requestContext);
        if (formattedResponse != null) {
          response = formattedResponse;
        }
      }
      return sendResponse(response);
      function parse2(query2, parseOptions) {
        return (0, graphql_1.parse)(query2, parseOptions);
      }
      function validate2(document2) {
        let rules = graphql_1.specifiedRules;
        if (config.validationRules) {
          rules = rules.concat(config.validationRules);
        }
        return (0, graphql_1.validate)(config.schema, document2, rules);
      }
      async function execute2(requestContext2) {
        const { request: request2, document: document2 } = requestContext2;
        const executionArgs = {
          schema: config.schema,
          document: document2,
          rootValue: typeof config.rootValue === "function" ? config.rootValue(document2) : config.rootValue,
          contextValue: requestContext2.context,
          variableValues: request2.variables,
          operationName: request2.operationName,
          fieldResolver: config.fieldResolver
        };
        if (config.executor) {
          return await config.executor(requestContext2);
        } else {
          return await (0, graphql_1.execute)(executionArgs);
        }
      }
      async function sendResponse(response2) {
        requestContext.response = {
          ...requestContext.response,
          errors: response2.errors,
          data: response2.data,
          extensions: response2.extensions
        };
        if (response2.http) {
          if (!requestContext.response.http) {
            requestContext.response.http = {
              headers: new apollo_server_env_1.Headers()
            };
          }
          if (response2.http.status) {
            requestContext.response.http.status = response2.http.status;
          }
          for (const [name, value] of response2.http.headers) {
            requestContext.response.http.headers.set(name, value);
          }
        }
        await dispatcher.invokeHook("willSendResponse", requestContext);
        return requestContext.response;
      }
      async function didEncounterErrors(errors) {
        requestContext.errors = errors;
        return await dispatcher.invokeHook("didEncounterErrors", requestContext);
      }
      async function sendErrorResponse(errorOrErrors, errorClass) {
        const errors = Array.isArray(errorOrErrors) ? errorOrErrors : [errorOrErrors];
        await didEncounterErrors(errors);
        const response2 = {
          errors: formatErrors(errors.map((err) => err instanceof apollo_server_errors_1.ApolloError && !errorClass ? err : (0, apollo_server_errors_1.fromGraphQLError)(err, errorClass && {
            errorClass
          })))
        };
        if (errors.every((err) => err instanceof apollo_server_errors_1.PersistedQueryNotSupportedError || err instanceof apollo_server_errors_1.PersistedQueryNotFoundError)) {
          response2.http = {
            status: 200,
            headers: new apollo_server_env_1.Headers({
              "Cache-Control": "private, no-cache, must-revalidate"
            })
          };
        } else if (errors.length === 1 && errors[0] instanceof runHttpQuery_1.HttpQueryError) {
          response2.http = {
            status: errors[0].statusCode,
            headers: new apollo_server_env_1.Headers(errors[0].headers)
          };
        }
        return sendResponse(response2);
      }
      function formatErrors(errors) {
        return (0, apollo_server_errors_1.formatApolloErrors)(errors, {
          formatter: config.formatError,
          debug: requestContext.debug
        });
      }
      async function initializeRequestListenerDispatcher() {
        const requestListeners = [];
        if (config.plugins) {
          for (const plugin of config.plugins) {
            if (!plugin.requestDidStart)
              continue;
            const listener = await plugin.requestDidStart(requestContext);
            if (listener) {
              requestListeners.push(listener);
            }
          }
        }
        return new dispatcher_1.Dispatcher(requestListeners);
      }
      async function initializeDataSources() {
        if (config.dataSources) {
          const context = requestContext.context;
          const dataSources = config.dataSources();
          const initializers = [];
          for (const dataSource of Object.values(dataSources)) {
            if (dataSource.initialize) {
              initializers.push(dataSource.initialize({
                context,
                cache: requestContext.cache
              }));
            }
          }
          await Promise.all(initializers);
          if ("dataSources" in context) {
            throw new Error("Please use the dataSources config option instead of putting dataSources on the context yourself.");
          }
          context.dataSources = dataSources;
        }
      }
    }
    exports2.processGraphQLRequest = processGraphQLRequest;
  }
});

// ../../../node_modules/apollo-server-core/dist/runHttpQuery.js
var require_runHttpQuery = __commonJS({
  "../../../node_modules/apollo-server-core/dist/runHttpQuery.js"(exports2) {
    "use strict";
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    var _a;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.cloneObject = exports2.processHTTPRequest = exports2.runHttpQuery = exports2.throwHttpGraphQLError = exports2.isHttpQueryError = exports2.HttpQueryError = void 0;
    var apollo_server_env_1 = require_index_browser();
    var apollo_server_errors_1 = require_dist();
    var whatwg_mimetype_1 = __importDefault2(require_mime_type());
    var cachePolicy_1 = require_cachePolicy();
    var graphqlOptions_1 = require_graphqlOptions();
    var requestPipeline_1 = require_requestPipeline();
    var HttpQueryError = class extends Error {
      constructor(statusCode, message, isGraphQLError = false, headers) {
        super(message);
        this.name = "HttpQueryError";
        this.statusCode = statusCode;
        this.isGraphQLError = isGraphQLError;
        this.headers = headers;
      }
    };
    exports2.HttpQueryError = HttpQueryError;
    function isHttpQueryError(e) {
      return (e === null || e === void 0 ? void 0 : e.name) === "HttpQueryError";
    }
    exports2.isHttpQueryError = isHttpQueryError;
    function throwHttpGraphQLError(statusCode, errors, options, extensions, headers) {
      const allHeaders = {
        "Content-Type": "application/json"
      };
      if (headers) {
        for (const [name, value] of headers) {
          allHeaders[name] = value;
        }
      }
      const result = {
        errors: options ? (0, apollo_server_errors_1.formatApolloErrors)(errors, {
          debug: options.debug,
          formatter: options.formatError
        }) : errors
      };
      if (extensions) {
        result.extensions = extensions;
      }
      throw new HttpQueryError(statusCode, prettyJSONStringify(result), true, allHeaders);
    }
    exports2.throwHttpGraphQLError = throwHttpGraphQLError;
    var NODE_ENV = (_a = "development") !== null && _a !== void 0 ? _a : "";
    var NON_PREFLIGHTED_CONTENT_TYPES = [
      "application/x-www-form-urlencoded",
      "multipart/form-data",
      "text/plain"
    ];
    function preventCsrf(headers, csrfPreventionRequestHeaders) {
      const contentType = headers.get("content-type");
      if (contentType !== null) {
        const contentTypeParsed = whatwg_mimetype_1.default.parse(contentType);
        if (contentTypeParsed === null) {
          return;
        }
        if (!NON_PREFLIGHTED_CONTENT_TYPES.includes(contentTypeParsed.essence)) {
          return;
        }
      }
      if (csrfPreventionRequestHeaders.some((header) => {
        const value = headers.get(header);
        return value !== null && value.length > 0;
      })) {
        return;
      }
      throw new HttpQueryError(400, `This operation has been blocked as a potential Cross-Site Request Forgery (CSRF). Please either specify a 'content-type' header (with a type that is not one of ${NON_PREFLIGHTED_CONTENT_TYPES.join(", ")}) or provide a non-empty value for one of the following headers: ${csrfPreventionRequestHeaders.join(", ")}
`);
    }
    async function runHttpQuery(handlerArguments, request, csrfPreventionRequestHeaders) {
      function debugFromNodeEnv(nodeEnv = NODE_ENV) {
        return nodeEnv !== "production" && nodeEnv !== "test";
      }
      if (csrfPreventionRequestHeaders) {
        preventCsrf(request.request.headers, csrfPreventionRequestHeaders);
      }
      let options;
      try {
        options = await (0, graphqlOptions_1.resolveGraphqlOptions)(request.options, ...handlerArguments);
      } catch (e) {
        return throwHttpGraphQLError(500, [e], {
          debug: debugFromNodeEnv()
        });
      }
      if (options.debug === void 0) {
        options.debug = debugFromNodeEnv(options.nodeEnv);
      }
      if (typeof options.context === "function") {
        try {
          options.context();
        } catch (e) {
          e.message = `Context creation failed: ${e.message}`;
          if (e.extensions && e.extensions.code && e.extensions.code !== "INTERNAL_SERVER_ERROR") {
            return throwHttpGraphQLError(400, [e], options);
          } else {
            return throwHttpGraphQLError(500, [e], options);
          }
        }
      }
      const config = {
        schema: options.schema,
        schemaHash: options.schemaHash,
        logger: options.logger,
        rootValue: options.rootValue,
        context: options.context || {},
        validationRules: options.validationRules,
        executor: options.executor,
        fieldResolver: options.fieldResolver,
        cache: options.cache,
        dataSources: options.dataSources,
        documentStore: options.documentStore,
        persistedQueries: options.persistedQueries,
        formatError: options.formatError,
        formatResponse: options.formatResponse,
        debug: options.debug,
        plugins: options.plugins || [],
        allowBatchedHttpRequests: options.allowBatchedHttpRequests
      };
      return processHTTPRequest(config, request);
    }
    exports2.runHttpQuery = runHttpQuery;
    async function processHTTPRequest(options, httpRequest) {
      var _a2, _b;
      let requestPayload;
      switch (httpRequest.method) {
        case "POST":
          if (!httpRequest.query || typeof httpRequest.query === "string" || Buffer.isBuffer(httpRequest.query) || Object.keys(httpRequest.query).length === 0) {
            throw new HttpQueryError(400, "POST body missing, invalid Content-Type, or JSON object has no keys.");
          }
          requestPayload = httpRequest.query;
          break;
        case "GET":
          if (!httpRequest.query || Object.keys(httpRequest.query).length === 0) {
            throw new HttpQueryError(400, "GET query missing.");
          }
          requestPayload = httpRequest.query;
          break;
        default:
          throw new HttpQueryError(405, "Apollo Server supports only GET/POST requests.", false, {
            Allow: "GET, POST"
          });
      }
      options = {
        ...options,
        plugins: [checkOperationPlugin, ...options.plugins]
      };
      function buildRequestContext(request, requestIsBatched) {
        const context = cloneObject(options.context);
        return {
          logger: options.logger || console,
          schema: options.schema,
          schemaHash: options.schemaHash,
          request,
          response: {
            http: {
              headers: new apollo_server_env_1.Headers()
            }
          },
          context,
          cache: options.cache,
          debug: options.debug,
          metrics: {},
          overallCachePolicy: (0, cachePolicy_1.newCachePolicy)(),
          requestIsBatched
        };
      }
      const responseInit = {
        headers: {
          "Content-Type": "application/json"
        }
      };
      let body;
      try {
        if (Array.isArray(requestPayload)) {
          if (options.allowBatchedHttpRequests === false) {
            return throwHttpGraphQLError(400, [new Error("Operation batching disabled.")], options);
          }
          const requests = requestPayload.map((requestParams) => parseGraphQLRequest(httpRequest.request, requestParams));
          const responses = await Promise.all(requests.map(async (request) => {
            try {
              const requestContext = buildRequestContext(request, true);
              const response = await (0, requestPipeline_1.processGraphQLRequest)(options, requestContext);
              if (response.http) {
                for (const [name, value] of response.http.headers) {
                  responseInit.headers[name] = value;
                }
                if (response.http.status) {
                  responseInit.status = response.http.status;
                }
              }
              return response;
            } catch (error) {
              return {
                errors: (0, apollo_server_errors_1.formatApolloErrors)([error], options)
              };
            }
          }));
          body = prettyJSONStringify(responses.map(serializeGraphQLResponse));
        } else {
          const request = parseGraphQLRequest(httpRequest.request, requestPayload);
          const requestContext = buildRequestContext(request, false);
          const response = await (0, requestPipeline_1.processGraphQLRequest)(options, requestContext);
          if (response.errors && typeof response.data === "undefined") {
            return throwHttpGraphQLError(((_a2 = response.http) === null || _a2 === void 0 ? void 0 : _a2.status) || 400, response.errors, void 0, response.extensions, (_b = response.http) === null || _b === void 0 ? void 0 : _b.headers);
          }
          if (response.http) {
            for (const [name, value] of response.http.headers) {
              responseInit.headers[name] = value;
            }
            if (response.http.status) {
              responseInit.status = response.http.status;
            }
          }
          body = prettyJSONStringify(serializeGraphQLResponse(response));
        }
      } catch (error) {
        if (error instanceof HttpQueryError) {
          throw error;
        }
        return throwHttpGraphQLError(500, [error], options);
      }
      responseInit.headers["Content-Length"] = Buffer.byteLength(body, "utf8").toString();
      return {
        graphqlResponse: body,
        responseInit
      };
    }
    exports2.processHTTPRequest = processHTTPRequest;
    function parseGraphQLRequest(httpRequest, requestParams) {
      let queryString = requestParams.query;
      let extensions = requestParams.extensions;
      if (typeof extensions === "string" && extensions !== "") {
        try {
          extensions = JSON.parse(extensions);
        } catch (error) {
          throw new HttpQueryError(400, "Extensions are invalid JSON.");
        }
      }
      if (queryString && typeof queryString !== "string") {
        if (queryString.kind === "Document") {
          throw new HttpQueryError(400, "GraphQL queries must be strings. It looks like you're sending the internal graphql-js representation of a parsed query in your request instead of a request in the GraphQL query language. You can convert an AST to a string using the `print` function from `graphql`, or use a client like `apollo-client` which converts the internal representation to a string for you.");
        } else {
          throw new HttpQueryError(400, "GraphQL queries must be strings.");
        }
      }
      const operationName = requestParams.operationName;
      let variables = requestParams.variables;
      if (typeof variables === "string" && variables !== "") {
        try {
          variables = JSON.parse(variables);
        } catch (error) {
          throw new HttpQueryError(400, "Variables are invalid JSON.");
        }
      }
      return {
        query: queryString,
        operationName,
        variables,
        extensions,
        http: httpRequest
      };
    }
    var checkOperationPlugin = {
      async requestDidStart() {
        return {
          async didResolveOperation({ request, operation }) {
            if (!request.http)
              return;
            if (request.http.method === "GET" && operation.operation !== "query") {
              throw new HttpQueryError(405, `GET supports only query operation`, false, {
                Allow: "POST"
              });
            }
          }
        };
      }
    };
    function serializeGraphQLResponse(response) {
      return {
        errors: response.errors,
        data: response.data,
        extensions: response.extensions
      };
    }
    function prettyJSONStringify(value) {
      return JSON.stringify(value) + "\n";
    }
    function cloneObject(object) {
      return Object.assign(Object.create(Object.getPrototypeOf(object)), object);
    }
    exports2.cloneObject = cloneObject;
  }
});

// ../../../node_modules/apollo-server-core/dist/nodeHttpToRequest.js
var require_nodeHttpToRequest = __commonJS({
  "../../../node_modules/apollo-server-core/dist/nodeHttpToRequest.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.convertNodeHttpToRequest = void 0;
    var apollo_server_env_1 = require_index_browser();
    function convertNodeHttpToRequest(req) {
      const headers = new apollo_server_env_1.Headers();
      Object.keys(req.headers).forEach((key) => {
        const values = req.headers[key];
        if (Array.isArray(values)) {
          values.forEach((value) => headers.append(key, value));
        } else {
          headers.append(key, values);
        }
      });
      return new apollo_server_env_1.Request(req.url, {
        headers,
        method: req.method
      });
    }
    exports2.convertNodeHttpToRequest = convertNodeHttpToRequest;
  }
});

// ../../../node_modules/tslib/tslib.es6.mjs
var tslib_es6_exports = {};
__export(tslib_es6_exports, {
  __addDisposableResource: () => __addDisposableResource,
  __assign: () => __assign,
  __asyncDelegator: () => __asyncDelegator,
  __asyncGenerator: () => __asyncGenerator,
  __asyncValues: () => __asyncValues,
  __await: () => __await,
  __awaiter: () => __awaiter,
  __classPrivateFieldGet: () => __classPrivateFieldGet,
  __classPrivateFieldIn: () => __classPrivateFieldIn,
  __classPrivateFieldSet: () => __classPrivateFieldSet,
  __createBinding: () => __createBinding,
  __decorate: () => __decorate,
  __disposeResources: () => __disposeResources,
  __esDecorate: () => __esDecorate,
  __exportStar: () => __exportStar,
  __extends: () => __extends,
  __generator: () => __generator,
  __importDefault: () => __importDefault,
  __importStar: () => __importStar,
  __makeTemplateObject: () => __makeTemplateObject,
  __metadata: () => __metadata,
  __param: () => __param,
  __propKey: () => __propKey,
  __read: () => __read,
  __rest: () => __rest,
  __runInitializers: () => __runInitializers,
  __setFunctionName: () => __setFunctionName,
  __spread: () => __spread,
  __spreadArray: () => __spreadArray,
  __spreadArrays: () => __spreadArrays,
  __values: () => __values,
  default: () => tslib_es6_default
});
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __rest(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function")
      throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p in contextIn)
      context[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access)
      context.access[p] = contextIn.access[p];
    context.addInitializer = function(f) {
      if (done)
        throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0)
        continue;
      if (result === null || typeof result !== "object")
        throw new TypeError("Object expected");
      if (_ = accept(result.get))
        descriptor.get = _;
      if (_ = accept(result.set))
        descriptor.set = _;
      if (_ = accept(result.init))
        initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field")
        initializers.unshift(_);
      else
        descriptor[key] = _;
    }
  }
  if (target)
    Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
}
function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
}
function __propKey(x) {
  return typeof x === "symbol" ? x : "".concat(x);
}
function __setFunctionName(f, name, prefix) {
  if (typeof name === "symbol")
    name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __exportStar(m, o) {
  for (var p in m)
    if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
      __createBinding(o, m, p);
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read(arguments[i]));
  return ar;
}
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function verb(n) {
    if (g[n])
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length)
      resume(q[0][0], q[0][1]);
  }
}
function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function(e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function() {
    return this;
  }, i;
  function verb(n, f) {
    i[n] = o[n] ? function(v) {
      return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
    } : f;
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
function __importStar(mod2) {
  if (mod2 && mod2.__esModule)
    return mod2;
  var result = {};
  if (mod2 != null) {
    for (var k in mod2)
      if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
        __createBinding(result, mod2, k);
  }
  __setModuleDefault(result, mod2);
  return result;
}
function __importDefault(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
}
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
    throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}
function __addDisposableResource(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object")
      throw new TypeError("Object expected.");
    var dispose;
    if (async) {
      if (!Symbol.asyncDispose)
        throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose)
        throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
    }
    if (typeof dispose !== "function")
      throw new TypeError("Object not disposable.");
    env.stack.push({ value, dispose, async });
  } else if (async) {
    env.stack.push({ async: true });
  }
  return value;
}
function __disposeResources(env) {
  function fail(e) {
    env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
    env.hasError = true;
  }
  function next() {
    while (env.stack.length) {
      var rec = env.stack.pop();
      try {
        var result = rec.dispose && rec.dispose.call(rec.value);
        if (rec.async)
          return Promise.resolve(result).then(next, function(e) {
            fail(e);
            return next();
          });
      } catch (e) {
        fail(e);
      }
    }
    if (env.hasError)
      throw env.error;
  }
  return next();
}
var extendStatics, __assign, __createBinding, __setModuleDefault, _SuppressedError, tslib_es6_default;
var init_tslib_es6 = __esm({
  "../../../node_modules/tslib/tslib.es6.mjs"() {
    extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    __assign = function() {
      __assign = Object.assign || function __assign2(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    __createBinding = Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    };
    __setModuleDefault = Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    };
    _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };
    tslib_es6_default = {
      __extends,
      __assign,
      __rest,
      __decorate,
      __param,
      __metadata,
      __awaiter,
      __generator,
      __createBinding,
      __exportStar,
      __values,
      __read,
      __spread,
      __spreadArrays,
      __spreadArray,
      __await,
      __asyncGenerator,
      __asyncDelegator,
      __asyncValues,
      __makeTemplateObject,
      __importStar,
      __importDefault,
      __classPrivateFieldGet,
      __classPrivateFieldSet,
      __classPrivateFieldIn,
      __addDisposableResource,
      __disposeResources
    };
  }
});

// ../../../node_modules/fast-json-stable-stringify/index.js
var require_fast_json_stable_stringify = __commonJS({
  "../../../node_modules/fast-json-stable-stringify/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function(data, opts) {
      if (!opts)
        opts = {};
      if (typeof opts === "function")
        opts = { cmp: opts };
      var cycles = typeof opts.cycles === "boolean" ? opts.cycles : false;
      var cmp = opts.cmp && /* @__PURE__ */ function(f) {
        return function(node) {
          return function(a, b) {
            var aobj = { key: a, value: node[a] };
            var bobj = { key: b, value: node[b] };
            return f(aobj, bobj);
          };
        };
      }(opts.cmp);
      var seen = [];
      return function stringify(node) {
        if (node && node.toJSON && typeof node.toJSON === "function") {
          node = node.toJSON();
        }
        if (node === void 0)
          return;
        if (typeof node == "number")
          return isFinite(node) ? "" + node : "null";
        if (typeof node !== "object")
          return JSON.stringify(node);
        var i, out;
        if (Array.isArray(node)) {
          out = "[";
          for (i = 0; i < node.length; i++) {
            if (i)
              out += ",";
            out += stringify(node[i]) || "null";
          }
          return out + "]";
        }
        if (node === null)
          return "null";
        if (seen.indexOf(node) !== -1) {
          if (cycles)
            return JSON.stringify("__cycle__");
          throw new TypeError("Converting circular structure to JSON");
        }
        var seenIndex = seen.push(node) - 1;
        var keys = Object.keys(node).sort(cmp && cmp(node));
        out = "";
        for (i = 0; i < keys.length; i++) {
          var key = keys[i];
          var value = stringify(node[key]);
          if (!value)
            continue;
          if (out)
            out += ",";
          out += JSON.stringify(key) + ":" + value;
        }
        seen.splice(seenIndex, 1);
        return "{" + out + "}";
      }(data);
    };
  }
});

// ../../../node_modules/@graphql-tools/mock/cjs/types.js
var require_types = __commonJS({
  "../../../node_modules/@graphql-tools/mock/cjs/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isRecord = exports2.assertIsRef = exports2.isRef = void 0;
    function isRef(maybeRef) {
      return !!(maybeRef && typeof maybeRef === "object" && "$ref" in maybeRef);
    }
    exports2.isRef = isRef;
    function assertIsRef(maybeRef, message) {
      if (!isRef(maybeRef)) {
        throw new Error(message || `Expected ${maybeRef} to be a valid Ref.`);
      }
    }
    exports2.assertIsRef = assertIsRef;
    function isRecord(obj) {
      return typeof obj === "object" && obj !== null;
    }
    exports2.isRecord = isRecord;
  }
});

// ../../../node_modules/@graphql-tools/utils/cjs/loaders.js
var require_loaders = __commonJS({
  "../../../node_modules/@graphql-tools/utils/cjs/loaders.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../../node_modules/@graphql-tools/utils/cjs/helpers.js
var require_helpers = __commonJS({
  "../../../node_modules/@graphql-tools/utils/cjs/helpers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.assertSome = exports2.isSome = exports2.compareNodes = exports2.nodeToString = exports2.compareStrings = exports2.isValidPath = exports2.isDocumentString = exports2.asArray = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var asArray = (fns) => Array.isArray(fns) ? fns : fns ? [fns] : [];
    exports2.asArray = asArray;
    var invalidDocRegex = /\.[a-z0-9]+$/i;
    function isDocumentString(str) {
      if (typeof str !== "string") {
        return false;
      }
      if (invalidDocRegex.test(str)) {
        return false;
      }
      try {
        (0, graphql_1.parse)(str);
        return true;
      } catch (e) {
      }
      return false;
    }
    exports2.isDocumentString = isDocumentString;
    var invalidPathRegex = /[!%^<=>`]/;
    function isValidPath(str) {
      return typeof str === "string" && !invalidPathRegex.test(str);
    }
    exports2.isValidPath = isValidPath;
    function compareStrings(a, b) {
      if (String(a) < String(b)) {
        return -1;
      }
      if (String(a) > String(b)) {
        return 1;
      }
      return 0;
    }
    exports2.compareStrings = compareStrings;
    function nodeToString(a) {
      var _a, _b;
      let name;
      if ("alias" in a) {
        name = (_a = a.alias) === null || _a === void 0 ? void 0 : _a.value;
      }
      if (name == null && "name" in a) {
        name = (_b = a.name) === null || _b === void 0 ? void 0 : _b.value;
      }
      if (name == null) {
        name = a.kind;
      }
      return name;
    }
    exports2.nodeToString = nodeToString;
    function compareNodes(a, b, customFn) {
      const aStr = nodeToString(a);
      const bStr = nodeToString(b);
      if (typeof customFn === "function") {
        return customFn(aStr, bStr);
      }
      return compareStrings(aStr, bStr);
    }
    exports2.compareNodes = compareNodes;
    function isSome(input) {
      return input != null;
    }
    exports2.isSome = isSome;
    function assertSome(input, message = "Value should be something") {
      if (input == null) {
        throw new Error(message);
      }
    }
    exports2.assertSome = assertSome;
  }
});

// ../../../node_modules/@graphql-tools/utils/cjs/jsutils.js
var require_jsutils = __commonJS({
  "../../../node_modules/@graphql-tools/utils/cjs/jsutils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hasOwnProperty = exports2.promiseReduce = exports2.isPromise = exports2.isObjectLike = exports2.isIterableObject = void 0;
    function isIterableObject2(value) {
      return value != null && typeof value === "object" && Symbol.iterator in value;
    }
    exports2.isIterableObject = isIterableObject2;
    function isObjectLike2(value) {
      return typeof value === "object" && value !== null;
    }
    exports2.isObjectLike = isObjectLike2;
    function isPromise2(value) {
      return isObjectLike2(value) && typeof value["then"] === "function";
    }
    exports2.isPromise = isPromise2;
    function promiseReduce2(values, callbackFn, initialValue) {
      let accumulator = initialValue;
      for (const value of values) {
        accumulator = isPromise2(accumulator) ? accumulator.then((resolved) => callbackFn(resolved, value)) : callbackFn(accumulator, value);
      }
      return accumulator;
    }
    exports2.promiseReduce = promiseReduce2;
    function hasOwnProperty2(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    exports2.hasOwnProperty = hasOwnProperty2;
  }
});

// ../../../node_modules/@graphql-tools/utils/cjs/errors.js
var require_errors = __commonJS({
  "../../../node_modules/@graphql-tools/utils/cjs/errors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.relocatedError = exports2.createGraphQLError = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function createGraphQLError(message, options) {
      if (graphql_1.versionInfo.major >= 17) {
        return new graphql_1.GraphQLError(message, options);
      }
      return new graphql_1.GraphQLError(message, options === null || options === void 0 ? void 0 : options.nodes, options === null || options === void 0 ? void 0 : options.source, options === null || options === void 0 ? void 0 : options.positions, options === null || options === void 0 ? void 0 : options.path, options === null || options === void 0 ? void 0 : options.originalError, options === null || options === void 0 ? void 0 : options.extensions);
    }
    exports2.createGraphQLError = createGraphQLError;
    function relocatedError(originalError, path) {
      return createGraphQLError(originalError.message, {
        nodes: originalError.nodes,
        source: originalError.source,
        positions: originalError.positions,
        path: path == null ? originalError.path : path,
        originalError,
        extensions: originalError.extensions
      });
    }
    exports2.relocatedError = relocatedError;
  }
});

// ../../../node_modules/@graphql-tools/utils/cjs/AggregateError.js
var require_AggregateError = __commonJS({
  "../../../node_modules/@graphql-tools/utils/cjs/AggregateError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isAggregateError = exports2.AggregateError = void 0;
    var AggregateErrorImpl;
    exports2.AggregateError = AggregateErrorImpl;
    if (typeof AggregateError === "undefined") {
      class AggregateErrorClass extends Error {
        constructor(errors, message = "") {
          super(message);
          this.errors = errors;
          this.name = "AggregateError";
          Error.captureStackTrace(this, AggregateErrorClass);
        }
      }
      exports2.AggregateError = AggregateErrorImpl = function(errors, message) {
        return new AggregateErrorClass(errors, message);
      };
    } else {
      exports2.AggregateError = AggregateErrorImpl = AggregateError;
    }
    function isAggregateError(error) {
      return "errors" in error && Array.isArray(error["errors"]);
    }
    exports2.isAggregateError = isAggregateError;
  }
});

// ../../../node_modules/@graphql-tools/utils/cjs/inspect.js
var require_inspect = __commonJS({
  "../../../node_modules/@graphql-tools/utils/cjs/inspect.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.inspect = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var AggregateError_js_1 = require_AggregateError();
    var MAX_RECURSIVE_DEPTH2 = 3;
    function inspect2(value) {
      return formatValue2(value, []);
    }
    exports2.inspect = inspect2;
    function formatValue2(value, seenValues) {
      switch (typeof value) {
        case "string":
          return JSON.stringify(value);
        case "function":
          return value.name ? `[function ${value.name}]` : "[function]";
        case "object":
          return formatObjectValue2(value, seenValues);
        default:
          return String(value);
      }
    }
    function formatError2(value) {
      if (value instanceof graphql_1.GraphQLError) {
        return value.toString();
      }
      return `${value.name}: ${value.message};
 ${value.stack}`;
    }
    function formatObjectValue2(value, previouslySeenValues) {
      if (value === null) {
        return "null";
      }
      if (value instanceof Error) {
        if ((0, AggregateError_js_1.isAggregateError)(value)) {
          return formatError2(value) + "\n" + formatArray2(value.errors, previouslySeenValues);
        }
        return formatError2(value);
      }
      if (previouslySeenValues.includes(value)) {
        return "[Circular]";
      }
      const seenValues = [...previouslySeenValues, value];
      if (isJSONable2(value)) {
        const jsonValue = value.toJSON();
        if (jsonValue !== value) {
          return typeof jsonValue === "string" ? jsonValue : formatValue2(jsonValue, seenValues);
        }
      } else if (Array.isArray(value)) {
        return formatArray2(value, seenValues);
      }
      return formatObject2(value, seenValues);
    }
    function isJSONable2(value) {
      return typeof value.toJSON === "function";
    }
    function formatObject2(object, seenValues) {
      const entries = Object.entries(object);
      if (entries.length === 0) {
        return "{}";
      }
      if (seenValues.length > MAX_RECURSIVE_DEPTH2) {
        return "[" + getObjectTag2(object) + "]";
      }
      const properties = entries.map(([key, value]) => key + ": " + formatValue2(value, seenValues));
      return "{ " + properties.join(", ") + " }";
    }
    function formatArray2(array, seenValues) {
      if (array.length === 0) {
        return "[]";
      }
      if (seenValues.length > MAX_RECURSIVE_DEPTH2) {
        return "[Array]";
      }
      const len = array.length;
      const items = [];
      for (let i = 0; i < len; ++i) {
        items.push(formatValue2(array[i], seenValues));
      }
      return "[" + items.join(", ") + "]";
    }
    function getObjectTag2(object) {
      const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
      if (tag === "Object" && typeof object.constructor === "function") {
        const name = object.constructor.name;
        if (typeof name === "string" && name !== "") {
          return name;
        }
      }
      return tag;
    }
  }
});

// ../../../node_modules/@graphql-tools/utils/cjs/getArgumentValues.js
var require_getArgumentValues = __commonJS({
  "../../../node_modules/@graphql-tools/utils/cjs/getArgumentValues.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getArgumentValues = void 0;
    var jsutils_js_1 = require_jsutils();
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var errors_js_1 = require_errors();
    var inspect_js_1 = require_inspect();
    function getArgumentValues2(def, node, variableValues = {}) {
      var _a;
      const coercedValues = {};
      const argumentNodes = (_a = node.arguments) !== null && _a !== void 0 ? _a : [];
      const argNodeMap = argumentNodes.reduce((prev, arg) => ({
        ...prev,
        [arg.name.value]: arg
      }), {});
      for (const { name, type: argType, defaultValue } of def.args) {
        const argumentNode = argNodeMap[name];
        if (!argumentNode) {
          if (defaultValue !== void 0) {
            coercedValues[name] = defaultValue;
          } else if ((0, graphql_1.isNonNullType)(argType)) {
            throw (0, errors_js_1.createGraphQLError)(`Argument "${name}" of required type "${(0, inspect_js_1.inspect)(argType)}" was not provided.`, {
              nodes: [node]
            });
          }
          continue;
        }
        const valueNode = argumentNode.value;
        let isNull = valueNode.kind === graphql_1.Kind.NULL;
        if (valueNode.kind === graphql_1.Kind.VARIABLE) {
          const variableName = valueNode.name.value;
          if (variableValues == null || !(0, jsutils_js_1.hasOwnProperty)(variableValues, variableName)) {
            if (defaultValue !== void 0) {
              coercedValues[name] = defaultValue;
            } else if ((0, graphql_1.isNonNullType)(argType)) {
              throw (0, errors_js_1.createGraphQLError)(`Argument "${name}" of required type "${(0, inspect_js_1.inspect)(argType)}" was provided the variable "$${variableName}" which was not provided a runtime value.`, {
                nodes: [valueNode]
              });
            }
            continue;
          }
          isNull = variableValues[variableName] == null;
        }
        if (isNull && (0, graphql_1.isNonNullType)(argType)) {
          throw (0, errors_js_1.createGraphQLError)(`Argument "${name}" of non-null type "${(0, inspect_js_1.inspect)(argType)}" must not be null.`, {
            nodes: [valueNode]
          });
        }
        const coercedValue = (0, graphql_1.valueFromAST)(valueNode, argType, variableValues);
        if (coercedValue === void 0) {
          throw (0, errors_js_1.createGraphQLError)(`Argument "${name}" has invalid value ${(0, graphql_1.print)(valueNode)}.`, {
            nodes: [valueNode]
          });
        }
        coercedValues[name] = coercedValue;
      }
      return coercedValues;
    }
    exports2.getArgumentValues = getArgumentValues2;
  }
});

// ../../../node_modules/@graphql-tools/utils/cjs/get-directives.js
var require_get_directives = __commonJS({
  "../../../node_modules/@graphql-tools/utils/cjs/get-directives.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getDirective = exports2.getDirectives = exports2.getDirectiveInExtensions = exports2.getDirectivesInExtensions = void 0;
    var getArgumentValues_js_1 = require_getArgumentValues();
    function getDirectivesInExtensions(node, pathToDirectivesInExtensions = ["directives"]) {
      return pathToDirectivesInExtensions.reduce((acc, pathSegment) => acc == null ? acc : acc[pathSegment], node === null || node === void 0 ? void 0 : node.extensions);
    }
    exports2.getDirectivesInExtensions = getDirectivesInExtensions;
    function _getDirectiveInExtensions(directivesInExtensions, directiveName) {
      const directiveInExtensions = directivesInExtensions.filter((directiveAnnotation) => directiveAnnotation.name === directiveName);
      if (!directiveInExtensions.length) {
        return void 0;
      }
      return directiveInExtensions.map((directive) => {
        var _a;
        return (_a = directive.args) !== null && _a !== void 0 ? _a : {};
      });
    }
    function getDirectiveInExtensions(node, directiveName, pathToDirectivesInExtensions = ["directives"]) {
      const directivesInExtensions = pathToDirectivesInExtensions.reduce((acc, pathSegment) => acc == null ? acc : acc[pathSegment], node === null || node === void 0 ? void 0 : node.extensions);
      if (directivesInExtensions === void 0) {
        return void 0;
      }
      if (Array.isArray(directivesInExtensions)) {
        return _getDirectiveInExtensions(directivesInExtensions, directiveName);
      }
      const reformattedDirectivesInExtensions = [];
      for (const [name, argsOrArrayOfArgs] of Object.entries(directivesInExtensions)) {
        if (Array.isArray(argsOrArrayOfArgs)) {
          for (const args of argsOrArrayOfArgs) {
            reformattedDirectivesInExtensions.push({ name, args });
          }
        } else {
          reformattedDirectivesInExtensions.push({ name, args: argsOrArrayOfArgs });
        }
      }
      return _getDirectiveInExtensions(reformattedDirectivesInExtensions, directiveName);
    }
    exports2.getDirectiveInExtensions = getDirectiveInExtensions;
    function getDirectives(schema, node, pathToDirectivesInExtensions = ["directives"]) {
      const directivesInExtensions = getDirectivesInExtensions(node, pathToDirectivesInExtensions);
      if (directivesInExtensions != null && directivesInExtensions.length > 0) {
        return directivesInExtensions;
      }
      const schemaDirectives = schema && schema.getDirectives ? schema.getDirectives() : [];
      const schemaDirectiveMap = schemaDirectives.reduce((schemaDirectiveMap2, schemaDirective) => {
        schemaDirectiveMap2[schemaDirective.name] = schemaDirective;
        return schemaDirectiveMap2;
      }, {});
      let astNodes = [];
      if (node.astNode) {
        astNodes.push(node.astNode);
      }
      if ("extensionASTNodes" in node && node.extensionASTNodes) {
        astNodes = [...astNodes, ...node.extensionASTNodes];
      }
      const result = [];
      for (const astNode of astNodes) {
        if (astNode.directives) {
          for (const directiveNode of astNode.directives) {
            const schemaDirective = schemaDirectiveMap[directiveNode.name.value];
            if (schemaDirective) {
              result.push({ name: directiveNode.name.value, args: (0, getArgumentValues_js_1.getArgumentValues)(schemaDirective, directiveNode) });
            }
          }
        }
      }
      return result;
    }
    exports2.getDirectives = getDirectives;
    function getDirective(schema, node, directiveName, pathToDirectivesInExtensions = ["directives"]) {
      const directiveInExtensions = getDirectiveInExtensions(node, directiveName, pathToDirectivesInExtensions);
      if (directiveInExtensions != null) {
        return directiveInExtensions;
      }
      const schemaDirective = schema && schema.getDirective ? schema.getDirective(directiveName) : void 0;
      if (schemaDirective == null) {
        return void 0;
      }
      let astNodes = [];
      if (node.astNode) {
        astNodes.push(node.astNode);
      }
      if ("extensionASTNodes" in node && node.extensionASTNodes) {
        astNodes = [...astNodes, ...node.extensionASTNodes];
      }
      const result = [];
      for (const astNode of astNodes) {
        if (astNode.directives) {
          for (const directiveNode of astNode.directives) {
            if (directiveNode.name.value === directiveName) {
              result.push((0, getArgumentValues_js_1.getArgumentValues)(schemaDirective, directiveNode));
            }
          }
        }
      }
      if (!result.length) {
        return void 0;
      }
      return result;
    }
    exports2.getDirective = getDirective;
  }
});

// ../../../node_modules/@graphql-tools/utils/cjs/get-fields-with-directives.js
var require_get_fields_with_directives = __commonJS({
  "../../../node_modules/@graphql-tools/utils/cjs/get-fields-with-directives.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getFieldsWithDirectives = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function getFieldsWithDirectives(documentNode, options = {}) {
      const result = {};
      let selected = ["ObjectTypeDefinition", "ObjectTypeExtension"];
      if (options.includeInputTypes) {
        selected = [...selected, "InputObjectTypeDefinition", "InputObjectTypeExtension"];
      }
      const allTypes = documentNode.definitions.filter((obj) => selected.includes(obj.kind));
      for (const type of allTypes) {
        const typeName = type.name.value;
        if (type.fields == null) {
          continue;
        }
        for (const field of type.fields) {
          if (field.directives && field.directives.length > 0) {
            const fieldName = field.name.value;
            const key = `${typeName}.${fieldName}`;
            const directives = field.directives.map((d) => ({
              name: d.name.value,
              args: (d.arguments || []).reduce((prev, arg) => ({ ...prev, [arg.name.value]: (0, graphql_1.valueFromASTUntyped)(arg.value) }), {})
            }));
            result[key] = directives;
          }
        }
      }
      return result;
    }
    exports2.getFieldsWithDirectives = getFieldsWithDirectives;
  }
});

// ../../../node_modules/@graphql-tools/utils/cjs/get-arguments-with-directives.js
var require_get_arguments_with_directives = __commonJS({
  "../../../node_modules/@graphql-tools/utils/cjs/get-arguments-with-directives.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getArgumentsWithDirectives = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function isTypeWithFields(t) {
      return t.kind === graphql_1.Kind.OBJECT_TYPE_DEFINITION || t.kind === graphql_1.Kind.OBJECT_TYPE_EXTENSION;
    }
    function getArgumentsWithDirectives(documentNode) {
      var _a;
      const result = {};
      const allTypes = documentNode.definitions.filter(isTypeWithFields);
      for (const type of allTypes) {
        if (type.fields == null) {
          continue;
        }
        for (const field of type.fields) {
          const argsWithDirectives = (_a = field.arguments) === null || _a === void 0 ? void 0 : _a.filter((arg) => {
            var _a2;
            return (_a2 = arg.directives) === null || _a2 === void 0 ? void 0 : _a2.length;
          });
          if (!(argsWithDirectives === null || argsWithDirectives === void 0 ? void 0 : argsWithDirectives.length)) {
            continue;
          }
          const typeFieldResult = result[`${type.name.value}.${field.name.value}`] = {};
          for (const arg of argsWithDirectives) {
            const directives = arg.directives.map((d) => ({
              name: d.name.value,
              args: (d.arguments || []).reduce((prev, dArg) => ({ ...prev, [dArg.name.value]: (0, graphql_1.valueFromASTUntyped)(dArg.value) }), {})
            }));
            typeFieldResult[arg.name.value] = directives;
          }
        }
      }
      return result;
    }
    exports2.getArgumentsWithDirectives = getArgumentsWithDirectives;
  }
});

// ../../../node_modules/@graphql-tools/utils/cjs/get-implementing-types.js
var require_get_implementing_types = __commonJS({
  "../../../node_modules/@graphql-tools/utils/cjs/get-implementing-types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getImplementingTypes = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function getImplementingTypes(interfaceName, schema) {
      const allTypesMap = schema.getTypeMap();
      const result = [];
      for (const graphqlTypeName in allTypesMap) {
        const graphqlType = allTypesMap[graphqlTypeName];
        if ((0, graphql_1.isObjectType)(graphqlType)) {
          const allInterfaces = graphqlType.getInterfaces();
          if (allInterfaces.find((int) => int.name === interfaceName)) {
            result.push(graphqlType.name);
          }
        }
      }
      return result;
    }
    exports2.getImplementingTypes = getImplementingTypes;
  }
});

// ../../../node_modules/@graphql-tools/utils/cjs/astFromType.js
var require_astFromType = __commonJS({
  "../../../node_modules/@graphql-tools/utils/cjs/astFromType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.astFromType = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var inspect_js_1 = require_inspect();
    function astFromType(type) {
      if ((0, graphql_1.isNonNullType)(type)) {
        const innerType = astFromType(type.ofType);
        if (innerType.kind === graphql_1.Kind.NON_NULL_TYPE) {
          throw new Error(`Invalid type node ${(0, inspect_js_1.inspect)(type)}. Inner type of non-null type cannot be a non-null type.`);
        }
        return {
          kind: graphql_1.Kind.NON_NULL_TYPE,
          type: innerType
        };
      } else if ((0, graphql_1.isListType)(type)) {
        return {
          kind: graphql_1.Kind.LIST_TYPE,
          type: astFromType(type.ofType)
        };
      }
      return {
        kind: graphql_1.Kind.NAMED_TYPE,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type.name
        }
      };
    }
    exports2.astFromType = astFromType;
  }
});

// ../../../node_modules/@graphql-tools/utils/cjs/astFromValueUntyped.js
var require_astFromValueUntyped = __commonJS({
  "../../../node_modules/@graphql-tools/utils/cjs/astFromValueUntyped.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.astFromValueUntyped = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function astFromValueUntyped(value) {
      if (value === null) {
        return { kind: graphql_1.Kind.NULL };
      }
      if (value === void 0) {
        return null;
      }
      if (Array.isArray(value)) {
        const valuesNodes = [];
        for (const item of value) {
          const itemNode = astFromValueUntyped(item);
          if (itemNode != null) {
            valuesNodes.push(itemNode);
          }
        }
        return { kind: graphql_1.Kind.LIST, values: valuesNodes };
      }
      if (typeof value === "object") {
        const fieldNodes = [];
        for (const fieldName in value) {
          const fieldValue = value[fieldName];
          const ast = astFromValueUntyped(fieldValue);
          if (ast) {
            fieldNodes.push({
              kind: graphql_1.Kind.OBJECT_FIELD,
              name: { kind: graphql_1.Kind.NAME, value: fieldName },
              value: ast
            });
          }
        }
        return { kind: graphql_1.Kind.OBJECT, fields: fieldNodes };
      }
      if (typeof value === "boolean") {
        return { kind: graphql_1.Kind.BOOLEAN, value };
      }
      if (typeof value === "number" && isFinite(value)) {
        const stringNum = String(value);
        return integerStringRegExp2.test(stringNum) ? { kind: graphql_1.Kind.INT, value: stringNum } : { kind: graphql_1.Kind.FLOAT, value: stringNum };
      }
      if (typeof value === "string") {
        return { kind: graphql_1.Kind.STRING, value };
      }
      throw new TypeError(`Cannot convert value to AST: ${value}.`);
    }
    exports2.astFromValueUntyped = astFromValueUntyped;
    var integerStringRegExp2 = /^-?(?:0|[1-9][0-9]*)$/;
  }
});

// ../../../node_modules/@graphql-tools/utils/cjs/memoize.js
var require_memoize = __commonJS({
  "../../../node_modules/@graphql-tools/utils/cjs/memoize.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.memoize2of5 = exports2.memoize2of4 = exports2.memoize5 = exports2.memoize4 = exports2.memoize3 = exports2.memoize2 = exports2.memoize1 = void 0;
    function memoize1(fn) {
      const memoize1cache = /* @__PURE__ */ new WeakMap();
      return function memoized(a1) {
        const cachedValue = memoize1cache.get(a1);
        if (cachedValue === void 0) {
          const newValue = fn(a1);
          memoize1cache.set(a1, newValue);
          return newValue;
        }
        return cachedValue;
      };
    }
    exports2.memoize1 = memoize1;
    function memoize2(fn) {
      const memoize2cache = /* @__PURE__ */ new WeakMap();
      return function memoized(a1, a2) {
        let cache2 = memoize2cache.get(a1);
        if (!cache2) {
          cache2 = /* @__PURE__ */ new WeakMap();
          memoize2cache.set(a1, cache2);
          const newValue = fn(a1, a2);
          cache2.set(a2, newValue);
          return newValue;
        }
        const cachedValue = cache2.get(a2);
        if (cachedValue === void 0) {
          const newValue = fn(a1, a2);
          cache2.set(a2, newValue);
          return newValue;
        }
        return cachedValue;
      };
    }
    exports2.memoize2 = memoize2;
    function memoize32(fn) {
      const memoize3Cache = /* @__PURE__ */ new WeakMap();
      return function memoized(a1, a2, a3) {
        let cache2 = memoize3Cache.get(a1);
        if (!cache2) {
          cache2 = /* @__PURE__ */ new WeakMap();
          memoize3Cache.set(a1, cache2);
          const cache32 = /* @__PURE__ */ new WeakMap();
          cache2.set(a2, cache32);
          const newValue = fn(a1, a2, a3);
          cache32.set(a3, newValue);
          return newValue;
        }
        let cache3 = cache2.get(a2);
        if (!cache3) {
          cache3 = /* @__PURE__ */ new WeakMap();
          cache2.set(a2, cache3);
          const newValue = fn(a1, a2, a3);
          cache3.set(a3, newValue);
          return newValue;
        }
        const cachedValue = cache3.get(a3);
        if (cachedValue === void 0) {
          const newValue = fn(a1, a2, a3);
          cache3.set(a3, newValue);
          return newValue;
        }
        return cachedValue;
      };
    }
    exports2.memoize3 = memoize32;
    function memoize4(fn) {
      const memoize4Cache = /* @__PURE__ */ new WeakMap();
      return function memoized(a1, a2, a3, a4) {
        let cache2 = memoize4Cache.get(a1);
        if (!cache2) {
          cache2 = /* @__PURE__ */ new WeakMap();
          memoize4Cache.set(a1, cache2);
          const cache32 = /* @__PURE__ */ new WeakMap();
          cache2.set(a2, cache32);
          const cache42 = /* @__PURE__ */ new WeakMap();
          cache32.set(a3, cache42);
          const newValue = fn(a1, a2, a3, a4);
          cache42.set(a4, newValue);
          return newValue;
        }
        let cache3 = cache2.get(a2);
        if (!cache3) {
          cache3 = /* @__PURE__ */ new WeakMap();
          cache2.set(a2, cache3);
          const cache42 = /* @__PURE__ */ new WeakMap();
          cache3.set(a3, cache42);
          const newValue = fn(a1, a2, a3, a4);
          cache42.set(a4, newValue);
          return newValue;
        }
        const cache4 = cache3.get(a3);
        if (!cache4) {
          const cache42 = /* @__PURE__ */ new WeakMap();
          cache3.set(a3, cache42);
          const newValue = fn(a1, a2, a3, a4);
          cache42.set(a4, newValue);
          return newValue;
        }
        const cachedValue = cache4.get(a4);
        if (cachedValue === void 0) {
          const newValue = fn(a1, a2, a3, a4);
          cache4.set(a4, newValue);
          return newValue;
        }
        return cachedValue;
      };
    }
    exports2.memoize4 = memoize4;
    function memoize5(fn) {
      const memoize5Cache = /* @__PURE__ */ new WeakMap();
      return function memoized(a1, a2, a3, a4, a5) {
        let cache2 = memoize5Cache.get(a1);
        if (!cache2) {
          cache2 = /* @__PURE__ */ new WeakMap();
          memoize5Cache.set(a1, cache2);
          const cache32 = /* @__PURE__ */ new WeakMap();
          cache2.set(a2, cache32);
          const cache42 = /* @__PURE__ */ new WeakMap();
          cache32.set(a3, cache42);
          const cache52 = /* @__PURE__ */ new WeakMap();
          cache42.set(a4, cache52);
          const newValue = fn(a1, a2, a3, a4, a5);
          cache52.set(a5, newValue);
          return newValue;
        }
        let cache3 = cache2.get(a2);
        if (!cache3) {
          cache3 = /* @__PURE__ */ new WeakMap();
          cache2.set(a2, cache3);
          const cache42 = /* @__PURE__ */ new WeakMap();
          cache3.set(a3, cache42);
          const cache52 = /* @__PURE__ */ new WeakMap();
          cache42.set(a4, cache52);
          const newValue = fn(a1, a2, a3, a4, a5);
          cache52.set(a5, newValue);
          return newValue;
        }
        let cache4 = cache3.get(a3);
        if (!cache4) {
          cache4 = /* @__PURE__ */ new WeakMap();
          cache3.set(a3, cache4);
          const cache52 = /* @__PURE__ */ new WeakMap();
          cache4.set(a4, cache52);
          const newValue = fn(a1, a2, a3, a4, a5);
          cache52.set(a5, newValue);
          return newValue;
        }
        let cache5 = cache4.get(a4);
        if (!cache5) {
          cache5 = /* @__PURE__ */ new WeakMap();
          cache4.set(a4, cache5);
          const newValue = fn(a1, a2, a3, a4, a5);
          cache5.set(a5, newValue);
          return newValue;
        }
        const cachedValue = cache5.get(a5);
        if (cachedValue === void 0) {
          const newValue = fn(a1, a2, a3, a4, a5);
          cache5.set(a5, newValue);
          return newValue;
        }
        return cachedValue;
      };
    }
    exports2.memoize5 = memoize5;
    function memoize2of4(fn) {
      const memoize2of4cache = /* @__PURE__ */ new WeakMap();
      return function memoized(a1, a2, a3, a4) {
        let cache2 = memoize2of4cache.get(a1);
        if (!cache2) {
          cache2 = /* @__PURE__ */ new WeakMap();
          memoize2of4cache.set(a1, cache2);
          const newValue = fn(a1, a2, a3, a4);
          cache2.set(a2, newValue);
          return newValue;
        }
        const cachedValue = cache2.get(a2);
        if (cachedValue === void 0) {
          const newValue = fn(a1, a2, a3, a4);
          cache2.set(a2, newValue);
          return newValue;
        }
        return cachedValue;
      };
    }
    exports2.memoize2of4 = memoize2of4;
    function memoize2of5(fn) {
      const memoize2of4cache = /* @__PURE__ */ new WeakMap();
      return function memoized(a1, a2, a3, a4, a5) {
        let cache2 = memoize2of4cache.get(a1);
        if (!cache2) {
          cache2 = /* @__PURE__ */ new WeakMap();
          memoize2of4cache.set(a1, cache2);
          const newValue = fn(a1, a2, a3, a4, a5);
          cache2.set(a2, newValue);
          return newValue;
        }
        const cachedValue = cache2.get(a2);
        if (cachedValue === void 0) {
          const newValue = fn(a1, a2, a3, a4, a5);
          cache2.set(a2, newValue);
          return newValue;
        }
        return cachedValue;
      };
    }
    exports2.memoize2of5 = memoize2of5;
  }
});

// ../../../node_modules/@graphql-tools/utils/cjs/rootTypes.js
var require_rootTypes = __commonJS({
  "../../../node_modules/@graphql-tools/utils/cjs/rootTypes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getRootTypeMap = exports2.getRootTypes = exports2.getRootTypeNames = exports2.getDefinedRootType = void 0;
    var errors_js_1 = require_errors();
    var memoize_js_1 = require_memoize();
    function getDefinedRootType(schema, operation, nodes) {
      const rootTypeMap = (0, exports2.getRootTypeMap)(schema);
      const rootType = rootTypeMap.get(operation);
      if (rootType == null) {
        throw (0, errors_js_1.createGraphQLError)(`Schema is not configured to execute ${operation} operation.`, {
          nodes
        });
      }
      return rootType;
    }
    exports2.getDefinedRootType = getDefinedRootType;
    exports2.getRootTypeNames = (0, memoize_js_1.memoize1)(function getRootTypeNames(schema) {
      const rootTypes = (0, exports2.getRootTypes)(schema);
      return new Set([...rootTypes].map((type) => type.name));
    });
    exports2.getRootTypes = (0, memoize_js_1.memoize1)(function getRootTypes(schema) {
      const rootTypeMap = (0, exports2.getRootTypeMap)(schema);
      return new Set(rootTypeMap.values());
    });
    exports2.getRootTypeMap = (0, memoize_js_1.memoize1)(function getRootTypeMap(schema) {
      const rootTypeMap = /* @__PURE__ */ new Map();
      const queryType = schema.getQueryType();
      if (queryType) {
        rootTypeMap.set("query", queryType);
      }
      const mutationType = schema.getMutationType();
      if (mutationType) {
        rootTypeMap.set("mutation", mutationType);
      }
      const subscriptionType = schema.getSubscriptionType();
      if (subscriptionType) {
        rootTypeMap.set("subscription", subscriptionType);
      }
      return rootTypeMap;
    });
  }
});

// ../../../node_modules/@graphql-tools/utils/cjs/print-schema-with-directives.js
var require_print_schema_with_directives = __commonJS({
  "../../../node_modules/@graphql-tools/utils/cjs/print-schema-with-directives.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.makeDirectiveNodes = exports2.makeDirectiveNode = exports2.makeDeprecatedDirective = exports2.astFromEnumValue = exports2.astFromInputField = exports2.astFromField = exports2.astFromScalarType = exports2.astFromEnumType = exports2.astFromInputObjectType = exports2.astFromUnionType = exports2.astFromInterfaceType = exports2.astFromObjectType = exports2.astFromArg = exports2.getDeprecatableDirectiveNodes = exports2.getDirectiveNodes = exports2.astFromDirective = exports2.astFromSchema = exports2.printSchemaWithDirectives = exports2.getDocumentNodeFromSchema = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var astFromType_js_1 = require_astFromType();
    var get_directives_js_1 = require_get_directives();
    var astFromValueUntyped_js_1 = require_astFromValueUntyped();
    var helpers_js_1 = require_helpers();
    var rootTypes_js_1 = require_rootTypes();
    function getDocumentNodeFromSchema(schema, options = {}) {
      const pathToDirectivesInExtensions = options.pathToDirectivesInExtensions;
      const typesMap = schema.getTypeMap();
      const schemaNode = astFromSchema(schema, pathToDirectivesInExtensions);
      const definitions = schemaNode != null ? [schemaNode] : [];
      const directives = schema.getDirectives();
      for (const directive of directives) {
        if ((0, graphql_1.isSpecifiedDirective)(directive)) {
          continue;
        }
        definitions.push(astFromDirective(directive, schema, pathToDirectivesInExtensions));
      }
      for (const typeName in typesMap) {
        const type = typesMap[typeName];
        const isPredefinedScalar = (0, graphql_1.isSpecifiedScalarType)(type);
        const isIntrospection = (0, graphql_1.isIntrospectionType)(type);
        if (isPredefinedScalar || isIntrospection) {
          continue;
        }
        if ((0, graphql_1.isObjectType)(type)) {
          definitions.push(astFromObjectType(type, schema, pathToDirectivesInExtensions));
        } else if ((0, graphql_1.isInterfaceType)(type)) {
          definitions.push(astFromInterfaceType(type, schema, pathToDirectivesInExtensions));
        } else if ((0, graphql_1.isUnionType)(type)) {
          definitions.push(astFromUnionType(type, schema, pathToDirectivesInExtensions));
        } else if ((0, graphql_1.isInputObjectType)(type)) {
          definitions.push(astFromInputObjectType(type, schema, pathToDirectivesInExtensions));
        } else if ((0, graphql_1.isEnumType)(type)) {
          definitions.push(astFromEnumType(type, schema, pathToDirectivesInExtensions));
        } else if ((0, graphql_1.isScalarType)(type)) {
          definitions.push(astFromScalarType(type, schema, pathToDirectivesInExtensions));
        } else {
          throw new Error(`Unknown type ${type}.`);
        }
      }
      return {
        kind: graphql_1.Kind.DOCUMENT,
        definitions
      };
    }
    exports2.getDocumentNodeFromSchema = getDocumentNodeFromSchema;
    function printSchemaWithDirectives(schema, options = {}) {
      const documentNode = getDocumentNodeFromSchema(schema, options);
      return (0, graphql_1.print)(documentNode);
    }
    exports2.printSchemaWithDirectives = printSchemaWithDirectives;
    function astFromSchema(schema, pathToDirectivesInExtensions) {
      var _a, _b;
      const operationTypeMap = /* @__PURE__ */ new Map([
        ["query", void 0],
        ["mutation", void 0],
        ["subscription", void 0]
      ]);
      const nodes = [];
      if (schema.astNode != null) {
        nodes.push(schema.astNode);
      }
      if (schema.extensionASTNodes != null) {
        for (const extensionASTNode of schema.extensionASTNodes) {
          nodes.push(extensionASTNode);
        }
      }
      for (const node of nodes) {
        if (node.operationTypes) {
          for (const operationTypeDefinitionNode of node.operationTypes) {
            operationTypeMap.set(operationTypeDefinitionNode.operation, operationTypeDefinitionNode);
          }
        }
      }
      const rootTypeMap = (0, rootTypes_js_1.getRootTypeMap)(schema);
      for (const [operationTypeNode, operationTypeDefinitionNode] of operationTypeMap) {
        const rootType = rootTypeMap.get(operationTypeNode);
        if (rootType != null) {
          const rootTypeAST = (0, astFromType_js_1.astFromType)(rootType);
          if (operationTypeDefinitionNode != null) {
            operationTypeDefinitionNode.type = rootTypeAST;
          } else {
            operationTypeMap.set(operationTypeNode, {
              kind: graphql_1.Kind.OPERATION_TYPE_DEFINITION,
              operation: operationTypeNode,
              type: rootTypeAST
            });
          }
        }
      }
      const operationTypes = [...operationTypeMap.values()].filter(helpers_js_1.isSome);
      const directives = getDirectiveNodes(schema, schema, pathToDirectivesInExtensions);
      if (!operationTypes.length && !directives.length) {
        return null;
      }
      const schemaNode = {
        kind: operationTypes != null ? graphql_1.Kind.SCHEMA_DEFINITION : graphql_1.Kind.SCHEMA_EXTENSION,
        operationTypes,
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives
      };
      schemaNode.description = ((_b = (_a = schema.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : schema.description != null) ? {
        kind: graphql_1.Kind.STRING,
        value: schema.description,
        block: true
      } : void 0;
      return schemaNode;
    }
    exports2.astFromSchema = astFromSchema;
    function astFromDirective(directive, schema, pathToDirectivesInExtensions) {
      var _a, _b, _c, _d;
      return {
        kind: graphql_1.Kind.DIRECTIVE_DEFINITION,
        description: (_b = (_a = directive.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : directive.description ? {
          kind: graphql_1.Kind.STRING,
          value: directive.description
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: directive.name
        },
        arguments: (_c = directive.args) === null || _c === void 0 ? void 0 : _c.map((arg) => astFromArg(arg, schema, pathToDirectivesInExtensions)),
        repeatable: directive.isRepeatable,
        locations: ((_d = directive.locations) === null || _d === void 0 ? void 0 : _d.map((location) => ({
          kind: graphql_1.Kind.NAME,
          value: location
        }))) || []
      };
    }
    exports2.astFromDirective = astFromDirective;
    function getDirectiveNodes(entity, schema, pathToDirectivesInExtensions) {
      const directivesInExtensions = (0, get_directives_js_1.getDirectivesInExtensions)(entity, pathToDirectivesInExtensions);
      let nodes = [];
      if (entity.astNode != null) {
        nodes.push(entity.astNode);
      }
      if ("extensionASTNodes" in entity && entity.extensionASTNodes != null) {
        nodes = nodes.concat(entity.extensionASTNodes);
      }
      let directives;
      if (directivesInExtensions != null) {
        directives = makeDirectiveNodes(schema, directivesInExtensions);
      } else {
        directives = [];
        for (const node of nodes) {
          if (node.directives) {
            directives.push(...node.directives);
          }
        }
      }
      return directives;
    }
    exports2.getDirectiveNodes = getDirectiveNodes;
    function getDeprecatableDirectiveNodes(entity, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      let directiveNodesBesidesDeprecated = [];
      let deprecatedDirectiveNode = null;
      const directivesInExtensions = (0, get_directives_js_1.getDirectivesInExtensions)(entity, pathToDirectivesInExtensions);
      let directives;
      if (directivesInExtensions != null) {
        directives = makeDirectiveNodes(schema, directivesInExtensions);
      } else {
        directives = (_a = entity.astNode) === null || _a === void 0 ? void 0 : _a.directives;
      }
      if (directives != null) {
        directiveNodesBesidesDeprecated = directives.filter((directive) => directive.name.value !== "deprecated");
        if (entity.deprecationReason != null) {
          deprecatedDirectiveNode = (_b = directives.filter((directive) => directive.name.value === "deprecated")) === null || _b === void 0 ? void 0 : _b[0];
        }
      }
      if (entity.deprecationReason != null && deprecatedDirectiveNode == null) {
        deprecatedDirectiveNode = makeDeprecatedDirective(entity.deprecationReason);
      }
      return deprecatedDirectiveNode == null ? directiveNodesBesidesDeprecated : [deprecatedDirectiveNode].concat(directiveNodesBesidesDeprecated);
    }
    exports2.getDeprecatableDirectiveNodes = getDeprecatableDirectiveNodes;
    function astFromArg(arg, schema, pathToDirectivesInExtensions) {
      var _a, _b, _c;
      return {
        kind: graphql_1.Kind.INPUT_VALUE_DEFINITION,
        description: (_b = (_a = arg.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : arg.description ? {
          kind: graphql_1.Kind.STRING,
          value: arg.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: arg.name
        },
        type: (0, astFromType_js_1.astFromType)(arg.type),
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        defaultValue: arg.defaultValue !== void 0 ? (_c = (0, graphql_1.astFromValue)(arg.defaultValue, arg.type)) !== null && _c !== void 0 ? _c : void 0 : void 0,
        directives: getDeprecatableDirectiveNodes(arg, schema, pathToDirectivesInExtensions)
      };
    }
    exports2.astFromArg = astFromArg;
    function astFromObjectType(type, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      return {
        kind: graphql_1.Kind.OBJECT_TYPE_DEFINITION,
        description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description ? {
          kind: graphql_1.Kind.STRING,
          value: type.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type.name
        },
        fields: Object.values(type.getFields()).map((field) => astFromField(field, schema, pathToDirectivesInExtensions)),
        interfaces: Object.values(type.getInterfaces()).map((iFace) => (0, astFromType_js_1.astFromType)(iFace)),
        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)
      };
    }
    exports2.astFromObjectType = astFromObjectType;
    function astFromInterfaceType(type, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      const node = {
        kind: graphql_1.Kind.INTERFACE_TYPE_DEFINITION,
        description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description ? {
          kind: graphql_1.Kind.STRING,
          value: type.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type.name
        },
        fields: Object.values(type.getFields()).map((field) => astFromField(field, schema, pathToDirectivesInExtensions)),
        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)
      };
      if ("getInterfaces" in type) {
        node.interfaces = Object.values(type.getInterfaces()).map((iFace) => (0, astFromType_js_1.astFromType)(iFace));
      }
      return node;
    }
    exports2.astFromInterfaceType = astFromInterfaceType;
    function astFromUnionType(type, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      return {
        kind: graphql_1.Kind.UNION_TYPE_DEFINITION,
        description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description ? {
          kind: graphql_1.Kind.STRING,
          value: type.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type.name
        },
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions),
        types: type.getTypes().map((type2) => (0, astFromType_js_1.astFromType)(type2))
      };
    }
    exports2.astFromUnionType = astFromUnionType;
    function astFromInputObjectType(type, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      return {
        kind: graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION,
        description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description ? {
          kind: graphql_1.Kind.STRING,
          value: type.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type.name
        },
        fields: Object.values(type.getFields()).map((field) => astFromInputField(field, schema, pathToDirectivesInExtensions)),
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)
      };
    }
    exports2.astFromInputObjectType = astFromInputObjectType;
    function astFromEnumType(type, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      return {
        kind: graphql_1.Kind.ENUM_TYPE_DEFINITION,
        description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description ? {
          kind: graphql_1.Kind.STRING,
          value: type.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type.name
        },
        values: Object.values(type.getValues()).map((value) => astFromEnumValue(value, schema, pathToDirectivesInExtensions)),
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)
      };
    }
    exports2.astFromEnumType = astFromEnumType;
    function astFromScalarType(type, schema, pathToDirectivesInExtensions) {
      var _a, _b, _c;
      const directivesInExtensions = (0, get_directives_js_1.getDirectivesInExtensions)(type, pathToDirectivesInExtensions);
      const directives = directivesInExtensions ? makeDirectiveNodes(schema, directivesInExtensions) : ((_a = type.astNode) === null || _a === void 0 ? void 0 : _a.directives) || [];
      const specifiedByValue = type["specifiedByUrl"] || type["specifiedByURL"];
      if (specifiedByValue && !directives.some((directiveNode) => directiveNode.name.value === "specifiedBy")) {
        const specifiedByArgs = {
          url: specifiedByValue
        };
        directives.push(makeDirectiveNode("specifiedBy", specifiedByArgs));
      }
      return {
        kind: graphql_1.Kind.SCALAR_TYPE_DEFINITION,
        description: (_c = (_b = type.astNode) === null || _b === void 0 ? void 0 : _b.description) !== null && _c !== void 0 ? _c : type.description ? {
          kind: graphql_1.Kind.STRING,
          value: type.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type.name
        },
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives
      };
    }
    exports2.astFromScalarType = astFromScalarType;
    function astFromField(field, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      return {
        kind: graphql_1.Kind.FIELD_DEFINITION,
        description: (_b = (_a = field.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : field.description ? {
          kind: graphql_1.Kind.STRING,
          value: field.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: field.name
        },
        arguments: field.args.map((arg) => astFromArg(arg, schema, pathToDirectivesInExtensions)),
        type: (0, astFromType_js_1.astFromType)(field.type),
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: getDeprecatableDirectiveNodes(field, schema, pathToDirectivesInExtensions)
      };
    }
    exports2.astFromField = astFromField;
    function astFromInputField(field, schema, pathToDirectivesInExtensions) {
      var _a, _b, _c;
      return {
        kind: graphql_1.Kind.INPUT_VALUE_DEFINITION,
        description: (_b = (_a = field.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : field.description ? {
          kind: graphql_1.Kind.STRING,
          value: field.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: field.name
        },
        type: (0, astFromType_js_1.astFromType)(field.type),
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: getDeprecatableDirectiveNodes(field, schema, pathToDirectivesInExtensions),
        defaultValue: (_c = (0, graphql_1.astFromValue)(field.defaultValue, field.type)) !== null && _c !== void 0 ? _c : void 0
      };
    }
    exports2.astFromInputField = astFromInputField;
    function astFromEnumValue(value, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      return {
        kind: graphql_1.Kind.ENUM_VALUE_DEFINITION,
        description: (_b = (_a = value.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : value.description ? {
          kind: graphql_1.Kind.STRING,
          value: value.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: value.name
        },
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: getDeprecatableDirectiveNodes(value, schema, pathToDirectivesInExtensions)
      };
    }
    exports2.astFromEnumValue = astFromEnumValue;
    function makeDeprecatedDirective(deprecationReason) {
      return makeDirectiveNode("deprecated", { reason: deprecationReason }, graphql_1.GraphQLDeprecatedDirective);
    }
    exports2.makeDeprecatedDirective = makeDeprecatedDirective;
    function makeDirectiveNode(name, args, directive) {
      const directiveArguments = [];
      if (directive != null) {
        for (const arg of directive.args) {
          const argName = arg.name;
          const argValue = args[argName];
          if (argValue !== void 0) {
            const value = (0, graphql_1.astFromValue)(argValue, arg.type);
            if (value) {
              directiveArguments.push({
                kind: graphql_1.Kind.ARGUMENT,
                name: {
                  kind: graphql_1.Kind.NAME,
                  value: argName
                },
                value
              });
            }
          }
        }
      } else {
        for (const argName in args) {
          const argValue = args[argName];
          const value = (0, astFromValueUntyped_js_1.astFromValueUntyped)(argValue);
          if (value) {
            directiveArguments.push({
              kind: graphql_1.Kind.ARGUMENT,
              name: {
                kind: graphql_1.Kind.NAME,
                value: argName
              },
              value
            });
          }
        }
      }
      return {
        kind: graphql_1.Kind.DIRECTIVE,
        name: {
          kind: graphql_1.Kind.NAME,
          value: name
        },
        arguments: directiveArguments
      };
    }
    exports2.makeDirectiveNode = makeDirectiveNode;
    function makeDirectiveNodes(schema, directiveValues) {
      const directiveNodes = [];
      for (const directiveName in directiveValues) {
        const arrayOrSingleValue = directiveValues[directiveName];
        const directive = schema === null || schema === void 0 ? void 0 : schema.getDirective(directiveName);
        if (Array.isArray(arrayOrSingleValue)) {
          for (const value of arrayOrSingleValue) {
            directiveNodes.push(makeDirectiveNode(directiveName, value, directive));
          }
        } else {
          directiveNodes.push(makeDirectiveNode(directiveName, arrayOrSingleValue, directive));
        }
      }
      return directiveNodes;
    }
    exports2.makeDirectiveNodes = makeDirectiveNodes;
  }
});

// ../../../node_modules/@graphql-tools/utils/cjs/validate-documents.js
var require_validate_documents = __commonJS({
  "../../../node_modules/@graphql-tools/utils/cjs/validate-documents.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createDefaultRules = exports2.validateGraphQlDocuments = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function validateGraphQlDocuments(schema, documents, rules = createDefaultRules()) {
      var _a;
      const definitionMap = /* @__PURE__ */ new Map();
      for (const document2 of documents) {
        for (const docDefinition of document2.definitions) {
          if ("name" in docDefinition && docDefinition.name) {
            definitionMap.set(`${docDefinition.kind}_${docDefinition.name.value}`, docDefinition);
          } else {
            definitionMap.set(Date.now().toString(), docDefinition);
          }
        }
      }
      const fullAST = {
        kind: graphql_1.Kind.DOCUMENT,
        definitions: Array.from(definitionMap.values())
      };
      const errors = (0, graphql_1.validate)(schema, fullAST, rules);
      for (const error of errors) {
        error.stack = error.message;
        if (error.locations) {
          for (const location of error.locations) {
            error.stack += `
    at ${(_a = error.source) === null || _a === void 0 ? void 0 : _a.name}:${location.line}:${location.column}`;
          }
        }
      }
      return errors;
    }
    exports2.validateGraphQlDocuments = validateGraphQlDocuments;
    function createDefaultRules() {
      let ignored = ["NoUnusedFragmentsRule", "NoUnusedVariablesRule", "KnownDirectivesRule"];
      if (graphql_1.versionInfo.major < 15) {
        ignored = ignored.map((rule) => rule.replace(/Rule$/, ""));
      }
      return graphql_1.specifiedRules.filter((f) => !ignored.includes(f.name));
    }
    exports2.createDefaultRules = createDefaultRules;
  }
});

// ../../../node_modules/@graphql-tools/utils/cjs/parse-graphql-json.js
var require_parse_graphql_json = __commonJS({
  "../../../node_modules/@graphql-tools/utils/cjs/parse-graphql-json.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseGraphQLJSON = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function stripBOM(content) {
      content = content.toString();
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    }
    function parseBOM(content) {
      return JSON.parse(stripBOM(content));
    }
    function parseGraphQLJSON(location, jsonContent, options) {
      let parsedJson = parseBOM(jsonContent);
      if (parsedJson.data) {
        parsedJson = parsedJson.data;
      }
      if (parsedJson.kind === "Document") {
        return {
          location,
          document: parsedJson
        };
      } else if (parsedJson.__schema) {
        const schema = (0, graphql_1.buildClientSchema)(parsedJson, options);
        return {
          location,
          schema
        };
      } else if (typeof parsedJson === "string") {
        return {
          location,
          rawSDL: parsedJson
        };
      }
      throw new Error(`Not valid JSON content`);
    }
    exports2.parseGraphQLJSON = parseGraphQLJSON;
  }
});

// ../../../node_modules/@graphql-tools/utils/cjs/comments.js
var require_comments = __commonJS({
  "../../../node_modules/@graphql-tools/utils/cjs/comments.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getBlockStringIndentation = exports2.dedentBlockStringValue = exports2.getLeadingCommentBlock = exports2.getComment = exports2.getDescription = exports2.printWithComments = exports2.printComment = exports2.pushComment = exports2.collectComment = exports2.resetComments = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var MAX_LINE_LENGTH2 = 80;
    var commentsRegistry = {};
    function resetComments() {
      commentsRegistry = {};
    }
    exports2.resetComments = resetComments;
    function collectComment(node) {
      var _a;
      const entityName = (_a = node.name) === null || _a === void 0 ? void 0 : _a.value;
      if (entityName == null) {
        return;
      }
      pushComment(node, entityName);
      switch (node.kind) {
        case "EnumTypeDefinition":
          if (node.values) {
            for (const value of node.values) {
              pushComment(value, entityName, value.name.value);
            }
          }
          break;
        case "ObjectTypeDefinition":
        case "InputObjectTypeDefinition":
        case "InterfaceTypeDefinition":
          if (node.fields) {
            for (const field of node.fields) {
              pushComment(field, entityName, field.name.value);
              if (isFieldDefinitionNode(field) && field.arguments) {
                for (const arg of field.arguments) {
                  pushComment(arg, entityName, field.name.value, arg.name.value);
                }
              }
            }
          }
          break;
      }
    }
    exports2.collectComment = collectComment;
    function pushComment(node, entity, field, argument) {
      const comment = getComment(node);
      if (typeof comment !== "string" || comment.length === 0) {
        return;
      }
      const keys = [entity];
      if (field) {
        keys.push(field);
        if (argument) {
          keys.push(argument);
        }
      }
      const path = keys.join(".");
      if (!commentsRegistry[path]) {
        commentsRegistry[path] = [];
      }
      commentsRegistry[path].push(comment);
    }
    exports2.pushComment = pushComment;
    function printComment(comment) {
      return "\n# " + comment.replace(/\n/g, "\n# ");
    }
    exports2.printComment = printComment;
    function join2(maybeArray, separator) {
      return maybeArray ? maybeArray.filter((x) => x).join(separator || "") : "";
    }
    function hasMultilineItems2(maybeArray) {
      var _a;
      return (_a = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes("\n"))) !== null && _a !== void 0 ? _a : false;
    }
    function addDescription(cb) {
      return (node, _key, _parent, path, ancestors) => {
        var _a;
        const keys = [];
        const parent = path.reduce((prev, key2) => {
          if (["fields", "arguments", "values"].includes(key2) && prev.name) {
            keys.push(prev.name.value);
          }
          return prev[key2];
        }, ancestors[0]);
        const key = [...keys, (_a = parent === null || parent === void 0 ? void 0 : parent.name) === null || _a === void 0 ? void 0 : _a.value].filter(Boolean).join(".");
        const items = [];
        if (node.kind.includes("Definition") && commentsRegistry[key]) {
          items.push(...commentsRegistry[key]);
        }
        return join2([...items.map(printComment), node.description, cb(node, _key, _parent, path, ancestors)], "\n");
      };
    }
    function indent2(maybeString) {
      return maybeString && `  ${maybeString.replace(/\n/g, "\n  ")}`;
    }
    function block2(array) {
      return array && array.length !== 0 ? `{
${indent2(join2(array, "\n"))}
}` : "";
    }
    function wrap2(start, maybeString, end) {
      return maybeString ? start + maybeString + (end || "") : "";
    }
    function printBlockString2(value, isDescription = false) {
      const escaped = value.replace(/"""/g, '\\"""');
      return (value[0] === " " || value[0] === "	") && value.indexOf("\n") === -1 ? `"""${escaped.replace(/"$/, '"\n')}"""` : `"""
${isDescription ? escaped : indent2(escaped)}
"""`;
    }
    var printDocASTReducer2 = {
      Name: { leave: (node) => node.value },
      Variable: { leave: (node) => "$" + node.name },
      // Document
      Document: {
        leave: (node) => join2(node.definitions, "\n\n")
      },
      OperationDefinition: {
        leave: (node) => {
          const varDefs = wrap2("(", join2(node.variableDefinitions, ", "), ")");
          const prefix = join2([node.operation, join2([node.name, varDefs]), join2(node.directives, " ")], " ");
          return prefix + " " + node.selectionSet;
        }
      },
      VariableDefinition: {
        leave: ({ variable, type, defaultValue, directives }) => variable + ": " + type + wrap2(" = ", defaultValue) + wrap2(" ", join2(directives, " "))
      },
      SelectionSet: { leave: ({ selections }) => block2(selections) },
      Field: {
        leave({ alias, name, arguments: args, directives, selectionSet }) {
          const prefix = wrap2("", alias, ": ") + name;
          let argsLine = prefix + wrap2("(", join2(args, ", "), ")");
          if (argsLine.length > MAX_LINE_LENGTH2) {
            argsLine = prefix + wrap2("(\n", indent2(join2(args, "\n")), "\n)");
          }
          return join2([argsLine, join2(directives, " "), selectionSet], " ");
        }
      },
      Argument: { leave: ({ name, value }) => name + ": " + value },
      // Fragments
      FragmentSpread: {
        leave: ({ name, directives }) => "..." + name + wrap2(" ", join2(directives, " "))
      },
      InlineFragment: {
        leave: ({ typeCondition, directives, selectionSet }) => join2(["...", wrap2("on ", typeCondition), join2(directives, " "), selectionSet], " ")
      },
      FragmentDefinition: {
        leave: ({ name, typeCondition, variableDefinitions, directives, selectionSet }) => (
          // Note: fragment variable definitions are experimental and may be changed
          // or removed in the future.
          `fragment ${name}${wrap2("(", join2(variableDefinitions, ", "), ")")} on ${typeCondition} ${wrap2("", join2(directives, " "), " ")}` + selectionSet
        )
      },
      // Value
      IntValue: { leave: ({ value }) => value },
      FloatValue: { leave: ({ value }) => value },
      StringValue: {
        leave: ({ value, block: isBlockString }) => {
          if (isBlockString) {
            return printBlockString2(value);
          }
          return JSON.stringify(value);
        }
      },
      BooleanValue: { leave: ({ value }) => value ? "true" : "false" },
      NullValue: { leave: () => "null" },
      EnumValue: { leave: ({ value }) => value },
      ListValue: { leave: ({ values }) => "[" + join2(values, ", ") + "]" },
      ObjectValue: { leave: ({ fields }) => "{" + join2(fields, ", ") + "}" },
      ObjectField: { leave: ({ name, value }) => name + ": " + value },
      // Directive
      Directive: {
        leave: ({ name, arguments: args }) => "@" + name + wrap2("(", join2(args, ", "), ")")
      },
      // Type
      NamedType: { leave: ({ name }) => name },
      ListType: { leave: ({ type }) => "[" + type + "]" },
      NonNullType: { leave: ({ type }) => type + "!" },
      // Type System Definitions
      SchemaDefinition: {
        leave: ({ directives, operationTypes }) => join2(["schema", join2(directives, " "), block2(operationTypes)], " ")
      },
      OperationTypeDefinition: {
        leave: ({ operation, type }) => operation + ": " + type
      },
      ScalarTypeDefinition: {
        leave: ({ name, directives }) => join2(["scalar", name, join2(directives, " ")], " ")
      },
      ObjectTypeDefinition: {
        leave: ({ name, interfaces, directives, fields }) => join2(["type", name, wrap2("implements ", join2(interfaces, " & ")), join2(directives, " "), block2(fields)], " ")
      },
      FieldDefinition: {
        leave: ({ name, arguments: args, type, directives }) => name + (hasMultilineItems2(args) ? wrap2("(\n", indent2(join2(args, "\n")), "\n)") : wrap2("(", join2(args, ", "), ")")) + ": " + type + wrap2(" ", join2(directives, " "))
      },
      InputValueDefinition: {
        leave: ({ name, type, defaultValue, directives }) => join2([name + ": " + type, wrap2("= ", defaultValue), join2(directives, " ")], " ")
      },
      InterfaceTypeDefinition: {
        leave: ({ name, interfaces, directives, fields }) => join2(["interface", name, wrap2("implements ", join2(interfaces, " & ")), join2(directives, " "), block2(fields)], " ")
      },
      UnionTypeDefinition: {
        leave: ({ name, directives, types }) => join2(["union", name, join2(directives, " "), wrap2("= ", join2(types, " | "))], " ")
      },
      EnumTypeDefinition: {
        leave: ({ name, directives, values }) => join2(["enum", name, join2(directives, " "), block2(values)], " ")
      },
      EnumValueDefinition: {
        leave: ({ name, directives }) => join2([name, join2(directives, " ")], " ")
      },
      InputObjectTypeDefinition: {
        leave: ({ name, directives, fields }) => join2(["input", name, join2(directives, " "), block2(fields)], " ")
      },
      DirectiveDefinition: {
        leave: ({ name, arguments: args, repeatable, locations }) => "directive @" + name + (hasMultilineItems2(args) ? wrap2("(\n", indent2(join2(args, "\n")), "\n)") : wrap2("(", join2(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join2(locations, " | ")
      },
      SchemaExtension: {
        leave: ({ directives, operationTypes }) => join2(["extend schema", join2(directives, " "), block2(operationTypes)], " ")
      },
      ScalarTypeExtension: {
        leave: ({ name, directives }) => join2(["extend scalar", name, join2(directives, " ")], " ")
      },
      ObjectTypeExtension: {
        leave: ({ name, interfaces, directives, fields }) => join2(["extend type", name, wrap2("implements ", join2(interfaces, " & ")), join2(directives, " "), block2(fields)], " ")
      },
      InterfaceTypeExtension: {
        leave: ({ name, interfaces, directives, fields }) => join2(["extend interface", name, wrap2("implements ", join2(interfaces, " & ")), join2(directives, " "), block2(fields)], " ")
      },
      UnionTypeExtension: {
        leave: ({ name, directives, types }) => join2(["extend union", name, join2(directives, " "), wrap2("= ", join2(types, " | "))], " ")
      },
      EnumTypeExtension: {
        leave: ({ name, directives, values }) => join2(["extend enum", name, join2(directives, " "), block2(values)], " ")
      },
      InputObjectTypeExtension: {
        leave: ({ name, directives, fields }) => join2(["extend input", name, join2(directives, " "), block2(fields)], " ")
      }
    };
    var printDocASTReducerWithComments = Object.keys(printDocASTReducer2).reduce((prev, key) => ({
      ...prev,
      [key]: {
        leave: addDescription(printDocASTReducer2[key].leave)
      }
    }), {});
    function printWithComments(ast) {
      return (0, graphql_1.visit)(ast, printDocASTReducerWithComments);
    }
    exports2.printWithComments = printWithComments;
    function isFieldDefinitionNode(node) {
      return node.kind === "FieldDefinition";
    }
    function getDescription(node, options) {
      if (node.description != null) {
        return node.description.value;
      }
      if (options === null || options === void 0 ? void 0 : options.commentDescriptions) {
        return getComment(node);
      }
    }
    exports2.getDescription = getDescription;
    function getComment(node) {
      const rawValue = getLeadingCommentBlock(node);
      if (rawValue !== void 0) {
        return dedentBlockStringValue(`
${rawValue}`);
      }
    }
    exports2.getComment = getComment;
    function getLeadingCommentBlock(node) {
      const loc = node.loc;
      if (!loc) {
        return;
      }
      const comments = [];
      let token = loc.startToken.prev;
      while (token != null && token.kind === graphql_1.TokenKind.COMMENT && token.next != null && token.prev != null && token.line + 1 === token.next.line && token.line !== token.prev.line) {
        const value = String(token.value);
        comments.push(value);
        token = token.prev;
      }
      return comments.length > 0 ? comments.reverse().join("\n") : void 0;
    }
    exports2.getLeadingCommentBlock = getLeadingCommentBlock;
    function dedentBlockStringValue(rawString) {
      const lines = rawString.split(/\r\n|[\n\r]/g);
      const commonIndent = getBlockStringIndentation(lines);
      if (commonIndent !== 0) {
        for (let i = 1; i < lines.length; i++) {
          lines[i] = lines[i].slice(commonIndent);
        }
      }
      while (lines.length > 0 && isBlank(lines[0])) {
        lines.shift();
      }
      while (lines.length > 0 && isBlank(lines[lines.length - 1])) {
        lines.pop();
      }
      return lines.join("\n");
    }
    exports2.dedentBlockStringValue = dedentBlockStringValue;
    function getBlockStringIndentation(lines) {
      let commonIndent = null;
      for (let i = 1; i < lines.length; i++) {
        const line = lines[i];
        const indent3 = leadingWhitespace2(line);
        if (indent3 === line.length) {
          continue;
        }
        if (commonIndent === null || indent3 < commonIndent) {
          commonIndent = indent3;
          if (commonIndent === 0) {
            break;
          }
        }
      }
      return commonIndent === null ? 0 : commonIndent;
    }
    exports2.getBlockStringIndentation = getBlockStringIndentation;
    function leadingWhitespace2(str) {
      let i = 0;
      while (i < str.length && (str[i] === " " || str[i] === "	")) {
        i++;
      }
      return i;
    }
    function isBlank(str) {
      return leadingWhitespace2(str) === str.length;
    }
  }
});

// ../../../node_modules/@graphql-tools/utils/cjs/parse-graphql-sdl.js
var require_parse_graphql_sdl = __commonJS({
  "../../../node_modules/@graphql-tools/utils/cjs/parse-graphql-sdl.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isDescribable = exports2.transformCommentsToDescriptions = exports2.parseGraphQLSDL = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var comments_js_1 = require_comments();
    function parseGraphQLSDL(location, rawSDL, options = {}) {
      let document2;
      try {
        if (options.commentDescriptions && rawSDL.includes("#")) {
          document2 = transformCommentsToDescriptions(rawSDL, options);
          if (options.noLocation) {
            document2 = (0, graphql_1.parse)((0, graphql_1.print)(document2), options);
          }
        } else {
          document2 = (0, graphql_1.parse)(new graphql_1.Source(rawSDL, location), options);
        }
      } catch (e) {
        if (e.message.includes("EOF") && rawSDL.replace(/(\#[^*]*)/g, "").trim() === "") {
          document2 = {
            kind: graphql_1.Kind.DOCUMENT,
            definitions: []
          };
        } else {
          throw e;
        }
      }
      return {
        location,
        document: document2
      };
    }
    exports2.parseGraphQLSDL = parseGraphQLSDL;
    function transformCommentsToDescriptions(sourceSdl, options = {}) {
      const parsedDoc = (0, graphql_1.parse)(sourceSdl, {
        ...options,
        noLocation: false
      });
      const modifiedDoc = (0, graphql_1.visit)(parsedDoc, {
        leave: (node) => {
          if (isDescribable(node)) {
            const rawValue = (0, comments_js_1.getLeadingCommentBlock)(node);
            if (rawValue !== void 0) {
              const commentsBlock = (0, comments_js_1.dedentBlockStringValue)("\n" + rawValue);
              const isBlock = commentsBlock.includes("\n");
              if (!node.description) {
                return {
                  ...node,
                  description: {
                    kind: graphql_1.Kind.STRING,
                    value: commentsBlock,
                    block: isBlock
                  }
                };
              } else {
                return {
                  ...node,
                  description: {
                    ...node.description,
                    value: node.description.value + "\n" + commentsBlock,
                    block: true
                  }
                };
              }
            }
          }
        }
      });
      return modifiedDoc;
    }
    exports2.transformCommentsToDescriptions = transformCommentsToDescriptions;
    function isDescribable(node) {
      return (0, graphql_1.isTypeSystemDefinitionNode)(node) || node.kind === graphql_1.Kind.FIELD_DEFINITION || node.kind === graphql_1.Kind.INPUT_VALUE_DEFINITION || node.kind === graphql_1.Kind.ENUM_VALUE_DEFINITION;
    }
    exports2.isDescribable = isDescribable;
  }
});

// ../../../node_modules/@graphql-tools/utils/cjs/build-operation-for-field.js
var require_build_operation_for_field = __commonJS({
  "../../../node_modules/@graphql-tools/utils/cjs/build-operation-for-field.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.buildOperationNodeForField = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var rootTypes_js_1 = require_rootTypes();
    var operationVariables = [];
    var fieldTypeMap = /* @__PURE__ */ new Map();
    function addOperationVariable(variable) {
      operationVariables.push(variable);
    }
    function resetOperationVariables() {
      operationVariables = [];
    }
    function resetFieldMap() {
      fieldTypeMap = /* @__PURE__ */ new Map();
    }
    function buildOperationNodeForField({ schema, kind, field, models, ignore = [], depthLimit, circularReferenceDepth, argNames, selectedFields = true }) {
      resetOperationVariables();
      resetFieldMap();
      const rootTypeNames = (0, rootTypes_js_1.getRootTypeNames)(schema);
      const operationNode = buildOperationAndCollectVariables({
        schema,
        fieldName: field,
        kind,
        models: models || [],
        ignore,
        depthLimit: depthLimit || Infinity,
        circularReferenceDepth: circularReferenceDepth || 1,
        argNames,
        selectedFields,
        rootTypeNames
      });
      operationNode.variableDefinitions = [...operationVariables];
      resetOperationVariables();
      resetFieldMap();
      return operationNode;
    }
    exports2.buildOperationNodeForField = buildOperationNodeForField;
    function buildOperationAndCollectVariables({ schema, fieldName, kind, models, ignore, depthLimit, circularReferenceDepth, argNames, selectedFields, rootTypeNames }) {
      const type = (0, rootTypes_js_1.getDefinedRootType)(schema, kind);
      const field = type.getFields()[fieldName];
      const operationName = `${fieldName}_${kind}`;
      if (field.args) {
        for (const arg of field.args) {
          const argName = arg.name;
          if (!argNames || argNames.includes(argName)) {
            addOperationVariable(resolveVariable(arg, argName));
          }
        }
      }
      return {
        kind: graphql_1.Kind.OPERATION_DEFINITION,
        operation: kind,
        name: {
          kind: graphql_1.Kind.NAME,
          value: operationName
        },
        variableDefinitions: [],
        selectionSet: {
          kind: graphql_1.Kind.SELECTION_SET,
          selections: [
            resolveField({
              type,
              field,
              models,
              firstCall: true,
              path: [],
              ancestors: [],
              ignore,
              depthLimit,
              circularReferenceDepth,
              schema,
              depth: 0,
              argNames,
              selectedFields,
              rootTypeNames
            })
          ]
        }
      };
    }
    function resolveSelectionSet({ parent, type, models, firstCall, path, ancestors, ignore, depthLimit, circularReferenceDepth, schema, depth, argNames, selectedFields, rootTypeNames }) {
      if (typeof selectedFields === "boolean" && depth > depthLimit) {
        return;
      }
      if ((0, graphql_1.isUnionType)(type)) {
        const types = type.getTypes();
        return {
          kind: graphql_1.Kind.SELECTION_SET,
          selections: types.filter((t) => !hasCircularRef([...ancestors, t], {
            depth: circularReferenceDepth
          })).map((t) => {
            return {
              kind: graphql_1.Kind.INLINE_FRAGMENT,
              typeCondition: {
                kind: graphql_1.Kind.NAMED_TYPE,
                name: {
                  kind: graphql_1.Kind.NAME,
                  value: t.name
                }
              },
              selectionSet: resolveSelectionSet({
                parent: type,
                type: t,
                models,
                path,
                ancestors,
                ignore,
                depthLimit,
                circularReferenceDepth,
                schema,
                depth,
                argNames,
                selectedFields,
                rootTypeNames
              })
            };
          }).filter((fragmentNode) => {
            var _a, _b;
            return ((_b = (_a = fragmentNode === null || fragmentNode === void 0 ? void 0 : fragmentNode.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length) > 0;
          })
        };
      }
      if ((0, graphql_1.isInterfaceType)(type)) {
        const types = Object.values(schema.getTypeMap()).filter((t) => (0, graphql_1.isObjectType)(t) && t.getInterfaces().includes(type));
        return {
          kind: graphql_1.Kind.SELECTION_SET,
          selections: types.filter((t) => !hasCircularRef([...ancestors, t], {
            depth: circularReferenceDepth
          })).map((t) => {
            return {
              kind: graphql_1.Kind.INLINE_FRAGMENT,
              typeCondition: {
                kind: graphql_1.Kind.NAMED_TYPE,
                name: {
                  kind: graphql_1.Kind.NAME,
                  value: t.name
                }
              },
              selectionSet: resolveSelectionSet({
                parent: type,
                type: t,
                models,
                path,
                ancestors,
                ignore,
                depthLimit,
                circularReferenceDepth,
                schema,
                depth,
                argNames,
                selectedFields,
                rootTypeNames
              })
            };
          }).filter((fragmentNode) => {
            var _a, _b;
            return ((_b = (_a = fragmentNode === null || fragmentNode === void 0 ? void 0 : fragmentNode.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length) > 0;
          })
        };
      }
      if ((0, graphql_1.isObjectType)(type) && !rootTypeNames.has(type.name)) {
        const isIgnored = ignore.includes(type.name) || ignore.includes(`${parent.name}.${path[path.length - 1]}`);
        const isModel = models.includes(type.name);
        if (!firstCall && isModel && !isIgnored) {
          return {
            kind: graphql_1.Kind.SELECTION_SET,
            selections: [
              {
                kind: graphql_1.Kind.FIELD,
                name: {
                  kind: graphql_1.Kind.NAME,
                  value: "id"
                }
              }
            ]
          };
        }
        const fields = type.getFields();
        return {
          kind: graphql_1.Kind.SELECTION_SET,
          selections: Object.keys(fields).filter((fieldName) => {
            return !hasCircularRef([...ancestors, (0, graphql_1.getNamedType)(fields[fieldName].type)], {
              depth: circularReferenceDepth
            });
          }).map((fieldName) => {
            const selectedSubFields = typeof selectedFields === "object" ? selectedFields[fieldName] : true;
            if (selectedSubFields) {
              return resolveField({
                type,
                field: fields[fieldName],
                models,
                path: [...path, fieldName],
                ancestors,
                ignore,
                depthLimit,
                circularReferenceDepth,
                schema,
                depth,
                argNames,
                selectedFields: selectedSubFields,
                rootTypeNames
              });
            }
            return null;
          }).filter((f) => {
            var _a, _b;
            if (f == null) {
              return false;
            } else if ("selectionSet" in f) {
              return !!((_b = (_a = f.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length);
            }
            return true;
          })
        };
      }
    }
    function resolveVariable(arg, name) {
      function resolveVariableType(type) {
        if ((0, graphql_1.isListType)(type)) {
          return {
            kind: graphql_1.Kind.LIST_TYPE,
            type: resolveVariableType(type.ofType)
          };
        }
        if ((0, graphql_1.isNonNullType)(type)) {
          return {
            kind: graphql_1.Kind.NON_NULL_TYPE,
            // for v16 compatibility
            type: resolveVariableType(type.ofType)
          };
        }
        return {
          kind: graphql_1.Kind.NAMED_TYPE,
          name: {
            kind: graphql_1.Kind.NAME,
            value: type.name
          }
        };
      }
      return {
        kind: graphql_1.Kind.VARIABLE_DEFINITION,
        variable: {
          kind: graphql_1.Kind.VARIABLE,
          name: {
            kind: graphql_1.Kind.NAME,
            value: name || arg.name
          }
        },
        type: resolveVariableType(arg.type)
      };
    }
    function getArgumentName(name, path) {
      return [...path, name].join("_");
    }
    function resolveField({ type, field, models, firstCall, path, ancestors, ignore, depthLimit, circularReferenceDepth, schema, depth, argNames, selectedFields, rootTypeNames }) {
      const namedType = (0, graphql_1.getNamedType)(field.type);
      let args = [];
      let removeField = false;
      if (field.args && field.args.length) {
        args = field.args.map((arg) => {
          const argumentName = getArgumentName(arg.name, path);
          if (argNames && !argNames.includes(argumentName)) {
            if ((0, graphql_1.isNonNullType)(arg.type)) {
              removeField = true;
            }
            return null;
          }
          if (!firstCall) {
            addOperationVariable(resolveVariable(arg, argumentName));
          }
          return {
            kind: graphql_1.Kind.ARGUMENT,
            name: {
              kind: graphql_1.Kind.NAME,
              value: arg.name
            },
            value: {
              kind: graphql_1.Kind.VARIABLE,
              name: {
                kind: graphql_1.Kind.NAME,
                value: getArgumentName(arg.name, path)
              }
            }
          };
        }).filter(Boolean);
      }
      if (removeField) {
        return null;
      }
      const fieldPath = [...path, field.name];
      const fieldPathStr = fieldPath.join(".");
      let fieldName = field.name;
      if (fieldTypeMap.has(fieldPathStr) && fieldTypeMap.get(fieldPathStr) !== field.type.toString()) {
        fieldName += field.type.toString().replace("!", "NonNull").replace("[", "List").replace("]", "");
      }
      fieldTypeMap.set(fieldPathStr, field.type.toString());
      if (!(0, graphql_1.isScalarType)(namedType) && !(0, graphql_1.isEnumType)(namedType)) {
        return {
          kind: graphql_1.Kind.FIELD,
          name: {
            kind: graphql_1.Kind.NAME,
            value: field.name
          },
          ...fieldName !== field.name && { alias: { kind: graphql_1.Kind.NAME, value: fieldName } },
          selectionSet: resolveSelectionSet({
            parent: type,
            type: namedType,
            models,
            firstCall,
            path: fieldPath,
            ancestors: [...ancestors, type],
            ignore,
            depthLimit,
            circularReferenceDepth,
            schema,
            depth: depth + 1,
            argNames,
            selectedFields,
            rootTypeNames
          }) || void 0,
          arguments: args
        };
      }
      return {
        kind: graphql_1.Kind.FIELD,
        name: {
          kind: graphql_1.Kind.NAME,
          value: field.name
        },
        ...fieldName !== field.name && { alias: { kind: graphql_1.Kind.NAME, value: fieldName } },
        arguments: args
      };
    }
    function hasCircularRef(types, config = {
      depth: 1
    }) {
      const type = types[types.length - 1];
      if ((0, graphql_1.isScalarType)(type)) {
        return false;
      }
      const size = types.filter((t) => t.name === type.name).length;
      return size > config.depth;
    }
  }
});

// ../../../node_modules/@graphql-tools/utils/cjs/types.js
var require_types2 = __commonJS({
  "../../../node_modules/@graphql-tools/utils/cjs/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DirectiveLocation = void 0;
    var DirectiveLocation2;
    (function(DirectiveLocation3) {
      DirectiveLocation3["QUERY"] = "QUERY";
      DirectiveLocation3["MUTATION"] = "MUTATION";
      DirectiveLocation3["SUBSCRIPTION"] = "SUBSCRIPTION";
      DirectiveLocation3["FIELD"] = "FIELD";
      DirectiveLocation3["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
      DirectiveLocation3["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
      DirectiveLocation3["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
      DirectiveLocation3["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
      DirectiveLocation3["SCHEMA"] = "SCHEMA";
      DirectiveLocation3["SCALAR"] = "SCALAR";
      DirectiveLocation3["OBJECT"] = "OBJECT";
      DirectiveLocation3["FIELD_DEFINITION"] = "FIELD_DEFINITION";
      DirectiveLocation3["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
      DirectiveLocation3["INTERFACE"] = "INTERFACE";
      DirectiveLocation3["UNION"] = "UNION";
      DirectiveLocation3["ENUM"] = "ENUM";
      DirectiveLocation3["ENUM_VALUE"] = "ENUM_VALUE";
      DirectiveLocation3["INPUT_OBJECT"] = "INPUT_OBJECT";
      DirectiveLocation3["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
    })(DirectiveLocation2 = exports2.DirectiveLocation || (exports2.DirectiveLocation = {}));
  }
});

// ../../../node_modules/@graphql-tools/utils/cjs/Interfaces.js
var require_Interfaces = __commonJS({
  "../../../node_modules/@graphql-tools/utils/cjs/Interfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MapperKind = void 0;
    var MapperKind;
    (function(MapperKind2) {
      MapperKind2["TYPE"] = "MapperKind.TYPE";
      MapperKind2["SCALAR_TYPE"] = "MapperKind.SCALAR_TYPE";
      MapperKind2["ENUM_TYPE"] = "MapperKind.ENUM_TYPE";
      MapperKind2["COMPOSITE_TYPE"] = "MapperKind.COMPOSITE_TYPE";
      MapperKind2["OBJECT_TYPE"] = "MapperKind.OBJECT_TYPE";
      MapperKind2["INPUT_OBJECT_TYPE"] = "MapperKind.INPUT_OBJECT_TYPE";
      MapperKind2["ABSTRACT_TYPE"] = "MapperKind.ABSTRACT_TYPE";
      MapperKind2["UNION_TYPE"] = "MapperKind.UNION_TYPE";
      MapperKind2["INTERFACE_TYPE"] = "MapperKind.INTERFACE_TYPE";
      MapperKind2["ROOT_OBJECT"] = "MapperKind.ROOT_OBJECT";
      MapperKind2["QUERY"] = "MapperKind.QUERY";
      MapperKind2["MUTATION"] = "MapperKind.MUTATION";
      MapperKind2["SUBSCRIPTION"] = "MapperKind.SUBSCRIPTION";
      MapperKind2["DIRECTIVE"] = "MapperKind.DIRECTIVE";
      MapperKind2["FIELD"] = "MapperKind.FIELD";
      MapperKind2["COMPOSITE_FIELD"] = "MapperKind.COMPOSITE_FIELD";
      MapperKind2["OBJECT_FIELD"] = "MapperKind.OBJECT_FIELD";
      MapperKind2["ROOT_FIELD"] = "MapperKind.ROOT_FIELD";
      MapperKind2["QUERY_ROOT_FIELD"] = "MapperKind.QUERY_ROOT_FIELD";
      MapperKind2["MUTATION_ROOT_FIELD"] = "MapperKind.MUTATION_ROOT_FIELD";
      MapperKind2["SUBSCRIPTION_ROOT_FIELD"] = "MapperKind.SUBSCRIPTION_ROOT_FIELD";
      MapperKind2["INTERFACE_FIELD"] = "MapperKind.INTERFACE_FIELD";
      MapperKind2["INPUT_OBJECT_FIELD"] = "MapperKind.INPUT_OBJECT_FIELD";
      MapperKind2["ARGUMENT"] = "MapperKind.ARGUMENT";
      MapperKind2["ENUM_VALUE"] = "MapperKind.ENUM_VALUE";
    })(MapperKind = exports2.MapperKind || (exports2.MapperKind = {}));
  }
});

// ../../../node_modules/@graphql-tools/utils/cjs/getObjectTypeFromTypeMap.js
var require_getObjectTypeFromTypeMap = __commonJS({
  "../../../node_modules/@graphql-tools/utils/cjs/getObjectTypeFromTypeMap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getObjectTypeFromTypeMap = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function getObjectTypeFromTypeMap(typeMap, type) {
      if (type) {
        const maybeObjectType = typeMap[type.name];
        if ((0, graphql_1.isObjectType)(maybeObjectType)) {
          return maybeObjectType;
        }
      }
    }
    exports2.getObjectTypeFromTypeMap = getObjectTypeFromTypeMap;
  }
});

// ../../../node_modules/@graphql-tools/utils/cjs/stub.js
var require_stub = __commonJS({
  "../../../node_modules/@graphql-tools/utils/cjs/stub.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getBuiltInForStub = exports2.isNamedStub = exports2.createStub = exports2.createNamedStub = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function createNamedStub(name, type) {
      let constructor;
      if (type === "object") {
        constructor = graphql_1.GraphQLObjectType;
      } else if (type === "interface") {
        constructor = graphql_1.GraphQLInterfaceType;
      } else {
        constructor = graphql_1.GraphQLInputObjectType;
      }
      return new constructor({
        name,
        fields: {
          _fake: {
            type: graphql_1.GraphQLString
          }
        }
      });
    }
    exports2.createNamedStub = createNamedStub;
    function createStub(node, type) {
      switch (node.kind) {
        case graphql_1.Kind.LIST_TYPE:
          return new graphql_1.GraphQLList(createStub(node.type, type));
        case graphql_1.Kind.NON_NULL_TYPE:
          return new graphql_1.GraphQLNonNull(createStub(node.type, type));
        default:
          if (type === "output") {
            return createNamedStub(node.name.value, "object");
          }
          return createNamedStub(node.name.value, "input");
      }
    }
    exports2.createStub = createStub;
    function isNamedStub(type) {
      if ("getFields" in type) {
        const fields = type.getFields();
        for (const fieldName in fields) {
          const field = fields[fieldName];
          return field.name === "_fake";
        }
      }
      return false;
    }
    exports2.isNamedStub = isNamedStub;
    function getBuiltInForStub(type) {
      switch (type.name) {
        case graphql_1.GraphQLInt.name:
          return graphql_1.GraphQLInt;
        case graphql_1.GraphQLFloat.name:
          return graphql_1.GraphQLFloat;
        case graphql_1.GraphQLString.name:
          return graphql_1.GraphQLString;
        case graphql_1.GraphQLBoolean.name:
          return graphql_1.GraphQLBoolean;
        case graphql_1.GraphQLID.name:
          return graphql_1.GraphQLID;
        default:
          return type;
      }
    }
    exports2.getBuiltInForStub = getBuiltInForStub;
  }
});

// ../../../node_modules/@graphql-tools/utils/cjs/rewire.js
var require_rewire = __commonJS({
  "../../../node_modules/@graphql-tools/utils/cjs/rewire.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.rewireTypes = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var stub_js_1 = require_stub();
    function rewireTypes(originalTypeMap, directives) {
      const referenceTypeMap = /* @__PURE__ */ Object.create(null);
      for (const typeName in originalTypeMap) {
        referenceTypeMap[typeName] = originalTypeMap[typeName];
      }
      const newTypeMap = /* @__PURE__ */ Object.create(null);
      for (const typeName in referenceTypeMap) {
        const namedType = referenceTypeMap[typeName];
        if (namedType == null || typeName.startsWith("__")) {
          continue;
        }
        const newName = namedType.name;
        if (newName.startsWith("__")) {
          continue;
        }
        if (newTypeMap[newName] != null) {
          console.warn(`Duplicate schema type name ${newName} found; keeping the existing one found in the schema`);
          continue;
        }
        newTypeMap[newName] = namedType;
      }
      for (const typeName in newTypeMap) {
        newTypeMap[typeName] = rewireNamedType(newTypeMap[typeName]);
      }
      const newDirectives = directives.map((directive) => rewireDirective(directive));
      return {
        typeMap: newTypeMap,
        directives: newDirectives
      };
      function rewireDirective(directive) {
        if ((0, graphql_1.isSpecifiedDirective)(directive)) {
          return directive;
        }
        const directiveConfig = directive.toConfig();
        directiveConfig.args = rewireArgs(directiveConfig.args);
        return new graphql_1.GraphQLDirective(directiveConfig);
      }
      function rewireArgs(args) {
        const rewiredArgs = {};
        for (const argName in args) {
          const arg = args[argName];
          const rewiredArgType = rewireType(arg.type);
          if (rewiredArgType != null) {
            arg.type = rewiredArgType;
            rewiredArgs[argName] = arg;
          }
        }
        return rewiredArgs;
      }
      function rewireNamedType(type) {
        if ((0, graphql_1.isObjectType)(type)) {
          const config = type.toConfig();
          const newConfig = {
            ...config,
            fields: () => rewireFields(config.fields),
            interfaces: () => rewireNamedTypes(config.interfaces)
          };
          return new graphql_1.GraphQLObjectType(newConfig);
        } else if ((0, graphql_1.isInterfaceType)(type)) {
          const config = type.toConfig();
          const newConfig = {
            ...config,
            fields: () => rewireFields(config.fields)
          };
          if ("interfaces" in newConfig) {
            newConfig.interfaces = () => rewireNamedTypes(config.interfaces);
          }
          return new graphql_1.GraphQLInterfaceType(newConfig);
        } else if ((0, graphql_1.isUnionType)(type)) {
          const config = type.toConfig();
          const newConfig = {
            ...config,
            types: () => rewireNamedTypes(config.types)
          };
          return new graphql_1.GraphQLUnionType(newConfig);
        } else if ((0, graphql_1.isInputObjectType)(type)) {
          const config = type.toConfig();
          const newConfig = {
            ...config,
            fields: () => rewireInputFields(config.fields)
          };
          return new graphql_1.GraphQLInputObjectType(newConfig);
        } else if ((0, graphql_1.isEnumType)(type)) {
          const enumConfig = type.toConfig();
          return new graphql_1.GraphQLEnumType(enumConfig);
        } else if ((0, graphql_1.isScalarType)(type)) {
          if ((0, graphql_1.isSpecifiedScalarType)(type)) {
            return type;
          }
          const scalarConfig = type.toConfig();
          return new graphql_1.GraphQLScalarType(scalarConfig);
        }
        throw new Error(`Unexpected schema type: ${type}`);
      }
      function rewireFields(fields) {
        const rewiredFields = {};
        for (const fieldName in fields) {
          const field = fields[fieldName];
          const rewiredFieldType = rewireType(field.type);
          if (rewiredFieldType != null && field.args) {
            field.type = rewiredFieldType;
            field.args = rewireArgs(field.args);
            rewiredFields[fieldName] = field;
          }
        }
        return rewiredFields;
      }
      function rewireInputFields(fields) {
        const rewiredFields = {};
        for (const fieldName in fields) {
          const field = fields[fieldName];
          const rewiredFieldType = rewireType(field.type);
          if (rewiredFieldType != null) {
            field.type = rewiredFieldType;
            rewiredFields[fieldName] = field;
          }
        }
        return rewiredFields;
      }
      function rewireNamedTypes(namedTypes) {
        const rewiredTypes = [];
        for (const namedType of namedTypes) {
          const rewiredType = rewireType(namedType);
          if (rewiredType != null) {
            rewiredTypes.push(rewiredType);
          }
        }
        return rewiredTypes;
      }
      function rewireType(type) {
        if ((0, graphql_1.isListType)(type)) {
          const rewiredType = rewireType(type.ofType);
          return rewiredType != null ? new graphql_1.GraphQLList(rewiredType) : null;
        } else if ((0, graphql_1.isNonNullType)(type)) {
          const rewiredType = rewireType(type.ofType);
          return rewiredType != null ? new graphql_1.GraphQLNonNull(rewiredType) : null;
        } else if ((0, graphql_1.isNamedType)(type)) {
          let rewiredType = referenceTypeMap[type.name];
          if (rewiredType === void 0) {
            rewiredType = (0, stub_js_1.isNamedStub)(type) ? (0, stub_js_1.getBuiltInForStub)(type) : rewireNamedType(type);
            newTypeMap[rewiredType.name] = referenceTypeMap[type.name] = rewiredType;
          }
          return rewiredType != null ? newTypeMap[rewiredType.name] : null;
        }
        return null;
      }
    }
    exports2.rewireTypes = rewireTypes;
  }
});

// ../../../node_modules/@graphql-tools/utils/cjs/transformInputValue.js
var require_transformInputValue = __commonJS({
  "../../../node_modules/@graphql-tools/utils/cjs/transformInputValue.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseInputValueLiteral = exports2.parseInputValue = exports2.serializeInputValue = exports2.transformInputValue = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var helpers_js_1 = require_helpers();
    function transformInputValue(type, value, inputLeafValueTransformer = null, inputObjectValueTransformer = null) {
      if (value == null) {
        return value;
      }
      const nullableType = (0, graphql_1.getNullableType)(type);
      if ((0, graphql_1.isLeafType)(nullableType)) {
        return inputLeafValueTransformer != null ? inputLeafValueTransformer(nullableType, value) : value;
      } else if ((0, graphql_1.isListType)(nullableType)) {
        return (0, helpers_js_1.asArray)(value).map((listMember) => transformInputValue(nullableType.ofType, listMember, inputLeafValueTransformer, inputObjectValueTransformer));
      } else if ((0, graphql_1.isInputObjectType)(nullableType)) {
        const fields = nullableType.getFields();
        const newValue = {};
        for (const key in value) {
          const field = fields[key];
          if (field != null) {
            newValue[key] = transformInputValue(field.type, value[key], inputLeafValueTransformer, inputObjectValueTransformer);
          }
        }
        return inputObjectValueTransformer != null ? inputObjectValueTransformer(nullableType, newValue) : newValue;
      }
    }
    exports2.transformInputValue = transformInputValue;
    function serializeInputValue(type, value) {
      return transformInputValue(type, value, (t, v) => {
        try {
          return t.serialize(v);
        } catch (_a) {
          return v;
        }
      });
    }
    exports2.serializeInputValue = serializeInputValue;
    function parseInputValue(type, value) {
      return transformInputValue(type, value, (t, v) => {
        try {
          return t.parseValue(v);
        } catch (_a) {
          return v;
        }
      });
    }
    exports2.parseInputValue = parseInputValue;
    function parseInputValueLiteral(type, value) {
      return transformInputValue(type, value, (t, v) => t.parseLiteral(v, {}));
    }
    exports2.parseInputValueLiteral = parseInputValueLiteral;
  }
});

// ../../../node_modules/@graphql-tools/utils/cjs/mapSchema.js
var require_mapSchema = __commonJS({
  "../../../node_modules/@graphql-tools/utils/cjs/mapSchema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.correctASTNodes = exports2.mapSchema = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var getObjectTypeFromTypeMap_js_1 = require_getObjectTypeFromTypeMap();
    var Interfaces_js_1 = require_Interfaces();
    var rewire_js_1 = require_rewire();
    var transformInputValue_js_1 = require_transformInputValue();
    function mapSchema(schema, schemaMapper = {}) {
      const newTypeMap = mapArguments(mapFields(mapTypes(mapDefaultValues(mapEnumValues(mapTypes(mapDefaultValues(schema.getTypeMap(), schema, transformInputValue_js_1.serializeInputValue), schema, schemaMapper, (type) => (0, graphql_1.isLeafType)(type)), schema, schemaMapper), schema, transformInputValue_js_1.parseInputValue), schema, schemaMapper, (type) => !(0, graphql_1.isLeafType)(type)), schema, schemaMapper), schema, schemaMapper);
      const originalDirectives = schema.getDirectives();
      const newDirectives = mapDirectives(originalDirectives, schema, schemaMapper);
      const { typeMap, directives } = (0, rewire_js_1.rewireTypes)(newTypeMap, newDirectives);
      return new graphql_1.GraphQLSchema({
        ...schema.toConfig(),
        query: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(newTypeMap, schema.getQueryType())),
        mutation: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(newTypeMap, schema.getMutationType())),
        subscription: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(newTypeMap, schema.getSubscriptionType())),
        types: Object.values(typeMap),
        directives
      });
    }
    exports2.mapSchema = mapSchema;
    function mapTypes(originalTypeMap, schema, schemaMapper, testFn = () => true) {
      const newTypeMap = {};
      for (const typeName in originalTypeMap) {
        if (!typeName.startsWith("__")) {
          const originalType = originalTypeMap[typeName];
          if (originalType == null || !testFn(originalType)) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          const typeMapper = getTypeMapper(schema, schemaMapper, typeName);
          if (typeMapper == null) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          const maybeNewType = typeMapper(originalType, schema);
          if (maybeNewType === void 0) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          newTypeMap[typeName] = maybeNewType;
        }
      }
      return newTypeMap;
    }
    function mapEnumValues(originalTypeMap, schema, schemaMapper) {
      const enumValueMapper = getEnumValueMapper(schemaMapper);
      if (!enumValueMapper) {
        return originalTypeMap;
      }
      return mapTypes(originalTypeMap, schema, {
        [Interfaces_js_1.MapperKind.ENUM_TYPE]: (type) => {
          const config = type.toConfig();
          const originalEnumValueConfigMap = config.values;
          const newEnumValueConfigMap = {};
          for (const externalValue in originalEnumValueConfigMap) {
            const originalEnumValueConfig = originalEnumValueConfigMap[externalValue];
            const mappedEnumValue = enumValueMapper(originalEnumValueConfig, type.name, schema, externalValue);
            if (mappedEnumValue === void 0) {
              newEnumValueConfigMap[externalValue] = originalEnumValueConfig;
            } else if (Array.isArray(mappedEnumValue)) {
              const [newExternalValue, newEnumValueConfig] = mappedEnumValue;
              newEnumValueConfigMap[newExternalValue] = newEnumValueConfig === void 0 ? originalEnumValueConfig : newEnumValueConfig;
            } else if (mappedEnumValue !== null) {
              newEnumValueConfigMap[externalValue] = mappedEnumValue;
            }
          }
          return correctASTNodes(new graphql_1.GraphQLEnumType({
            ...config,
            values: newEnumValueConfigMap
          }));
        }
      }, (type) => (0, graphql_1.isEnumType)(type));
    }
    function mapDefaultValues(originalTypeMap, schema, fn) {
      const newTypeMap = mapArguments(originalTypeMap, schema, {
        [Interfaces_js_1.MapperKind.ARGUMENT]: (argumentConfig) => {
          if (argumentConfig.defaultValue === void 0) {
            return argumentConfig;
          }
          const maybeNewType = getNewType(originalTypeMap, argumentConfig.type);
          if (maybeNewType != null) {
            return {
              ...argumentConfig,
              defaultValue: fn(maybeNewType, argumentConfig.defaultValue)
            };
          }
        }
      });
      return mapFields(newTypeMap, schema, {
        [Interfaces_js_1.MapperKind.INPUT_OBJECT_FIELD]: (inputFieldConfig) => {
          if (inputFieldConfig.defaultValue === void 0) {
            return inputFieldConfig;
          }
          const maybeNewType = getNewType(newTypeMap, inputFieldConfig.type);
          if (maybeNewType != null) {
            return {
              ...inputFieldConfig,
              defaultValue: fn(maybeNewType, inputFieldConfig.defaultValue)
            };
          }
        }
      });
    }
    function getNewType(newTypeMap, type) {
      if ((0, graphql_1.isListType)(type)) {
        const newType = getNewType(newTypeMap, type.ofType);
        return newType != null ? new graphql_1.GraphQLList(newType) : null;
      } else if ((0, graphql_1.isNonNullType)(type)) {
        const newType = getNewType(newTypeMap, type.ofType);
        return newType != null ? new graphql_1.GraphQLNonNull(newType) : null;
      } else if ((0, graphql_1.isNamedType)(type)) {
        const newType = newTypeMap[type.name];
        return newType != null ? newType : null;
      }
      return null;
    }
    function mapFields(originalTypeMap, schema, schemaMapper) {
      const newTypeMap = {};
      for (const typeName in originalTypeMap) {
        if (!typeName.startsWith("__")) {
          const originalType = originalTypeMap[typeName];
          if (!(0, graphql_1.isObjectType)(originalType) && !(0, graphql_1.isInterfaceType)(originalType) && !(0, graphql_1.isInputObjectType)(originalType)) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          const fieldMapper = getFieldMapper(schema, schemaMapper, typeName);
          if (fieldMapper == null) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          const config = originalType.toConfig();
          const originalFieldConfigMap = config.fields;
          const newFieldConfigMap = {};
          for (const fieldName in originalFieldConfigMap) {
            const originalFieldConfig = originalFieldConfigMap[fieldName];
            const mappedField = fieldMapper(originalFieldConfig, fieldName, typeName, schema);
            if (mappedField === void 0) {
              newFieldConfigMap[fieldName] = originalFieldConfig;
            } else if (Array.isArray(mappedField)) {
              const [newFieldName, newFieldConfig] = mappedField;
              if (newFieldConfig.astNode != null) {
                newFieldConfig.astNode = {
                  ...newFieldConfig.astNode,
                  name: {
                    ...newFieldConfig.astNode.name,
                    value: newFieldName
                  }
                };
              }
              newFieldConfigMap[newFieldName] = newFieldConfig === void 0 ? originalFieldConfig : newFieldConfig;
            } else if (mappedField !== null) {
              newFieldConfigMap[fieldName] = mappedField;
            }
          }
          if ((0, graphql_1.isObjectType)(originalType)) {
            newTypeMap[typeName] = correctASTNodes(new graphql_1.GraphQLObjectType({
              ...config,
              fields: newFieldConfigMap
            }));
          } else if ((0, graphql_1.isInterfaceType)(originalType)) {
            newTypeMap[typeName] = correctASTNodes(new graphql_1.GraphQLInterfaceType({
              ...config,
              fields: newFieldConfigMap
            }));
          } else {
            newTypeMap[typeName] = correctASTNodes(new graphql_1.GraphQLInputObjectType({
              ...config,
              fields: newFieldConfigMap
            }));
          }
        }
      }
      return newTypeMap;
    }
    function mapArguments(originalTypeMap, schema, schemaMapper) {
      const newTypeMap = {};
      for (const typeName in originalTypeMap) {
        if (!typeName.startsWith("__")) {
          const originalType = originalTypeMap[typeName];
          if (!(0, graphql_1.isObjectType)(originalType) && !(0, graphql_1.isInterfaceType)(originalType)) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          const argumentMapper = getArgumentMapper(schemaMapper);
          if (argumentMapper == null) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          const config = originalType.toConfig();
          const originalFieldConfigMap = config.fields;
          const newFieldConfigMap = {};
          for (const fieldName in originalFieldConfigMap) {
            const originalFieldConfig = originalFieldConfigMap[fieldName];
            const originalArgumentConfigMap = originalFieldConfig.args;
            if (originalArgumentConfigMap == null) {
              newFieldConfigMap[fieldName] = originalFieldConfig;
              continue;
            }
            const argumentNames = Object.keys(originalArgumentConfigMap);
            if (!argumentNames.length) {
              newFieldConfigMap[fieldName] = originalFieldConfig;
              continue;
            }
            const newArgumentConfigMap = {};
            for (const argumentName of argumentNames) {
              const originalArgumentConfig = originalArgumentConfigMap[argumentName];
              const mappedArgument = argumentMapper(originalArgumentConfig, fieldName, typeName, schema);
              if (mappedArgument === void 0) {
                newArgumentConfigMap[argumentName] = originalArgumentConfig;
              } else if (Array.isArray(mappedArgument)) {
                const [newArgumentName, newArgumentConfig] = mappedArgument;
                newArgumentConfigMap[newArgumentName] = newArgumentConfig;
              } else if (mappedArgument !== null) {
                newArgumentConfigMap[argumentName] = mappedArgument;
              }
            }
            newFieldConfigMap[fieldName] = {
              ...originalFieldConfig,
              args: newArgumentConfigMap
            };
          }
          if ((0, graphql_1.isObjectType)(originalType)) {
            newTypeMap[typeName] = new graphql_1.GraphQLObjectType({
              ...config,
              fields: newFieldConfigMap
            });
          } else if ((0, graphql_1.isInterfaceType)(originalType)) {
            newTypeMap[typeName] = new graphql_1.GraphQLInterfaceType({
              ...config,
              fields: newFieldConfigMap
            });
          } else {
            newTypeMap[typeName] = new graphql_1.GraphQLInputObjectType({
              ...config,
              fields: newFieldConfigMap
            });
          }
        }
      }
      return newTypeMap;
    }
    function mapDirectives(originalDirectives, schema, schemaMapper) {
      const directiveMapper = getDirectiveMapper(schemaMapper);
      if (directiveMapper == null) {
        return originalDirectives.slice();
      }
      const newDirectives = [];
      for (const directive of originalDirectives) {
        const mappedDirective = directiveMapper(directive, schema);
        if (mappedDirective === void 0) {
          newDirectives.push(directive);
        } else if (mappedDirective !== null) {
          newDirectives.push(mappedDirective);
        }
      }
      return newDirectives;
    }
    function getTypeSpecifiers(schema, typeName) {
      var _a, _b, _c;
      const type = schema.getType(typeName);
      const specifiers = [Interfaces_js_1.MapperKind.TYPE];
      if ((0, graphql_1.isObjectType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_TYPE, Interfaces_js_1.MapperKind.OBJECT_TYPE);
        if (typeName === ((_a = schema.getQueryType()) === null || _a === void 0 ? void 0 : _a.name)) {
          specifiers.push(Interfaces_js_1.MapperKind.ROOT_OBJECT, Interfaces_js_1.MapperKind.QUERY);
        } else if (typeName === ((_b = schema.getMutationType()) === null || _b === void 0 ? void 0 : _b.name)) {
          specifiers.push(Interfaces_js_1.MapperKind.ROOT_OBJECT, Interfaces_js_1.MapperKind.MUTATION);
        } else if (typeName === ((_c = schema.getSubscriptionType()) === null || _c === void 0 ? void 0 : _c.name)) {
          specifiers.push(Interfaces_js_1.MapperKind.ROOT_OBJECT, Interfaces_js_1.MapperKind.SUBSCRIPTION);
        }
      } else if ((0, graphql_1.isInputObjectType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.INPUT_OBJECT_TYPE);
      } else if ((0, graphql_1.isInterfaceType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_TYPE, Interfaces_js_1.MapperKind.ABSTRACT_TYPE, Interfaces_js_1.MapperKind.INTERFACE_TYPE);
      } else if ((0, graphql_1.isUnionType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_TYPE, Interfaces_js_1.MapperKind.ABSTRACT_TYPE, Interfaces_js_1.MapperKind.UNION_TYPE);
      } else if ((0, graphql_1.isEnumType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.ENUM_TYPE);
      } else if ((0, graphql_1.isScalarType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.SCALAR_TYPE);
      }
      return specifiers;
    }
    function getTypeMapper(schema, schemaMapper, typeName) {
      const specifiers = getTypeSpecifiers(schema, typeName);
      let typeMapper;
      const stack = [...specifiers];
      while (!typeMapper && stack.length > 0) {
        const next = stack.pop();
        typeMapper = schemaMapper[next];
      }
      return typeMapper != null ? typeMapper : null;
    }
    function getFieldSpecifiers(schema, typeName) {
      var _a, _b, _c;
      const type = schema.getType(typeName);
      const specifiers = [Interfaces_js_1.MapperKind.FIELD];
      if ((0, graphql_1.isObjectType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_FIELD, Interfaces_js_1.MapperKind.OBJECT_FIELD);
        if (typeName === ((_a = schema.getQueryType()) === null || _a === void 0 ? void 0 : _a.name)) {
          specifiers.push(Interfaces_js_1.MapperKind.ROOT_FIELD, Interfaces_js_1.MapperKind.QUERY_ROOT_FIELD);
        } else if (typeName === ((_b = schema.getMutationType()) === null || _b === void 0 ? void 0 : _b.name)) {
          specifiers.push(Interfaces_js_1.MapperKind.ROOT_FIELD, Interfaces_js_1.MapperKind.MUTATION_ROOT_FIELD);
        } else if (typeName === ((_c = schema.getSubscriptionType()) === null || _c === void 0 ? void 0 : _c.name)) {
          specifiers.push(Interfaces_js_1.MapperKind.ROOT_FIELD, Interfaces_js_1.MapperKind.SUBSCRIPTION_ROOT_FIELD);
        }
      } else if ((0, graphql_1.isInterfaceType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_FIELD, Interfaces_js_1.MapperKind.INTERFACE_FIELD);
      } else if ((0, graphql_1.isInputObjectType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.INPUT_OBJECT_FIELD);
      }
      return specifiers;
    }
    function getFieldMapper(schema, schemaMapper, typeName) {
      const specifiers = getFieldSpecifiers(schema, typeName);
      let fieldMapper;
      const stack = [...specifiers];
      while (!fieldMapper && stack.length > 0) {
        const next = stack.pop();
        fieldMapper = schemaMapper[next];
      }
      return fieldMapper !== null && fieldMapper !== void 0 ? fieldMapper : null;
    }
    function getArgumentMapper(schemaMapper) {
      const argumentMapper = schemaMapper[Interfaces_js_1.MapperKind.ARGUMENT];
      return argumentMapper != null ? argumentMapper : null;
    }
    function getDirectiveMapper(schemaMapper) {
      const directiveMapper = schemaMapper[Interfaces_js_1.MapperKind.DIRECTIVE];
      return directiveMapper != null ? directiveMapper : null;
    }
    function getEnumValueMapper(schemaMapper) {
      const enumValueMapper = schemaMapper[Interfaces_js_1.MapperKind.ENUM_VALUE];
      return enumValueMapper != null ? enumValueMapper : null;
    }
    function correctASTNodes(type) {
      if ((0, graphql_1.isObjectType)(type)) {
        const config = type.toConfig();
        if (config.astNode != null) {
          const fields = [];
          for (const fieldName in config.fields) {
            const fieldConfig = config.fields[fieldName];
            if (fieldConfig.astNode != null) {
              fields.push(fieldConfig.astNode);
            }
          }
          config.astNode = {
            ...config.astNode,
            kind: graphql_1.Kind.OBJECT_TYPE_DEFINITION,
            fields
          };
        }
        if (config.extensionASTNodes != null) {
          config.extensionASTNodes = config.extensionASTNodes.map((node) => ({
            ...node,
            kind: graphql_1.Kind.OBJECT_TYPE_EXTENSION,
            fields: void 0
          }));
        }
        return new graphql_1.GraphQLObjectType(config);
      } else if ((0, graphql_1.isInterfaceType)(type)) {
        const config = type.toConfig();
        if (config.astNode != null) {
          const fields = [];
          for (const fieldName in config.fields) {
            const fieldConfig = config.fields[fieldName];
            if (fieldConfig.astNode != null) {
              fields.push(fieldConfig.astNode);
            }
          }
          config.astNode = {
            ...config.astNode,
            kind: graphql_1.Kind.INTERFACE_TYPE_DEFINITION,
            fields
          };
        }
        if (config.extensionASTNodes != null) {
          config.extensionASTNodes = config.extensionASTNodes.map((node) => ({
            ...node,
            kind: graphql_1.Kind.INTERFACE_TYPE_EXTENSION,
            fields: void 0
          }));
        }
        return new graphql_1.GraphQLInterfaceType(config);
      } else if ((0, graphql_1.isInputObjectType)(type)) {
        const config = type.toConfig();
        if (config.astNode != null) {
          const fields = [];
          for (const fieldName in config.fields) {
            const fieldConfig = config.fields[fieldName];
            if (fieldConfig.astNode != null) {
              fields.push(fieldConfig.astNode);
            }
          }
          config.astNode = {
            ...config.astNode,
            kind: graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION,
            fields
          };
        }
        if (config.extensionASTNodes != null) {
          config.extensionASTNodes = config.extensionASTNodes.map((node) => ({
            ...node,
            kind: graphql_1.Kind.INPUT_OBJECT_TYPE_EXTENSION,
            fields: void 0
          }));
        }
        return new graphql_1.GraphQLInputObjectType(config);
      } else if ((0, graphql_1.isEnumType)(type)) {
        const config = type.toConfig();
        if (config.astNode != null) {
          const values = [];
          for (const enumKey in config.values) {
            const enumValueConfig = config.values[enumKey];
            if (enumValueConfig.astNode != null) {
              values.push(enumValueConfig.astNode);
            }
          }
          config.astNode = {
            ...config.astNode,
            values
          };
        }
        if (config.extensionASTNodes != null) {
          config.extensionASTNodes = config.extensionASTNodes.map((node) => ({
            ...node,
            values: void 0
          }));
        }
        return new graphql_1.GraphQLEnumType(config);
      } else {
        return type;
      }
    }
    exports2.correctASTNodes = correctASTNodes;
  }
});

// ../../../node_modules/@graphql-tools/utils/cjs/filterSchema.js
var require_filterSchema = __commonJS({
  "../../../node_modules/@graphql-tools/utils/cjs/filterSchema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.filterSchema = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var Interfaces_js_1 = require_Interfaces();
    var mapSchema_js_1 = require_mapSchema();
    function filterSchema({ schema, typeFilter = () => true, fieldFilter = void 0, rootFieldFilter = void 0, objectFieldFilter = void 0, interfaceFieldFilter = void 0, inputObjectFieldFilter = void 0, argumentFilter = void 0 }) {
      const filteredSchema = (0, mapSchema_js_1.mapSchema)(schema, {
        [Interfaces_js_1.MapperKind.QUERY]: (type) => filterRootFields(type, "Query", rootFieldFilter, argumentFilter),
        [Interfaces_js_1.MapperKind.MUTATION]: (type) => filterRootFields(type, "Mutation", rootFieldFilter, argumentFilter),
        [Interfaces_js_1.MapperKind.SUBSCRIPTION]: (type) => filterRootFields(type, "Subscription", rootFieldFilter, argumentFilter),
        [Interfaces_js_1.MapperKind.OBJECT_TYPE]: (type) => typeFilter(type.name, type) ? filterElementFields(graphql_1.GraphQLObjectType, type, objectFieldFilter || fieldFilter, argumentFilter) : null,
        [Interfaces_js_1.MapperKind.INTERFACE_TYPE]: (type) => typeFilter(type.name, type) ? filterElementFields(graphql_1.GraphQLInterfaceType, type, interfaceFieldFilter || fieldFilter, argumentFilter) : null,
        [Interfaces_js_1.MapperKind.INPUT_OBJECT_TYPE]: (type) => typeFilter(type.name, type) ? filterElementFields(graphql_1.GraphQLInputObjectType, type, inputObjectFieldFilter || fieldFilter) : null,
        [Interfaces_js_1.MapperKind.UNION_TYPE]: (type) => typeFilter(type.name, type) ? void 0 : null,
        [Interfaces_js_1.MapperKind.ENUM_TYPE]: (type) => typeFilter(type.name, type) ? void 0 : null,
        [Interfaces_js_1.MapperKind.SCALAR_TYPE]: (type) => typeFilter(type.name, type) ? void 0 : null
      });
      return filteredSchema;
    }
    exports2.filterSchema = filterSchema;
    function filterRootFields(type, operation, rootFieldFilter, argumentFilter) {
      if (rootFieldFilter || argumentFilter) {
        const config = type.toConfig();
        for (const fieldName in config.fields) {
          const field = config.fields[fieldName];
          if (rootFieldFilter && !rootFieldFilter(operation, fieldName, config.fields[fieldName])) {
            delete config.fields[fieldName];
          } else if (argumentFilter && field.args) {
            for (const argName in field.args) {
              if (!argumentFilter(operation, fieldName, argName, field.args[argName])) {
                delete field.args[argName];
              }
            }
          }
        }
        return new graphql_1.GraphQLObjectType(config);
      }
      return type;
    }
    function filterElementFields(ElementConstructor, type, fieldFilter, argumentFilter) {
      if (fieldFilter || argumentFilter) {
        const config = type.toConfig();
        for (const fieldName in config.fields) {
          const field = config.fields[fieldName];
          if (fieldFilter && !fieldFilter(type.name, fieldName, config.fields[fieldName])) {
            delete config.fields[fieldName];
          } else if (argumentFilter && "args" in field) {
            for (const argName in field.args) {
              if (!argumentFilter(type.name, fieldName, argName, field.args[argName])) {
                delete field.args[argName];
              }
            }
          }
        }
        return new ElementConstructor(config);
      }
    }
  }
});

// ../../../node_modules/@graphql-tools/utils/cjs/heal.js
var require_heal = __commonJS({
  "../../../node_modules/@graphql-tools/utils/cjs/heal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.healTypes = exports2.healSchema = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function healSchema(schema) {
      healTypes(schema.getTypeMap(), schema.getDirectives());
      return schema;
    }
    exports2.healSchema = healSchema;
    function healTypes(originalTypeMap, directives) {
      const actualNamedTypeMap = /* @__PURE__ */ Object.create(null);
      for (const typeName in originalTypeMap) {
        const namedType = originalTypeMap[typeName];
        if (namedType == null || typeName.startsWith("__")) {
          continue;
        }
        const actualName = namedType.name;
        if (actualName.startsWith("__")) {
          continue;
        }
        if (actualNamedTypeMap[actualName] != null) {
          console.warn(`Duplicate schema type name ${actualName} found; keeping the existing one found in the schema`);
          continue;
        }
        actualNamedTypeMap[actualName] = namedType;
      }
      for (const typeName in actualNamedTypeMap) {
        const namedType = actualNamedTypeMap[typeName];
        originalTypeMap[typeName] = namedType;
      }
      for (const decl of directives) {
        decl.args = decl.args.filter((arg) => {
          arg.type = healType(arg.type);
          return arg.type !== null;
        });
      }
      for (const typeName in originalTypeMap) {
        const namedType = originalTypeMap[typeName];
        if (!typeName.startsWith("__") && typeName in actualNamedTypeMap) {
          if (namedType != null) {
            healNamedType(namedType);
          }
        }
      }
      for (const typeName in originalTypeMap) {
        if (!typeName.startsWith("__") && !(typeName in actualNamedTypeMap)) {
          delete originalTypeMap[typeName];
        }
      }
      function healNamedType(type) {
        if ((0, graphql_1.isObjectType)(type)) {
          healFields(type);
          healInterfaces(type);
          return;
        } else if ((0, graphql_1.isInterfaceType)(type)) {
          healFields(type);
          if ("getInterfaces" in type) {
            healInterfaces(type);
          }
          return;
        } else if ((0, graphql_1.isUnionType)(type)) {
          healUnderlyingTypes(type);
          return;
        } else if ((0, graphql_1.isInputObjectType)(type)) {
          healInputFields(type);
          return;
        } else if ((0, graphql_1.isLeafType)(type)) {
          return;
        }
        throw new Error(`Unexpected schema type: ${type}`);
      }
      function healFields(type) {
        const fieldMap = type.getFields();
        for (const [key, field] of Object.entries(fieldMap)) {
          field.args.map((arg) => {
            arg.type = healType(arg.type);
            return arg.type === null ? null : arg;
          }).filter(Boolean);
          field.type = healType(field.type);
          if (field.type === null) {
            delete fieldMap[key];
          }
        }
      }
      function healInterfaces(type) {
        if ("getInterfaces" in type) {
          const interfaces = type.getInterfaces();
          interfaces.push(...interfaces.splice(0).map((iface) => healType(iface)).filter(Boolean));
        }
      }
      function healInputFields(type) {
        const fieldMap = type.getFields();
        for (const [key, field] of Object.entries(fieldMap)) {
          field.type = healType(field.type);
          if (field.type === null) {
            delete fieldMap[key];
          }
        }
      }
      function healUnderlyingTypes(type) {
        const types = type.getTypes();
        types.push(...types.splice(0).map((t) => healType(t)).filter(Boolean));
      }
      function healType(type) {
        if ((0, graphql_1.isListType)(type)) {
          const healedType = healType(type.ofType);
          return healedType != null ? new graphql_1.GraphQLList(healedType) : null;
        } else if ((0, graphql_1.isNonNullType)(type)) {
          const healedType = healType(type.ofType);
          return healedType != null ? new graphql_1.GraphQLNonNull(healedType) : null;
        } else if ((0, graphql_1.isNamedType)(type)) {
          const officialType = originalTypeMap[type.name];
          if (officialType && type !== officialType) {
            return officialType;
          }
        }
        return type;
      }
    }
    exports2.healTypes = healTypes;
  }
});

// ../../../node_modules/@graphql-tools/utils/cjs/getResolversFromSchema.js
var require_getResolversFromSchema = __commonJS({
  "../../../node_modules/@graphql-tools/utils/cjs/getResolversFromSchema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getResolversFromSchema = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function getResolversFromSchema(schema, includeDefaultMergedResolver) {
      var _a, _b;
      const resolvers = /* @__PURE__ */ Object.create(null);
      const typeMap = schema.getTypeMap();
      for (const typeName in typeMap) {
        if (!typeName.startsWith("__")) {
          const type = typeMap[typeName];
          if ((0, graphql_1.isScalarType)(type)) {
            if (!(0, graphql_1.isSpecifiedScalarType)(type)) {
              const config = type.toConfig();
              delete config.astNode;
              resolvers[typeName] = new graphql_1.GraphQLScalarType(config);
            }
          } else if ((0, graphql_1.isEnumType)(type)) {
            resolvers[typeName] = {};
            const values = type.getValues();
            for (const value of values) {
              resolvers[typeName][value.name] = value.value;
            }
          } else if ((0, graphql_1.isInterfaceType)(type)) {
            if (type.resolveType != null) {
              resolvers[typeName] = {
                __resolveType: type.resolveType
              };
            }
          } else if ((0, graphql_1.isUnionType)(type)) {
            if (type.resolveType != null) {
              resolvers[typeName] = {
                __resolveType: type.resolveType
              };
            }
          } else if ((0, graphql_1.isObjectType)(type)) {
            resolvers[typeName] = {};
            if (type.isTypeOf != null) {
              resolvers[typeName].__isTypeOf = type.isTypeOf;
            }
            const fields = type.getFields();
            for (const fieldName in fields) {
              const field = fields[fieldName];
              if (field.subscribe != null) {
                resolvers[typeName][fieldName] = resolvers[typeName][fieldName] || {};
                resolvers[typeName][fieldName].subscribe = field.subscribe;
              }
              if (field.resolve != null && ((_a = field.resolve) === null || _a === void 0 ? void 0 : _a.name) !== "defaultFieldResolver") {
                switch ((_b = field.resolve) === null || _b === void 0 ? void 0 : _b.name) {
                  case "defaultMergedResolver":
                    if (!includeDefaultMergedResolver) {
                      continue;
                    }
                    break;
                  case "defaultFieldResolver":
                    continue;
                }
                resolvers[typeName][fieldName] = resolvers[typeName][fieldName] || {};
                resolvers[typeName][fieldName].resolve = field.resolve;
              }
            }
          }
        }
      }
      return resolvers;
    }
    exports2.getResolversFromSchema = getResolversFromSchema;
  }
});

// ../../../node_modules/@graphql-tools/utils/cjs/forEachField.js
var require_forEachField = __commonJS({
  "../../../node_modules/@graphql-tools/utils/cjs/forEachField.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.forEachField = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function forEachField(schema, fn) {
      const typeMap = schema.getTypeMap();
      for (const typeName in typeMap) {
        const type = typeMap[typeName];
        if (!(0, graphql_1.getNamedType)(type).name.startsWith("__") && (0, graphql_1.isObjectType)(type)) {
          const fields = type.getFields();
          for (const fieldName in fields) {
            const field = fields[fieldName];
            fn(field, typeName, fieldName);
          }
        }
      }
    }
    exports2.forEachField = forEachField;
  }
});

// ../../../node_modules/@graphql-tools/utils/cjs/forEachDefaultValue.js
var require_forEachDefaultValue = __commonJS({
  "../../../node_modules/@graphql-tools/utils/cjs/forEachDefaultValue.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.forEachDefaultValue = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function forEachDefaultValue(schema, fn) {
      const typeMap = schema.getTypeMap();
      for (const typeName in typeMap) {
        const type = typeMap[typeName];
        if (!(0, graphql_1.getNamedType)(type).name.startsWith("__")) {
          if ((0, graphql_1.isObjectType)(type)) {
            const fields = type.getFields();
            for (const fieldName in fields) {
              const field = fields[fieldName];
              for (const arg of field.args) {
                arg.defaultValue = fn(arg.type, arg.defaultValue);
              }
            }
          } else if ((0, graphql_1.isInputObjectType)(type)) {
            const fields = type.getFields();
            for (const fieldName in fields) {
              const field = fields[fieldName];
              field.defaultValue = fn(field.type, field.defaultValue);
            }
          }
        }
      }
    }
    exports2.forEachDefaultValue = forEachDefaultValue;
  }
});

// ../../../node_modules/@graphql-tools/utils/cjs/addTypes.js
var require_addTypes = __commonJS({
  "../../../node_modules/@graphql-tools/utils/cjs/addTypes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.addTypes = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var getObjectTypeFromTypeMap_js_1 = require_getObjectTypeFromTypeMap();
    var rewire_js_1 = require_rewire();
    function addTypes(schema, newTypesOrDirectives) {
      const config = schema.toConfig();
      const originalTypeMap = {};
      for (const type of config.types) {
        originalTypeMap[type.name] = type;
      }
      const originalDirectiveMap = {};
      for (const directive of config.directives) {
        originalDirectiveMap[directive.name] = directive;
      }
      for (const newTypeOrDirective of newTypesOrDirectives) {
        if ((0, graphql_1.isNamedType)(newTypeOrDirective)) {
          originalTypeMap[newTypeOrDirective.name] = newTypeOrDirective;
        } else if ((0, graphql_1.isDirective)(newTypeOrDirective)) {
          originalDirectiveMap[newTypeOrDirective.name] = newTypeOrDirective;
        }
      }
      const { typeMap, directives } = (0, rewire_js_1.rewireTypes)(originalTypeMap, Object.values(originalDirectiveMap));
      return new graphql_1.GraphQLSchema({
        ...config,
        query: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, schema.getQueryType()),
        mutation: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, schema.getMutationType()),
        subscription: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, schema.getSubscriptionType()),
        types: Object.values(typeMap),
        directives
      });
    }
    exports2.addTypes = addTypes;
  }
});

// ../../../node_modules/@graphql-tools/utils/cjs/prune.js
var require_prune = __commonJS({
  "../../../node_modules/@graphql-tools/utils/cjs/prune.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.pruneSchema = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var mapSchema_js_1 = require_mapSchema();
    var Interfaces_js_1 = require_Interfaces();
    var rootTypes_js_1 = require_rootTypes();
    var get_implementing_types_js_1 = require_get_implementing_types();
    function pruneSchema(schema, options = {}) {
      const { skipEmptyCompositeTypePruning, skipEmptyUnionPruning, skipPruning, skipUnimplementedInterfacesPruning, skipUnusedTypesPruning } = options;
      let prunedTypes = [];
      let prunedSchema = schema;
      do {
        let visited = visitSchema(prunedSchema);
        if (skipPruning) {
          const revisit = [];
          for (const typeName in prunedSchema.getTypeMap()) {
            if (typeName.startsWith("__")) {
              continue;
            }
            const type = prunedSchema.getType(typeName);
            if (type && skipPruning(type)) {
              revisit.push(typeName);
            }
          }
          visited = visitQueue(revisit, prunedSchema, visited);
        }
        prunedTypes = [];
        prunedSchema = (0, mapSchema_js_1.mapSchema)(prunedSchema, {
          [Interfaces_js_1.MapperKind.TYPE]: (type) => {
            if (!visited.has(type.name) && !(0, graphql_1.isSpecifiedScalarType)(type)) {
              if ((0, graphql_1.isUnionType)(type) || (0, graphql_1.isInputObjectType)(type) || (0, graphql_1.isInterfaceType)(type) || (0, graphql_1.isObjectType)(type) || (0, graphql_1.isScalarType)(type)) {
                if (skipUnusedTypesPruning) {
                  return type;
                }
                if ((0, graphql_1.isUnionType)(type) && skipEmptyUnionPruning && !Object.keys(type.getTypes()).length) {
                  return type;
                }
                if ((0, graphql_1.isInputObjectType)(type) || (0, graphql_1.isInterfaceType)(type) || (0, graphql_1.isObjectType)(type)) {
                  if (skipEmptyCompositeTypePruning && !Object.keys(type.getFields()).length) {
                    return type;
                  }
                }
                if ((0, graphql_1.isInterfaceType)(type) && skipUnimplementedInterfacesPruning) {
                  return type;
                }
              }
              prunedTypes.push(type.name);
              visited.delete(type.name);
              return null;
            }
            return type;
          }
        });
      } while (prunedTypes.length);
      return prunedSchema;
    }
    exports2.pruneSchema = pruneSchema;
    function visitSchema(schema) {
      const queue = [];
      for (const type of (0, rootTypes_js_1.getRootTypes)(schema)) {
        queue.push(type.name);
      }
      return visitQueue(queue, schema);
    }
    function visitQueue(queue, schema, visited = /* @__PURE__ */ new Set()) {
      const revisit = /* @__PURE__ */ new Map();
      while (queue.length) {
        const typeName = queue.pop();
        if (visited.has(typeName) && revisit[typeName] !== true) {
          continue;
        }
        const type = schema.getType(typeName);
        if (type) {
          if ((0, graphql_1.isUnionType)(type)) {
            queue.push(...type.getTypes().map((type2) => type2.name));
          }
          if ((0, graphql_1.isInterfaceType)(type) && revisit[typeName] === true) {
            queue.push(...(0, get_implementing_types_js_1.getImplementingTypes)(type.name, schema));
            revisit[typeName] = false;
          }
          if ((0, graphql_1.isEnumType)(type)) {
            queue.push(...type.getValues().flatMap((value) => {
              if (value.astNode) {
                return getDirectivesArgumentsTypeNames(schema, value.astNode);
              }
              return [];
            }));
          }
          if ("getInterfaces" in type) {
            queue.push(...type.getInterfaces().map((iface) => iface.name));
          }
          if ("getFields" in type) {
            const fields = type.getFields();
            const entries = Object.entries(fields);
            if (!entries.length) {
              continue;
            }
            for (const [, field] of entries) {
              if ((0, graphql_1.isObjectType)(type)) {
                queue.push(...field.args.flatMap((arg) => {
                  const typeNames = [(0, graphql_1.getNamedType)(arg.type).name];
                  if (arg.astNode) {
                    typeNames.push(...getDirectivesArgumentsTypeNames(schema, arg.astNode));
                  }
                  return typeNames;
                }));
              }
              const namedType = (0, graphql_1.getNamedType)(field.type);
              queue.push(namedType.name);
              if (field.astNode) {
                queue.push(...getDirectivesArgumentsTypeNames(schema, field.astNode));
              }
              if ((0, graphql_1.isInterfaceType)(namedType) && !(namedType.name in revisit)) {
                revisit[namedType.name] = true;
              }
            }
          }
          if (type.astNode) {
            queue.push(...getDirectivesArgumentsTypeNames(schema, type.astNode));
          }
          visited.add(typeName);
        }
      }
      return visited;
    }
    function getDirectivesArgumentsTypeNames(schema, astNode) {
      var _a;
      return ((_a = astNode.directives) !== null && _a !== void 0 ? _a : []).flatMap((directive) => {
        var _a2, _b;
        return (_b = (_a2 = schema.getDirective(directive.name.value)) === null || _a2 === void 0 ? void 0 : _a2.args.map((arg) => (0, graphql_1.getNamedType)(arg.type).name)) !== null && _b !== void 0 ? _b : [];
      });
    }
  }
});

// ../../../node_modules/@graphql-tools/utils/cjs/mergeDeep.js
var require_mergeDeep = __commonJS({
  "../../../node_modules/@graphql-tools/utils/cjs/mergeDeep.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeDeep = void 0;
    var helpers_js_1 = require_helpers();
    function mergeDeep(sources, respectPrototype = false) {
      const target = sources[0] || {};
      const output = {};
      if (respectPrototype) {
        Object.setPrototypeOf(output, Object.create(Object.getPrototypeOf(target)));
      }
      for (const source of sources) {
        if (isObject(target) && isObject(source)) {
          if (respectPrototype) {
            const outputPrototype = Object.getPrototypeOf(output);
            const sourcePrototype = Object.getPrototypeOf(source);
            if (sourcePrototype) {
              for (const key of Object.getOwnPropertyNames(sourcePrototype)) {
                const descriptor = Object.getOwnPropertyDescriptor(sourcePrototype, key);
                if ((0, helpers_js_1.isSome)(descriptor)) {
                  Object.defineProperty(outputPrototype, key, descriptor);
                }
              }
            }
          }
          for (const key in source) {
            if (isObject(source[key])) {
              if (!(key in output)) {
                Object.assign(output, { [key]: source[key] });
              } else {
                output[key] = mergeDeep([output[key], source[key]], respectPrototype);
              }
            } else {
              Object.assign(output, { [key]: source[key] });
            }
          }
        }
      }
      return output;
    }
    exports2.mergeDeep = mergeDeep;
    function isObject(item) {
      return item && typeof item === "object" && !Array.isArray(item);
    }
  }
});

// ../../../node_modules/@graphql-tools/utils/cjs/selectionSets.js
var require_selectionSets = __commonJS({
  "../../../node_modules/@graphql-tools/utils/cjs/selectionSets.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseSelectionSet = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function parseSelectionSet(selectionSet, options) {
      const query = (0, graphql_1.parse)(selectionSet, options).definitions[0];
      return query.selectionSet;
    }
    exports2.parseSelectionSet = parseSelectionSet;
  }
});

// ../../../node_modules/@graphql-tools/utils/cjs/getResponseKeyFromInfo.js
var require_getResponseKeyFromInfo = __commonJS({
  "../../../node_modules/@graphql-tools/utils/cjs/getResponseKeyFromInfo.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getResponseKeyFromInfo = void 0;
    function getResponseKeyFromInfo(info) {
      return info.fieldNodes[0].alias != null ? info.fieldNodes[0].alias.value : info.fieldName;
    }
    exports2.getResponseKeyFromInfo = getResponseKeyFromInfo;
  }
});

// ../../../node_modules/@graphql-tools/utils/cjs/fields.js
var require_fields = __commonJS({
  "../../../node_modules/@graphql-tools/utils/cjs/fields.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.modifyObjectFields = exports2.selectObjectFields = exports2.removeObjectFields = exports2.appendObjectFields = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var Interfaces_js_1 = require_Interfaces();
    var mapSchema_js_1 = require_mapSchema();
    var addTypes_js_1 = require_addTypes();
    function appendObjectFields(schema, typeName, additionalFields) {
      if (schema.getType(typeName) == null) {
        return (0, addTypes_js_1.addTypes)(schema, [
          new graphql_1.GraphQLObjectType({
            name: typeName,
            fields: additionalFields
          })
        ]);
      }
      return (0, mapSchema_js_1.mapSchema)(schema, {
        [Interfaces_js_1.MapperKind.OBJECT_TYPE]: (type) => {
          if (type.name === typeName) {
            const config = type.toConfig();
            const originalFieldConfigMap = config.fields;
            const newFieldConfigMap = {};
            for (const fieldName in originalFieldConfigMap) {
              newFieldConfigMap[fieldName] = originalFieldConfigMap[fieldName];
            }
            for (const fieldName in additionalFields) {
              newFieldConfigMap[fieldName] = additionalFields[fieldName];
            }
            return (0, mapSchema_js_1.correctASTNodes)(new graphql_1.GraphQLObjectType({
              ...config,
              fields: newFieldConfigMap
            }));
          }
        }
      });
    }
    exports2.appendObjectFields = appendObjectFields;
    function removeObjectFields(schema, typeName, testFn) {
      const removedFields = {};
      const newSchema = (0, mapSchema_js_1.mapSchema)(schema, {
        [Interfaces_js_1.MapperKind.OBJECT_TYPE]: (type) => {
          if (type.name === typeName) {
            const config = type.toConfig();
            const originalFieldConfigMap = config.fields;
            const newFieldConfigMap = {};
            for (const fieldName in originalFieldConfigMap) {
              const originalFieldConfig = originalFieldConfigMap[fieldName];
              if (testFn(fieldName, originalFieldConfig)) {
                removedFields[fieldName] = originalFieldConfig;
              } else {
                newFieldConfigMap[fieldName] = originalFieldConfig;
              }
            }
            return (0, mapSchema_js_1.correctASTNodes)(new graphql_1.GraphQLObjectType({
              ...config,
              fields: newFieldConfigMap
            }));
          }
        }
      });
      return [newSchema, removedFields];
    }
    exports2.removeObjectFields = removeObjectFields;
    function selectObjectFields(schema, typeName, testFn) {
      const selectedFields = {};
      (0, mapSchema_js_1.mapSchema)(schema, {
        [Interfaces_js_1.MapperKind.OBJECT_TYPE]: (type) => {
          if (type.name === typeName) {
            const config = type.toConfig();
            const originalFieldConfigMap = config.fields;
            for (const fieldName in originalFieldConfigMap) {
              const originalFieldConfig = originalFieldConfigMap[fieldName];
              if (testFn(fieldName, originalFieldConfig)) {
                selectedFields[fieldName] = originalFieldConfig;
              }
            }
          }
          return void 0;
        }
      });
      return selectedFields;
    }
    exports2.selectObjectFields = selectObjectFields;
    function modifyObjectFields(schema, typeName, testFn, newFields) {
      const removedFields = {};
      const newSchema = (0, mapSchema_js_1.mapSchema)(schema, {
        [Interfaces_js_1.MapperKind.OBJECT_TYPE]: (type) => {
          if (type.name === typeName) {
            const config = type.toConfig();
            const originalFieldConfigMap = config.fields;
            const newFieldConfigMap = {};
            for (const fieldName in originalFieldConfigMap) {
              const originalFieldConfig = originalFieldConfigMap[fieldName];
              if (testFn(fieldName, originalFieldConfig)) {
                removedFields[fieldName] = originalFieldConfig;
              } else {
                newFieldConfigMap[fieldName] = originalFieldConfig;
              }
            }
            for (const fieldName in newFields) {
              const fieldConfig = newFields[fieldName];
              newFieldConfigMap[fieldName] = fieldConfig;
            }
            return (0, mapSchema_js_1.correctASTNodes)(new graphql_1.GraphQLObjectType({
              ...config,
              fields: newFieldConfigMap
            }));
          }
        }
      });
      return [newSchema, removedFields];
    }
    exports2.modifyObjectFields = modifyObjectFields;
  }
});

// ../../../node_modules/@graphql-tools/utils/cjs/renameType.js
var require_renameType = __commonJS({
  "../../../node_modules/@graphql-tools/utils/cjs/renameType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.renameType = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function renameType(type, newTypeName) {
      if ((0, graphql_1.isObjectType)(type)) {
        return new graphql_1.GraphQLObjectType({
          ...type.toConfig(),
          name: newTypeName,
          astNode: type.astNode == null ? type.astNode : {
            ...type.astNode,
            name: {
              ...type.astNode.name,
              value: newTypeName
            }
          },
          extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map((node) => ({
            ...node,
            name: {
              ...node.name,
              value: newTypeName
            }
          }))
        });
      } else if ((0, graphql_1.isInterfaceType)(type)) {
        return new graphql_1.GraphQLInterfaceType({
          ...type.toConfig(),
          name: newTypeName,
          astNode: type.astNode == null ? type.astNode : {
            ...type.astNode,
            name: {
              ...type.astNode.name,
              value: newTypeName
            }
          },
          extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map((node) => ({
            ...node,
            name: {
              ...node.name,
              value: newTypeName
            }
          }))
        });
      } else if ((0, graphql_1.isUnionType)(type)) {
        return new graphql_1.GraphQLUnionType({
          ...type.toConfig(),
          name: newTypeName,
          astNode: type.astNode == null ? type.astNode : {
            ...type.astNode,
            name: {
              ...type.astNode.name,
              value: newTypeName
            }
          },
          extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map((node) => ({
            ...node,
            name: {
              ...node.name,
              value: newTypeName
            }
          }))
        });
      } else if ((0, graphql_1.isInputObjectType)(type)) {
        return new graphql_1.GraphQLInputObjectType({
          ...type.toConfig(),
          name: newTypeName,
          astNode: type.astNode == null ? type.astNode : {
            ...type.astNode,
            name: {
              ...type.astNode.name,
              value: newTypeName
            }
          },
          extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map((node) => ({
            ...node,
            name: {
              ...node.name,
              value: newTypeName
            }
          }))
        });
      } else if ((0, graphql_1.isEnumType)(type)) {
        return new graphql_1.GraphQLEnumType({
          ...type.toConfig(),
          name: newTypeName,
          astNode: type.astNode == null ? type.astNode : {
            ...type.astNode,
            name: {
              ...type.astNode.name,
              value: newTypeName
            }
          },
          extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map((node) => ({
            ...node,
            name: {
              ...node.name,
              value: newTypeName
            }
          }))
        });
      } else if ((0, graphql_1.isScalarType)(type)) {
        return new graphql_1.GraphQLScalarType({
          ...type.toConfig(),
          name: newTypeName,
          astNode: type.astNode == null ? type.astNode : {
            ...type.astNode,
            name: {
              ...type.astNode.name,
              value: newTypeName
            }
          },
          extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map((node) => ({
            ...node,
            name: {
              ...node.name,
              value: newTypeName
            }
          }))
        });
      }
      throw new Error(`Unknown type ${type}.`);
    }
    exports2.renameType = renameType;
  }
});

// ../../../node_modules/@graphql-tools/utils/cjs/mapAsyncIterator.js
var require_mapAsyncIterator = __commonJS({
  "../../../node_modules/@graphql-tools/utils/cjs/mapAsyncIterator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mapAsyncIterator = void 0;
    function mapAsyncIterator2(iterator, callback, rejectCallback) {
      let $return;
      let abruptClose;
      if (typeof iterator.return === "function") {
        $return = iterator.return;
        abruptClose = (error) => {
          const rethrow = () => Promise.reject(error);
          return $return.call(iterator).then(rethrow, rethrow);
        };
      }
      function mapResult(result) {
        return result.done ? result : asyncMapValue(result.value, callback).then(iteratorResult, abruptClose);
      }
      let mapReject;
      if (rejectCallback) {
        const reject = rejectCallback;
        mapReject = (error) => asyncMapValue(error, reject).then(iteratorResult, abruptClose);
      }
      return {
        next() {
          return iterator.next().then(mapResult, mapReject);
        },
        return() {
          return $return ? $return.call(iterator).then(mapResult, mapReject) : Promise.resolve({ value: void 0, done: true });
        },
        throw(error) {
          if (typeof iterator.throw === "function") {
            return iterator.throw(error).then(mapResult, mapReject);
          }
          return Promise.reject(error).catch(abruptClose);
        },
        [Symbol.asyncIterator]() {
          return this;
        }
      };
    }
    exports2.mapAsyncIterator = mapAsyncIterator2;
    function asyncMapValue(value, callback) {
      return new Promise((resolve) => resolve(callback(value)));
    }
    function iteratorResult(value) {
      return { value, done: false };
    }
  }
});

// ../../../node_modules/@graphql-tools/utils/cjs/updateArgument.js
var require_updateArgument = __commonJS({
  "../../../node_modules/@graphql-tools/utils/cjs/updateArgument.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createVariableNameGenerator = exports2.updateArgument = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var astFromType_js_1 = require_astFromType();
    function updateArgument(argumentNodes, variableDefinitionsMap, variableValues, argName, varName, type, value) {
      argumentNodes[argName] = {
        kind: graphql_1.Kind.ARGUMENT,
        name: {
          kind: graphql_1.Kind.NAME,
          value: argName
        },
        value: {
          kind: graphql_1.Kind.VARIABLE,
          name: {
            kind: graphql_1.Kind.NAME,
            value: varName
          }
        }
      };
      variableDefinitionsMap[varName] = {
        kind: graphql_1.Kind.VARIABLE_DEFINITION,
        variable: {
          kind: graphql_1.Kind.VARIABLE,
          name: {
            kind: graphql_1.Kind.NAME,
            value: varName
          }
        },
        type: (0, astFromType_js_1.astFromType)(type)
      };
      if (value !== void 0) {
        variableValues[varName] = value;
        return;
      }
      if (varName in variableValues) {
        delete variableValues[varName];
      }
    }
    exports2.updateArgument = updateArgument;
    function createVariableNameGenerator(variableDefinitionMap) {
      let varCounter = 0;
      return (argName) => {
        let varName;
        do {
          varName = `_v${(varCounter++).toString()}_${argName}`;
        } while (varName in variableDefinitionMap);
        return varName;
      };
    }
    exports2.createVariableNameGenerator = createVariableNameGenerator;
  }
});

// ../../../node_modules/@graphql-tools/utils/cjs/implementsAbstractType.js
var require_implementsAbstractType = __commonJS({
  "../../../node_modules/@graphql-tools/utils/cjs/implementsAbstractType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.implementsAbstractType = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function implementsAbstractType(schema, typeA, typeB) {
      if (typeB == null || typeA == null) {
        return false;
      } else if (typeA === typeB) {
        return true;
      } else if ((0, graphql_1.isCompositeType)(typeA) && (0, graphql_1.isCompositeType)(typeB)) {
        return (0, graphql_1.doTypesOverlap)(schema, typeA, typeB);
      }
      return false;
    }
    exports2.implementsAbstractType = implementsAbstractType;
  }
});

// ../../../node_modules/@graphql-tools/utils/cjs/observableToAsyncIterable.js
var require_observableToAsyncIterable = __commonJS({
  "../../../node_modules/@graphql-tools/utils/cjs/observableToAsyncIterable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.observableToAsyncIterable = void 0;
    function observableToAsyncIterable(observable) {
      const pullQueue = [];
      const pushQueue = [];
      let listening = true;
      const pushValue = (value) => {
        if (pullQueue.length !== 0) {
          pullQueue.shift()({ value, done: false });
        } else {
          pushQueue.push({ value, done: false });
        }
      };
      const pushError = (error) => {
        if (pullQueue.length !== 0) {
          pullQueue.shift()({ value: { errors: [error] }, done: false });
        } else {
          pushQueue.push({ value: { errors: [error] }, done: false });
        }
      };
      const pushDone = () => {
        if (pullQueue.length !== 0) {
          pullQueue.shift()({ done: true });
        } else {
          pushQueue.push({ done: true });
        }
      };
      const pullValue = () => new Promise((resolve) => {
        if (pushQueue.length !== 0) {
          const element = pushQueue.shift();
          resolve(element);
        } else {
          pullQueue.push(resolve);
        }
      });
      const subscription = observable.subscribe({
        next(value) {
          pushValue(value);
        },
        error(err) {
          pushError(err);
        },
        complete() {
          pushDone();
        }
      });
      const emptyQueue = () => {
        if (listening) {
          listening = false;
          subscription.unsubscribe();
          for (const resolve of pullQueue) {
            resolve({ value: void 0, done: true });
          }
          pullQueue.length = 0;
          pushQueue.length = 0;
        }
      };
      return {
        next() {
          return listening ? pullValue() : this.return();
        },
        return() {
          emptyQueue();
          return Promise.resolve({ value: void 0, done: true });
        },
        throw(error) {
          emptyQueue();
          return Promise.reject(error);
        },
        [Symbol.asyncIterator]() {
          return this;
        }
      };
    }
    exports2.observableToAsyncIterable = observableToAsyncIterable;
  }
});

// ../../../node_modules/@graphql-tools/utils/cjs/getOperationASTFromRequest.js
var require_getOperationASTFromRequest = __commonJS({
  "../../../node_modules/@graphql-tools/utils/cjs/getOperationASTFromRequest.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getOperationASTFromRequest = exports2.getOperationASTFromDocument = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var memoize_js_1 = require_memoize();
    function getOperationASTFromDocument(documentNode, operationName) {
      const doc = (0, graphql_1.getOperationAST)(documentNode, operationName);
      if (!doc) {
        throw new Error(`Cannot infer operation ${operationName || ""}`);
      }
      return doc;
    }
    exports2.getOperationASTFromDocument = getOperationASTFromDocument;
    exports2.getOperationASTFromRequest = (0, memoize_js_1.memoize1)(function getOperationASTFromRequest(request) {
      return getOperationASTFromDocument(request.document, request.operationName);
    });
  }
});

// ../../../node_modules/@graphql-tools/utils/cjs/directives.js
var require_directives = __commonJS({
  "../../../node_modules/@graphql-tools/utils/cjs/directives.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GraphQLStreamDirective = exports2.GraphQLDeferDirective = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    exports2.GraphQLDeferDirective = new graphql_1.GraphQLDirective({
      name: "defer",
      description: "Directs the executor to defer this fragment when the `if` argument is true or undefined.",
      locations: [graphql_1.DirectiveLocation.FRAGMENT_SPREAD, graphql_1.DirectiveLocation.INLINE_FRAGMENT],
      args: {
        if: {
          type: new graphql_1.GraphQLNonNull(graphql_1.GraphQLBoolean),
          description: "Deferred when true or undefined.",
          defaultValue: true
        },
        label: {
          type: graphql_1.GraphQLString,
          description: "Unique name"
        }
      }
    });
    exports2.GraphQLStreamDirective = new graphql_1.GraphQLDirective({
      name: "stream",
      description: "Directs the executor to stream plural fields when the `if` argument is true or undefined.",
      locations: [graphql_1.DirectiveLocation.FIELD],
      args: {
        if: {
          type: new graphql_1.GraphQLNonNull(graphql_1.GraphQLBoolean),
          description: "Stream when true or undefined.",
          defaultValue: true
        },
        label: {
          type: graphql_1.GraphQLString,
          description: "Unique name"
        },
        initialCount: {
          defaultValue: 0,
          type: graphql_1.GraphQLInt,
          description: "Number of items to return immediately"
        }
      }
    });
  }
});

// ../../../node_modules/@graphql-tools/utils/cjs/AccumulatorMap.js
var require_AccumulatorMap = __commonJS({
  "../../../node_modules/@graphql-tools/utils/cjs/AccumulatorMap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AccumulatorMap = void 0;
    var AccumulatorMap = class extends Map {
      get [Symbol.toStringTag]() {
        return "AccumulatorMap";
      }
      add(key, item) {
        const group = this.get(key);
        if (group === void 0) {
          this.set(key, [item]);
        } else {
          group.push(item);
        }
      }
    };
    exports2.AccumulatorMap = AccumulatorMap;
  }
});

// ../../../node_modules/@graphql-tools/utils/cjs/collectFields.js
var require_collectFields = __commonJS({
  "../../../node_modules/@graphql-tools/utils/cjs/collectFields.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.collectSubFields = exports2.getDeferValues = exports2.getFieldEntryKey = exports2.doesFragmentConditionMatch = exports2.shouldIncludeNode = exports2.collectFields = void 0;
    var memoize_js_1 = require_memoize();
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var directives_js_1 = require_directives();
    var AccumulatorMap_js_1 = require_AccumulatorMap();
    function collectFieldsImpl2(schema, fragments, variableValues, runtimeType, selectionSet, fields, patches, visitedFragmentNames) {
      for (const selection of selectionSet.selections) {
        switch (selection.kind) {
          case graphql_1.Kind.FIELD: {
            if (!shouldIncludeNode2(variableValues, selection)) {
              continue;
            }
            fields.add(getFieldEntryKey2(selection), selection);
            break;
          }
          case graphql_1.Kind.INLINE_FRAGMENT: {
            if (!shouldIncludeNode2(variableValues, selection) || !doesFragmentConditionMatch2(schema, selection, runtimeType)) {
              continue;
            }
            const defer = getDeferValues(variableValues, selection);
            if (defer) {
              const patchFields = new AccumulatorMap_js_1.AccumulatorMap();
              collectFieldsImpl2(schema, fragments, variableValues, runtimeType, selection.selectionSet, patchFields, patches, visitedFragmentNames);
              patches.push({
                label: defer.label,
                fields: patchFields
              });
            } else {
              collectFieldsImpl2(schema, fragments, variableValues, runtimeType, selection.selectionSet, fields, patches, visitedFragmentNames);
            }
            break;
          }
          case graphql_1.Kind.FRAGMENT_SPREAD: {
            const fragName = selection.name.value;
            if (!shouldIncludeNode2(variableValues, selection)) {
              continue;
            }
            const defer = getDeferValues(variableValues, selection);
            if (visitedFragmentNames.has(fragName) && !defer) {
              continue;
            }
            const fragment = fragments[fragName];
            if (!fragment || !doesFragmentConditionMatch2(schema, fragment, runtimeType)) {
              continue;
            }
            if (!defer) {
              visitedFragmentNames.add(fragName);
            }
            if (defer) {
              const patchFields = new AccumulatorMap_js_1.AccumulatorMap();
              collectFieldsImpl2(schema, fragments, variableValues, runtimeType, fragment.selectionSet, patchFields, patches, visitedFragmentNames);
              patches.push({
                label: defer.label,
                fields: patchFields
              });
            } else {
              collectFieldsImpl2(schema, fragments, variableValues, runtimeType, fragment.selectionSet, fields, patches, visitedFragmentNames);
            }
            break;
          }
        }
      }
    }
    function collectFields2(schema, fragments, variableValues, runtimeType, selectionSet) {
      const fields = new AccumulatorMap_js_1.AccumulatorMap();
      const patches = [];
      collectFieldsImpl2(schema, fragments, variableValues, runtimeType, selectionSet, fields, patches, /* @__PURE__ */ new Set());
      return { fields, patches };
    }
    exports2.collectFields = collectFields2;
    function shouldIncludeNode2(variableValues, node) {
      const skip = (0, graphql_1.getDirectiveValues)(graphql_1.GraphQLSkipDirective, node, variableValues);
      if ((skip === null || skip === void 0 ? void 0 : skip["if"]) === true) {
        return false;
      }
      const include = (0, graphql_1.getDirectiveValues)(graphql_1.GraphQLIncludeDirective, node, variableValues);
      if ((include === null || include === void 0 ? void 0 : include["if"]) === false) {
        return false;
      }
      return true;
    }
    exports2.shouldIncludeNode = shouldIncludeNode2;
    function doesFragmentConditionMatch2(schema, fragment, type) {
      const typeConditionNode = fragment.typeCondition;
      if (!typeConditionNode) {
        return true;
      }
      const conditionalType = (0, graphql_1.typeFromAST)(schema, typeConditionNode);
      if (conditionalType === type) {
        return true;
      }
      if ((0, graphql_1.isAbstractType)(conditionalType)) {
        const possibleTypes = schema.getPossibleTypes(conditionalType);
        return possibleTypes.includes(type);
      }
      return false;
    }
    exports2.doesFragmentConditionMatch = doesFragmentConditionMatch2;
    function getFieldEntryKey2(node) {
      return node.alias ? node.alias.value : node.name.value;
    }
    exports2.getFieldEntryKey = getFieldEntryKey2;
    function getDeferValues(variableValues, node) {
      const defer = (0, graphql_1.getDirectiveValues)(directives_js_1.GraphQLDeferDirective, node, variableValues);
      if (!defer) {
        return;
      }
      if (defer["if"] === false) {
        return;
      }
      return {
        label: typeof defer["label"] === "string" ? defer["label"] : void 0
      };
    }
    exports2.getDeferValues = getDeferValues;
    exports2.collectSubFields = (0, memoize_js_1.memoize5)(function collectSubfields3(schema, fragments, variableValues, returnType, fieldNodes) {
      const subFieldNodes = new AccumulatorMap_js_1.AccumulatorMap();
      const visitedFragmentNames = /* @__PURE__ */ new Set();
      const subPatches = [];
      const subFieldsAndPatches = {
        fields: subFieldNodes,
        patches: subPatches
      };
      for (const node of fieldNodes) {
        if (node.selectionSet) {
          collectFieldsImpl2(schema, fragments, variableValues, returnType, node.selectionSet, subFieldNodes, subPatches, visitedFragmentNames);
        }
      }
      return subFieldsAndPatches;
    });
  }
});

// ../../../node_modules/@graphql-tools/utils/cjs/visitResult.js
var require_visitResult = __commonJS({
  "../../../node_modules/@graphql-tools/utils/cjs/visitResult.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.visitResult = exports2.visitErrors = exports2.visitData = void 0;
    var getOperationASTFromRequest_js_1 = require_getOperationASTFromRequest();
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var collectFields_js_1 = require_collectFields();
    function visitData(data, enter, leave) {
      if (Array.isArray(data)) {
        return data.map((value) => visitData(value, enter, leave));
      } else if (typeof data === "object") {
        const newData = enter != null ? enter(data) : data;
        if (newData != null) {
          for (const key in newData) {
            const value = newData[key];
            Object.defineProperty(newData, key, {
              value: visitData(value, enter, leave)
            });
          }
        }
        return leave != null ? leave(newData) : newData;
      }
      return data;
    }
    exports2.visitData = visitData;
    function visitErrors(errors, visitor) {
      return errors.map((error) => visitor(error));
    }
    exports2.visitErrors = visitErrors;
    function visitResult(result, request, schema, resultVisitorMap, errorVisitorMap) {
      const fragments = request.document.definitions.reduce((acc, def) => {
        if (def.kind === graphql_1.Kind.FRAGMENT_DEFINITION) {
          acc[def.name.value] = def;
        }
        return acc;
      }, {});
      const variableValues = request.variables || {};
      const errorInfo = {
        segmentInfoMap: /* @__PURE__ */ new Map(),
        unpathedErrors: /* @__PURE__ */ new Set()
      };
      const data = result.data;
      const errors = result.errors;
      const visitingErrors = errors != null && errorVisitorMap != null;
      const operationDocumentNode = (0, getOperationASTFromRequest_js_1.getOperationASTFromRequest)(request);
      if (data != null && operationDocumentNode != null) {
        result.data = visitRoot(data, operationDocumentNode, schema, fragments, variableValues, resultVisitorMap, visitingErrors ? errors : void 0, errorInfo);
      }
      if (errors != null && errorVisitorMap) {
        result.errors = visitErrorsByType(errors, errorVisitorMap, errorInfo);
      }
      return result;
    }
    exports2.visitResult = visitResult;
    function visitErrorsByType(errors, errorVisitorMap, errorInfo) {
      const segmentInfoMap = errorInfo.segmentInfoMap;
      const unpathedErrors = errorInfo.unpathedErrors;
      const unpathedErrorVisitor = errorVisitorMap["__unpathed"];
      return errors.map((originalError) => {
        const pathSegmentsInfo = segmentInfoMap.get(originalError);
        const newError = pathSegmentsInfo == null ? originalError : pathSegmentsInfo.reduceRight((acc, segmentInfo) => {
          const typeName = segmentInfo.type.name;
          const typeVisitorMap = errorVisitorMap[typeName];
          if (typeVisitorMap == null) {
            return acc;
          }
          const errorVisitor = typeVisitorMap[segmentInfo.fieldName];
          return errorVisitor == null ? acc : errorVisitor(acc, segmentInfo.pathIndex);
        }, originalError);
        if (unpathedErrorVisitor && unpathedErrors.has(originalError)) {
          return unpathedErrorVisitor(newError);
        }
        return newError;
      });
    }
    function getOperationRootType2(schema, operationDef) {
      switch (operationDef.operation) {
        case "query":
          return schema.getQueryType();
        case "mutation":
          return schema.getMutationType();
        case "subscription":
          return schema.getSubscriptionType();
      }
    }
    function visitRoot(root, operation, schema, fragments, variableValues, resultVisitorMap, errors, errorInfo) {
      const operationRootType = getOperationRootType2(schema, operation);
      const { fields: collectedFields } = (0, collectFields_js_1.collectFields)(schema, fragments, variableValues, operationRootType, operation.selectionSet);
      return visitObjectValue(root, operationRootType, collectedFields, schema, fragments, variableValues, resultVisitorMap, 0, errors, errorInfo);
    }
    function visitObjectValue(object, type, fieldNodeMap, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo) {
      var _a;
      const fieldMap = type.getFields();
      const typeVisitorMap = resultVisitorMap === null || resultVisitorMap === void 0 ? void 0 : resultVisitorMap[type.name];
      const enterObject = typeVisitorMap === null || typeVisitorMap === void 0 ? void 0 : typeVisitorMap.__enter;
      const newObject = enterObject != null ? enterObject(object) : object;
      let sortedErrors;
      let errorMap = null;
      if (errors != null) {
        sortedErrors = sortErrorsByPathSegment(errors, pathIndex);
        errorMap = sortedErrors.errorMap;
        for (const error of sortedErrors.unpathedErrors) {
          errorInfo.unpathedErrors.add(error);
        }
      }
      for (const [responseKey, subFieldNodes] of fieldNodeMap) {
        const fieldName = subFieldNodes[0].name.value;
        let fieldType = (_a = fieldMap[fieldName]) === null || _a === void 0 ? void 0 : _a.type;
        if (fieldType == null) {
          switch (fieldName) {
            case "__typename":
              fieldType = graphql_1.TypeNameMetaFieldDef.type;
              break;
            case "__schema":
              fieldType = graphql_1.SchemaMetaFieldDef.type;
              break;
            case "__type":
              fieldType = graphql_1.TypeMetaFieldDef.type;
              break;
          }
        }
        const newPathIndex = pathIndex + 1;
        let fieldErrors;
        if (errorMap) {
          fieldErrors = errorMap[responseKey];
          if (fieldErrors != null) {
            delete errorMap[responseKey];
          }
          addPathSegmentInfo(type, fieldName, newPathIndex, fieldErrors, errorInfo);
        }
        const newValue = visitFieldValue(object[responseKey], fieldType, subFieldNodes, schema, fragments, variableValues, resultVisitorMap, newPathIndex, fieldErrors, errorInfo);
        updateObject(newObject, responseKey, newValue, typeVisitorMap, fieldName);
      }
      const oldTypename = newObject.__typename;
      if (oldTypename != null) {
        updateObject(newObject, "__typename", oldTypename, typeVisitorMap, "__typename");
      }
      if (errorMap) {
        for (const errorsKey in errorMap) {
          const errors2 = errorMap[errorsKey];
          for (const error of errors2) {
            errorInfo.unpathedErrors.add(error);
          }
        }
      }
      const leaveObject = typeVisitorMap === null || typeVisitorMap === void 0 ? void 0 : typeVisitorMap.__leave;
      return leaveObject != null ? leaveObject(newObject) : newObject;
    }
    function updateObject(object, responseKey, newValue, typeVisitorMap, fieldName) {
      if (typeVisitorMap == null) {
        object[responseKey] = newValue;
        return;
      }
      const fieldVisitor = typeVisitorMap[fieldName];
      if (fieldVisitor == null) {
        object[responseKey] = newValue;
        return;
      }
      const visitedValue = fieldVisitor(newValue);
      if (visitedValue === void 0) {
        delete object[responseKey];
        return;
      }
      object[responseKey] = visitedValue;
    }
    function visitListValue(list, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo) {
      return list.map((listMember) => visitFieldValue(listMember, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex + 1, errors, errorInfo));
    }
    function visitFieldValue(value, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors = [], errorInfo) {
      if (value == null) {
        return value;
      }
      const nullableType = (0, graphql_1.getNullableType)(returnType);
      if ((0, graphql_1.isListType)(nullableType)) {
        return visitListValue(value, nullableType.ofType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);
      } else if ((0, graphql_1.isAbstractType)(nullableType)) {
        const finalType = schema.getType(value.__typename);
        const { fields: collectedFields } = (0, collectFields_js_1.collectSubFields)(schema, fragments, variableValues, finalType, fieldNodes);
        return visitObjectValue(value, finalType, collectedFields, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);
      } else if ((0, graphql_1.isObjectType)(nullableType)) {
        const { fields: collectedFields } = (0, collectFields_js_1.collectSubFields)(schema, fragments, variableValues, nullableType, fieldNodes);
        return visitObjectValue(value, nullableType, collectedFields, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);
      }
      const typeVisitorMap = resultVisitorMap === null || resultVisitorMap === void 0 ? void 0 : resultVisitorMap[nullableType.name];
      if (typeVisitorMap == null) {
        return value;
      }
      const visitedValue = typeVisitorMap(value);
      return visitedValue === void 0 ? value : visitedValue;
    }
    function sortErrorsByPathSegment(errors, pathIndex) {
      var _a;
      const errorMap = /* @__PURE__ */ Object.create(null);
      const unpathedErrors = /* @__PURE__ */ new Set();
      for (const error of errors) {
        const pathSegment = (_a = error.path) === null || _a === void 0 ? void 0 : _a[pathIndex];
        if (pathSegment == null) {
          unpathedErrors.add(error);
          continue;
        }
        if (pathSegment in errorMap) {
          errorMap[pathSegment].push(error);
        } else {
          errorMap[pathSegment] = [error];
        }
      }
      return {
        errorMap,
        unpathedErrors
      };
    }
    function addPathSegmentInfo(type, fieldName, pathIndex, errors = [], errorInfo) {
      for (const error of errors) {
        const segmentInfo = {
          type,
          fieldName,
          pathIndex
        };
        const pathSegmentsInfo = errorInfo.segmentInfoMap.get(error);
        if (pathSegmentsInfo == null) {
          errorInfo.segmentInfoMap.set(error, [segmentInfo]);
        } else {
          pathSegmentsInfo.push(segmentInfo);
        }
      }
    }
  }
});

// ../../../node_modules/@graphql-tools/utils/cjs/valueMatchesCriteria.js
var require_valueMatchesCriteria = __commonJS({
  "../../../node_modules/@graphql-tools/utils/cjs/valueMatchesCriteria.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.valueMatchesCriteria = void 0;
    function valueMatchesCriteria(value, criteria) {
      if (value == null) {
        return value === criteria;
      } else if (Array.isArray(value)) {
        return Array.isArray(criteria) && value.every((val, index) => valueMatchesCriteria(val, criteria[index]));
      } else if (typeof value === "object") {
        return typeof criteria === "object" && criteria && Object.keys(criteria).every((propertyName) => valueMatchesCriteria(value[propertyName], criteria[propertyName]));
      } else if (criteria instanceof RegExp) {
        return criteria.test(value);
      }
      return value === criteria;
    }
    exports2.valueMatchesCriteria = valueMatchesCriteria;
  }
});

// ../../../node_modules/@graphql-tools/utils/cjs/isAsyncIterable.js
var require_isAsyncIterable = __commonJS({
  "../../../node_modules/@graphql-tools/utils/cjs/isAsyncIterable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isAsyncIterable = void 0;
    function isAsyncIterable2(value) {
      return typeof value === "object" && value != null && Symbol.asyncIterator in value && typeof value[Symbol.asyncIterator] === "function";
    }
    exports2.isAsyncIterable = isAsyncIterable2;
  }
});

// ../../../node_modules/@graphql-tools/utils/cjs/isDocumentNode.js
var require_isDocumentNode = __commonJS({
  "../../../node_modules/@graphql-tools/utils/cjs/isDocumentNode.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isDocumentNode = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function isDocumentNode(object) {
      return object && typeof object === "object" && "kind" in object && object.kind === graphql_1.Kind.DOCUMENT;
    }
    exports2.isDocumentNode = isDocumentNode;
  }
});

// ../../../node_modules/@graphql-tools/utils/cjs/executor.js
var require_executor = __commonJS({
  "../../../node_modules/@graphql-tools/utils/cjs/executor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../../node_modules/@graphql-tools/utils/cjs/withCancel.js
var require_withCancel = __commonJS({
  "../../../node_modules/@graphql-tools/utils/cjs/withCancel.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.withCancel = exports2.getAsyncIterableWithCancel = exports2.getAsyncIteratorWithCancel = void 0;
    var memoize_js_1 = require_memoize();
    async function defaultAsyncIteratorReturn(value) {
      return { value, done: true };
    }
    var proxyMethodFactory = (0, memoize_js_1.memoize2)(function proxyMethodFactory2(target, targetMethod) {
      return function proxyMethod(...args) {
        return Reflect.apply(targetMethod, target, args);
      };
    });
    function getAsyncIteratorWithCancel(asyncIterator, onCancel) {
      return new Proxy(asyncIterator, {
        has(asyncIterator2, prop) {
          if (prop === "return") {
            return true;
          }
          return Reflect.has(asyncIterator2, prop);
        },
        get(asyncIterator2, prop, receiver) {
          const existingPropValue = Reflect.get(asyncIterator2, prop, receiver);
          if (prop === "return") {
            const existingReturn = existingPropValue || defaultAsyncIteratorReturn;
            return async function returnWithCancel(value) {
              const returnValue = await onCancel(value);
              return Reflect.apply(existingReturn, asyncIterator2, [returnValue]);
            };
          } else if (typeof existingPropValue === "function") {
            return proxyMethodFactory(asyncIterator2, existingPropValue);
          }
          return existingPropValue;
        }
      });
    }
    exports2.getAsyncIteratorWithCancel = getAsyncIteratorWithCancel;
    function getAsyncIterableWithCancel(asyncIterable, onCancel) {
      return new Proxy(asyncIterable, {
        get(asyncIterable2, prop, receiver) {
          const existingPropValue = Reflect.get(asyncIterable2, prop, receiver);
          if (Symbol.asyncIterator === prop) {
            return function asyncIteratorFactory() {
              const asyncIterator = Reflect.apply(existingPropValue, asyncIterable2, []);
              return getAsyncIteratorWithCancel(asyncIterator, onCancel);
            };
          } else if (typeof existingPropValue === "function") {
            return proxyMethodFactory(asyncIterable2, existingPropValue);
          }
          return existingPropValue;
        }
      });
    }
    exports2.getAsyncIterableWithCancel = getAsyncIterableWithCancel;
    exports2.withCancel = getAsyncIterableWithCancel;
  }
});

// ../../../node_modules/@graphql-tools/utils/cjs/fixSchemaAst.js
var require_fixSchemaAst = __commonJS({
  "../../../node_modules/@graphql-tools/utils/cjs/fixSchemaAst.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fixSchemaAst = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var print_schema_with_directives_js_1 = require_print_schema_with_directives();
    function buildFixedSchema(schema, options) {
      const document2 = (0, print_schema_with_directives_js_1.getDocumentNodeFromSchema)(schema);
      return (0, graphql_1.buildASTSchema)(document2, {
        ...options || {}
      });
    }
    function fixSchemaAst(schema, options) {
      let schemaWithValidAst = void 0;
      if (!schema.astNode || !schema.extensionASTNodes) {
        schemaWithValidAst = buildFixedSchema(schema, options);
      }
      if (!schema.astNode && (schemaWithValidAst === null || schemaWithValidAst === void 0 ? void 0 : schemaWithValidAst.astNode)) {
        schema.astNode = schemaWithValidAst.astNode;
      }
      if (!schema.extensionASTNodes && (schemaWithValidAst === null || schemaWithValidAst === void 0 ? void 0 : schemaWithValidAst.astNode)) {
        schema.extensionASTNodes = schemaWithValidAst.extensionASTNodes;
      }
      return schema;
    }
    exports2.fixSchemaAst = fixSchemaAst;
  }
});

// ../../../node_modules/@graphql-tools/utils/cjs/extractExtensionsFromSchema.js
var require_extractExtensionsFromSchema = __commonJS({
  "../../../node_modules/@graphql-tools/utils/cjs/extractExtensionsFromSchema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.extractExtensionsFromSchema = void 0;
    var mapSchema_js_1 = require_mapSchema();
    var Interfaces_js_1 = require_Interfaces();
    function extractExtensionsFromSchema(schema) {
      const result = {
        schemaExtensions: schema.extensions || {},
        types: {}
      };
      (0, mapSchema_js_1.mapSchema)(schema, {
        [Interfaces_js_1.MapperKind.OBJECT_TYPE]: (type) => {
          result.types[type.name] = { fields: {}, type: "object", extensions: type.extensions || {} };
          return type;
        },
        [Interfaces_js_1.MapperKind.INTERFACE_TYPE]: (type) => {
          result.types[type.name] = { fields: {}, type: "interface", extensions: type.extensions || {} };
          return type;
        },
        [Interfaces_js_1.MapperKind.FIELD]: (field, fieldName, typeName) => {
          result.types[typeName].fields[fieldName] = {
            arguments: {},
            extensions: field.extensions || {}
          };
          const args = field.args;
          if (args != null) {
            for (const argName in args) {
              result.types[typeName].fields[fieldName].arguments[argName] = args[argName].extensions || {};
            }
          }
          return field;
        },
        [Interfaces_js_1.MapperKind.ENUM_TYPE]: (type) => {
          result.types[type.name] = { values: {}, type: "enum", extensions: type.extensions || {} };
          return type;
        },
        [Interfaces_js_1.MapperKind.ENUM_VALUE]: (value, typeName, _schema, valueName) => {
          result.types[typeName].values[valueName] = value.extensions || {};
          return value;
        },
        [Interfaces_js_1.MapperKind.SCALAR_TYPE]: (type) => {
          result.types[type.name] = { type: "scalar", extensions: type.extensions || {} };
          return type;
        },
        [Interfaces_js_1.MapperKind.UNION_TYPE]: (type) => {
          result.types[type.name] = { type: "union", extensions: type.extensions || {} };
          return type;
        },
        [Interfaces_js_1.MapperKind.INPUT_OBJECT_TYPE]: (type) => {
          result.types[type.name] = { fields: {}, type: "input", extensions: type.extensions || {} };
          return type;
        },
        [Interfaces_js_1.MapperKind.INPUT_OBJECT_FIELD]: (field, fieldName, typeName) => {
          result.types[typeName].fields[fieldName] = {
            extensions: field.extensions || {}
          };
          return field;
        }
      });
      return result;
    }
    exports2.extractExtensionsFromSchema = extractExtensionsFromSchema;
  }
});

// ../../../node_modules/@graphql-tools/utils/cjs/Path.js
var require_Path = __commonJS({
  "../../../node_modules/@graphql-tools/utils/cjs/Path.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.printPathArray = exports2.pathToArray = exports2.addPath = void 0;
    function addPath2(prev, key, typename) {
      return { prev, key, typename };
    }
    exports2.addPath = addPath2;
    function pathToArray2(path) {
      const flattened = [];
      let curr = path;
      while (curr) {
        flattened.push(curr.key);
        curr = curr.prev;
      }
      return flattened.reverse();
    }
    exports2.pathToArray = pathToArray2;
    function printPathArray2(path) {
      return path.map((key) => typeof key === "number" ? "[" + key.toString() + "]" : "." + key).join("");
    }
    exports2.printPathArray = printPathArray2;
  }
});

// ../../../node_modules/@graphql-tools/utils/cjs/index.js
var require_cjs = __commonJS({
  "../../../node_modules/@graphql-tools/utils/cjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_loaders(), exports2);
    tslib_1.__exportStar(require_helpers(), exports2);
    tslib_1.__exportStar(require_get_directives(), exports2);
    tslib_1.__exportStar(require_get_fields_with_directives(), exports2);
    tslib_1.__exportStar(require_get_arguments_with_directives(), exports2);
    tslib_1.__exportStar(require_get_implementing_types(), exports2);
    tslib_1.__exportStar(require_print_schema_with_directives(), exports2);
    tslib_1.__exportStar(require_get_fields_with_directives(), exports2);
    tslib_1.__exportStar(require_validate_documents(), exports2);
    tslib_1.__exportStar(require_parse_graphql_json(), exports2);
    tslib_1.__exportStar(require_parse_graphql_sdl(), exports2);
    tslib_1.__exportStar(require_build_operation_for_field(), exports2);
    tslib_1.__exportStar(require_types2(), exports2);
    tslib_1.__exportStar(require_filterSchema(), exports2);
    tslib_1.__exportStar(require_heal(), exports2);
    tslib_1.__exportStar(require_getResolversFromSchema(), exports2);
    tslib_1.__exportStar(require_forEachField(), exports2);
    tslib_1.__exportStar(require_forEachDefaultValue(), exports2);
    tslib_1.__exportStar(require_mapSchema(), exports2);
    tslib_1.__exportStar(require_addTypes(), exports2);
    tslib_1.__exportStar(require_rewire(), exports2);
    tslib_1.__exportStar(require_prune(), exports2);
    tslib_1.__exportStar(require_mergeDeep(), exports2);
    tslib_1.__exportStar(require_Interfaces(), exports2);
    tslib_1.__exportStar(require_stub(), exports2);
    tslib_1.__exportStar(require_selectionSets(), exports2);
    tslib_1.__exportStar(require_getResponseKeyFromInfo(), exports2);
    tslib_1.__exportStar(require_fields(), exports2);
    tslib_1.__exportStar(require_renameType(), exports2);
    tslib_1.__exportStar(require_transformInputValue(), exports2);
    tslib_1.__exportStar(require_mapAsyncIterator(), exports2);
    tslib_1.__exportStar(require_updateArgument(), exports2);
    tslib_1.__exportStar(require_implementsAbstractType(), exports2);
    tslib_1.__exportStar(require_errors(), exports2);
    tslib_1.__exportStar(require_observableToAsyncIterable(), exports2);
    tslib_1.__exportStar(require_visitResult(), exports2);
    tslib_1.__exportStar(require_getArgumentValues(), exports2);
    tslib_1.__exportStar(require_valueMatchesCriteria(), exports2);
    tslib_1.__exportStar(require_isAsyncIterable(), exports2);
    tslib_1.__exportStar(require_isDocumentNode(), exports2);
    tslib_1.__exportStar(require_astFromValueUntyped(), exports2);
    tslib_1.__exportStar(require_executor(), exports2);
    tslib_1.__exportStar(require_withCancel(), exports2);
    tslib_1.__exportStar(require_AggregateError(), exports2);
    tslib_1.__exportStar(require_rootTypes(), exports2);
    tslib_1.__exportStar(require_comments(), exports2);
    tslib_1.__exportStar(require_collectFields(), exports2);
    tslib_1.__exportStar(require_inspect(), exports2);
    tslib_1.__exportStar(require_memoize(), exports2);
    tslib_1.__exportStar(require_fixSchemaAst(), exports2);
    tslib_1.__exportStar(require_getOperationASTFromRequest(), exports2);
    tslib_1.__exportStar(require_extractExtensionsFromSchema(), exports2);
    tslib_1.__exportStar(require_Path(), exports2);
    tslib_1.__exportStar(require_jsutils(), exports2);
    tslib_1.__exportStar(require_directives(), exports2);
  }
});

// ../../../node_modules/@graphql-tools/mock/cjs/utils.js
var require_utils2 = __commonJS({
  "../../../node_modules/@graphql-tools/mock/cjs/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isRootType = exports2.copyOwnProps = exports2.copyOwnPropsIfNotPresent = exports2.isObject = exports2.makeRef = exports2.takeRandom = exports2.randomListLength = exports2.uuidv4 = void 0;
    var utils_1 = require_cjs();
    function uuidv4() {
      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
        const r = Math.random() * 16 | 0;
        const v = c == "x" ? r : r & 3 | 8;
        return v.toString(16);
      });
    }
    exports2.uuidv4 = uuidv4;
    var randomListLength = () => {
      return 2;
    };
    exports2.randomListLength = randomListLength;
    var takeRandom = (arr) => arr[Math.floor(Math.random() * arr.length)];
    exports2.takeRandom = takeRandom;
    function makeRef(typeName, key) {
      return { $ref: { key, typeName } };
    }
    exports2.makeRef = makeRef;
    function isObject(thing) {
      return thing === Object(thing) && !Array.isArray(thing);
    }
    exports2.isObject = isObject;
    function copyOwnPropsIfNotPresent(target, source) {
      for (const prop of Object.getOwnPropertyNames(source)) {
        if (!Object.getOwnPropertyDescriptor(target, prop)) {
          const propertyDescriptor = Object.getOwnPropertyDescriptor(source, prop);
          Object.defineProperty(target, prop, propertyDescriptor == null ? {} : propertyDescriptor);
        }
      }
    }
    exports2.copyOwnPropsIfNotPresent = copyOwnPropsIfNotPresent;
    function copyOwnProps(target, ...sources) {
      for (const source of sources) {
        let chain = source;
        while (chain != null) {
          copyOwnPropsIfNotPresent(target, chain);
          chain = Object.getPrototypeOf(chain);
        }
      }
      return target;
    }
    exports2.copyOwnProps = copyOwnProps;
    var isRootType = (type, schema) => {
      const rootTypeNames = (0, utils_1.getRootTypeNames)(schema);
      return rootTypeNames.has(type.name);
    };
    exports2.isRootType = isRootType;
  }
});

// ../../../node_modules/@graphql-tools/mock/cjs/MockList.js
var require_MockList = __commonJS({
  "../../../node_modules/@graphql-tools/mock/cjs/MockList.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.deepResolveMockList = exports2.MockList = exports2.isMockList = void 0;
    function isMockList(obj) {
      if (typeof (obj === null || obj === void 0 ? void 0 : obj.len) === "number" || Array.isArray(obj === null || obj === void 0 ? void 0 : obj.len) && typeof (obj === null || obj === void 0 ? void 0 : obj.len[0]) === "number") {
        if (typeof obj.wrappedFunction === "undefined" || typeof obj.wrappedFunction === "function") {
          return true;
        }
      }
      return false;
    }
    exports2.isMockList = isMockList;
    var MockList = class {
      /**
       * @param length Either the exact length of items to return or an inclusive
       * range of possible lengths.
       * @param mockFunction The function to call for each item in the list to
       * resolve it. It can return another MockList or a value.
       */
      constructor(length, mockFunction) {
        this.len = length;
        if (typeof mockFunction !== "undefined") {
          if (typeof mockFunction !== "function") {
            throw new Error("Second argument to MockList must be a function or undefined");
          }
          this.wrappedFunction = mockFunction;
        }
      }
      /**
       * @internal
       */
      mock() {
        let arr;
        if (Array.isArray(this.len)) {
          arr = new Array(this.randint(this.len[0], this.len[1]));
        } else {
          arr = new Array(this.len);
        }
        for (let i = 0; i < arr.length; i++) {
          if (typeof this.wrappedFunction === "function") {
            const res = this.wrappedFunction();
            if (isMockList(res)) {
              arr[i] = res.mock();
            } else {
              arr[i] = res;
            }
          } else {
            arr[i] = void 0;
          }
        }
        return arr;
      }
      randint(low, high) {
        return Math.floor(Math.random() * (high - low + 1) + low);
      }
    };
    exports2.MockList = MockList;
    function deepResolveMockList(mockList) {
      return mockList.mock().map((v) => {
        if (isMockList(v))
          return deepResolveMockList(v);
        return v;
      });
    }
    exports2.deepResolveMockList = deepResolveMockList;
  }
});

// ../../../node_modules/@graphql-tools/mock/cjs/MockStore.js
var require_MockStore = __commonJS({
  "../../../node_modules/@graphql-tools/mock/cjs/MockStore.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createMockStore = exports2.MockStore = exports2.defaultMocks = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var fast_json_stable_stringify_1 = tslib_1.__importDefault(require_fast_json_stable_stringify());
    var types_js_1 = require_types();
    var utils_js_1 = require_utils2();
    var MockList_js_1 = require_MockList();
    exports2.defaultMocks = {
      Int: () => Math.round(Math.random() * 200) - 100,
      Float: () => Math.random() * 200 - 100,
      String: () => "Hello World",
      Boolean: () => Math.random() > 0.5,
      ID: () => (0, utils_js_1.uuidv4)()
    };
    var defaultKeyFieldNames = ["id", "_id"];
    var MockStore = class {
      constructor({ schema, mocks, typePolicies }) {
        this.store = {};
        this.schema = schema;
        this.mocks = { ...exports2.defaultMocks, ...mocks };
        this.typePolicies = typePolicies || {};
      }
      has(typeName, key) {
        return !!this.store[typeName] && !!this.store[typeName][key];
      }
      get(_typeName, _key, _fieldName, _fieldArgs) {
        if (typeof _typeName !== "string") {
          if (_key === void 0) {
            if ((0, types_js_1.isRef)(_typeName)) {
              throw new Error("Can't provide a ref as first argument and no other argument");
            }
            return this.getImpl(_typeName);
          } else {
            (0, types_js_1.assertIsRef)(_typeName);
            const { $ref } = _typeName;
            _fieldArgs = _fieldName;
            _fieldName = _key;
            _key = $ref.key;
            _typeName = $ref.typeName;
          }
        }
        const args = {
          typeName: _typeName
        };
        if ((0, types_js_1.isRecord)(_key) || _key === void 0) {
          args.defaultValue = _key;
          return this.getImpl(args);
        }
        args.key = _key;
        if (Array.isArray(_fieldName) && _fieldName.length === 1) {
          _fieldName = _fieldName[0];
        }
        if (typeof _fieldName !== "string" && !Array.isArray(_fieldName)) {
          args.defaultValue = _fieldName;
          return this.getImpl(args);
        }
        if (Array.isArray(_fieldName)) {
          const ref = this.get(_typeName, _key, _fieldName[0], _fieldArgs);
          (0, types_js_1.assertIsRef)(ref);
          return this.get(ref.$ref.typeName, ref.$ref.key, _fieldName.slice(1, _fieldName.length));
        }
        args.fieldName = _fieldName;
        args.fieldArgs = _fieldArgs;
        return this.getImpl(args);
      }
      set(_typeName, _key, _fieldName, _value) {
        if (typeof _typeName !== "string") {
          if (_key === void 0) {
            if ((0, types_js_1.isRef)(_typeName)) {
              throw new Error("Can't provide a ref as first argument and no other argument");
            }
            return this.setImpl(_typeName);
          } else {
            (0, types_js_1.assertIsRef)(_typeName);
            const { $ref } = _typeName;
            _value = _fieldName;
            _fieldName = _key;
            _key = $ref.key;
            _typeName = $ref.typeName;
          }
        }
        assertIsDefined(_key, "key was not provided");
        const args = {
          typeName: _typeName,
          key: _key
        };
        if (typeof _fieldName !== "string") {
          if (!(0, types_js_1.isRecord)(_fieldName))
            throw new Error("Expected value to be a record");
          args.value = _fieldName;
          return this.setImpl(args);
        }
        args.fieldName = _fieldName;
        args.value = _value;
        return this.setImpl(args);
      }
      reset() {
        this.store = {};
      }
      filter(key, predicate) {
        const entity = this.store[key];
        return Object.values(entity).filter(predicate);
      }
      find(key, predicate) {
        const entity = this.store[key];
        return Object.values(entity).find(predicate);
      }
      getImpl(args) {
        const { typeName, key, fieldName, fieldArgs, defaultValue } = args;
        if (!fieldName) {
          if (defaultValue !== void 0 && !(0, types_js_1.isRecord)(defaultValue)) {
            throw new Error("`defaultValue` should be an object");
          }
          let valuesToInsert = defaultValue || {};
          if (key) {
            valuesToInsert = { ...valuesToInsert, ...(0, utils_js_1.makeRef)(typeName, key) };
          }
          return this.insert(typeName, valuesToInsert, true);
        }
        assertIsDefined(key, "key argument should be given when fieldName is given");
        const fieldNameInStore = getFieldNameInStore(fieldName, fieldArgs);
        if (this.store[typeName] === void 0 || this.store[typeName][key] === void 0 || this.store[typeName][key][fieldNameInStore] === void 0) {
          let value;
          if (defaultValue !== void 0) {
            value = defaultValue;
          } else if (this.isKeyField(typeName, fieldName)) {
            value = key;
          } else {
            value = this.generateFieldValue(typeName, fieldName, (otherFieldName, otherValue) => {
              if (this.isKeyField(typeName, otherFieldName))
                return;
              this.set({ typeName, key, fieldName: otherFieldName, value: otherValue, noOverride: true });
            });
          }
          this.set({ typeName, key, fieldName, fieldArgs, value, noOverride: true });
        }
        return this.store[typeName][key][fieldNameInStore];
      }
      setImpl(args) {
        const { typeName, key, fieldName, fieldArgs, noOverride } = args;
        let { value } = args;
        if ((0, MockList_js_1.isMockList)(value)) {
          value = (0, MockList_js_1.deepResolveMockList)(value);
        }
        if (this.store[typeName] === void 0) {
          this.store[typeName] = {};
        }
        if (this.store[typeName][key] === void 0) {
          this.store[typeName][key] = {};
        }
        if (!fieldName) {
          if (!(0, types_js_1.isRecord)(value)) {
            throw new Error("When no `fieldName` is provided, `value` should be a record.");
          }
          for (const fieldName2 in value) {
            this.setImpl({
              typeName,
              key,
              fieldName: fieldName2,
              value: value[fieldName2],
              noOverride
            });
          }
          return;
        }
        const fieldNameInStore = getFieldNameInStore(fieldName, fieldArgs);
        if (this.isKeyField(typeName, fieldName) && value !== key) {
          throw new Error(`Field ${fieldName} is a key field of ${typeName} and you are trying to set it to ${value} while the key is ${key}`);
        }
        if (this.store[typeName][key][fieldNameInStore] !== void 0 && noOverride) {
          return;
        }
        const fieldType = this.getFieldType(typeName, fieldName);
        const currentValue = this.store[typeName][key][fieldNameInStore];
        let valueToStore;
        try {
          valueToStore = this.normalizeValueToStore(fieldType, value, currentValue, (typeName2, values) => this.insert(typeName2, values, noOverride));
        } catch (e) {
          throw new Error(`Value to set in ${typeName}.${fieldName} in not normalizable: ${e.message}`);
        }
        this.store[typeName][key] = {
          ...this.store[typeName][key],
          [fieldNameInStore]: valueToStore
        };
      }
      normalizeValueToStore(fieldType, value, currentValue, onInsertType) {
        const fieldTypeName = fieldType.toString();
        if (value === null) {
          if (!(0, graphql_1.isNullableType)(fieldType)) {
            throw new Error(`should not be null because ${fieldTypeName} is not nullable. Received null.`);
          }
          return null;
        }
        const nullableFieldType = (0, graphql_1.getNullableType)(fieldType);
        if (value === void 0)
          return this.generateValueFromType(nullableFieldType);
        if ((0, graphql_1.isCompositeType)(nullableFieldType)) {
          if (!(0, types_js_1.isRecord)(value))
            throw new Error(`should be an object or null or undefined. Received ${value}`);
          let joinedTypeName;
          if ((0, graphql_1.isAbstractType)(nullableFieldType)) {
            if ((0, types_js_1.isRef)(value)) {
              joinedTypeName = value.$ref.typeName;
            } else {
              if (typeof value["__typename"] !== "string") {
                throw new Error(`should contain a '__typename' because ${nullableFieldType.name} an abstract type`);
              }
              joinedTypeName = value["__typename"];
            }
          } else {
            joinedTypeName = nullableFieldType.name;
          }
          return onInsertType(joinedTypeName, (0, types_js_1.isRef)(currentValue) ? { ...currentValue, ...value } : value);
        }
        if ((0, graphql_1.isListType)(nullableFieldType)) {
          if (!Array.isArray(value))
            throw new Error(`should be an array or null or undefined. Received ${value}`);
          return value.map((v, index) => {
            return this.normalizeValueToStore(nullableFieldType.ofType, v, typeof currentValue === "object" && currentValue != null && currentValue[index] ? currentValue : void 0, onInsertType);
          });
        }
        return value;
      }
      insert(typeName, values, noOverride) {
        const keyFieldName = this.getKeyFieldName(typeName);
        let key;
        const otherValues = {};
        if ((0, types_js_1.isRef)(values)) {
          key = values.$ref.key;
        } else if (keyFieldName && keyFieldName in values) {
          key = values[keyFieldName];
        } else {
          key = this.generateKeyForType(typeName, (otherFieldName, otherFieldValue) => {
            otherValues[otherFieldName] = otherFieldValue;
          });
        }
        const toInsert = { ...otherValues, ...values };
        for (const fieldName in toInsert) {
          if (fieldName === "$ref")
            continue;
          if (fieldName === "__typename")
            continue;
          this.set({
            typeName,
            key,
            fieldName,
            value: toInsert[fieldName],
            noOverride
          });
        }
        if (this.store[typeName] === void 0) {
          this.store[typeName] = {};
        }
        if (this.store[typeName][key] === void 0) {
          this.store[typeName][key] = {};
        }
        return (0, utils_js_1.makeRef)(typeName, key);
      }
      generateFieldValue(typeName, fieldName, onOtherFieldsGenerated) {
        const mockedValue = this.generateFieldValueFromMocks(typeName, fieldName, onOtherFieldsGenerated);
        if (mockedValue !== void 0)
          return mockedValue;
        const fieldType = this.getFieldType(typeName, fieldName);
        return this.generateValueFromType(fieldType);
      }
      generateFieldValueFromMocks(typeName, fieldName, onOtherFieldsGenerated) {
        let value;
        const mock = this.mocks ? this.mocks[typeName] : void 0;
        if (mock) {
          if (typeof mock === "function") {
            const values = mock();
            if (typeof values !== "object" || values == null) {
              throw new Error(`Value returned by the mock for ${typeName} is not an object`);
            }
            for (const otherFieldName in values) {
              if (otherFieldName === fieldName)
                continue;
              if (typeof values[otherFieldName] === "function")
                continue;
              onOtherFieldsGenerated && onOtherFieldsGenerated(otherFieldName, values[otherFieldName]);
            }
            value = values[fieldName];
            if (typeof value === "function")
              value = value();
          } else if (typeof mock === "object" && mock != null && typeof mock[fieldName] === "function") {
            value = mock[fieldName]();
          }
        }
        if (value !== void 0)
          return value;
        const type = this.getType(typeName);
        const interfaces = "getInterfaces" in type ? type.getInterfaces() : [];
        if (interfaces.length > 0) {
          for (const interface_ of interfaces) {
            if (value)
              break;
            value = this.generateFieldValueFromMocks(interface_.name, fieldName, onOtherFieldsGenerated);
          }
        }
        return value;
      }
      generateKeyForType(typeName, onOtherFieldsGenerated) {
        const keyFieldName = this.getKeyFieldName(typeName);
        if (!keyFieldName)
          return (0, utils_js_1.uuidv4)();
        return this.generateFieldValue(typeName, keyFieldName, onOtherFieldsGenerated);
      }
      generateValueFromType(fieldType) {
        const nullableType = (0, graphql_1.getNullableType)(fieldType);
        if ((0, graphql_1.isScalarType)(nullableType)) {
          const mockFn = this.mocks[nullableType.name];
          if (typeof mockFn !== "function")
            throw new Error(`No mock defined for type "${nullableType.name}"`);
          return mockFn();
        } else if ((0, graphql_1.isEnumType)(nullableType)) {
          const mockFn = this.mocks[nullableType.name];
          if (typeof mockFn === "function")
            return mockFn();
          const values = nullableType.getValues().map((v) => v.value);
          return (0, utils_js_1.takeRandom)(values);
        } else if ((0, graphql_1.isObjectType)(nullableType)) {
          return this.insert(nullableType.name, {});
        } else if ((0, graphql_1.isListType)(nullableType)) {
          return [...new Array((0, utils_js_1.randomListLength)())].map(() => this.generateValueFromType(nullableType.ofType));
        } else if ((0, graphql_1.isAbstractType)(nullableType)) {
          const mock = this.mocks[nullableType.name];
          let typeName;
          let values = {};
          if (!mock) {
            typeName = (0, utils_js_1.takeRandom)(this.schema.getPossibleTypes(nullableType).map((t) => t.name));
          } else if (typeof mock === "function") {
            const mockRes = mock();
            if (mockRes === null)
              return null;
            if (!(0, types_js_1.isRecord)(mockRes)) {
              throw new Error(`Value returned by the mock for ${nullableType.name} is not an object or null`);
            }
            values = mockRes;
            if (typeof values["__typename"] !== "string") {
              throw new Error(`Please return a __typename in "${nullableType.name}"`);
            }
            typeName = values["__typename"];
          } else if (typeof mock === "object" && mock != null && typeof mock["__typename"] === "function") {
            const mockRes = mock["__typename"]();
            if (typeof mockRes !== "string")
              throw new Error(`'__typename' returned by the mock for abstract type ${nullableType.name} is not a string`);
            typeName = mockRes;
          } else {
            throw new Error(`Please return a __typename in "${nullableType.name}"`);
          }
          const toInsert = {};
          for (const fieldName in values) {
            if (fieldName === "__typename")
              continue;
            const fieldValue = values[fieldName];
            toInsert[fieldName] = typeof fieldValue === "function" ? fieldValue() : fieldValue;
          }
          return this.insert(typeName, toInsert);
        } else {
          throw new Error(`${nullableType} not implemented`);
        }
      }
      getFieldType(typeName, fieldName) {
        if (fieldName === "__typename") {
          return graphql_1.GraphQLString;
        }
        const type = this.getType(typeName);
        const field = type.getFields()[fieldName];
        if (!field) {
          throw new Error(`${fieldName} does not exist on type ${typeName}`);
        }
        return field.type;
      }
      getType(typeName) {
        const type = this.schema.getType(typeName);
        if (!type || !((0, graphql_1.isObjectType)(type) || (0, graphql_1.isInterfaceType)(type))) {
          throw new Error(`${typeName} does not exist on schema or is not an object or interface`);
        }
        return type;
      }
      isKeyField(typeName, fieldName) {
        return this.getKeyFieldName(typeName) === fieldName;
      }
      getKeyFieldName(typeName) {
        var _a;
        const typePolicyKeyField = (_a = this.typePolicies[typeName]) === null || _a === void 0 ? void 0 : _a.keyFieldName;
        if (typePolicyKeyField !== void 0) {
          if (typePolicyKeyField === false)
            return null;
          return typePolicyKeyField;
        }
        const gqlType = this.getType(typeName);
        for (const fieldName in gqlType.getFields()) {
          if (defaultKeyFieldNames.includes(fieldName)) {
            return fieldName;
          }
        }
        return null;
      }
    };
    exports2.MockStore = MockStore;
    var getFieldNameInStore = (fieldName, fieldArgs) => {
      if (!fieldArgs)
        return fieldName;
      if (typeof fieldArgs === "string") {
        return `${fieldName}:${fieldArgs}`;
      }
      if (Object.keys(fieldArgs).length === 0) {
        return fieldName;
      }
      return `${fieldName}:${(0, fast_json_stable_stringify_1.default)(fieldArgs)}`;
    };
    function assertIsDefined(value, message) {
      if (value !== void 0 && value !== null) {
        return;
      }
      throw new Error(false ? "Invariant failed:" : `Invariant failed: ${message || ""}`);
    }
    function createMockStore(options) {
      return new MockStore(options);
    }
    exports2.createMockStore = createMockStore;
  }
});

// ../../../node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/assertResolversPresent.js
var require_assertResolversPresent = __commonJS({
  "../../../node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/assertResolversPresent.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.assertResolversPresent = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var utils_1 = require_cjs();
    function assertResolversPresent(schema, resolverValidationOptions = {}) {
      const { requireResolversForArgs, requireResolversForNonScalar, requireResolversForAllFields } = resolverValidationOptions;
      if (requireResolversForAllFields && (requireResolversForArgs || requireResolversForNonScalar)) {
        throw new TypeError("requireResolversForAllFields takes precedence over the more specific assertions. Please configure either requireResolversForAllFields or requireResolversForArgs / requireResolversForNonScalar, but not a combination of them.");
      }
      (0, utils_1.forEachField)(schema, (field, typeName, fieldName) => {
        if (requireResolversForAllFields) {
          expectResolver("requireResolversForAllFields", requireResolversForAllFields, field, typeName, fieldName);
        }
        if (requireResolversForArgs && field.args.length > 0) {
          expectResolver("requireResolversForArgs", requireResolversForArgs, field, typeName, fieldName);
        }
        if (requireResolversForNonScalar !== "ignore" && !(0, graphql_1.isScalarType)((0, graphql_1.getNamedType)(field.type))) {
          expectResolver("requireResolversForNonScalar", requireResolversForNonScalar, field, typeName, fieldName);
        }
      });
    }
    exports2.assertResolversPresent = assertResolversPresent;
    function expectResolver(validator, behavior, field, typeName, fieldName) {
      if (!field.resolve) {
        const message = `Resolver missing for "${typeName}.${fieldName}".
To disable this validator, use:
  resolverValidationOptions: {
    ${validator}: 'ignore'
  }`;
        if (behavior === "error") {
          throw new Error(message);
        }
        if (behavior === "warn") {
          console.warn(message);
        }
        return;
      }
      if (typeof field.resolve !== "function") {
        throw new Error(`Resolver "${typeName}.${fieldName}" must be a function`);
      }
    }
  }
});

// ../../../node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/chainResolvers.js
var require_chainResolvers = __commonJS({
  "../../../node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/chainResolvers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.chainResolvers = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function chainResolvers(resolvers) {
      return (root, args, ctx, info) => resolvers.reduce((prev, curResolver) => {
        if (curResolver != null) {
          return curResolver(prev, args, ctx, info);
        }
        return (0, graphql_1.defaultFieldResolver)(prev, args, ctx, info);
      }, root);
    }
    exports2.chainResolvers = chainResolvers;
  }
});

// ../../../node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/checkForResolveTypeResolver.js
var require_checkForResolveTypeResolver = __commonJS({
  "../../../node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/checkForResolveTypeResolver.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.checkForResolveTypeResolver = void 0;
    var utils_1 = require_cjs();
    function checkForResolveTypeResolver(schema, requireResolversForResolveType) {
      (0, utils_1.mapSchema)(schema, {
        [utils_1.MapperKind.ABSTRACT_TYPE]: (type) => {
          if (!type.resolveType) {
            const message = `Type "${type.name}" is missing a "__resolveType" resolver. Pass 'ignore' into "resolverValidationOptions.requireResolversForResolveType" to disable this error.`;
            if (requireResolversForResolveType === "error") {
              throw new Error(message);
            }
            if (requireResolversForResolveType === "warn") {
              console.warn(message);
            }
          }
          return void 0;
        }
      });
    }
    exports2.checkForResolveTypeResolver = checkForResolveTypeResolver;
  }
});

// ../../../node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/extendResolversFromInterfaces.js
var require_extendResolversFromInterfaces = __commonJS({
  "../../../node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/extendResolversFromInterfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.extendResolversFromInterfaces = void 0;
    function extendResolversFromInterfaces(schema, resolvers) {
      const extendedResolvers = {};
      const typeMap = schema.getTypeMap();
      for (const typeName in typeMap) {
        const type = typeMap[typeName];
        if ("getInterfaces" in type) {
          extendedResolvers[typeName] = {};
          for (const iFace of type.getInterfaces()) {
            if (resolvers[iFace.name]) {
              for (const fieldName in resolvers[iFace.name]) {
                if (fieldName === "__isTypeOf" || !fieldName.startsWith("__")) {
                  extendedResolvers[typeName][fieldName] = resolvers[iFace.name][fieldName];
                }
              }
            }
          }
          const typeResolvers = resolvers[typeName];
          extendedResolvers[typeName] = {
            ...extendedResolvers[typeName],
            ...typeResolvers
          };
        } else {
          const typeResolvers = resolvers[typeName];
          if (typeResolvers != null) {
            extendedResolvers[typeName] = typeResolvers;
          }
        }
      }
      return extendedResolvers;
    }
    exports2.extendResolversFromInterfaces = extendResolversFromInterfaces;
  }
});

// ../../../node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/addResolversToSchema.js
var require_addResolversToSchema = __commonJS({
  "../../../node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/addResolversToSchema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.addResolversToSchema = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var utils_1 = require_cjs();
    var checkForResolveTypeResolver_js_1 = require_checkForResolveTypeResolver();
    var extendResolversFromInterfaces_js_1 = require_extendResolversFromInterfaces();
    function addResolversToSchema({ schema, resolvers: inputResolvers, defaultFieldResolver: defaultFieldResolver2, resolverValidationOptions = {}, inheritResolversFromInterfaces = false, updateResolversInPlace = false }) {
      const { requireResolversToMatchSchema = "error", requireResolversForResolveType } = resolverValidationOptions;
      const resolvers = inheritResolversFromInterfaces ? (0, extendResolversFromInterfaces_js_1.extendResolversFromInterfaces)(schema, inputResolvers) : inputResolvers;
      for (const typeName in resolvers) {
        const resolverValue = resolvers[typeName];
        const resolverType = typeof resolverValue;
        if (resolverType !== "object") {
          throw new Error(`"${typeName}" defined in resolvers, but has invalid value "${resolverValue}". The resolver's value must be of type object.`);
        }
        const type = schema.getType(typeName);
        if (type == null) {
          if (requireResolversToMatchSchema === "ignore") {
            continue;
          }
          throw new Error(`"${typeName}" defined in resolvers, but not in schema`);
        } else if ((0, graphql_1.isSpecifiedScalarType)(type)) {
          for (const fieldName in resolverValue) {
            if (fieldName.startsWith("__")) {
              type[fieldName.substring(2)] = resolverValue[fieldName];
            } else {
              type[fieldName] = resolverValue[fieldName];
            }
          }
        } else if ((0, graphql_1.isEnumType)(type)) {
          const values = type.getValues();
          for (const fieldName in resolverValue) {
            if (!fieldName.startsWith("__") && !values.some((value) => value.name === fieldName) && requireResolversToMatchSchema && requireResolversToMatchSchema !== "ignore") {
              throw new Error(`${type.name}.${fieldName} was defined in resolvers, but not present within ${type.name}`);
            }
          }
        } else if ((0, graphql_1.isUnionType)(type)) {
          for (const fieldName in resolverValue) {
            if (!fieldName.startsWith("__") && requireResolversToMatchSchema && requireResolversToMatchSchema !== "ignore") {
              throw new Error(`${type.name}.${fieldName} was defined in resolvers, but ${type.name} is not an object or interface type`);
            }
          }
        } else if ((0, graphql_1.isObjectType)(type) || (0, graphql_1.isInterfaceType)(type)) {
          for (const fieldName in resolverValue) {
            if (!fieldName.startsWith("__")) {
              const fields = type.getFields();
              const field = fields[fieldName];
              if (field == null) {
                if (requireResolversToMatchSchema && requireResolversToMatchSchema !== "ignore") {
                  throw new Error(`${typeName}.${fieldName} defined in resolvers, but not in schema`);
                }
              } else {
                const fieldResolve = resolverValue[fieldName];
                if (typeof fieldResolve !== "function" && typeof fieldResolve !== "object") {
                  throw new Error(`Resolver ${typeName}.${fieldName} must be object or function`);
                }
              }
            }
          }
        }
      }
      schema = updateResolversInPlace ? addResolversToExistingSchema(schema, resolvers, defaultFieldResolver2) : createNewSchemaWithResolvers(schema, resolvers, defaultFieldResolver2);
      if (requireResolversForResolveType && requireResolversForResolveType !== "ignore") {
        (0, checkForResolveTypeResolver_js_1.checkForResolveTypeResolver)(schema, requireResolversForResolveType);
      }
      return schema;
    }
    exports2.addResolversToSchema = addResolversToSchema;
    function addResolversToExistingSchema(schema, resolvers, defaultFieldResolver2) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
      const typeMap = schema.getTypeMap();
      for (const typeName in resolvers) {
        const type = schema.getType(typeName);
        const resolverValue = resolvers[typeName];
        if ((0, graphql_1.isScalarType)(type)) {
          for (const fieldName in resolverValue) {
            if (fieldName.startsWith("__")) {
              type[fieldName.substring(2)] = resolverValue[fieldName];
            } else if (fieldName === "astNode" && type.astNode != null) {
              type.astNode = {
                ...type.astNode,
                description: (_b = (_a = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.astNode.description,
                directives: ((_c = type.astNode.directives) !== null && _c !== void 0 ? _c : []).concat((_e = (_d = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _d === void 0 ? void 0 : _d.directives) !== null && _e !== void 0 ? _e : [])
              };
            } else if (fieldName === "extensionASTNodes" && type.extensionASTNodes != null) {
              type.extensionASTNodes = type.extensionASTNodes.concat((_f = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _f !== void 0 ? _f : []);
            } else if (fieldName === "extensions" && type.extensions != null && resolverValue.extensions != null) {
              type.extensions = Object.assign(/* @__PURE__ */ Object.create(null), type.extensions, resolverValue.extensions);
            } else {
              type[fieldName] = resolverValue[fieldName];
            }
          }
        } else if ((0, graphql_1.isEnumType)(type)) {
          const config = type.toConfig();
          const enumValueConfigMap = config.values;
          for (const fieldName in resolverValue) {
            if (fieldName.startsWith("__")) {
              config[fieldName.substring(2)] = resolverValue[fieldName];
            } else if (fieldName === "astNode" && config.astNode != null) {
              config.astNode = {
                ...config.astNode,
                description: (_h = (_g = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _g === void 0 ? void 0 : _g.description) !== null && _h !== void 0 ? _h : config.astNode.description,
                directives: ((_j = config.astNode.directives) !== null && _j !== void 0 ? _j : []).concat((_l = (_k = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _k === void 0 ? void 0 : _k.directives) !== null && _l !== void 0 ? _l : [])
              };
            } else if (fieldName === "extensionASTNodes" && config.extensionASTNodes != null) {
              config.extensionASTNodes = config.extensionASTNodes.concat((_m = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _m !== void 0 ? _m : []);
            } else if (fieldName === "extensions" && type.extensions != null && resolverValue.extensions != null) {
              type.extensions = Object.assign(/* @__PURE__ */ Object.create(null), type.extensions, resolverValue.extensions);
            } else if (enumValueConfigMap[fieldName]) {
              enumValueConfigMap[fieldName].value = resolverValue[fieldName];
            }
          }
          typeMap[typeName] = new graphql_1.GraphQLEnumType(config);
        } else if ((0, graphql_1.isUnionType)(type)) {
          for (const fieldName in resolverValue) {
            if (fieldName.startsWith("__")) {
              type[fieldName.substring(2)] = resolverValue[fieldName];
            }
          }
        } else if ((0, graphql_1.isObjectType)(type) || (0, graphql_1.isInterfaceType)(type)) {
          for (const fieldName in resolverValue) {
            if (fieldName.startsWith("__")) {
              type[fieldName.substring(2)] = resolverValue[fieldName];
              continue;
            }
            const fields = type.getFields();
            const field = fields[fieldName];
            if (field != null) {
              const fieldResolve = resolverValue[fieldName];
              if (typeof fieldResolve === "function") {
                field.resolve = fieldResolve.bind(resolverValue);
              } else {
                setFieldProperties(field, fieldResolve);
              }
            }
          }
        }
      }
      (0, utils_1.forEachDefaultValue)(schema, utils_1.serializeInputValue);
      (0, utils_1.healSchema)(schema);
      (0, utils_1.forEachDefaultValue)(schema, utils_1.parseInputValue);
      if (defaultFieldResolver2 != null) {
        (0, utils_1.forEachField)(schema, (field) => {
          if (!field.resolve) {
            field.resolve = defaultFieldResolver2;
          }
        });
      }
      return schema;
    }
    function createNewSchemaWithResolvers(schema, resolvers, defaultFieldResolver2) {
      schema = (0, utils_1.mapSchema)(schema, {
        [utils_1.MapperKind.SCALAR_TYPE]: (type) => {
          var _a, _b, _c, _d, _e, _f;
          const config = type.toConfig();
          const resolverValue = resolvers[type.name];
          if (!(0, graphql_1.isSpecifiedScalarType)(type) && resolverValue != null) {
            for (const fieldName in resolverValue) {
              if (fieldName.startsWith("__")) {
                config[fieldName.substring(2)] = resolverValue[fieldName];
              } else if (fieldName === "astNode" && config.astNode != null) {
                config.astNode = {
                  ...config.astNode,
                  description: (_b = (_a = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : config.astNode.description,
                  directives: ((_c = config.astNode.directives) !== null && _c !== void 0 ? _c : []).concat((_e = (_d = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _d === void 0 ? void 0 : _d.directives) !== null && _e !== void 0 ? _e : [])
                };
              } else if (fieldName === "extensionASTNodes" && config.extensionASTNodes != null) {
                config.extensionASTNodes = config.extensionASTNodes.concat((_f = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _f !== void 0 ? _f : []);
              } else if (fieldName === "extensions" && config.extensions != null && resolverValue.extensions != null) {
                config.extensions = Object.assign(/* @__PURE__ */ Object.create(null), type.extensions, resolverValue.extensions);
              } else {
                config[fieldName] = resolverValue[fieldName];
              }
            }
            return new graphql_1.GraphQLScalarType(config);
          }
        },
        [utils_1.MapperKind.ENUM_TYPE]: (type) => {
          var _a, _b, _c, _d, _e, _f;
          const resolverValue = resolvers[type.name];
          const config = type.toConfig();
          const enumValueConfigMap = config.values;
          if (resolverValue != null) {
            for (const fieldName in resolverValue) {
              if (fieldName.startsWith("__")) {
                config[fieldName.substring(2)] = resolverValue[fieldName];
              } else if (fieldName === "astNode" && config.astNode != null) {
                config.astNode = {
                  ...config.astNode,
                  description: (_b = (_a = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : config.astNode.description,
                  directives: ((_c = config.astNode.directives) !== null && _c !== void 0 ? _c : []).concat((_e = (_d = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _d === void 0 ? void 0 : _d.directives) !== null && _e !== void 0 ? _e : [])
                };
              } else if (fieldName === "extensionASTNodes" && config.extensionASTNodes != null) {
                config.extensionASTNodes = config.extensionASTNodes.concat((_f = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _f !== void 0 ? _f : []);
              } else if (fieldName === "extensions" && config.extensions != null && resolverValue.extensions != null) {
                config.extensions = Object.assign(/* @__PURE__ */ Object.create(null), type.extensions, resolverValue.extensions);
              } else if (enumValueConfigMap[fieldName]) {
                enumValueConfigMap[fieldName].value = resolverValue[fieldName];
              }
            }
            return new graphql_1.GraphQLEnumType(config);
          }
        },
        [utils_1.MapperKind.UNION_TYPE]: (type) => {
          const resolverValue = resolvers[type.name];
          if (resolverValue != null) {
            const config = type.toConfig();
            if (resolverValue["__resolveType"]) {
              config.resolveType = resolverValue["__resolveType"];
            }
            return new graphql_1.GraphQLUnionType(config);
          }
        },
        [utils_1.MapperKind.OBJECT_TYPE]: (type) => {
          const resolverValue = resolvers[type.name];
          if (resolverValue != null) {
            const config = type.toConfig();
            if (resolverValue["__isTypeOf"]) {
              config.isTypeOf = resolverValue["__isTypeOf"];
            }
            return new graphql_1.GraphQLObjectType(config);
          }
        },
        [utils_1.MapperKind.INTERFACE_TYPE]: (type) => {
          const resolverValue = resolvers[type.name];
          if (resolverValue != null) {
            const config = type.toConfig();
            if (resolverValue["__resolveType"]) {
              config.resolveType = resolverValue["__resolveType"];
            }
            return new graphql_1.GraphQLInterfaceType(config);
          }
        },
        [utils_1.MapperKind.COMPOSITE_FIELD]: (fieldConfig, fieldName, typeName) => {
          const resolverValue = resolvers[typeName];
          if (resolverValue != null) {
            const fieldResolve = resolverValue[fieldName];
            if (fieldResolve != null) {
              const newFieldConfig = { ...fieldConfig };
              if (typeof fieldResolve === "function") {
                newFieldConfig.resolve = fieldResolve.bind(resolverValue);
              } else {
                setFieldProperties(newFieldConfig, fieldResolve);
              }
              return newFieldConfig;
            }
          }
        }
      });
      if (defaultFieldResolver2 != null) {
        schema = (0, utils_1.mapSchema)(schema, {
          [utils_1.MapperKind.OBJECT_FIELD]: (fieldConfig) => ({
            ...fieldConfig,
            resolve: fieldConfig.resolve != null ? fieldConfig.resolve : defaultFieldResolver2
          })
        });
      }
      return schema;
    }
    function setFieldProperties(field, propertiesObj) {
      for (const propertyName in propertiesObj) {
        field[propertyName] = propertiesObj[propertyName];
      }
    }
  }
});

// ../../../node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/merge-resolvers.js
var require_merge_resolvers = __commonJS({
  "../../../node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/merge-resolvers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeResolvers = void 0;
    var utils_1 = require_cjs();
    function mergeResolvers(resolversDefinitions, options) {
      if (!resolversDefinitions || Array.isArray(resolversDefinitions) && resolversDefinitions.length === 0) {
        return {};
      }
      if (!Array.isArray(resolversDefinitions)) {
        return resolversDefinitions;
      }
      if (resolversDefinitions.length === 1) {
        return resolversDefinitions[0] || {};
      }
      const resolvers = new Array();
      for (let resolversDefinition of resolversDefinitions) {
        if (Array.isArray(resolversDefinition)) {
          resolversDefinition = mergeResolvers(resolversDefinition);
        }
        if (typeof resolversDefinition === "object" && resolversDefinition) {
          resolvers.push(resolversDefinition);
        }
      }
      const result = (0, utils_1.mergeDeep)(resolvers, true);
      if (options === null || options === void 0 ? void 0 : options.exclusions) {
        for (const exclusion of options.exclusions) {
          const [typeName, fieldName] = exclusion.split(".");
          if (!fieldName || fieldName === "*") {
            delete result[typeName];
          } else if (result[typeName]) {
            delete result[typeName][fieldName];
          }
        }
      }
      return result;
    }
    exports2.mergeResolvers = mergeResolvers;
  }
});

// ../../../node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/arguments.js
var require_arguments = __commonJS({
  "../../../node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/arguments.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeArguments = void 0;
    var utils_1 = require_cjs();
    function mergeArguments(args1, args2, config) {
      const result = deduplicateArguments([...args2, ...args1].filter(utils_1.isSome), config);
      if (config && config.sort) {
        result.sort(utils_1.compareNodes);
      }
      return result;
    }
    exports2.mergeArguments = mergeArguments;
    function deduplicateArguments(args, config) {
      return args.reduce((acc, current) => {
        const dupIndex = acc.findIndex((arg) => arg.name.value === current.name.value);
        if (dupIndex === -1) {
          return acc.concat([current]);
        } else if (!(config === null || config === void 0 ? void 0 : config.reverseArguments)) {
          acc[dupIndex] = current;
        }
        return acc;
      }, []);
    }
  }
});

// ../../../node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/directives.js
var require_directives2 = __commonJS({
  "../../../node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/directives.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeDirective = exports2.mergeDirectives = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var utils_1 = require_cjs();
    function directiveAlreadyExists(directivesArr, otherDirective) {
      return !!directivesArr.find((directive) => directive.name.value === otherDirective.name.value);
    }
    function isRepeatableDirective(directive, directives) {
      var _a;
      return !!((_a = directives === null || directives === void 0 ? void 0 : directives[directive.name.value]) === null || _a === void 0 ? void 0 : _a.repeatable);
    }
    function nameAlreadyExists(name, namesArr) {
      return namesArr.some(({ value }) => value === name.value);
    }
    function mergeArguments(a1, a2) {
      const result = [...a2];
      for (const argument of a1) {
        const existingIndex = result.findIndex((a) => a.name.value === argument.name.value);
        if (existingIndex > -1) {
          const existingArg = result[existingIndex];
          if (existingArg.value.kind === "ListValue") {
            const source = existingArg.value.values;
            const target = argument.value.values;
            existingArg.value.values = deduplicateLists(source, target, (targetVal, source2) => {
              const value = targetVal.value;
              return !value || !source2.some((sourceVal) => sourceVal.value === value);
            });
          } else {
            existingArg.value = argument.value;
          }
        } else {
          result.push(argument);
        }
      }
      return result;
    }
    function deduplicateDirectives(directives, definitions) {
      return directives.map((directive, i, all) => {
        const firstAt = all.findIndex((d) => d.name.value === directive.name.value);
        if (firstAt !== i && !isRepeatableDirective(directive, definitions)) {
          const dup = all[firstAt];
          directive.arguments = mergeArguments(directive.arguments, dup.arguments);
          return null;
        }
        return directive;
      }).filter(utils_1.isSome);
    }
    function mergeDirectives(d1 = [], d2 = [], config, directives) {
      const reverseOrder = config && config.reverseDirectives;
      const asNext = reverseOrder ? d1 : d2;
      const asFirst = reverseOrder ? d2 : d1;
      const result = deduplicateDirectives([...asNext], directives);
      for (const directive of asFirst) {
        if (directiveAlreadyExists(result, directive) && !isRepeatableDirective(directive, directives)) {
          const existingDirectiveIndex = result.findIndex((d) => d.name.value === directive.name.value);
          const existingDirective = result[existingDirectiveIndex];
          result[existingDirectiveIndex].arguments = mergeArguments(directive.arguments || [], existingDirective.arguments || []);
        } else {
          result.push(directive);
        }
      }
      return result;
    }
    exports2.mergeDirectives = mergeDirectives;
    function validateInputs(node, existingNode) {
      const printedNode = (0, graphql_1.print)({
        ...node,
        description: void 0
      });
      const printedExistingNode = (0, graphql_1.print)({
        ...existingNode,
        description: void 0
      });
      const leaveInputs = new RegExp("(directive @w*d*)|( on .*$)", "g");
      const sameArguments = printedNode.replace(leaveInputs, "") === printedExistingNode.replace(leaveInputs, "");
      if (!sameArguments) {
        throw new Error(`Unable to merge GraphQL directive "${node.name.value}". 
Existing directive:  
	${printedExistingNode} 
Received directive: 
	${printedNode}`);
      }
    }
    function mergeDirective(node, existingNode) {
      if (existingNode) {
        validateInputs(node, existingNode);
        return {
          ...node,
          locations: [
            ...existingNode.locations,
            ...node.locations.filter((name) => !nameAlreadyExists(name, existingNode.locations))
          ]
        };
      }
      return node;
    }
    exports2.mergeDirective = mergeDirective;
    function deduplicateLists(source, target, filterFn) {
      return source.concat(target.filter((val) => filterFn(val, source)));
    }
  }
});

// ../../../node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/enum-values.js
var require_enum_values = __commonJS({
  "../../../node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/enum-values.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeEnumValues = void 0;
    var directives_js_1 = require_directives2();
    var utils_1 = require_cjs();
    function mergeEnumValues(first, second, config, directives) {
      if (config === null || config === void 0 ? void 0 : config.consistentEnumMerge) {
        const reversed = [];
        if (first) {
          reversed.push(...first);
        }
        first = second;
        second = reversed;
      }
      const enumValueMap = /* @__PURE__ */ new Map();
      if (first) {
        for (const firstValue of first) {
          enumValueMap.set(firstValue.name.value, firstValue);
        }
      }
      if (second) {
        for (const secondValue of second) {
          const enumValue = secondValue.name.value;
          if (enumValueMap.has(enumValue)) {
            const firstValue = enumValueMap.get(enumValue);
            firstValue.description = secondValue.description || firstValue.description;
            firstValue.directives = (0, directives_js_1.mergeDirectives)(secondValue.directives, firstValue.directives, directives);
          } else {
            enumValueMap.set(enumValue, secondValue);
          }
        }
      }
      const result = [...enumValueMap.values()];
      if (config && config.sort) {
        result.sort(utils_1.compareNodes);
      }
      return result;
    }
    exports2.mergeEnumValues = mergeEnumValues;
  }
});

// ../../../node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/enum.js
var require_enum = __commonJS({
  "../../../node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/enum.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeEnum = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var directives_js_1 = require_directives2();
    var enum_values_js_1 = require_enum_values();
    function mergeEnum(e1, e2, config, directives) {
      if (e2) {
        return {
          name: e1.name,
          description: e1["description"] || e2["description"],
          kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || e1.kind === "EnumTypeDefinition" || e2.kind === "EnumTypeDefinition" ? "EnumTypeDefinition" : "EnumTypeExtension",
          loc: e1.loc,
          directives: (0, directives_js_1.mergeDirectives)(e1.directives, e2.directives, config, directives),
          values: (0, enum_values_js_1.mergeEnumValues)(e1.values, e2.values, config)
        };
      }
      return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? {
        ...e1,
        kind: graphql_1.Kind.ENUM_TYPE_DEFINITION
      } : e1;
    }
    exports2.mergeEnum = mergeEnum;
  }
});

// ../../../node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/utils.js
var require_utils3 = __commonJS({
  "../../../node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defaultStringComparator = exports2.CompareVal = exports2.printTypeNode = exports2.isNonNullTypeNode = exports2.isListTypeNode = exports2.isWrappingTypeNode = exports2.extractType = exports2.isSourceTypes = exports2.isStringTypes = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function isStringTypes(types) {
      return typeof types === "string";
    }
    exports2.isStringTypes = isStringTypes;
    function isSourceTypes(types) {
      return types instanceof graphql_1.Source;
    }
    exports2.isSourceTypes = isSourceTypes;
    function extractType(type) {
      let visitedType = type;
      while (visitedType.kind === graphql_1.Kind.LIST_TYPE || visitedType.kind === "NonNullType") {
        visitedType = visitedType.type;
      }
      return visitedType;
    }
    exports2.extractType = extractType;
    function isWrappingTypeNode(type) {
      return type.kind !== graphql_1.Kind.NAMED_TYPE;
    }
    exports2.isWrappingTypeNode = isWrappingTypeNode;
    function isListTypeNode(type) {
      return type.kind === graphql_1.Kind.LIST_TYPE;
    }
    exports2.isListTypeNode = isListTypeNode;
    function isNonNullTypeNode(type) {
      return type.kind === graphql_1.Kind.NON_NULL_TYPE;
    }
    exports2.isNonNullTypeNode = isNonNullTypeNode;
    function printTypeNode(type) {
      if (isListTypeNode(type)) {
        return `[${printTypeNode(type.type)}]`;
      }
      if (isNonNullTypeNode(type)) {
        return `${printTypeNode(type.type)}!`;
      }
      return type.name.value;
    }
    exports2.printTypeNode = printTypeNode;
    var CompareVal;
    (function(CompareVal2) {
      CompareVal2[CompareVal2["A_SMALLER_THAN_B"] = -1] = "A_SMALLER_THAN_B";
      CompareVal2[CompareVal2["A_EQUALS_B"] = 0] = "A_EQUALS_B";
      CompareVal2[CompareVal2["A_GREATER_THAN_B"] = 1] = "A_GREATER_THAN_B";
    })(CompareVal = exports2.CompareVal || (exports2.CompareVal = {}));
    function defaultStringComparator(a, b) {
      if (a == null && b == null) {
        return CompareVal.A_EQUALS_B;
      }
      if (a == null) {
        return CompareVal.A_SMALLER_THAN_B;
      }
      if (b == null) {
        return CompareVal.A_GREATER_THAN_B;
      }
      if (a < b)
        return CompareVal.A_SMALLER_THAN_B;
      if (a > b)
        return CompareVal.A_GREATER_THAN_B;
      return CompareVal.A_EQUALS_B;
    }
    exports2.defaultStringComparator = defaultStringComparator;
  }
});

// ../../../node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/fields.js
var require_fields2 = __commonJS({
  "../../../node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/fields.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeFields = void 0;
    var utils_js_1 = require_utils3();
    var directives_js_1 = require_directives2();
    var utils_1 = require_cjs();
    var arguments_js_1 = require_arguments();
    function fieldAlreadyExists(fieldsArr, otherField) {
      const resultIndex = fieldsArr.findIndex((field) => field.name.value === otherField.name.value);
      return [resultIndex > -1 ? fieldsArr[resultIndex] : null, resultIndex];
    }
    function mergeFields(type, f1, f2, config, directives) {
      const result = [];
      if (f2 != null) {
        result.push(...f2);
      }
      if (f1 != null) {
        for (const field of f1) {
          const [existing, existingIndex] = fieldAlreadyExists(result, field);
          if (existing && !(config === null || config === void 0 ? void 0 : config.ignoreFieldConflicts)) {
            const newField = (config === null || config === void 0 ? void 0 : config.onFieldTypeConflict) && config.onFieldTypeConflict(existing, field, type, config === null || config === void 0 ? void 0 : config.throwOnConflict) || preventConflicts(type, existing, field, config === null || config === void 0 ? void 0 : config.throwOnConflict);
            newField.arguments = (0, arguments_js_1.mergeArguments)(field["arguments"] || [], existing["arguments"] || [], config);
            newField.directives = (0, directives_js_1.mergeDirectives)(field.directives, existing.directives, config, directives);
            newField.description = field.description || existing.description;
            result[existingIndex] = newField;
          } else {
            result.push(field);
          }
        }
      }
      if (config && config.sort) {
        result.sort(utils_1.compareNodes);
      }
      if (config && config.exclusions) {
        const exclusions = config.exclusions;
        return result.filter((field) => !exclusions.includes(`${type.name.value}.${field.name.value}`));
      }
      return result;
    }
    exports2.mergeFields = mergeFields;
    function preventConflicts(type, a, b, ignoreNullability = false) {
      const aType = (0, utils_js_1.printTypeNode)(a.type);
      const bType = (0, utils_js_1.printTypeNode)(b.type);
      if (aType !== bType) {
        const t1 = (0, utils_js_1.extractType)(a.type);
        const t2 = (0, utils_js_1.extractType)(b.type);
        if (t1.name.value !== t2.name.value) {
          throw new Error(`Field "${b.name.value}" already defined with a different type. Declared as "${t1.name.value}", but you tried to override with "${t2.name.value}"`);
        }
        if (!safeChangeForFieldType(a.type, b.type, !ignoreNullability)) {
          throw new Error(`Field '${type.name.value}.${a.name.value}' changed type from '${aType}' to '${bType}'`);
        }
      }
      if ((0, utils_js_1.isNonNullTypeNode)(b.type) && !(0, utils_js_1.isNonNullTypeNode)(a.type)) {
        a.type = b.type;
      }
      return a;
    }
    function safeChangeForFieldType(oldType, newType, ignoreNullability = false) {
      if (!(0, utils_js_1.isWrappingTypeNode)(oldType) && !(0, utils_js_1.isWrappingTypeNode)(newType)) {
        return oldType.toString() === newType.toString();
      }
      if ((0, utils_js_1.isNonNullTypeNode)(newType)) {
        const ofType = (0, utils_js_1.isNonNullTypeNode)(oldType) ? oldType.type : oldType;
        return safeChangeForFieldType(ofType, newType.type);
      }
      if ((0, utils_js_1.isNonNullTypeNode)(oldType)) {
        return safeChangeForFieldType(newType, oldType, ignoreNullability);
      }
      if ((0, utils_js_1.isListTypeNode)(oldType)) {
        return (0, utils_js_1.isListTypeNode)(newType) && safeChangeForFieldType(oldType.type, newType.type) || (0, utils_js_1.isNonNullTypeNode)(newType) && safeChangeForFieldType(oldType, newType["type"]);
      }
      return false;
    }
  }
});

// ../../../node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/input-type.js
var require_input_type = __commonJS({
  "../../../node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/input-type.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeInputType = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var fields_js_1 = require_fields2();
    var directives_js_1 = require_directives2();
    function mergeInputType(node, existingNode, config, directives) {
      if (existingNode) {
        try {
          return {
            name: node.name,
            description: node["description"] || existingNode["description"],
            kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || node.kind === "InputObjectTypeDefinition" || existingNode.kind === "InputObjectTypeDefinition" ? "InputObjectTypeDefinition" : "InputObjectTypeExtension",
            loc: node.loc,
            fields: (0, fields_js_1.mergeFields)(node, node.fields, existingNode.fields, config),
            directives: (0, directives_js_1.mergeDirectives)(node.directives, existingNode.directives, config, directives)
          };
        } catch (e) {
          throw new Error(`Unable to merge GraphQL input type "${node.name.value}": ${e.message}`);
        }
      }
      return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? {
        ...node,
        kind: graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION
      } : node;
    }
    exports2.mergeInputType = mergeInputType;
  }
});

// ../../../node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-named-type-array.js
var require_merge_named_type_array = __commonJS({
  "../../../node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-named-type-array.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeNamedTypeArray = void 0;
    var utils_1 = require_cjs();
    function alreadyExists(arr, other) {
      return !!arr.find((i) => i.name.value === other.name.value);
    }
    function mergeNamedTypeArray(first = [], second = [], config = {}) {
      const result = [...second, ...first.filter((d) => !alreadyExists(second, d))];
      if (config && config.sort) {
        result.sort(utils_1.compareNodes);
      }
      return result;
    }
    exports2.mergeNamedTypeArray = mergeNamedTypeArray;
  }
});

// ../../../node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/interface.js
var require_interface = __commonJS({
  "../../../node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/interface.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeInterface = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var fields_js_1 = require_fields2();
    var directives_js_1 = require_directives2();
    var merge_named_type_array_js_1 = require_merge_named_type_array();
    function mergeInterface(node, existingNode, config, directives) {
      if (existingNode) {
        try {
          return {
            name: node.name,
            description: node["description"] || existingNode["description"],
            kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || node.kind === "InterfaceTypeDefinition" || existingNode.kind === "InterfaceTypeDefinition" ? "InterfaceTypeDefinition" : "InterfaceTypeExtension",
            loc: node.loc,
            fields: (0, fields_js_1.mergeFields)(node, node.fields, existingNode.fields, config),
            directives: (0, directives_js_1.mergeDirectives)(node.directives, existingNode.directives, config, directives),
            interfaces: node["interfaces"] ? (0, merge_named_type_array_js_1.mergeNamedTypeArray)(node["interfaces"], existingNode["interfaces"], config) : void 0
          };
        } catch (e) {
          throw new Error(`Unable to merge GraphQL interface "${node.name.value}": ${e.message}`);
        }
      }
      return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? {
        ...node,
        kind: graphql_1.Kind.INTERFACE_TYPE_DEFINITION
      } : node;
    }
    exports2.mergeInterface = mergeInterface;
  }
});

// ../../../node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/type.js
var require_type = __commonJS({
  "../../../node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/type.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeType = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var fields_js_1 = require_fields2();
    var directives_js_1 = require_directives2();
    var merge_named_type_array_js_1 = require_merge_named_type_array();
    function mergeType(node, existingNode, config, directives) {
      if (existingNode) {
        try {
          return {
            name: node.name,
            description: node["description"] || existingNode["description"],
            kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || node.kind === "ObjectTypeDefinition" || existingNode.kind === "ObjectTypeDefinition" ? "ObjectTypeDefinition" : "ObjectTypeExtension",
            loc: node.loc,
            fields: (0, fields_js_1.mergeFields)(node, node.fields, existingNode.fields, config),
            directives: (0, directives_js_1.mergeDirectives)(node.directives, existingNode.directives, config, directives),
            interfaces: (0, merge_named_type_array_js_1.mergeNamedTypeArray)(node.interfaces, existingNode.interfaces, config)
          };
        } catch (e) {
          throw new Error(`Unable to merge GraphQL type "${node.name.value}": ${e.message}`);
        }
      }
      return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? {
        ...node,
        kind: graphql_1.Kind.OBJECT_TYPE_DEFINITION
      } : node;
    }
    exports2.mergeType = mergeType;
  }
});

// ../../../node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/scalar.js
var require_scalar = __commonJS({
  "../../../node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/scalar.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeScalar = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var directives_js_1 = require_directives2();
    function mergeScalar(node, existingNode, config, directives) {
      if (existingNode) {
        return {
          name: node.name,
          description: node["description"] || existingNode["description"],
          kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || node.kind === "ScalarTypeDefinition" || existingNode.kind === "ScalarTypeDefinition" ? "ScalarTypeDefinition" : "ScalarTypeExtension",
          loc: node.loc,
          directives: (0, directives_js_1.mergeDirectives)(node.directives, existingNode.directives, config, directives)
        };
      }
      return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? {
        ...node,
        kind: graphql_1.Kind.SCALAR_TYPE_DEFINITION
      } : node;
    }
    exports2.mergeScalar = mergeScalar;
  }
});

// ../../../node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/union.js
var require_union = __commonJS({
  "../../../node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/union.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeUnion = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var directives_js_1 = require_directives2();
    var merge_named_type_array_js_1 = require_merge_named_type_array();
    function mergeUnion(first, second, config, directives) {
      if (second) {
        return {
          name: first.name,
          description: first["description"] || second["description"],
          // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
          directives: (0, directives_js_1.mergeDirectives)(first.directives, second.directives, config, directives),
          kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || first.kind === "UnionTypeDefinition" || second.kind === "UnionTypeDefinition" ? graphql_1.Kind.UNION_TYPE_DEFINITION : graphql_1.Kind.UNION_TYPE_EXTENSION,
          loc: first.loc,
          types: (0, merge_named_type_array_js_1.mergeNamedTypeArray)(first.types, second.types, config)
        };
      }
      return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? {
        ...first,
        kind: graphql_1.Kind.UNION_TYPE_DEFINITION
      } : first;
    }
    exports2.mergeUnion = mergeUnion;
  }
});

// ../../../node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/schema-def.js
var require_schema_def = __commonJS({
  "../../../node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/schema-def.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeSchemaDefs = exports2.DEFAULT_OPERATION_TYPE_NAME_MAP = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var directives_js_1 = require_directives2();
    exports2.DEFAULT_OPERATION_TYPE_NAME_MAP = {
      query: "Query",
      mutation: "Mutation",
      subscription: "Subscription"
    };
    function mergeOperationTypes(opNodeList = [], existingOpNodeList = []) {
      const finalOpNodeList = [];
      for (const opNodeType in exports2.DEFAULT_OPERATION_TYPE_NAME_MAP) {
        const opNode = opNodeList.find((n) => n.operation === opNodeType) || existingOpNodeList.find((n) => n.operation === opNodeType);
        if (opNode) {
          finalOpNodeList.push(opNode);
        }
      }
      return finalOpNodeList;
    }
    function mergeSchemaDefs(node, existingNode, config, directives) {
      if (existingNode) {
        return {
          kind: node.kind === graphql_1.Kind.SCHEMA_DEFINITION || existingNode.kind === graphql_1.Kind.SCHEMA_DEFINITION ? graphql_1.Kind.SCHEMA_DEFINITION : graphql_1.Kind.SCHEMA_EXTENSION,
          description: node["description"] || existingNode["description"],
          directives: (0, directives_js_1.mergeDirectives)(node.directives, existingNode.directives, config, directives),
          operationTypes: mergeOperationTypes(node.operationTypes, existingNode.operationTypes)
        };
      }
      return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? {
        ...node,
        kind: graphql_1.Kind.SCHEMA_DEFINITION
      } : node;
    }
    exports2.mergeSchemaDefs = mergeSchemaDefs;
  }
});

// ../../../node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-nodes.js
var require_merge_nodes = __commonJS({
  "../../../node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-nodes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeGraphQLNodes = exports2.isNamedDefinitionNode = exports2.schemaDefSymbol = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var type_js_1 = require_type();
    var enum_js_1 = require_enum();
    var scalar_js_1 = require_scalar();
    var union_js_1 = require_union();
    var input_type_js_1 = require_input_type();
    var interface_js_1 = require_interface();
    var directives_js_1 = require_directives2();
    var schema_def_js_1 = require_schema_def();
    var utils_1 = require_cjs();
    exports2.schemaDefSymbol = "SCHEMA_DEF_SYMBOL";
    function isNamedDefinitionNode(definitionNode) {
      return "name" in definitionNode;
    }
    exports2.isNamedDefinitionNode = isNamedDefinitionNode;
    function mergeGraphQLNodes(nodes, config, directives = {}) {
      var _a, _b, _c;
      const mergedResultMap = directives;
      for (const nodeDefinition of nodes) {
        if (isNamedDefinitionNode(nodeDefinition)) {
          const name = (_a = nodeDefinition.name) === null || _a === void 0 ? void 0 : _a.value;
          if (config === null || config === void 0 ? void 0 : config.commentDescriptions) {
            (0, utils_1.collectComment)(nodeDefinition);
          }
          if (name == null) {
            continue;
          }
          if (((_b = config === null || config === void 0 ? void 0 : config.exclusions) === null || _b === void 0 ? void 0 : _b.includes(name + ".*")) || ((_c = config === null || config === void 0 ? void 0 : config.exclusions) === null || _c === void 0 ? void 0 : _c.includes(name))) {
            delete mergedResultMap[name];
          } else {
            switch (nodeDefinition.kind) {
              case graphql_1.Kind.OBJECT_TYPE_DEFINITION:
              case graphql_1.Kind.OBJECT_TYPE_EXTENSION:
                mergedResultMap[name] = (0, type_js_1.mergeType)(nodeDefinition, mergedResultMap[name], config, directives);
                break;
              case graphql_1.Kind.ENUM_TYPE_DEFINITION:
              case graphql_1.Kind.ENUM_TYPE_EXTENSION:
                mergedResultMap[name] = (0, enum_js_1.mergeEnum)(nodeDefinition, mergedResultMap[name], config, directives);
                break;
              case graphql_1.Kind.UNION_TYPE_DEFINITION:
              case graphql_1.Kind.UNION_TYPE_EXTENSION:
                mergedResultMap[name] = (0, union_js_1.mergeUnion)(nodeDefinition, mergedResultMap[name], config, directives);
                break;
              case graphql_1.Kind.SCALAR_TYPE_DEFINITION:
              case graphql_1.Kind.SCALAR_TYPE_EXTENSION:
                mergedResultMap[name] = (0, scalar_js_1.mergeScalar)(nodeDefinition, mergedResultMap[name], config, directives);
                break;
              case graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION:
              case graphql_1.Kind.INPUT_OBJECT_TYPE_EXTENSION:
                mergedResultMap[name] = (0, input_type_js_1.mergeInputType)(nodeDefinition, mergedResultMap[name], config, directives);
                break;
              case graphql_1.Kind.INTERFACE_TYPE_DEFINITION:
              case graphql_1.Kind.INTERFACE_TYPE_EXTENSION:
                mergedResultMap[name] = (0, interface_js_1.mergeInterface)(nodeDefinition, mergedResultMap[name], config, directives);
                break;
              case graphql_1.Kind.DIRECTIVE_DEFINITION:
                mergedResultMap[name] = (0, directives_js_1.mergeDirective)(nodeDefinition, mergedResultMap[name]);
                break;
            }
          }
        } else if (nodeDefinition.kind === graphql_1.Kind.SCHEMA_DEFINITION || nodeDefinition.kind === graphql_1.Kind.SCHEMA_EXTENSION) {
          mergedResultMap[exports2.schemaDefSymbol] = (0, schema_def_js_1.mergeSchemaDefs)(nodeDefinition, mergedResultMap[exports2.schemaDefSymbol], config);
        }
      }
      return mergedResultMap;
    }
    exports2.mergeGraphQLNodes = mergeGraphQLNodes;
  }
});

// ../../../node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-typedefs.js
var require_merge_typedefs = __commonJS({
  "../../../node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-typedefs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeGraphQLTypes = exports2.mergeTypeDefs = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var utils_js_1 = require_utils3();
    var merge_nodes_js_1 = require_merge_nodes();
    var utils_1 = require_cjs();
    var schema_def_js_1 = require_schema_def();
    function mergeTypeDefs(typeSource, config) {
      (0, utils_1.resetComments)();
      const doc = {
        kind: graphql_1.Kind.DOCUMENT,
        definitions: mergeGraphQLTypes(typeSource, {
          useSchemaDefinition: true,
          forceSchemaDefinition: false,
          throwOnConflict: false,
          commentDescriptions: false,
          ...config
        })
      };
      let result;
      if (config === null || config === void 0 ? void 0 : config.commentDescriptions) {
        result = (0, utils_1.printWithComments)(doc);
      } else {
        result = doc;
      }
      (0, utils_1.resetComments)();
      return result;
    }
    exports2.mergeTypeDefs = mergeTypeDefs;
    function visitTypeSources(typeSource, options, allDirectives = [], allNodes = [], visitedTypeSources = /* @__PURE__ */ new Set()) {
      if (typeSource && !visitedTypeSources.has(typeSource)) {
        visitedTypeSources.add(typeSource);
        if (typeof typeSource === "function") {
          visitTypeSources(typeSource(), options, allDirectives, allNodes, visitedTypeSources);
        } else if (Array.isArray(typeSource)) {
          for (const type of typeSource) {
            visitTypeSources(type, options, allDirectives, allNodes, visitedTypeSources);
          }
        } else if ((0, graphql_1.isSchema)(typeSource)) {
          const documentNode = (0, utils_1.getDocumentNodeFromSchema)(typeSource, options);
          visitTypeSources(documentNode.definitions, options, allDirectives, allNodes, visitedTypeSources);
        } else if ((0, utils_js_1.isStringTypes)(typeSource) || (0, utils_js_1.isSourceTypes)(typeSource)) {
          const documentNode = (0, graphql_1.parse)(typeSource, options);
          visitTypeSources(documentNode.definitions, options, allDirectives, allNodes, visitedTypeSources);
        } else if (typeof typeSource === "object" && (0, graphql_1.isDefinitionNode)(typeSource)) {
          if (typeSource.kind === graphql_1.Kind.DIRECTIVE_DEFINITION) {
            allDirectives.push(typeSource);
          } else {
            allNodes.push(typeSource);
          }
        } else if ((0, utils_1.isDocumentNode)(typeSource)) {
          visitTypeSources(typeSource.definitions, options, allDirectives, allNodes, visitedTypeSources);
        } else {
          throw new Error(`typeDefs must contain only strings, documents, schemas, or functions, got ${typeof typeSource}`);
        }
      }
      return { allDirectives, allNodes };
    }
    function mergeGraphQLTypes(typeSource, config) {
      var _a, _b, _c;
      (0, utils_1.resetComments)();
      const { allDirectives, allNodes } = visitTypeSources(typeSource, config);
      const mergedDirectives = (0, merge_nodes_js_1.mergeGraphQLNodes)(allDirectives, config);
      const mergedNodes = (0, merge_nodes_js_1.mergeGraphQLNodes)(allNodes, config, mergedDirectives);
      if (config === null || config === void 0 ? void 0 : config.useSchemaDefinition) {
        const schemaDef = mergedNodes[merge_nodes_js_1.schemaDefSymbol] || {
          kind: graphql_1.Kind.SCHEMA_DEFINITION,
          operationTypes: []
        };
        const operationTypes = schemaDef.operationTypes;
        for (const opTypeDefNodeType in schema_def_js_1.DEFAULT_OPERATION_TYPE_NAME_MAP) {
          const opTypeDefNode = operationTypes.find((operationType) => operationType.operation === opTypeDefNodeType);
          if (!opTypeDefNode) {
            const possibleRootTypeName = schema_def_js_1.DEFAULT_OPERATION_TYPE_NAME_MAP[opTypeDefNodeType];
            const existingPossibleRootType = mergedNodes[possibleRootTypeName];
            if (existingPossibleRootType != null && existingPossibleRootType.name != null) {
              operationTypes.push({
                kind: graphql_1.Kind.OPERATION_TYPE_DEFINITION,
                type: {
                  kind: graphql_1.Kind.NAMED_TYPE,
                  name: existingPossibleRootType.name
                },
                operation: opTypeDefNodeType
              });
            }
          }
        }
        if (((_a = schemaDef === null || schemaDef === void 0 ? void 0 : schemaDef.operationTypes) === null || _a === void 0 ? void 0 : _a.length) != null && schemaDef.operationTypes.length > 0) {
          mergedNodes[merge_nodes_js_1.schemaDefSymbol] = schemaDef;
        }
      }
      if ((config === null || config === void 0 ? void 0 : config.forceSchemaDefinition) && !((_c = (_b = mergedNodes[merge_nodes_js_1.schemaDefSymbol]) === null || _b === void 0 ? void 0 : _b.operationTypes) === null || _c === void 0 ? void 0 : _c.length)) {
        mergedNodes[merge_nodes_js_1.schemaDefSymbol] = {
          kind: graphql_1.Kind.SCHEMA_DEFINITION,
          operationTypes: [
            {
              kind: graphql_1.Kind.OPERATION_TYPE_DEFINITION,
              operation: "query",
              type: {
                kind: graphql_1.Kind.NAMED_TYPE,
                name: {
                  kind: graphql_1.Kind.NAME,
                  value: "Query"
                }
              }
            }
          ]
        };
      }
      const mergedNodeDefinitions = Object.values(mergedNodes);
      if (config === null || config === void 0 ? void 0 : config.sort) {
        const sortFn = typeof config.sort === "function" ? config.sort : utils_js_1.defaultStringComparator;
        mergedNodeDefinitions.sort((a, b) => {
          var _a2, _b2;
          return sortFn((_a2 = a.name) === null || _a2 === void 0 ? void 0 : _a2.value, (_b2 = b.name) === null || _b2 === void 0 ? void 0 : _b2.value);
        });
      }
      return mergedNodeDefinitions;
    }
    exports2.mergeGraphQLTypes = mergeGraphQLTypes;
  }
});

// ../../../node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/index.js
var require_typedefs_mergers = __commonJS({
  "../../../node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_arguments(), exports2);
    tslib_1.__exportStar(require_directives2(), exports2);
    tslib_1.__exportStar(require_enum_values(), exports2);
    tslib_1.__exportStar(require_enum(), exports2);
    tslib_1.__exportStar(require_fields2(), exports2);
    tslib_1.__exportStar(require_input_type(), exports2);
    tslib_1.__exportStar(require_interface(), exports2);
    tslib_1.__exportStar(require_merge_named_type_array(), exports2);
    tslib_1.__exportStar(require_merge_nodes(), exports2);
    tslib_1.__exportStar(require_merge_typedefs(), exports2);
    tslib_1.__exportStar(require_scalar(), exports2);
    tslib_1.__exportStar(require_type(), exports2);
    tslib_1.__exportStar(require_union(), exports2);
    tslib_1.__exportStar(require_utils3(), exports2);
  }
});

// ../../../node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/extensions.js
var require_extensions = __commonJS({
  "../../../node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/extensions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.applyExtensions = exports2.mergeExtensions = exports2.extractExtensionsFromSchema = void 0;
    var utils_1 = require_cjs();
    var utils_2 = require_cjs();
    Object.defineProperty(exports2, "extractExtensionsFromSchema", { enumerable: true, get: function() {
      return utils_2.extractExtensionsFromSchema;
    } });
    function mergeExtensions(extensions) {
      return (0, utils_1.mergeDeep)(extensions);
    }
    exports2.mergeExtensions = mergeExtensions;
    function applyExtensionObject(obj, extensions) {
      if (!obj) {
        return;
      }
      obj.extensions = (0, utils_1.mergeDeep)([obj.extensions || {}, extensions || {}]);
    }
    function applyExtensions(schema, extensions) {
      applyExtensionObject(schema, extensions.schemaExtensions);
      for (const [typeName, data] of Object.entries(extensions.types || {})) {
        const type = schema.getType(typeName);
        if (type) {
          applyExtensionObject(type, data.extensions);
          if (data.type === "object" || data.type === "interface") {
            for (const [fieldName, fieldData] of Object.entries(data.fields)) {
              const field = type.getFields()[fieldName];
              if (field) {
                applyExtensionObject(field, fieldData.extensions);
                for (const [arg, argData] of Object.entries(fieldData.arguments)) {
                  applyExtensionObject(field.args.find((a) => a.name === arg), argData);
                }
              }
            }
          } else if (data.type === "input") {
            for (const [fieldName, fieldData] of Object.entries(data.fields)) {
              const field = type.getFields()[fieldName];
              applyExtensionObject(field, fieldData.extensions);
            }
          } else if (data.type === "enum") {
            for (const [valueName, valueData] of Object.entries(data.values)) {
              const value = type.getValue(valueName);
              applyExtensionObject(value, valueData);
            }
          }
        }
      }
      return schema;
    }
    exports2.applyExtensions = applyExtensions;
  }
});

// ../../../node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/index.js
var require_cjs2 = __commonJS({
  "../../../node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_merge_resolvers(), exports2);
    tslib_1.__exportStar(require_typedefs_mergers(), exports2);
    tslib_1.__exportStar(require_extensions(), exports2);
  }
});

// ../../../node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/makeExecutableSchema.js
var require_makeExecutableSchema = __commonJS({
  "../../../node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/makeExecutableSchema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.makeExecutableSchema = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var utils_1 = require_cjs();
    var addResolversToSchema_js_1 = require_addResolversToSchema();
    var assertResolversPresent_js_1 = require_assertResolversPresent();
    var merge_1 = require_cjs2();
    function makeExecutableSchema({ typeDefs, resolvers = {}, resolverValidationOptions = {}, inheritResolversFromInterfaces = false, updateResolversInPlace = false, schemaExtensions, ...otherOptions }) {
      if (typeof resolverValidationOptions !== "object") {
        throw new Error("Expected `resolverValidationOptions` to be an object");
      }
      if (!typeDefs) {
        throw new Error("Must provide typeDefs");
      }
      let schema;
      if ((0, graphql_1.isSchema)(typeDefs)) {
        schema = typeDefs;
      } else if (otherOptions === null || otherOptions === void 0 ? void 0 : otherOptions.commentDescriptions) {
        const mergedTypeDefs = (0, merge_1.mergeTypeDefs)(typeDefs, {
          ...otherOptions,
          commentDescriptions: true
        });
        schema = (0, graphql_1.buildSchema)(mergedTypeDefs, otherOptions);
      } else {
        const mergedTypeDefs = (0, merge_1.mergeTypeDefs)(typeDefs, otherOptions);
        schema = (0, graphql_1.buildASTSchema)(mergedTypeDefs, otherOptions);
      }
      schema = (0, addResolversToSchema_js_1.addResolversToSchema)({
        schema,
        resolvers: (0, merge_1.mergeResolvers)(resolvers),
        resolverValidationOptions,
        inheritResolversFromInterfaces,
        updateResolversInPlace
      });
      if (Object.keys(resolverValidationOptions).length > 0) {
        (0, assertResolversPresent_js_1.assertResolversPresent)(schema, resolverValidationOptions);
      }
      if (schemaExtensions) {
        schemaExtensions = (0, merge_1.mergeExtensions)((0, utils_1.asArray)(schemaExtensions));
        (0, merge_1.applyExtensions)(schema, schemaExtensions);
      }
      return schema;
    }
    exports2.makeExecutableSchema = makeExecutableSchema;
  }
});

// ../../../node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/types.js
var require_types3 = __commonJS({
  "../../../node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/types.js"() {
  }
});

// ../../../node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/merge-schemas.js
var require_merge_schemas = __commonJS({
  "../../../node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/merge-schemas.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeSchemas = void 0;
    var utils_1 = require_cjs();
    var makeExecutableSchema_js_1 = require_makeExecutableSchema();
    function mergeSchemas(config) {
      const extractedTypeDefs = [];
      const extractedResolvers = [];
      const extractedSchemaExtensions = [];
      if (config.schemas != null) {
        for (const schema of config.schemas) {
          extractedTypeDefs.push(schema);
          extractedResolvers.push((0, utils_1.getResolversFromSchema)(schema));
          extractedSchemaExtensions.push((0, utils_1.extractExtensionsFromSchema)(schema));
        }
      }
      if (config.typeDefs != null) {
        extractedTypeDefs.push(config.typeDefs);
      }
      if (config.resolvers != null) {
        const additionalResolvers = (0, utils_1.asArray)(config.resolvers);
        extractedResolvers.push(...additionalResolvers);
      }
      if (config.schemaExtensions != null) {
        const additionalSchemaExtensions = (0, utils_1.asArray)(config.schemaExtensions);
        extractedSchemaExtensions.push(...additionalSchemaExtensions);
      }
      return (0, makeExecutableSchema_js_1.makeExecutableSchema)({
        ...config,
        typeDefs: extractedTypeDefs,
        resolvers: extractedResolvers,
        schemaExtensions: extractedSchemaExtensions
      });
    }
    exports2.mergeSchemas = mergeSchemas;
  }
});

// ../../../node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/index.js
var require_cjs3 = __commonJS({
  "../../../node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.extractExtensionsFromSchema = exports2.extendResolversFromInterfaces = exports2.checkForResolveTypeResolver = exports2.addResolversToSchema = exports2.chainResolvers = exports2.assertResolversPresent = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var assertResolversPresent_js_1 = require_assertResolversPresent();
    Object.defineProperty(exports2, "assertResolversPresent", { enumerable: true, get: function() {
      return assertResolversPresent_js_1.assertResolversPresent;
    } });
    var chainResolvers_js_1 = require_chainResolvers();
    Object.defineProperty(exports2, "chainResolvers", { enumerable: true, get: function() {
      return chainResolvers_js_1.chainResolvers;
    } });
    var addResolversToSchema_js_1 = require_addResolversToSchema();
    Object.defineProperty(exports2, "addResolversToSchema", { enumerable: true, get: function() {
      return addResolversToSchema_js_1.addResolversToSchema;
    } });
    var checkForResolveTypeResolver_js_1 = require_checkForResolveTypeResolver();
    Object.defineProperty(exports2, "checkForResolveTypeResolver", { enumerable: true, get: function() {
      return checkForResolveTypeResolver_js_1.checkForResolveTypeResolver;
    } });
    var extendResolversFromInterfaces_js_1 = require_extendResolversFromInterfaces();
    Object.defineProperty(exports2, "extendResolversFromInterfaces", { enumerable: true, get: function() {
      return extendResolversFromInterfaces_js_1.extendResolversFromInterfaces;
    } });
    tslib_1.__exportStar(require_makeExecutableSchema(), exports2);
    tslib_1.__exportStar(require_types3(), exports2);
    tslib_1.__exportStar(require_merge_schemas(), exports2);
    var utils_1 = require_cjs();
    Object.defineProperty(exports2, "extractExtensionsFromSchema", { enumerable: true, get: function() {
      return utils_1.extractExtensionsFromSchema;
    } });
  }
});

// ../../../node_modules/@graphql-tools/mock/cjs/addMocksToSchema.js
var require_addMocksToSchema = __commonJS({
  "../../../node_modules/@graphql-tools/mock/cjs/addMocksToSchema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.addMocksToSchema = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var utils_1 = require_cjs();
    var schema_1 = require_cjs3();
    var types_js_1 = require_types();
    var utils_js_1 = require_utils2();
    var MockStore_js_1 = require_MockStore();
    function addMocksToSchema({ schema, store: maybeStore, mocks, typePolicies, resolvers: resolversOrFnResolvers, preserveResolvers = false }) {
      if (!schema) {
        throw new Error("Must provide schema to mock");
      }
      if (!(0, graphql_1.isSchema)(schema)) {
        throw new Error('Value at "schema" must be of type GraphQLSchema');
      }
      if (mocks && !(0, utils_js_1.isObject)(mocks)) {
        throw new Error("mocks must be of type Object");
      }
      const store = maybeStore || (0, MockStore_js_1.createMockStore)({
        schema,
        mocks,
        typePolicies
      });
      const resolvers = typeof resolversOrFnResolvers === "function" ? resolversOrFnResolvers(store) : resolversOrFnResolvers;
      const mockResolver = (source, args, contex, info) => {
        const defaultResolvedValue = (0, graphql_1.defaultFieldResolver)(source, args, contex, info);
        if (defaultResolvedValue !== void 0)
          return defaultResolvedValue;
        if ((0, types_js_1.isRef)(source)) {
          return store.get({
            typeName: source.$ref.typeName,
            key: source.$ref.key,
            fieldName: info.fieldName,
            fieldArgs: args
          });
        }
        if ((0, utils_js_1.isRootType)(info.parentType, info.schema)) {
          return store.get({
            typeName: info.parentType.name,
            key: "ROOT",
            fieldName: info.fieldName,
            fieldArgs: args
          });
        }
        if (defaultResolvedValue === void 0) {
          return store.generateFieldValue(info.parentType.name, info.fieldName);
        }
        return void 0;
      };
      const typeResolver = (data) => {
        if ((0, types_js_1.isRef)(data)) {
          return data.$ref.typeName;
        }
      };
      const mockSubscriber = () => ({
        [Symbol.asyncIterator]() {
          return {
            async next() {
              return {
                done: true,
                value: {}
              };
            }
          };
        }
      });
      const schemaWithMocks = (0, utils_1.mapSchema)(schema, {
        [utils_1.MapperKind.OBJECT_FIELD]: (fieldConfig) => {
          const newFieldConfig = {
            ...fieldConfig
          };
          const oldResolver = fieldConfig.resolve;
          if (!preserveResolvers || !oldResolver) {
            newFieldConfig.resolve = mockResolver;
          } else {
            newFieldConfig.resolve = async (rootObject, args, context, info) => {
              const [mockedValue, resolvedValue] = await Promise.all([
                mockResolver(rootObject, args, context, info),
                oldResolver(rootObject, args, context, info)
              ]);
              if (mockedValue instanceof Error) {
                if (void 0 === resolvedValue) {
                  throw mockedValue;
                }
                return resolvedValue;
              }
              if (resolvedValue instanceof Date && mockedValue instanceof Date) {
                return void 0 !== resolvedValue ? resolvedValue : mockedValue;
              }
              if ((0, utils_js_1.isObject)(mockedValue) && (0, utils_js_1.isObject)(resolvedValue)) {
                const emptyObject = Object.create(Object.getPrototypeOf(resolvedValue));
                return (0, utils_js_1.copyOwnProps)(emptyObject, resolvedValue, mockedValue);
              }
              return void 0 !== resolvedValue ? resolvedValue : mockedValue;
            };
          }
          const fieldSubscriber = fieldConfig.subscribe;
          if (!preserveResolvers || !fieldSubscriber) {
            newFieldConfig.subscribe = mockSubscriber;
          } else {
            newFieldConfig.subscribe = async (rootObject, args, context, info) => {
              const [mockAsyncIterable, oldAsyncIterable] = await Promise.all([
                mockSubscriber(rootObject, args, context, info),
                fieldSubscriber(rootObject, args, context, info)
              ]);
              return oldAsyncIterable || mockAsyncIterable;
            };
          }
          return newFieldConfig;
        },
        [utils_1.MapperKind.ABSTRACT_TYPE]: (type) => {
          if (preserveResolvers && type.resolveType != null && type.resolveType.length) {
            return;
          }
          if ((0, graphql_1.isUnionType)(type)) {
            return new graphql_1.GraphQLUnionType({
              ...type.toConfig(),
              resolveType: typeResolver
            });
          } else {
            return new graphql_1.GraphQLInterfaceType({
              ...type.toConfig(),
              resolveType: typeResolver
            });
          }
        }
      });
      return resolvers ? (0, schema_1.addResolversToSchema)({
        schema: schemaWithMocks,
        resolvers
      }) : schemaWithMocks;
    }
    exports2.addMocksToSchema = addMocksToSchema;
  }
});

// ../../../node_modules/@graphql-tools/mock/cjs/mockServer.js
var require_mockServer = __commonJS({
  "../../../node_modules/@graphql-tools/mock/cjs/mockServer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mockServer = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var schema_1 = require_cjs3();
    var addMocksToSchema_js_1 = require_addMocksToSchema();
    function mockServer(schema, mocks, preserveResolvers = false) {
      const mockedSchema = (0, addMocksToSchema_js_1.addMocksToSchema)({
        schema: (0, graphql_1.isSchema)(schema) ? schema : (0, schema_1.makeExecutableSchema)({
          typeDefs: schema
        }),
        mocks,
        preserveResolvers
      });
      return {
        query: (query, vars) => (0, graphql_1.graphql)({
          schema: mockedSchema,
          source: query,
          rootValue: {},
          contextValue: {},
          variableValues: vars
        })
      };
    }
    exports2.mockServer = mockServer;
  }
});

// ../../../node_modules/@graphql-tools/mock/cjs/pagination.js
var require_pagination = __commonJS({
  "../../../node_modules/@graphql-tools/mock/cjs/pagination.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.relayStylePaginationMock = void 0;
    var utils_js_1 = require_utils2();
    var relayStylePaginationMock = (store, { cursorFn = (node) => `${node.$ref.key}`, applyOnNodes, allNodesFn } = {}) => {
      return (parent, args, context, info) => {
        const source = (0, utils_js_1.isRootType)(info.parentType, info.schema) ? (0, utils_js_1.makeRef)(info.parentType.name, "ROOT") : parent;
        const allNodesFn_ = allNodesFn !== null && allNodesFn !== void 0 ? allNodesFn : defaultAllNodesFn(store);
        let allNodes = allNodesFn_(source, args, context, info);
        if (applyOnNodes) {
          allNodes = applyOnNodes(allNodes, args);
        }
        const allEdges = allNodes.map((node) => ({
          node,
          cursor: cursorFn(node)
        }));
        let start, end;
        const { first, after, last, before } = args;
        if (typeof first === "number") {
          if (last || before) {
            throw new Error("if `first` is provided, `last` or `before` can't be provided");
          }
          const afterIndex = after ? allEdges.findIndex((e) => e.cursor === after) : -1;
          start = afterIndex + 1;
          end = afterIndex + 1 + first;
        } else if (typeof last === "number") {
          if (first || after) {
            throw new Error("if `last` is provided, `first` or `after` can't be provided");
          }
          const foundBeforeIndex = before ? allEdges.findIndex((e) => e.cursor === before) : -1;
          const beforeIndex = foundBeforeIndex !== -1 ? foundBeforeIndex : allNodes.length;
          start = allEdges.length - (allEdges.length - beforeIndex) - last;
          if (start < 0)
            start = 0;
          end = beforeIndex;
        } else {
          throw new Error("A `first` or a `last` arguments should be provided");
        }
        const edges = allEdges.slice(start, end);
        const pageInfo = {
          startCursor: edges.length > 0 ? edges[0].cursor : "",
          endCursor: edges.length > 0 ? edges[edges.length - 1].cursor : "",
          hasNextPage: end < allEdges.length - 1,
          hasPreviousPage: start > 0
        };
        return {
          edges,
          pageInfo,
          totalCount: allEdges.length
        };
      };
    };
    exports2.relayStylePaginationMock = relayStylePaginationMock;
    var defaultAllNodesFn = (store) => (parent, _, __, info) => store.get(parent, [info.fieldName, "edges"]).map((e) => store.get(e, "node"));
  }
});

// ../../../node_modules/@graphql-tools/mock/cjs/index.js
var require_cjs4 = __commonJS({
  "../../../node_modules/@graphql-tools/mock/cjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_MockStore(), exports2);
    tslib_1.__exportStar(require_addMocksToSchema(), exports2);
    tslib_1.__exportStar(require_mockServer(), exports2);
    tslib_1.__exportStar(require_types(), exports2);
    tslib_1.__exportStar(require_MockList(), exports2);
    tslib_1.__exportStar(require_pagination(), exports2);
  }
});

// ../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/loaders.js
var require_loaders2 = __commonJS({
  "../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/loaders.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/helpers.js
var require_helpers2 = __commonJS({
  "../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/helpers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.assertSome = exports2.isSome = exports2.compareNodes = exports2.nodeToString = exports2.compareStrings = exports2.isValidPath = exports2.isDocumentString = exports2.asArray = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var asArray = (fns) => Array.isArray(fns) ? fns : fns ? [fns] : [];
    exports2.asArray = asArray;
    var invalidDocRegex = /\.[a-z0-9]+$/i;
    function isDocumentString(str) {
      if (typeof str !== "string") {
        return false;
      }
      if (invalidDocRegex.test(str)) {
        return false;
      }
      try {
        (0, graphql_1.parse)(str);
        return true;
      } catch (e) {
      }
      return false;
    }
    exports2.isDocumentString = isDocumentString;
    var invalidPathRegex = /[!%^<=>`]/;
    function isValidPath(str) {
      return typeof str === "string" && !invalidPathRegex.test(str);
    }
    exports2.isValidPath = isValidPath;
    function compareStrings(a, b) {
      if (String(a) < String(b)) {
        return -1;
      }
      if (String(a) > String(b)) {
        return 1;
      }
      return 0;
    }
    exports2.compareStrings = compareStrings;
    function nodeToString(a) {
      var _a, _b;
      let name;
      if ("alias" in a) {
        name = (_a = a.alias) === null || _a === void 0 ? void 0 : _a.value;
      }
      if (name == null && "name" in a) {
        name = (_b = a.name) === null || _b === void 0 ? void 0 : _b.value;
      }
      if (name == null) {
        name = a.kind;
      }
      return name;
    }
    exports2.nodeToString = nodeToString;
    function compareNodes(a, b, customFn) {
      const aStr = nodeToString(a);
      const bStr = nodeToString(b);
      if (typeof customFn === "function") {
        return customFn(aStr, bStr);
      }
      return compareStrings(aStr, bStr);
    }
    exports2.compareNodes = compareNodes;
    function isSome(input) {
      return input != null;
    }
    exports2.isSome = isSome;
    function assertSome(input, message = "Value should be something") {
      if (input == null) {
        throw new Error(message);
      }
    }
    exports2.assertSome = assertSome;
  }
});

// ../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/errors.js
var require_errors2 = __commonJS({
  "../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/errors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.relocatedError = exports2.createGraphQLError = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function createGraphQLError(message, options) {
      if (graphql_1.versionInfo.major >= 17) {
        return new graphql_1.GraphQLError(message, options);
      }
      return new graphql_1.GraphQLError(message, options === null || options === void 0 ? void 0 : options.nodes, options === null || options === void 0 ? void 0 : options.source, options === null || options === void 0 ? void 0 : options.positions, options === null || options === void 0 ? void 0 : options.path, options === null || options === void 0 ? void 0 : options.originalError, options === null || options === void 0 ? void 0 : options.extensions);
    }
    exports2.createGraphQLError = createGraphQLError;
    function relocatedError(originalError, path) {
      return createGraphQLError(originalError.message, {
        nodes: originalError.nodes,
        source: originalError.source,
        positions: originalError.positions,
        path: path == null ? originalError.path : path,
        originalError,
        extensions: originalError.extensions
      });
    }
    exports2.relocatedError = relocatedError;
  }
});

// ../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/AggregateError.js
var require_AggregateError2 = __commonJS({
  "../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/AggregateError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isAggregateError = exports2.AggregateError = void 0;
    var AggregateErrorImpl;
    exports2.AggregateError = AggregateErrorImpl;
    if (typeof AggregateError === "undefined") {
      class AggregateErrorClass extends Error {
        constructor(errors, message = "") {
          super(message);
          this.errors = errors;
          this.name = "AggregateError";
          Error.captureStackTrace(this, AggregateErrorClass);
        }
      }
      exports2.AggregateError = AggregateErrorImpl = function(errors, message) {
        return new AggregateErrorClass(errors, message);
      };
    } else {
      exports2.AggregateError = AggregateErrorImpl = AggregateError;
    }
    function isAggregateError(error) {
      return "errors" in error && Array.isArray(error["errors"]);
    }
    exports2.isAggregateError = isAggregateError;
  }
});

// ../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/inspect.js
var require_inspect2 = __commonJS({
  "../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/inspect.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.inspect = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var AggregateError_js_1 = require_AggregateError2();
    var MAX_RECURSIVE_DEPTH2 = 3;
    function inspect2(value) {
      return formatValue2(value, []);
    }
    exports2.inspect = inspect2;
    function formatValue2(value, seenValues) {
      switch (typeof value) {
        case "string":
          return JSON.stringify(value);
        case "function":
          return value.name ? `[function ${value.name}]` : "[function]";
        case "object":
          return formatObjectValue2(value, seenValues);
        default:
          return String(value);
      }
    }
    function formatError2(value) {
      if (value instanceof graphql_1.GraphQLError) {
        return value.toString();
      }
      return `${value.name}: ${value.message};
 ${value.stack}`;
    }
    function formatObjectValue2(value, previouslySeenValues) {
      if (value === null) {
        return "null";
      }
      if (value instanceof Error) {
        if ((0, AggregateError_js_1.isAggregateError)(value)) {
          return formatError2(value) + "\n" + formatArray2(value.errors, previouslySeenValues);
        }
        return formatError2(value);
      }
      if (previouslySeenValues.includes(value)) {
        return "[Circular]";
      }
      const seenValues = [...previouslySeenValues, value];
      if (isJSONable2(value)) {
        const jsonValue = value.toJSON();
        if (jsonValue !== value) {
          return typeof jsonValue === "string" ? jsonValue : formatValue2(jsonValue, seenValues);
        }
      } else if (Array.isArray(value)) {
        return formatArray2(value, seenValues);
      }
      return formatObject2(value, seenValues);
    }
    function isJSONable2(value) {
      return typeof value.toJSON === "function";
    }
    function formatObject2(object, seenValues) {
      const entries = Object.entries(object);
      if (entries.length === 0) {
        return "{}";
      }
      if (seenValues.length > MAX_RECURSIVE_DEPTH2) {
        return "[" + getObjectTag2(object) + "]";
      }
      const properties = entries.map(([key, value]) => key + ": " + formatValue2(value, seenValues));
      return "{ " + properties.join(", ") + " }";
    }
    function formatArray2(array, seenValues) {
      if (array.length === 0) {
        return "[]";
      }
      if (seenValues.length > MAX_RECURSIVE_DEPTH2) {
        return "[Array]";
      }
      const len = array.length;
      const remaining = array.length;
      const items = [];
      for (let i = 0; i < len; ++i) {
        items.push(formatValue2(array[i], seenValues));
      }
      if (remaining === 1) {
        items.push("... 1 more item");
      } else if (remaining > 1) {
        items.push(`... ${remaining} more items`);
      }
      return "[" + items.join(", ") + "]";
    }
    function getObjectTag2(object) {
      const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
      if (tag === "Object" && typeof object.constructor === "function") {
        const name = object.constructor.name;
        if (typeof name === "string" && name !== "") {
          return name;
        }
      }
      return tag;
    }
  }
});

// ../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/getArgumentValues.js
var require_getArgumentValues2 = __commonJS({
  "../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/getArgumentValues.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getArgumentValues = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var errors_js_1 = require_errors2();
    var inspect_js_1 = require_inspect2();
    function getArgumentValues2(def, node, variableValues = {}) {
      var _a;
      const variableMap = Object.entries(variableValues).reduce((prev, [key, value]) => ({
        ...prev,
        [key]: value
      }), {});
      const coercedValues = {};
      const argumentNodes = (_a = node.arguments) !== null && _a !== void 0 ? _a : [];
      const argNodeMap = argumentNodes.reduce((prev, arg) => ({
        ...prev,
        [arg.name.value]: arg
      }), {});
      for (const { name, type: argType, defaultValue } of def.args) {
        const argumentNode = argNodeMap[name];
        if (!argumentNode) {
          if (defaultValue !== void 0) {
            coercedValues[name] = defaultValue;
          } else if ((0, graphql_1.isNonNullType)(argType)) {
            throw (0, errors_js_1.createGraphQLError)(`Argument "${name}" of required type "${(0, inspect_js_1.inspect)(argType)}" was not provided.`, {
              nodes: [node]
            });
          }
          continue;
        }
        const valueNode = argumentNode.value;
        let isNull = valueNode.kind === graphql_1.Kind.NULL;
        if (valueNode.kind === graphql_1.Kind.VARIABLE) {
          const variableName = valueNode.name.value;
          if (variableValues == null || variableMap[variableName] == null) {
            if (defaultValue !== void 0) {
              coercedValues[name] = defaultValue;
            } else if ((0, graphql_1.isNonNullType)(argType)) {
              throw (0, errors_js_1.createGraphQLError)(`Argument "${name}" of required type "${(0, inspect_js_1.inspect)(argType)}" was provided the variable "$${variableName}" which was not provided a runtime value.`, {
                nodes: [valueNode]
              });
            }
            continue;
          }
          isNull = variableValues[variableName] == null;
        }
        if (isNull && (0, graphql_1.isNonNullType)(argType)) {
          throw (0, errors_js_1.createGraphQLError)(`Argument "${name}" of non-null type "${(0, inspect_js_1.inspect)(argType)}" must not be null.`, {
            nodes: [valueNode]
          });
        }
        const coercedValue = (0, graphql_1.valueFromAST)(valueNode, argType, variableValues);
        if (coercedValue === void 0) {
          throw (0, errors_js_1.createGraphQLError)(`Argument "${name}" has invalid value ${(0, graphql_1.print)(valueNode)}.`, {
            nodes: [valueNode]
          });
        }
        coercedValues[name] = coercedValue;
      }
      return coercedValues;
    }
    exports2.getArgumentValues = getArgumentValues2;
  }
});

// ../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/get-directives.js
var require_get_directives2 = __commonJS({
  "../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/get-directives.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getDirective = exports2.getDirectives = exports2.getDirectiveInExtensions = exports2.getDirectivesInExtensions = void 0;
    var getArgumentValues_js_1 = require_getArgumentValues2();
    function getDirectivesInExtensions(node, pathToDirectivesInExtensions = ["directives"]) {
      return pathToDirectivesInExtensions.reduce((acc, pathSegment) => acc == null ? acc : acc[pathSegment], node === null || node === void 0 ? void 0 : node.extensions);
    }
    exports2.getDirectivesInExtensions = getDirectivesInExtensions;
    function _getDirectiveInExtensions(directivesInExtensions, directiveName) {
      const directiveInExtensions = directivesInExtensions.filter((directiveAnnotation) => directiveAnnotation.name === directiveName);
      if (!directiveInExtensions.length) {
        return void 0;
      }
      return directiveInExtensions.map((directive) => {
        var _a;
        return (_a = directive.args) !== null && _a !== void 0 ? _a : {};
      });
    }
    function getDirectiveInExtensions(node, directiveName, pathToDirectivesInExtensions = ["directives"]) {
      const directivesInExtensions = pathToDirectivesInExtensions.reduce((acc, pathSegment) => acc == null ? acc : acc[pathSegment], node === null || node === void 0 ? void 0 : node.extensions);
      if (directivesInExtensions === void 0) {
        return void 0;
      }
      if (Array.isArray(directivesInExtensions)) {
        return _getDirectiveInExtensions(directivesInExtensions, directiveName);
      }
      const reformattedDirectivesInExtensions = [];
      for (const [name, argsOrArrayOfArgs] of Object.entries(directivesInExtensions)) {
        if (Array.isArray(argsOrArrayOfArgs)) {
          for (const args of argsOrArrayOfArgs) {
            reformattedDirectivesInExtensions.push({ name, args });
          }
        } else {
          reformattedDirectivesInExtensions.push({ name, args: argsOrArrayOfArgs });
        }
      }
      return _getDirectiveInExtensions(reformattedDirectivesInExtensions, directiveName);
    }
    exports2.getDirectiveInExtensions = getDirectiveInExtensions;
    function getDirectives(schema, node, pathToDirectivesInExtensions = ["directives"]) {
      const directivesInExtensions = getDirectivesInExtensions(node, pathToDirectivesInExtensions);
      if (directivesInExtensions != null && directivesInExtensions.length > 0) {
        return directivesInExtensions;
      }
      const schemaDirectives = schema && schema.getDirectives ? schema.getDirectives() : [];
      const schemaDirectiveMap = schemaDirectives.reduce((schemaDirectiveMap2, schemaDirective) => {
        schemaDirectiveMap2[schemaDirective.name] = schemaDirective;
        return schemaDirectiveMap2;
      }, {});
      let astNodes = [];
      if (node.astNode) {
        astNodes.push(node.astNode);
      }
      if ("extensionASTNodes" in node && node.extensionASTNodes) {
        astNodes = [...astNodes, ...node.extensionASTNodes];
      }
      const result = [];
      for (const astNode of astNodes) {
        if (astNode.directives) {
          for (const directiveNode of astNode.directives) {
            const schemaDirective = schemaDirectiveMap[directiveNode.name.value];
            if (schemaDirective) {
              result.push({ name: directiveNode.name.value, args: (0, getArgumentValues_js_1.getArgumentValues)(schemaDirective, directiveNode) });
            }
          }
        }
      }
      return result;
    }
    exports2.getDirectives = getDirectives;
    function getDirective(schema, node, directiveName, pathToDirectivesInExtensions = ["directives"]) {
      const directiveInExtensions = getDirectiveInExtensions(node, directiveName, pathToDirectivesInExtensions);
      if (directiveInExtensions != null) {
        return directiveInExtensions;
      }
      const schemaDirective = schema && schema.getDirective ? schema.getDirective(directiveName) : void 0;
      if (schemaDirective == null) {
        return void 0;
      }
      let astNodes = [];
      if (node.astNode) {
        astNodes.push(node.astNode);
      }
      if ("extensionASTNodes" in node && node.extensionASTNodes) {
        astNodes = [...astNodes, ...node.extensionASTNodes];
      }
      const result = [];
      for (const astNode of astNodes) {
        if (astNode.directives) {
          for (const directiveNode of astNode.directives) {
            if (directiveNode.name.value === directiveName) {
              result.push((0, getArgumentValues_js_1.getArgumentValues)(schemaDirective, directiveNode));
            }
          }
        }
      }
      if (!result.length) {
        return void 0;
      }
      return result;
    }
    exports2.getDirective = getDirective;
  }
});

// ../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/get-fields-with-directives.js
var require_get_fields_with_directives2 = __commonJS({
  "../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/get-fields-with-directives.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getFieldsWithDirectives = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function parseDirectiveValue(value) {
      switch (value.kind) {
        case graphql_1.Kind.INT:
          return parseInt(value.value);
        case graphql_1.Kind.FLOAT:
          return parseFloat(value.value);
        case graphql_1.Kind.BOOLEAN:
          return Boolean(value.value);
        case graphql_1.Kind.STRING:
        case graphql_1.Kind.ENUM:
          return value.value;
        case graphql_1.Kind.LIST:
          return value.values.map((v) => parseDirectiveValue(v));
        case graphql_1.Kind.OBJECT:
          return value.fields.reduce((prev, v) => ({ ...prev, [v.name.value]: parseDirectiveValue(v.value) }), {});
        case graphql_1.Kind.NULL:
          return null;
        default:
          return null;
      }
    }
    function getFieldsWithDirectives(documentNode, options = {}) {
      const result = {};
      let selected = ["ObjectTypeDefinition", "ObjectTypeExtension"];
      if (options.includeInputTypes) {
        selected = [...selected, "InputObjectTypeDefinition", "InputObjectTypeExtension"];
      }
      const allTypes = documentNode.definitions.filter((obj) => selected.includes(obj.kind));
      for (const type of allTypes) {
        const typeName = type.name.value;
        if (type.fields == null) {
          continue;
        }
        for (const field of type.fields) {
          if (field.directives && field.directives.length > 0) {
            const fieldName = field.name.value;
            const key = `${typeName}.${fieldName}`;
            const directives = field.directives.map((d) => ({
              name: d.name.value,
              args: (d.arguments || []).reduce((prev, arg) => ({ ...prev, [arg.name.value]: parseDirectiveValue(arg.value) }), {})
            }));
            result[key] = directives;
          }
        }
      }
      return result;
    }
    exports2.getFieldsWithDirectives = getFieldsWithDirectives;
  }
});

// ../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/get-implementing-types.js
var require_get_implementing_types2 = __commonJS({
  "../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/get-implementing-types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getImplementingTypes = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function getImplementingTypes(interfaceName, schema) {
      const allTypesMap = schema.getTypeMap();
      const result = [];
      for (const graphqlTypeName in allTypesMap) {
        const graphqlType = allTypesMap[graphqlTypeName];
        if ((0, graphql_1.isObjectType)(graphqlType)) {
          const allInterfaces = graphqlType.getInterfaces();
          if (allInterfaces.find((int) => int.name === interfaceName)) {
            result.push(graphqlType.name);
          }
        }
      }
      return result;
    }
    exports2.getImplementingTypes = getImplementingTypes;
  }
});

// ../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/astFromType.js
var require_astFromType2 = __commonJS({
  "../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/astFromType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.astFromType = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var inspect_js_1 = require_inspect2();
    function astFromType(type) {
      if ((0, graphql_1.isNonNullType)(type)) {
        const innerType = astFromType(type.ofType);
        if (innerType.kind === graphql_1.Kind.NON_NULL_TYPE) {
          throw new Error(`Invalid type node ${(0, inspect_js_1.inspect)(type)}. Inner type of non-null type cannot be a non-null type.`);
        }
        return {
          kind: graphql_1.Kind.NON_NULL_TYPE,
          type: innerType
        };
      } else if ((0, graphql_1.isListType)(type)) {
        return {
          kind: graphql_1.Kind.LIST_TYPE,
          type: astFromType(type.ofType)
        };
      }
      return {
        kind: graphql_1.Kind.NAMED_TYPE,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type.name
        }
      };
    }
    exports2.astFromType = astFromType;
  }
});

// ../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/astFromValueUntyped.js
var require_astFromValueUntyped2 = __commonJS({
  "../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/astFromValueUntyped.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.astFromValueUntyped = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function astFromValueUntyped(value) {
      if (value === null) {
        return { kind: graphql_1.Kind.NULL };
      }
      if (value === void 0) {
        return null;
      }
      if (Array.isArray(value)) {
        const valuesNodes = [];
        for (const item of value) {
          const itemNode = astFromValueUntyped(item);
          if (itemNode != null) {
            valuesNodes.push(itemNode);
          }
        }
        return { kind: graphql_1.Kind.LIST, values: valuesNodes };
      }
      if (typeof value === "object") {
        const fieldNodes = [];
        for (const fieldName in value) {
          const fieldValue = value[fieldName];
          const ast = astFromValueUntyped(fieldValue);
          if (ast) {
            fieldNodes.push({
              kind: graphql_1.Kind.OBJECT_FIELD,
              name: { kind: graphql_1.Kind.NAME, value: fieldName },
              value: ast
            });
          }
        }
        return { kind: graphql_1.Kind.OBJECT, fields: fieldNodes };
      }
      if (typeof value === "boolean") {
        return { kind: graphql_1.Kind.BOOLEAN, value };
      }
      if (typeof value === "number" && isFinite(value)) {
        const stringNum = String(value);
        return integerStringRegExp2.test(stringNum) ? { kind: graphql_1.Kind.INT, value: stringNum } : { kind: graphql_1.Kind.FLOAT, value: stringNum };
      }
      if (typeof value === "string") {
        return { kind: graphql_1.Kind.STRING, value };
      }
      throw new TypeError(`Cannot convert value to AST: ${value}.`);
    }
    exports2.astFromValueUntyped = astFromValueUntyped;
    var integerStringRegExp2 = /^-?(?:0|[1-9][0-9]*)$/;
  }
});

// ../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/memoize.js
var require_memoize2 = __commonJS({
  "../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/memoize.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.memoize2of4 = exports2.memoize5 = exports2.memoize4 = exports2.memoize3 = exports2.memoize2 = exports2.memoize1 = void 0;
    function memoize1(fn) {
      const memoize1cache = /* @__PURE__ */ new WeakMap();
      return function memoized(a1) {
        const cachedValue = memoize1cache.get(a1);
        if (cachedValue === void 0) {
          const newValue = fn(a1);
          memoize1cache.set(a1, newValue);
          return newValue;
        }
        return cachedValue;
      };
    }
    exports2.memoize1 = memoize1;
    function memoize2(fn) {
      const memoize2cache = /* @__PURE__ */ new WeakMap();
      return function memoized(a1, a2) {
        let cache2 = memoize2cache.get(a1);
        if (!cache2) {
          cache2 = /* @__PURE__ */ new WeakMap();
          memoize2cache.set(a1, cache2);
          const newValue = fn(a1, a2);
          cache2.set(a2, newValue);
          return newValue;
        }
        const cachedValue = cache2.get(a2);
        if (cachedValue === void 0) {
          const newValue = fn(a1, a2);
          cache2.set(a2, newValue);
          return newValue;
        }
        return cachedValue;
      };
    }
    exports2.memoize2 = memoize2;
    function memoize32(fn) {
      const memoize3Cache = /* @__PURE__ */ new WeakMap();
      return function memoized(a1, a2, a3) {
        let cache2 = memoize3Cache.get(a1);
        if (!cache2) {
          cache2 = /* @__PURE__ */ new WeakMap();
          memoize3Cache.set(a1, cache2);
          const cache32 = /* @__PURE__ */ new WeakMap();
          cache2.set(a2, cache32);
          const newValue = fn(a1, a2, a3);
          cache32.set(a3, newValue);
          return newValue;
        }
        let cache3 = cache2.get(a2);
        if (!cache3) {
          cache3 = /* @__PURE__ */ new WeakMap();
          cache2.set(a2, cache3);
          const newValue = fn(a1, a2, a3);
          cache3.set(a3, newValue);
          return newValue;
        }
        const cachedValue = cache3.get(a3);
        if (cachedValue === void 0) {
          const newValue = fn(a1, a2, a3);
          cache3.set(a3, newValue);
          return newValue;
        }
        return cachedValue;
      };
    }
    exports2.memoize3 = memoize32;
    function memoize4(fn) {
      const memoize4Cache = /* @__PURE__ */ new WeakMap();
      return function memoized(a1, a2, a3, a4) {
        let cache2 = memoize4Cache.get(a1);
        if (!cache2) {
          cache2 = /* @__PURE__ */ new WeakMap();
          memoize4Cache.set(a1, cache2);
          const cache32 = /* @__PURE__ */ new WeakMap();
          cache2.set(a2, cache32);
          const cache42 = /* @__PURE__ */ new WeakMap();
          cache32.set(a3, cache42);
          const newValue = fn(a1, a2, a3, a4);
          cache42.set(a4, newValue);
          return newValue;
        }
        let cache3 = cache2.get(a2);
        if (!cache3) {
          cache3 = /* @__PURE__ */ new WeakMap();
          cache2.set(a2, cache3);
          const cache42 = /* @__PURE__ */ new WeakMap();
          cache3.set(a3, cache42);
          const newValue = fn(a1, a2, a3, a4);
          cache42.set(a4, newValue);
          return newValue;
        }
        const cache4 = cache3.get(a3);
        if (!cache4) {
          const cache42 = /* @__PURE__ */ new WeakMap();
          cache3.set(a3, cache42);
          const newValue = fn(a1, a2, a3, a4);
          cache42.set(a4, newValue);
          return newValue;
        }
        const cachedValue = cache4.get(a4);
        if (cachedValue === void 0) {
          const newValue = fn(a1, a2, a3, a4);
          cache4.set(a4, newValue);
          return newValue;
        }
        return cachedValue;
      };
    }
    exports2.memoize4 = memoize4;
    function memoize5(fn) {
      const memoize5Cache = /* @__PURE__ */ new WeakMap();
      return function memoized(a1, a2, a3, a4, a5) {
        let cache2 = memoize5Cache.get(a1);
        if (!cache2) {
          cache2 = /* @__PURE__ */ new WeakMap();
          memoize5Cache.set(a1, cache2);
          const cache32 = /* @__PURE__ */ new WeakMap();
          cache2.set(a2, cache32);
          const cache42 = /* @__PURE__ */ new WeakMap();
          cache32.set(a3, cache42);
          const cache52 = /* @__PURE__ */ new WeakMap();
          cache42.set(a4, cache52);
          const newValue = fn(a1, a2, a3, a4, a5);
          cache52.set(a5, newValue);
          return newValue;
        }
        let cache3 = cache2.get(a2);
        if (!cache3) {
          cache3 = /* @__PURE__ */ new WeakMap();
          cache2.set(a2, cache3);
          const cache42 = /* @__PURE__ */ new WeakMap();
          cache3.set(a3, cache42);
          const cache52 = /* @__PURE__ */ new WeakMap();
          cache42.set(a4, cache52);
          const newValue = fn(a1, a2, a3, a4, a5);
          cache52.set(a5, newValue);
          return newValue;
        }
        let cache4 = cache3.get(a3);
        if (!cache4) {
          cache4 = /* @__PURE__ */ new WeakMap();
          cache3.set(a3, cache4);
          const cache52 = /* @__PURE__ */ new WeakMap();
          cache4.set(a4, cache52);
          const newValue = fn(a1, a2, a3, a4, a5);
          cache52.set(a5, newValue);
          return newValue;
        }
        let cache5 = cache4.get(a4);
        if (!cache5) {
          cache5 = /* @__PURE__ */ new WeakMap();
          cache4.set(a4, cache5);
          const newValue = fn(a1, a2, a3, a4, a5);
          cache5.set(a5, newValue);
          return newValue;
        }
        const cachedValue = cache5.get(a5);
        if (cachedValue === void 0) {
          const newValue = fn(a1, a2, a3, a4, a5);
          cache5.set(a5, newValue);
          return newValue;
        }
        return cachedValue;
      };
    }
    exports2.memoize5 = memoize5;
    var memoize2of4cache = /* @__PURE__ */ new WeakMap();
    function memoize2of4(fn) {
      return function memoized(a1, a2, a3, a4) {
        let cache2 = memoize2of4cache.get(a1);
        if (!cache2) {
          cache2 = /* @__PURE__ */ new WeakMap();
          memoize2of4cache.set(a1, cache2);
          const newValue = fn(a1, a2, a3, a4);
          cache2.set(a2, newValue);
          return newValue;
        }
        const cachedValue = cache2.get(a2);
        if (cachedValue === void 0) {
          const newValue = fn(a1, a2, a3, a4);
          cache2.set(a2, newValue);
          return newValue;
        }
        return cachedValue;
      };
    }
    exports2.memoize2of4 = memoize2of4;
  }
});

// ../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/rootTypes.js
var require_rootTypes2 = __commonJS({
  "../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/rootTypes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getRootTypeMap = exports2.getRootTypes = exports2.getRootTypeNames = exports2.getDefinedRootType = void 0;
    var memoize_js_1 = require_memoize2();
    function getDefinedRootType(schema, operation) {
      const rootTypeMap = (0, exports2.getRootTypeMap)(schema);
      const rootType = rootTypeMap.get(operation);
      if (rootType == null) {
        throw new Error(`Root type for operation "${operation}" not defined by the given schema.`);
      }
      return rootType;
    }
    exports2.getDefinedRootType = getDefinedRootType;
    exports2.getRootTypeNames = (0, memoize_js_1.memoize1)(function getRootTypeNames(schema) {
      const rootTypes = (0, exports2.getRootTypes)(schema);
      return new Set([...rootTypes].map((type) => type.name));
    });
    exports2.getRootTypes = (0, memoize_js_1.memoize1)(function getRootTypes(schema) {
      const rootTypeMap = (0, exports2.getRootTypeMap)(schema);
      return new Set(rootTypeMap.values());
    });
    exports2.getRootTypeMap = (0, memoize_js_1.memoize1)(function getRootTypeMap(schema) {
      const rootTypeMap = /* @__PURE__ */ new Map();
      const queryType = schema.getQueryType();
      if (queryType) {
        rootTypeMap.set("query", queryType);
      }
      const mutationType = schema.getMutationType();
      if (mutationType) {
        rootTypeMap.set("mutation", mutationType);
      }
      const subscriptionType = schema.getSubscriptionType();
      if (subscriptionType) {
        rootTypeMap.set("subscription", subscriptionType);
      }
      return rootTypeMap;
    });
  }
});

// ../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/print-schema-with-directives.js
var require_print_schema_with_directives2 = __commonJS({
  "../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/print-schema-with-directives.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.makeDirectiveNodes = exports2.makeDirectiveNode = exports2.makeDeprecatedDirective = exports2.astFromEnumValue = exports2.astFromInputField = exports2.astFromField = exports2.astFromScalarType = exports2.astFromEnumType = exports2.astFromInputObjectType = exports2.astFromUnionType = exports2.astFromInterfaceType = exports2.astFromObjectType = exports2.astFromArg = exports2.getDeprecatableDirectiveNodes = exports2.getDirectiveNodes = exports2.astFromDirective = exports2.astFromSchema = exports2.printSchemaWithDirectives = exports2.getDocumentNodeFromSchema = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var astFromType_js_1 = require_astFromType2();
    var get_directives_js_1 = require_get_directives2();
    var astFromValueUntyped_js_1 = require_astFromValueUntyped2();
    var helpers_js_1 = require_helpers2();
    var rootTypes_js_1 = require_rootTypes2();
    function getDocumentNodeFromSchema(schema, options = {}) {
      const pathToDirectivesInExtensions = options.pathToDirectivesInExtensions;
      const typesMap = schema.getTypeMap();
      const schemaNode = astFromSchema(schema, pathToDirectivesInExtensions);
      const definitions = schemaNode != null ? [schemaNode] : [];
      const directives = schema.getDirectives();
      for (const directive of directives) {
        if ((0, graphql_1.isSpecifiedDirective)(directive)) {
          continue;
        }
        definitions.push(astFromDirective(directive, schema, pathToDirectivesInExtensions));
      }
      for (const typeName in typesMap) {
        const type = typesMap[typeName];
        const isPredefinedScalar = (0, graphql_1.isSpecifiedScalarType)(type);
        const isIntrospection = (0, graphql_1.isIntrospectionType)(type);
        if (isPredefinedScalar || isIntrospection) {
          continue;
        }
        if ((0, graphql_1.isObjectType)(type)) {
          definitions.push(astFromObjectType(type, schema, pathToDirectivesInExtensions));
        } else if ((0, graphql_1.isInterfaceType)(type)) {
          definitions.push(astFromInterfaceType(type, schema, pathToDirectivesInExtensions));
        } else if ((0, graphql_1.isUnionType)(type)) {
          definitions.push(astFromUnionType(type, schema, pathToDirectivesInExtensions));
        } else if ((0, graphql_1.isInputObjectType)(type)) {
          definitions.push(astFromInputObjectType(type, schema, pathToDirectivesInExtensions));
        } else if ((0, graphql_1.isEnumType)(type)) {
          definitions.push(astFromEnumType(type, schema, pathToDirectivesInExtensions));
        } else if ((0, graphql_1.isScalarType)(type)) {
          definitions.push(astFromScalarType(type, schema, pathToDirectivesInExtensions));
        } else {
          throw new Error(`Unknown type ${type}.`);
        }
      }
      return {
        kind: graphql_1.Kind.DOCUMENT,
        definitions
      };
    }
    exports2.getDocumentNodeFromSchema = getDocumentNodeFromSchema;
    function printSchemaWithDirectives(schema, options = {}) {
      const documentNode = getDocumentNodeFromSchema(schema, options);
      return (0, graphql_1.print)(documentNode);
    }
    exports2.printSchemaWithDirectives = printSchemaWithDirectives;
    function astFromSchema(schema, pathToDirectivesInExtensions) {
      var _a, _b;
      const operationTypeMap = /* @__PURE__ */ new Map([
        ["query", void 0],
        ["mutation", void 0],
        ["subscription", void 0]
      ]);
      const nodes = [];
      if (schema.astNode != null) {
        nodes.push(schema.astNode);
      }
      if (schema.extensionASTNodes != null) {
        for (const extensionASTNode of schema.extensionASTNodes) {
          nodes.push(extensionASTNode);
        }
      }
      for (const node of nodes) {
        if (node.operationTypes) {
          for (const operationTypeDefinitionNode of node.operationTypes) {
            operationTypeMap.set(operationTypeDefinitionNode.operation, operationTypeDefinitionNode);
          }
        }
      }
      const rootTypeMap = (0, rootTypes_js_1.getRootTypeMap)(schema);
      for (const [operationTypeNode, operationTypeDefinitionNode] of operationTypeMap) {
        const rootType = rootTypeMap.get(operationTypeNode);
        if (rootType != null) {
          const rootTypeAST = (0, astFromType_js_1.astFromType)(rootType);
          if (operationTypeDefinitionNode != null) {
            operationTypeDefinitionNode.type = rootTypeAST;
          } else {
            operationTypeMap.set(operationTypeNode, {
              kind: graphql_1.Kind.OPERATION_TYPE_DEFINITION,
              operation: operationTypeNode,
              type: rootTypeAST
            });
          }
        }
      }
      const operationTypes = [...operationTypeMap.values()].filter(helpers_js_1.isSome);
      const directives = getDirectiveNodes(schema, schema, pathToDirectivesInExtensions);
      if (!operationTypes.length && !directives.length) {
        return null;
      }
      const schemaNode = {
        kind: operationTypes != null ? graphql_1.Kind.SCHEMA_DEFINITION : graphql_1.Kind.SCHEMA_EXTENSION,
        operationTypes,
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives
      };
      schemaNode.description = ((_b = (_a = schema.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : schema.description != null) ? {
        kind: graphql_1.Kind.STRING,
        value: schema.description,
        block: true
      } : void 0;
      return schemaNode;
    }
    exports2.astFromSchema = astFromSchema;
    function astFromDirective(directive, schema, pathToDirectivesInExtensions) {
      var _a, _b, _c, _d;
      return {
        kind: graphql_1.Kind.DIRECTIVE_DEFINITION,
        description: (_b = (_a = directive.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : directive.description ? {
          kind: graphql_1.Kind.STRING,
          value: directive.description
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: directive.name
        },
        arguments: (_c = directive.args) === null || _c === void 0 ? void 0 : _c.map((arg) => astFromArg(arg, schema, pathToDirectivesInExtensions)),
        repeatable: directive.isRepeatable,
        locations: ((_d = directive.locations) === null || _d === void 0 ? void 0 : _d.map((location) => ({
          kind: graphql_1.Kind.NAME,
          value: location
        }))) || []
      };
    }
    exports2.astFromDirective = astFromDirective;
    function getDirectiveNodes(entity, schema, pathToDirectivesInExtensions) {
      const directivesInExtensions = (0, get_directives_js_1.getDirectivesInExtensions)(entity, pathToDirectivesInExtensions);
      let nodes = [];
      if (entity.astNode != null) {
        nodes.push(entity.astNode);
      }
      if ("extensionASTNodes" in entity && entity.extensionASTNodes != null) {
        nodes = nodes.concat(entity.extensionASTNodes);
      }
      let directives;
      if (directivesInExtensions != null) {
        directives = makeDirectiveNodes(schema, directivesInExtensions);
      } else {
        directives = [];
        for (const node of nodes) {
          if (node.directives) {
            directives.push(...node.directives);
          }
        }
      }
      return directives;
    }
    exports2.getDirectiveNodes = getDirectiveNodes;
    function getDeprecatableDirectiveNodes(entity, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      let directiveNodesBesidesDeprecated = [];
      let deprecatedDirectiveNode = null;
      const directivesInExtensions = (0, get_directives_js_1.getDirectivesInExtensions)(entity, pathToDirectivesInExtensions);
      let directives;
      if (directivesInExtensions != null) {
        directives = makeDirectiveNodes(schema, directivesInExtensions);
      } else {
        directives = (_a = entity.astNode) === null || _a === void 0 ? void 0 : _a.directives;
      }
      if (directives != null) {
        directiveNodesBesidesDeprecated = directives.filter((directive) => directive.name.value !== "deprecated");
        if (entity.deprecationReason != null) {
          deprecatedDirectiveNode = (_b = directives.filter((directive) => directive.name.value === "deprecated")) === null || _b === void 0 ? void 0 : _b[0];
        }
      }
      if (entity.deprecationReason != null && deprecatedDirectiveNode == null) {
        deprecatedDirectiveNode = makeDeprecatedDirective(entity.deprecationReason);
      }
      return deprecatedDirectiveNode == null ? directiveNodesBesidesDeprecated : [deprecatedDirectiveNode].concat(directiveNodesBesidesDeprecated);
    }
    exports2.getDeprecatableDirectiveNodes = getDeprecatableDirectiveNodes;
    function astFromArg(arg, schema, pathToDirectivesInExtensions) {
      var _a, _b, _c;
      return {
        kind: graphql_1.Kind.INPUT_VALUE_DEFINITION,
        description: (_b = (_a = arg.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : arg.description ? {
          kind: graphql_1.Kind.STRING,
          value: arg.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: arg.name
        },
        type: (0, astFromType_js_1.astFromType)(arg.type),
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        defaultValue: arg.defaultValue !== void 0 ? (_c = (0, graphql_1.astFromValue)(arg.defaultValue, arg.type)) !== null && _c !== void 0 ? _c : void 0 : void 0,
        directives: getDeprecatableDirectiveNodes(arg, schema, pathToDirectivesInExtensions)
      };
    }
    exports2.astFromArg = astFromArg;
    function astFromObjectType(type, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      return {
        kind: graphql_1.Kind.OBJECT_TYPE_DEFINITION,
        description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description ? {
          kind: graphql_1.Kind.STRING,
          value: type.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type.name
        },
        fields: Object.values(type.getFields()).map((field) => astFromField(field, schema, pathToDirectivesInExtensions)),
        interfaces: Object.values(type.getInterfaces()).map((iFace) => (0, astFromType_js_1.astFromType)(iFace)),
        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)
      };
    }
    exports2.astFromObjectType = astFromObjectType;
    function astFromInterfaceType(type, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      const node = {
        kind: graphql_1.Kind.INTERFACE_TYPE_DEFINITION,
        description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description ? {
          kind: graphql_1.Kind.STRING,
          value: type.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type.name
        },
        fields: Object.values(type.getFields()).map((field) => astFromField(field, schema, pathToDirectivesInExtensions)),
        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)
      };
      if ("getInterfaces" in type) {
        node.interfaces = Object.values(type.getInterfaces()).map((iFace) => (0, astFromType_js_1.astFromType)(iFace));
      }
      return node;
    }
    exports2.astFromInterfaceType = astFromInterfaceType;
    function astFromUnionType(type, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      return {
        kind: graphql_1.Kind.UNION_TYPE_DEFINITION,
        description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description ? {
          kind: graphql_1.Kind.STRING,
          value: type.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type.name
        },
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions),
        types: type.getTypes().map((type2) => (0, astFromType_js_1.astFromType)(type2))
      };
    }
    exports2.astFromUnionType = astFromUnionType;
    function astFromInputObjectType(type, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      return {
        kind: graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION,
        description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description ? {
          kind: graphql_1.Kind.STRING,
          value: type.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type.name
        },
        fields: Object.values(type.getFields()).map((field) => astFromInputField(field, schema, pathToDirectivesInExtensions)),
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)
      };
    }
    exports2.astFromInputObjectType = astFromInputObjectType;
    function astFromEnumType(type, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      return {
        kind: graphql_1.Kind.ENUM_TYPE_DEFINITION,
        description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description ? {
          kind: graphql_1.Kind.STRING,
          value: type.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type.name
        },
        values: Object.values(type.getValues()).map((value) => astFromEnumValue(value, schema, pathToDirectivesInExtensions)),
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)
      };
    }
    exports2.astFromEnumType = astFromEnumType;
    function astFromScalarType(type, schema, pathToDirectivesInExtensions) {
      var _a, _b, _c;
      const directivesInExtensions = (0, get_directives_js_1.getDirectivesInExtensions)(type, pathToDirectivesInExtensions);
      const directives = directivesInExtensions ? makeDirectiveNodes(schema, directivesInExtensions) : ((_a = type.astNode) === null || _a === void 0 ? void 0 : _a.directives) || [];
      const specifiedByValue = type["specifiedByUrl"] || type["specifiedByURL"];
      if (specifiedByValue && !directives.some((directiveNode) => directiveNode.name.value === "specifiedBy")) {
        const specifiedByArgs = {
          url: specifiedByValue
        };
        directives.push(makeDirectiveNode("specifiedBy", specifiedByArgs));
      }
      return {
        kind: graphql_1.Kind.SCALAR_TYPE_DEFINITION,
        description: (_c = (_b = type.astNode) === null || _b === void 0 ? void 0 : _b.description) !== null && _c !== void 0 ? _c : type.description ? {
          kind: graphql_1.Kind.STRING,
          value: type.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type.name
        },
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives
      };
    }
    exports2.astFromScalarType = astFromScalarType;
    function astFromField(field, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      return {
        kind: graphql_1.Kind.FIELD_DEFINITION,
        description: (_b = (_a = field.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : field.description ? {
          kind: graphql_1.Kind.STRING,
          value: field.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: field.name
        },
        arguments: field.args.map((arg) => astFromArg(arg, schema, pathToDirectivesInExtensions)),
        type: (0, astFromType_js_1.astFromType)(field.type),
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: getDeprecatableDirectiveNodes(field, schema, pathToDirectivesInExtensions)
      };
    }
    exports2.astFromField = astFromField;
    function astFromInputField(field, schema, pathToDirectivesInExtensions) {
      var _a, _b, _c;
      return {
        kind: graphql_1.Kind.INPUT_VALUE_DEFINITION,
        description: (_b = (_a = field.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : field.description ? {
          kind: graphql_1.Kind.STRING,
          value: field.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: field.name
        },
        type: (0, astFromType_js_1.astFromType)(field.type),
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: getDeprecatableDirectiveNodes(field, schema, pathToDirectivesInExtensions),
        defaultValue: (_c = (0, graphql_1.astFromValue)(field.defaultValue, field.type)) !== null && _c !== void 0 ? _c : void 0
      };
    }
    exports2.astFromInputField = astFromInputField;
    function astFromEnumValue(value, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      return {
        kind: graphql_1.Kind.ENUM_VALUE_DEFINITION,
        description: (_b = (_a = value.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : value.description ? {
          kind: graphql_1.Kind.STRING,
          value: value.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: value.name
        },
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: getDeprecatableDirectiveNodes(value, schema, pathToDirectivesInExtensions)
      };
    }
    exports2.astFromEnumValue = astFromEnumValue;
    function makeDeprecatedDirective(deprecationReason) {
      return makeDirectiveNode("deprecated", { reason: deprecationReason }, graphql_1.GraphQLDeprecatedDirective);
    }
    exports2.makeDeprecatedDirective = makeDeprecatedDirective;
    function makeDirectiveNode(name, args, directive) {
      const directiveArguments = [];
      if (directive != null) {
        for (const arg of directive.args) {
          const argName = arg.name;
          const argValue = args[argName];
          if (argValue !== void 0) {
            const value = (0, graphql_1.astFromValue)(argValue, arg.type);
            if (value) {
              directiveArguments.push({
                kind: graphql_1.Kind.ARGUMENT,
                name: {
                  kind: graphql_1.Kind.NAME,
                  value: argName
                },
                value
              });
            }
          }
        }
      } else {
        for (const argName in args) {
          const argValue = args[argName];
          const value = (0, astFromValueUntyped_js_1.astFromValueUntyped)(argValue);
          if (value) {
            directiveArguments.push({
              kind: graphql_1.Kind.ARGUMENT,
              name: {
                kind: graphql_1.Kind.NAME,
                value: argName
              },
              value
            });
          }
        }
      }
      return {
        kind: graphql_1.Kind.DIRECTIVE,
        name: {
          kind: graphql_1.Kind.NAME,
          value: name
        },
        arguments: directiveArguments
      };
    }
    exports2.makeDirectiveNode = makeDirectiveNode;
    function makeDirectiveNodes(schema, directiveValues) {
      const directiveNodes = [];
      for (const directiveName in directiveValues) {
        const arrayOrSingleValue = directiveValues[directiveName];
        const directive = schema === null || schema === void 0 ? void 0 : schema.getDirective(directiveName);
        if (Array.isArray(arrayOrSingleValue)) {
          for (const value of arrayOrSingleValue) {
            directiveNodes.push(makeDirectiveNode(directiveName, value, directive));
          }
        } else {
          directiveNodes.push(makeDirectiveNode(directiveName, arrayOrSingleValue, directive));
        }
      }
      return directiveNodes;
    }
    exports2.makeDirectiveNodes = makeDirectiveNodes;
  }
});

// ../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/validate-documents.js
var require_validate_documents2 = __commonJS({
  "../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/validate-documents.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createDefaultRules = exports2.checkValidationErrors = exports2.validateGraphQlDocuments = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var AggregateError_js_1 = require_AggregateError2();
    async function validateGraphQlDocuments(schema, documentFiles, effectiveRules = createDefaultRules()) {
      const allFragmentMap = /* @__PURE__ */ new Map();
      const documentFileObjectsToValidate = [];
      for (const documentFile of documentFiles) {
        if (documentFile.document) {
          const definitionsToValidate = [];
          for (const definitionNode of documentFile.document.definitions) {
            if (definitionNode.kind === graphql_1.Kind.FRAGMENT_DEFINITION) {
              allFragmentMap.set(definitionNode.name.value, definitionNode);
            } else {
              definitionsToValidate.push(definitionNode);
            }
          }
          documentFileObjectsToValidate.push({
            location: documentFile.location,
            document: {
              kind: graphql_1.Kind.DOCUMENT,
              definitions: definitionsToValidate
            }
          });
        }
      }
      const allErrors = [];
      const allFragmentsDocument = {
        kind: graphql_1.Kind.DOCUMENT,
        definitions: [...allFragmentMap.values()]
      };
      await Promise.all(documentFileObjectsToValidate.map(async (documentFile) => {
        const documentToValidate = (0, graphql_1.concatAST)([allFragmentsDocument, documentFile.document]);
        const errors = (0, graphql_1.validate)(schema, documentToValidate, effectiveRules);
        if (errors.length > 0) {
          allErrors.push({
            filePath: documentFile.location,
            errors
          });
        }
      }));
      return allErrors;
    }
    exports2.validateGraphQlDocuments = validateGraphQlDocuments;
    function checkValidationErrors(loadDocumentErrors) {
      if (loadDocumentErrors.length > 0) {
        const errors = [];
        for (const loadDocumentError of loadDocumentErrors) {
          for (const graphQLError of loadDocumentError.errors) {
            const error = new Error();
            error.name = "GraphQLDocumentError";
            error.message = `${error.name}: ${graphQLError.message}`;
            error.stack = error.message;
            if (graphQLError.locations) {
              for (const location of graphQLError.locations) {
                error.stack += `
    at ${loadDocumentError.filePath}:${location.line}:${location.column}`;
              }
            }
            errors.push(error);
          }
        }
        throw new AggregateError_js_1.AggregateError(errors, `GraphQL Document Validation failed with ${errors.length} errors;
  ${errors.map((error, index) => `Error ${index}: ${error.stack}`).join("\n\n")}`);
      }
    }
    exports2.checkValidationErrors = checkValidationErrors;
    function createDefaultRules() {
      let ignored = ["NoUnusedFragmentsRule", "NoUnusedVariablesRule", "KnownDirectivesRule"];
      if (graphql_1.versionInfo.major < 15) {
        ignored = ignored.map((rule) => rule.replace(/Rule$/, ""));
      }
      return graphql_1.specifiedRules.filter((f) => !ignored.includes(f.name));
    }
    exports2.createDefaultRules = createDefaultRules;
  }
});

// ../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/parse-graphql-json.js
var require_parse_graphql_json2 = __commonJS({
  "../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/parse-graphql-json.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseGraphQLJSON = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function stripBOM(content) {
      content = content.toString();
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    }
    function parseBOM(content) {
      return JSON.parse(stripBOM(content));
    }
    function parseGraphQLJSON(location, jsonContent, options) {
      let parsedJson = parseBOM(jsonContent);
      if (parsedJson.data) {
        parsedJson = parsedJson.data;
      }
      if (parsedJson.kind === "Document") {
        return {
          location,
          document: parsedJson
        };
      } else if (parsedJson.__schema) {
        const schema = (0, graphql_1.buildClientSchema)(parsedJson, options);
        return {
          location,
          schema
        };
      } else if (typeof parsedJson === "string") {
        return {
          location,
          rawSDL: parsedJson
        };
      }
      throw new Error(`Not valid JSON content`);
    }
    exports2.parseGraphQLJSON = parseGraphQLJSON;
  }
});

// ../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/comments.js
var require_comments2 = __commonJS({
  "../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/comments.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getBlockStringIndentation = exports2.dedentBlockStringValue = exports2.getLeadingCommentBlock = exports2.getComment = exports2.getDescription = exports2.printWithComments = exports2.printComment = exports2.pushComment = exports2.collectComment = exports2.resetComments = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var MAX_LINE_LENGTH2 = 80;
    var commentsRegistry = {};
    function resetComments() {
      commentsRegistry = {};
    }
    exports2.resetComments = resetComments;
    function collectComment(node) {
      var _a;
      const entityName = (_a = node.name) === null || _a === void 0 ? void 0 : _a.value;
      if (entityName == null) {
        return;
      }
      pushComment(node, entityName);
      switch (node.kind) {
        case "EnumTypeDefinition":
          if (node.values) {
            for (const value of node.values) {
              pushComment(value, entityName, value.name.value);
            }
          }
          break;
        case "ObjectTypeDefinition":
        case "InputObjectTypeDefinition":
        case "InterfaceTypeDefinition":
          if (node.fields) {
            for (const field of node.fields) {
              pushComment(field, entityName, field.name.value);
              if (isFieldDefinitionNode(field) && field.arguments) {
                for (const arg of field.arguments) {
                  pushComment(arg, entityName, field.name.value, arg.name.value);
                }
              }
            }
          }
          break;
      }
    }
    exports2.collectComment = collectComment;
    function pushComment(node, entity, field, argument) {
      const comment = getComment(node);
      if (typeof comment !== "string" || comment.length === 0) {
        return;
      }
      const keys = [entity];
      if (field) {
        keys.push(field);
        if (argument) {
          keys.push(argument);
        }
      }
      const path = keys.join(".");
      if (!commentsRegistry[path]) {
        commentsRegistry[path] = [];
      }
      commentsRegistry[path].push(comment);
    }
    exports2.pushComment = pushComment;
    function printComment(comment) {
      return "\n# " + comment.replace(/\n/g, "\n# ");
    }
    exports2.printComment = printComment;
    function join2(maybeArray, separator) {
      return maybeArray ? maybeArray.filter((x) => x).join(separator || "") : "";
    }
    function hasMultilineItems2(maybeArray) {
      var _a;
      return (_a = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes("\n"))) !== null && _a !== void 0 ? _a : false;
    }
    function addDescription(cb) {
      return (node, _key, _parent, path, ancestors) => {
        var _a;
        const keys = [];
        const parent = path.reduce((prev, key2) => {
          if (["fields", "arguments", "values"].includes(key2) && prev.name) {
            keys.push(prev.name.value);
          }
          return prev[key2];
        }, ancestors[0]);
        const key = [...keys, (_a = parent === null || parent === void 0 ? void 0 : parent.name) === null || _a === void 0 ? void 0 : _a.value].filter(Boolean).join(".");
        const items = [];
        if (node.kind.includes("Definition") && commentsRegistry[key]) {
          items.push(...commentsRegistry[key]);
        }
        return join2([...items.map(printComment), node.description, cb(node, _key, _parent, path, ancestors)], "\n");
      };
    }
    function indent2(maybeString) {
      return maybeString && `  ${maybeString.replace(/\n/g, "\n  ")}`;
    }
    function block2(array) {
      return array && array.length !== 0 ? `{
${indent2(join2(array, "\n"))}
}` : "";
    }
    function wrap2(start, maybeString, end) {
      return maybeString ? start + maybeString + (end || "") : "";
    }
    function printBlockString2(value, isDescription = false) {
      const escaped = value.replace(/"""/g, '\\"""');
      return (value[0] === " " || value[0] === "	") && value.indexOf("\n") === -1 ? `"""${escaped.replace(/"$/, '"\n')}"""` : `"""
${isDescription ? escaped : indent2(escaped)}
"""`;
    }
    var printDocASTReducer2 = {
      Name: { leave: (node) => node.value },
      Variable: { leave: (node) => "$" + node.name },
      // Document
      Document: {
        leave: (node) => join2(node.definitions, "\n\n")
      },
      OperationDefinition: {
        leave: (node) => {
          const varDefs = wrap2("(", join2(node.variableDefinitions, ", "), ")");
          const prefix = join2([node.operation, join2([node.name, varDefs]), join2(node.directives, " ")], " ");
          return prefix + " " + node.selectionSet;
        }
      },
      VariableDefinition: {
        leave: ({ variable, type, defaultValue, directives }) => variable + ": " + type + wrap2(" = ", defaultValue) + wrap2(" ", join2(directives, " "))
      },
      SelectionSet: { leave: ({ selections }) => block2(selections) },
      Field: {
        leave({ alias, name, arguments: args, directives, selectionSet }) {
          const prefix = wrap2("", alias, ": ") + name;
          let argsLine = prefix + wrap2("(", join2(args, ", "), ")");
          if (argsLine.length > MAX_LINE_LENGTH2) {
            argsLine = prefix + wrap2("(\n", indent2(join2(args, "\n")), "\n)");
          }
          return join2([argsLine, join2(directives, " "), selectionSet], " ");
        }
      },
      Argument: { leave: ({ name, value }) => name + ": " + value },
      // Fragments
      FragmentSpread: {
        leave: ({ name, directives }) => "..." + name + wrap2(" ", join2(directives, " "))
      },
      InlineFragment: {
        leave: ({ typeCondition, directives, selectionSet }) => join2(["...", wrap2("on ", typeCondition), join2(directives, " "), selectionSet], " ")
      },
      FragmentDefinition: {
        leave: ({ name, typeCondition, variableDefinitions, directives, selectionSet }) => (
          // Note: fragment variable definitions are experimental and may be changed
          // or removed in the future.
          `fragment ${name}${wrap2("(", join2(variableDefinitions, ", "), ")")} on ${typeCondition} ${wrap2("", join2(directives, " "), " ")}` + selectionSet
        )
      },
      // Value
      IntValue: { leave: ({ value }) => value },
      FloatValue: { leave: ({ value }) => value },
      StringValue: {
        leave: ({ value, block: isBlockString }) => {
          if (isBlockString) {
            return printBlockString2(value);
          }
          return JSON.stringify(value);
        }
      },
      BooleanValue: { leave: ({ value }) => value ? "true" : "false" },
      NullValue: { leave: () => "null" },
      EnumValue: { leave: ({ value }) => value },
      ListValue: { leave: ({ values }) => "[" + join2(values, ", ") + "]" },
      ObjectValue: { leave: ({ fields }) => "{" + join2(fields, ", ") + "}" },
      ObjectField: { leave: ({ name, value }) => name + ": " + value },
      // Directive
      Directive: {
        leave: ({ name, arguments: args }) => "@" + name + wrap2("(", join2(args, ", "), ")")
      },
      // Type
      NamedType: { leave: ({ name }) => name },
      ListType: { leave: ({ type }) => "[" + type + "]" },
      NonNullType: { leave: ({ type }) => type + "!" },
      // Type System Definitions
      SchemaDefinition: {
        leave: ({ directives, operationTypes }) => join2(["schema", join2(directives, " "), block2(operationTypes)], " ")
      },
      OperationTypeDefinition: {
        leave: ({ operation, type }) => operation + ": " + type
      },
      ScalarTypeDefinition: {
        leave: ({ name, directives }) => join2(["scalar", name, join2(directives, " ")], " ")
      },
      ObjectTypeDefinition: {
        leave: ({ name, interfaces, directives, fields }) => join2(["type", name, wrap2("implements ", join2(interfaces, " & ")), join2(directives, " "), block2(fields)], " ")
      },
      FieldDefinition: {
        leave: ({ name, arguments: args, type, directives }) => name + (hasMultilineItems2(args) ? wrap2("(\n", indent2(join2(args, "\n")), "\n)") : wrap2("(", join2(args, ", "), ")")) + ": " + type + wrap2(" ", join2(directives, " "))
      },
      InputValueDefinition: {
        leave: ({ name, type, defaultValue, directives }) => join2([name + ": " + type, wrap2("= ", defaultValue), join2(directives, " ")], " ")
      },
      InterfaceTypeDefinition: {
        leave: ({ name, interfaces, directives, fields }) => join2(["interface", name, wrap2("implements ", join2(interfaces, " & ")), join2(directives, " "), block2(fields)], " ")
      },
      UnionTypeDefinition: {
        leave: ({ name, directives, types }) => join2(["union", name, join2(directives, " "), wrap2("= ", join2(types, " | "))], " ")
      },
      EnumTypeDefinition: {
        leave: ({ name, directives, values }) => join2(["enum", name, join2(directives, " "), block2(values)], " ")
      },
      EnumValueDefinition: {
        leave: ({ name, directives }) => join2([name, join2(directives, " ")], " ")
      },
      InputObjectTypeDefinition: {
        leave: ({ name, directives, fields }) => join2(["input", name, join2(directives, " "), block2(fields)], " ")
      },
      DirectiveDefinition: {
        leave: ({ name, arguments: args, repeatable, locations }) => "directive @" + name + (hasMultilineItems2(args) ? wrap2("(\n", indent2(join2(args, "\n")), "\n)") : wrap2("(", join2(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join2(locations, " | ")
      },
      SchemaExtension: {
        leave: ({ directives, operationTypes }) => join2(["extend schema", join2(directives, " "), block2(operationTypes)], " ")
      },
      ScalarTypeExtension: {
        leave: ({ name, directives }) => join2(["extend scalar", name, join2(directives, " ")], " ")
      },
      ObjectTypeExtension: {
        leave: ({ name, interfaces, directives, fields }) => join2(["extend type", name, wrap2("implements ", join2(interfaces, " & ")), join2(directives, " "), block2(fields)], " ")
      },
      InterfaceTypeExtension: {
        leave: ({ name, interfaces, directives, fields }) => join2(["extend interface", name, wrap2("implements ", join2(interfaces, " & ")), join2(directives, " "), block2(fields)], " ")
      },
      UnionTypeExtension: {
        leave: ({ name, directives, types }) => join2(["extend union", name, join2(directives, " "), wrap2("= ", join2(types, " | "))], " ")
      },
      EnumTypeExtension: {
        leave: ({ name, directives, values }) => join2(["extend enum", name, join2(directives, " "), block2(values)], " ")
      },
      InputObjectTypeExtension: {
        leave: ({ name, directives, fields }) => join2(["extend input", name, join2(directives, " "), block2(fields)], " ")
      }
    };
    var printDocASTReducerWithComments = Object.keys(printDocASTReducer2).reduce((prev, key) => ({
      ...prev,
      [key]: {
        leave: addDescription(printDocASTReducer2[key].leave)
      }
    }), {});
    function printWithComments(ast) {
      return (0, graphql_1.visit)(ast, printDocASTReducerWithComments);
    }
    exports2.printWithComments = printWithComments;
    function isFieldDefinitionNode(node) {
      return node.kind === "FieldDefinition";
    }
    function getDescription(node, options) {
      if (node.description != null) {
        return node.description.value;
      }
      if (options === null || options === void 0 ? void 0 : options.commentDescriptions) {
        return getComment(node);
      }
    }
    exports2.getDescription = getDescription;
    function getComment(node) {
      const rawValue = getLeadingCommentBlock(node);
      if (rawValue !== void 0) {
        return dedentBlockStringValue(`
${rawValue}`);
      }
    }
    exports2.getComment = getComment;
    function getLeadingCommentBlock(node) {
      const loc = node.loc;
      if (!loc) {
        return;
      }
      const comments = [];
      let token = loc.startToken.prev;
      while (token != null && token.kind === graphql_1.TokenKind.COMMENT && token.next != null && token.prev != null && token.line + 1 === token.next.line && token.line !== token.prev.line) {
        const value = String(token.value);
        comments.push(value);
        token = token.prev;
      }
      return comments.length > 0 ? comments.reverse().join("\n") : void 0;
    }
    exports2.getLeadingCommentBlock = getLeadingCommentBlock;
    function dedentBlockStringValue(rawString) {
      const lines = rawString.split(/\r\n|[\n\r]/g);
      const commonIndent = getBlockStringIndentation(lines);
      if (commonIndent !== 0) {
        for (let i = 1; i < lines.length; i++) {
          lines[i] = lines[i].slice(commonIndent);
        }
      }
      while (lines.length > 0 && isBlank(lines[0])) {
        lines.shift();
      }
      while (lines.length > 0 && isBlank(lines[lines.length - 1])) {
        lines.pop();
      }
      return lines.join("\n");
    }
    exports2.dedentBlockStringValue = dedentBlockStringValue;
    function getBlockStringIndentation(lines) {
      let commonIndent = null;
      for (let i = 1; i < lines.length; i++) {
        const line = lines[i];
        const indent3 = leadingWhitespace2(line);
        if (indent3 === line.length) {
          continue;
        }
        if (commonIndent === null || indent3 < commonIndent) {
          commonIndent = indent3;
          if (commonIndent === 0) {
            break;
          }
        }
      }
      return commonIndent === null ? 0 : commonIndent;
    }
    exports2.getBlockStringIndentation = getBlockStringIndentation;
    function leadingWhitespace2(str) {
      let i = 0;
      while (i < str.length && (str[i] === " " || str[i] === "	")) {
        i++;
      }
      return i;
    }
    function isBlank(str) {
      return leadingWhitespace2(str) === str.length;
    }
  }
});

// ../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/parse-graphql-sdl.js
var require_parse_graphql_sdl2 = __commonJS({
  "../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/parse-graphql-sdl.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isDescribable = exports2.transformCommentsToDescriptions = exports2.parseGraphQLSDL = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var comments_js_1 = require_comments2();
    function parseGraphQLSDL(location, rawSDL, options = {}) {
      let document2;
      try {
        if (options.commentDescriptions && rawSDL.includes("#")) {
          document2 = transformCommentsToDescriptions(rawSDL, options);
          if (options.noLocation) {
            document2 = (0, graphql_1.parse)((0, graphql_1.print)(document2), options);
          }
        } else {
          document2 = (0, graphql_1.parse)(new graphql_1.Source(rawSDL, location), options);
        }
      } catch (e) {
        if (e.message.includes("EOF") && rawSDL.replace(/(\#[^*]*)/g, "").trim() === "") {
          document2 = {
            kind: graphql_1.Kind.DOCUMENT,
            definitions: []
          };
        } else {
          throw e;
        }
      }
      return {
        location,
        document: document2
      };
    }
    exports2.parseGraphQLSDL = parseGraphQLSDL;
    function transformCommentsToDescriptions(sourceSdl, options = {}) {
      const parsedDoc = (0, graphql_1.parse)(sourceSdl, {
        ...options,
        noLocation: false
      });
      const modifiedDoc = (0, graphql_1.visit)(parsedDoc, {
        leave: (node) => {
          if (isDescribable(node)) {
            const rawValue = (0, comments_js_1.getLeadingCommentBlock)(node);
            if (rawValue !== void 0) {
              const commentsBlock = (0, comments_js_1.dedentBlockStringValue)("\n" + rawValue);
              const isBlock = commentsBlock.includes("\n");
              if (!node.description) {
                return {
                  ...node,
                  description: {
                    kind: graphql_1.Kind.STRING,
                    value: commentsBlock,
                    block: isBlock
                  }
                };
              } else {
                return {
                  ...node,
                  description: {
                    ...node.description,
                    value: node.description.value + "\n" + commentsBlock,
                    block: true
                  }
                };
              }
            }
          }
        }
      });
      return modifiedDoc;
    }
    exports2.transformCommentsToDescriptions = transformCommentsToDescriptions;
    function isDescribable(node) {
      return (0, graphql_1.isTypeSystemDefinitionNode)(node) || node.kind === graphql_1.Kind.FIELD_DEFINITION || node.kind === graphql_1.Kind.INPUT_VALUE_DEFINITION || node.kind === graphql_1.Kind.ENUM_VALUE_DEFINITION;
    }
    exports2.isDescribable = isDescribable;
  }
});

// ../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/build-operation-for-field.js
var require_build_operation_for_field2 = __commonJS({
  "../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/build-operation-for-field.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.buildOperationNodeForField = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var rootTypes_js_1 = require_rootTypes2();
    var operationVariables = [];
    var fieldTypeMap = /* @__PURE__ */ new Map();
    function addOperationVariable(variable) {
      operationVariables.push(variable);
    }
    function resetOperationVariables() {
      operationVariables = [];
    }
    function resetFieldMap() {
      fieldTypeMap = /* @__PURE__ */ new Map();
    }
    function buildOperationNodeForField({ schema, kind, field, models, ignore = [], depthLimit, circularReferenceDepth, argNames, selectedFields = true }) {
      resetOperationVariables();
      resetFieldMap();
      const rootTypeNames = (0, rootTypes_js_1.getRootTypeNames)(schema);
      const operationNode = buildOperationAndCollectVariables({
        schema,
        fieldName: field,
        kind,
        models: models || [],
        ignore,
        depthLimit: depthLimit || Infinity,
        circularReferenceDepth: circularReferenceDepth || 1,
        argNames,
        selectedFields,
        rootTypeNames
      });
      operationNode.variableDefinitions = [...operationVariables];
      resetOperationVariables();
      resetFieldMap();
      return operationNode;
    }
    exports2.buildOperationNodeForField = buildOperationNodeForField;
    function buildOperationAndCollectVariables({ schema, fieldName, kind, models, ignore, depthLimit, circularReferenceDepth, argNames, selectedFields, rootTypeNames }) {
      const type = (0, rootTypes_js_1.getDefinedRootType)(schema, kind);
      const field = type.getFields()[fieldName];
      const operationName = `${fieldName}_${kind}`;
      if (field.args) {
        for (const arg of field.args) {
          const argName = arg.name;
          if (!argNames || argNames.includes(argName)) {
            addOperationVariable(resolveVariable(arg, argName));
          }
        }
      }
      return {
        kind: graphql_1.Kind.OPERATION_DEFINITION,
        operation: kind,
        name: {
          kind: graphql_1.Kind.NAME,
          value: operationName
        },
        variableDefinitions: [],
        selectionSet: {
          kind: graphql_1.Kind.SELECTION_SET,
          selections: [
            resolveField({
              type,
              field,
              models,
              firstCall: true,
              path: [],
              ancestors: [],
              ignore,
              depthLimit,
              circularReferenceDepth,
              schema,
              depth: 0,
              argNames,
              selectedFields,
              rootTypeNames
            })
          ]
        }
      };
    }
    function resolveSelectionSet({ parent, type, models, firstCall, path, ancestors, ignore, depthLimit, circularReferenceDepth, schema, depth, argNames, selectedFields, rootTypeNames }) {
      if (typeof selectedFields === "boolean" && depth > depthLimit) {
        return;
      }
      if ((0, graphql_1.isUnionType)(type)) {
        const types = type.getTypes();
        return {
          kind: graphql_1.Kind.SELECTION_SET,
          selections: types.filter((t) => !hasCircularRef([...ancestors, t], {
            depth: circularReferenceDepth
          })).map((t) => {
            return {
              kind: graphql_1.Kind.INLINE_FRAGMENT,
              typeCondition: {
                kind: graphql_1.Kind.NAMED_TYPE,
                name: {
                  kind: graphql_1.Kind.NAME,
                  value: t.name
                }
              },
              selectionSet: resolveSelectionSet({
                parent: type,
                type: t,
                models,
                path,
                ancestors,
                ignore,
                depthLimit,
                circularReferenceDepth,
                schema,
                depth,
                argNames,
                selectedFields,
                rootTypeNames
              })
            };
          }).filter((fragmentNode) => {
            var _a, _b;
            return ((_b = (_a = fragmentNode === null || fragmentNode === void 0 ? void 0 : fragmentNode.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length) > 0;
          })
        };
      }
      if ((0, graphql_1.isInterfaceType)(type)) {
        const types = Object.values(schema.getTypeMap()).filter((t) => (0, graphql_1.isObjectType)(t) && t.getInterfaces().includes(type));
        return {
          kind: graphql_1.Kind.SELECTION_SET,
          selections: types.filter((t) => !hasCircularRef([...ancestors, t], {
            depth: circularReferenceDepth
          })).map((t) => {
            return {
              kind: graphql_1.Kind.INLINE_FRAGMENT,
              typeCondition: {
                kind: graphql_1.Kind.NAMED_TYPE,
                name: {
                  kind: graphql_1.Kind.NAME,
                  value: t.name
                }
              },
              selectionSet: resolveSelectionSet({
                parent: type,
                type: t,
                models,
                path,
                ancestors,
                ignore,
                depthLimit,
                circularReferenceDepth,
                schema,
                depth,
                argNames,
                selectedFields,
                rootTypeNames
              })
            };
          }).filter((fragmentNode) => {
            var _a, _b;
            return ((_b = (_a = fragmentNode === null || fragmentNode === void 0 ? void 0 : fragmentNode.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length) > 0;
          })
        };
      }
      if ((0, graphql_1.isObjectType)(type) && !rootTypeNames.has(type.name)) {
        const isIgnored = ignore.includes(type.name) || ignore.includes(`${parent.name}.${path[path.length - 1]}`);
        const isModel = models.includes(type.name);
        if (!firstCall && isModel && !isIgnored) {
          return {
            kind: graphql_1.Kind.SELECTION_SET,
            selections: [
              {
                kind: graphql_1.Kind.FIELD,
                name: {
                  kind: graphql_1.Kind.NAME,
                  value: "id"
                }
              }
            ]
          };
        }
        const fields = type.getFields();
        return {
          kind: graphql_1.Kind.SELECTION_SET,
          selections: Object.keys(fields).filter((fieldName) => {
            return !hasCircularRef([...ancestors, (0, graphql_1.getNamedType)(fields[fieldName].type)], {
              depth: circularReferenceDepth
            });
          }).map((fieldName) => {
            const selectedSubFields = typeof selectedFields === "object" ? selectedFields[fieldName] : true;
            if (selectedSubFields) {
              return resolveField({
                type,
                field: fields[fieldName],
                models,
                path: [...path, fieldName],
                ancestors,
                ignore,
                depthLimit,
                circularReferenceDepth,
                schema,
                depth,
                argNames,
                selectedFields: selectedSubFields,
                rootTypeNames
              });
            }
            return null;
          }).filter((f) => {
            var _a, _b;
            if (f == null) {
              return false;
            } else if ("selectionSet" in f) {
              return !!((_b = (_a = f.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length);
            }
            return true;
          })
        };
      }
    }
    function resolveVariable(arg, name) {
      function resolveVariableType(type) {
        if ((0, graphql_1.isListType)(type)) {
          return {
            kind: graphql_1.Kind.LIST_TYPE,
            type: resolveVariableType(type.ofType)
          };
        }
        if ((0, graphql_1.isNonNullType)(type)) {
          return {
            kind: graphql_1.Kind.NON_NULL_TYPE,
            // for v16 compatibility
            type: resolveVariableType(type.ofType)
          };
        }
        return {
          kind: graphql_1.Kind.NAMED_TYPE,
          name: {
            kind: graphql_1.Kind.NAME,
            value: type.name
          }
        };
      }
      return {
        kind: graphql_1.Kind.VARIABLE_DEFINITION,
        variable: {
          kind: graphql_1.Kind.VARIABLE,
          name: {
            kind: graphql_1.Kind.NAME,
            value: name || arg.name
          }
        },
        type: resolveVariableType(arg.type)
      };
    }
    function getArgumentName(name, path) {
      return [...path, name].join("_");
    }
    function resolveField({ type, field, models, firstCall, path, ancestors, ignore, depthLimit, circularReferenceDepth, schema, depth, argNames, selectedFields, rootTypeNames }) {
      const namedType = (0, graphql_1.getNamedType)(field.type);
      let args = [];
      let removeField = false;
      if (field.args && field.args.length) {
        args = field.args.map((arg) => {
          const argumentName = getArgumentName(arg.name, path);
          if (argNames && !argNames.includes(argumentName)) {
            if ((0, graphql_1.isNonNullType)(arg.type)) {
              removeField = true;
            }
            return null;
          }
          if (!firstCall) {
            addOperationVariable(resolveVariable(arg, argumentName));
          }
          return {
            kind: graphql_1.Kind.ARGUMENT,
            name: {
              kind: graphql_1.Kind.NAME,
              value: arg.name
            },
            value: {
              kind: graphql_1.Kind.VARIABLE,
              name: {
                kind: graphql_1.Kind.NAME,
                value: getArgumentName(arg.name, path)
              }
            }
          };
        }).filter(Boolean);
      }
      if (removeField) {
        return null;
      }
      const fieldPath = [...path, field.name];
      const fieldPathStr = fieldPath.join(".");
      let fieldName = field.name;
      if (fieldTypeMap.has(fieldPathStr) && fieldTypeMap.get(fieldPathStr) !== field.type.toString()) {
        fieldName += field.type.toString().replace("!", "NonNull");
      }
      fieldTypeMap.set(fieldPathStr, field.type.toString());
      if (!(0, graphql_1.isScalarType)(namedType) && !(0, graphql_1.isEnumType)(namedType)) {
        return {
          kind: graphql_1.Kind.FIELD,
          name: {
            kind: graphql_1.Kind.NAME,
            value: field.name
          },
          ...fieldName !== field.name && { alias: { kind: graphql_1.Kind.NAME, value: fieldName } },
          selectionSet: resolveSelectionSet({
            parent: type,
            type: namedType,
            models,
            firstCall,
            path: fieldPath,
            ancestors: [...ancestors, type],
            ignore,
            depthLimit,
            circularReferenceDepth,
            schema,
            depth: depth + 1,
            argNames,
            selectedFields,
            rootTypeNames
          }) || void 0,
          arguments: args
        };
      }
      return {
        kind: graphql_1.Kind.FIELD,
        name: {
          kind: graphql_1.Kind.NAME,
          value: field.name
        },
        ...fieldName !== field.name && { alias: { kind: graphql_1.Kind.NAME, value: fieldName } },
        arguments: args
      };
    }
    function hasCircularRef(types, config = {
      depth: 1
    }) {
      const type = types[types.length - 1];
      if ((0, graphql_1.isScalarType)(type)) {
        return false;
      }
      const size = types.filter((t) => t.name === type.name).length;
      return size > config.depth;
    }
  }
});

// ../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/types.js
var require_types4 = __commonJS({
  "../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DirectiveLocation = void 0;
    var DirectiveLocation2;
    (function(DirectiveLocation3) {
      DirectiveLocation3["QUERY"] = "QUERY";
      DirectiveLocation3["MUTATION"] = "MUTATION";
      DirectiveLocation3["SUBSCRIPTION"] = "SUBSCRIPTION";
      DirectiveLocation3["FIELD"] = "FIELD";
      DirectiveLocation3["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
      DirectiveLocation3["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
      DirectiveLocation3["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
      DirectiveLocation3["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
      DirectiveLocation3["SCHEMA"] = "SCHEMA";
      DirectiveLocation3["SCALAR"] = "SCALAR";
      DirectiveLocation3["OBJECT"] = "OBJECT";
      DirectiveLocation3["FIELD_DEFINITION"] = "FIELD_DEFINITION";
      DirectiveLocation3["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
      DirectiveLocation3["INTERFACE"] = "INTERFACE";
      DirectiveLocation3["UNION"] = "UNION";
      DirectiveLocation3["ENUM"] = "ENUM";
      DirectiveLocation3["ENUM_VALUE"] = "ENUM_VALUE";
      DirectiveLocation3["INPUT_OBJECT"] = "INPUT_OBJECT";
      DirectiveLocation3["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
    })(DirectiveLocation2 = exports2.DirectiveLocation || (exports2.DirectiveLocation = {}));
  }
});

// ../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/Interfaces.js
var require_Interfaces2 = __commonJS({
  "../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/Interfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MapperKind = void 0;
    var MapperKind;
    (function(MapperKind2) {
      MapperKind2["TYPE"] = "MapperKind.TYPE";
      MapperKind2["SCALAR_TYPE"] = "MapperKind.SCALAR_TYPE";
      MapperKind2["ENUM_TYPE"] = "MapperKind.ENUM_TYPE";
      MapperKind2["COMPOSITE_TYPE"] = "MapperKind.COMPOSITE_TYPE";
      MapperKind2["OBJECT_TYPE"] = "MapperKind.OBJECT_TYPE";
      MapperKind2["INPUT_OBJECT_TYPE"] = "MapperKind.INPUT_OBJECT_TYPE";
      MapperKind2["ABSTRACT_TYPE"] = "MapperKind.ABSTRACT_TYPE";
      MapperKind2["UNION_TYPE"] = "MapperKind.UNION_TYPE";
      MapperKind2["INTERFACE_TYPE"] = "MapperKind.INTERFACE_TYPE";
      MapperKind2["ROOT_OBJECT"] = "MapperKind.ROOT_OBJECT";
      MapperKind2["QUERY"] = "MapperKind.QUERY";
      MapperKind2["MUTATION"] = "MapperKind.MUTATION";
      MapperKind2["SUBSCRIPTION"] = "MapperKind.SUBSCRIPTION";
      MapperKind2["DIRECTIVE"] = "MapperKind.DIRECTIVE";
      MapperKind2["FIELD"] = "MapperKind.FIELD";
      MapperKind2["COMPOSITE_FIELD"] = "MapperKind.COMPOSITE_FIELD";
      MapperKind2["OBJECT_FIELD"] = "MapperKind.OBJECT_FIELD";
      MapperKind2["ROOT_FIELD"] = "MapperKind.ROOT_FIELD";
      MapperKind2["QUERY_ROOT_FIELD"] = "MapperKind.QUERY_ROOT_FIELD";
      MapperKind2["MUTATION_ROOT_FIELD"] = "MapperKind.MUTATION_ROOT_FIELD";
      MapperKind2["SUBSCRIPTION_ROOT_FIELD"] = "MapperKind.SUBSCRIPTION_ROOT_FIELD";
      MapperKind2["INTERFACE_FIELD"] = "MapperKind.INTERFACE_FIELD";
      MapperKind2["INPUT_OBJECT_FIELD"] = "MapperKind.INPUT_OBJECT_FIELD";
      MapperKind2["ARGUMENT"] = "MapperKind.ARGUMENT";
      MapperKind2["ENUM_VALUE"] = "MapperKind.ENUM_VALUE";
    })(MapperKind = exports2.MapperKind || (exports2.MapperKind = {}));
  }
});

// ../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/getObjectTypeFromTypeMap.js
var require_getObjectTypeFromTypeMap2 = __commonJS({
  "../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/getObjectTypeFromTypeMap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getObjectTypeFromTypeMap = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function getObjectTypeFromTypeMap(typeMap, type) {
      if (type) {
        const maybeObjectType = typeMap[type.name];
        if ((0, graphql_1.isObjectType)(maybeObjectType)) {
          return maybeObjectType;
        }
      }
    }
    exports2.getObjectTypeFromTypeMap = getObjectTypeFromTypeMap;
  }
});

// ../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/stub.js
var require_stub2 = __commonJS({
  "../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/stub.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getBuiltInForStub = exports2.isNamedStub = exports2.createStub = exports2.createNamedStub = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function createNamedStub(name, type) {
      let constructor;
      if (type === "object") {
        constructor = graphql_1.GraphQLObjectType;
      } else if (type === "interface") {
        constructor = graphql_1.GraphQLInterfaceType;
      } else {
        constructor = graphql_1.GraphQLInputObjectType;
      }
      return new constructor({
        name,
        fields: {
          _fake: {
            type: graphql_1.GraphQLString
          }
        }
      });
    }
    exports2.createNamedStub = createNamedStub;
    function createStub(node, type) {
      switch (node.kind) {
        case graphql_1.Kind.LIST_TYPE:
          return new graphql_1.GraphQLList(createStub(node.type, type));
        case graphql_1.Kind.NON_NULL_TYPE:
          return new graphql_1.GraphQLNonNull(createStub(node.type, type));
        default:
          if (type === "output") {
            return createNamedStub(node.name.value, "object");
          }
          return createNamedStub(node.name.value, "input");
      }
    }
    exports2.createStub = createStub;
    function isNamedStub(type) {
      if ("getFields" in type) {
        const fields = type.getFields();
        for (const fieldName in fields) {
          const field = fields[fieldName];
          return field.name === "_fake";
        }
      }
      return false;
    }
    exports2.isNamedStub = isNamedStub;
    function getBuiltInForStub(type) {
      switch (type.name) {
        case graphql_1.GraphQLInt.name:
          return graphql_1.GraphQLInt;
        case graphql_1.GraphQLFloat.name:
          return graphql_1.GraphQLFloat;
        case graphql_1.GraphQLString.name:
          return graphql_1.GraphQLString;
        case graphql_1.GraphQLBoolean.name:
          return graphql_1.GraphQLBoolean;
        case graphql_1.GraphQLID.name:
          return graphql_1.GraphQLID;
        default:
          return type;
      }
    }
    exports2.getBuiltInForStub = getBuiltInForStub;
  }
});

// ../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/rewire.js
var require_rewire2 = __commonJS({
  "../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/rewire.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.rewireTypes = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var stub_js_1 = require_stub2();
    function rewireTypes(originalTypeMap, directives) {
      const referenceTypeMap = /* @__PURE__ */ Object.create(null);
      for (const typeName in originalTypeMap) {
        referenceTypeMap[typeName] = originalTypeMap[typeName];
      }
      const newTypeMap = /* @__PURE__ */ Object.create(null);
      for (const typeName in referenceTypeMap) {
        const namedType = referenceTypeMap[typeName];
        if (namedType == null || typeName.startsWith("__")) {
          continue;
        }
        const newName = namedType.name;
        if (newName.startsWith("__")) {
          continue;
        }
        if (newTypeMap[newName] != null) {
          throw new Error(`Duplicate schema type name ${newName}`);
        }
        newTypeMap[newName] = namedType;
      }
      for (const typeName in newTypeMap) {
        newTypeMap[typeName] = rewireNamedType(newTypeMap[typeName]);
      }
      const newDirectives = directives.map((directive) => rewireDirective(directive));
      return {
        typeMap: newTypeMap,
        directives: newDirectives
      };
      function rewireDirective(directive) {
        if ((0, graphql_1.isSpecifiedDirective)(directive)) {
          return directive;
        }
        const directiveConfig = directive.toConfig();
        directiveConfig.args = rewireArgs(directiveConfig.args);
        return new graphql_1.GraphQLDirective(directiveConfig);
      }
      function rewireArgs(args) {
        const rewiredArgs = {};
        for (const argName in args) {
          const arg = args[argName];
          const rewiredArgType = rewireType(arg.type);
          if (rewiredArgType != null) {
            arg.type = rewiredArgType;
            rewiredArgs[argName] = arg;
          }
        }
        return rewiredArgs;
      }
      function rewireNamedType(type) {
        if ((0, graphql_1.isObjectType)(type)) {
          const config = type.toConfig();
          const newConfig = {
            ...config,
            fields: () => rewireFields(config.fields),
            interfaces: () => rewireNamedTypes(config.interfaces)
          };
          return new graphql_1.GraphQLObjectType(newConfig);
        } else if ((0, graphql_1.isInterfaceType)(type)) {
          const config = type.toConfig();
          const newConfig = {
            ...config,
            fields: () => rewireFields(config.fields)
          };
          if ("interfaces" in newConfig) {
            newConfig.interfaces = () => rewireNamedTypes(config.interfaces);
          }
          return new graphql_1.GraphQLInterfaceType(newConfig);
        } else if ((0, graphql_1.isUnionType)(type)) {
          const config = type.toConfig();
          const newConfig = {
            ...config,
            types: () => rewireNamedTypes(config.types)
          };
          return new graphql_1.GraphQLUnionType(newConfig);
        } else if ((0, graphql_1.isInputObjectType)(type)) {
          const config = type.toConfig();
          const newConfig = {
            ...config,
            fields: () => rewireInputFields(config.fields)
          };
          return new graphql_1.GraphQLInputObjectType(newConfig);
        } else if ((0, graphql_1.isEnumType)(type)) {
          const enumConfig = type.toConfig();
          return new graphql_1.GraphQLEnumType(enumConfig);
        } else if ((0, graphql_1.isScalarType)(type)) {
          if ((0, graphql_1.isSpecifiedScalarType)(type)) {
            return type;
          }
          const scalarConfig = type.toConfig();
          return new graphql_1.GraphQLScalarType(scalarConfig);
        }
        throw new Error(`Unexpected schema type: ${type}`);
      }
      function rewireFields(fields) {
        const rewiredFields = {};
        for (const fieldName in fields) {
          const field = fields[fieldName];
          const rewiredFieldType = rewireType(field.type);
          if (rewiredFieldType != null && field.args) {
            field.type = rewiredFieldType;
            field.args = rewireArgs(field.args);
            rewiredFields[fieldName] = field;
          }
        }
        return rewiredFields;
      }
      function rewireInputFields(fields) {
        const rewiredFields = {};
        for (const fieldName in fields) {
          const field = fields[fieldName];
          const rewiredFieldType = rewireType(field.type);
          if (rewiredFieldType != null) {
            field.type = rewiredFieldType;
            rewiredFields[fieldName] = field;
          }
        }
        return rewiredFields;
      }
      function rewireNamedTypes(namedTypes) {
        const rewiredTypes = [];
        for (const namedType of namedTypes) {
          const rewiredType = rewireType(namedType);
          if (rewiredType != null) {
            rewiredTypes.push(rewiredType);
          }
        }
        return rewiredTypes;
      }
      function rewireType(type) {
        if ((0, graphql_1.isListType)(type)) {
          const rewiredType = rewireType(type.ofType);
          return rewiredType != null ? new graphql_1.GraphQLList(rewiredType) : null;
        } else if ((0, graphql_1.isNonNullType)(type)) {
          const rewiredType = rewireType(type.ofType);
          return rewiredType != null ? new graphql_1.GraphQLNonNull(rewiredType) : null;
        } else if ((0, graphql_1.isNamedType)(type)) {
          let rewiredType = referenceTypeMap[type.name];
          if (rewiredType === void 0) {
            rewiredType = (0, stub_js_1.isNamedStub)(type) ? (0, stub_js_1.getBuiltInForStub)(type) : rewireNamedType(type);
            newTypeMap[rewiredType.name] = referenceTypeMap[type.name] = rewiredType;
          }
          return rewiredType != null ? newTypeMap[rewiredType.name] : null;
        }
        return null;
      }
    }
    exports2.rewireTypes = rewireTypes;
  }
});

// ../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/transformInputValue.js
var require_transformInputValue2 = __commonJS({
  "../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/transformInputValue.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseInputValueLiteral = exports2.parseInputValue = exports2.serializeInputValue = exports2.transformInputValue = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function transformInputValue(type, value, inputLeafValueTransformer = null, inputObjectValueTransformer = null) {
      if (value == null) {
        return value;
      }
      const nullableType = (0, graphql_1.getNullableType)(type);
      if ((0, graphql_1.isLeafType)(nullableType)) {
        return inputLeafValueTransformer != null ? inputLeafValueTransformer(nullableType, value) : value;
      } else if ((0, graphql_1.isListType)(nullableType)) {
        return value.map((listMember) => transformInputValue(nullableType.ofType, listMember, inputLeafValueTransformer, inputObjectValueTransformer));
      } else if ((0, graphql_1.isInputObjectType)(nullableType)) {
        const fields = nullableType.getFields();
        const newValue = {};
        for (const key in value) {
          const field = fields[key];
          if (field != null) {
            newValue[key] = transformInputValue(field.type, value[key], inputLeafValueTransformer, inputObjectValueTransformer);
          }
        }
        return inputObjectValueTransformer != null ? inputObjectValueTransformer(nullableType, newValue) : newValue;
      }
    }
    exports2.transformInputValue = transformInputValue;
    function serializeInputValue(type, value) {
      return transformInputValue(type, value, (t, v) => {
        try {
          return t.serialize(v);
        } catch (_a) {
          return v;
        }
      });
    }
    exports2.serializeInputValue = serializeInputValue;
    function parseInputValue(type, value) {
      return transformInputValue(type, value, (t, v) => {
        try {
          return t.parseValue(v);
        } catch (_a) {
          return v;
        }
      });
    }
    exports2.parseInputValue = parseInputValue;
    function parseInputValueLiteral(type, value) {
      return transformInputValue(type, value, (t, v) => t.parseLiteral(v, {}));
    }
    exports2.parseInputValueLiteral = parseInputValueLiteral;
  }
});

// ../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/mapSchema.js
var require_mapSchema2 = __commonJS({
  "../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/mapSchema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.correctASTNodes = exports2.mapSchema = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var getObjectTypeFromTypeMap_js_1 = require_getObjectTypeFromTypeMap2();
    var Interfaces_js_1 = require_Interfaces2();
    var rewire_js_1 = require_rewire2();
    var transformInputValue_js_1 = require_transformInputValue2();
    function mapSchema(schema, schemaMapper = {}) {
      const newTypeMap = mapArguments(mapFields(mapTypes(mapDefaultValues(mapEnumValues(mapTypes(mapDefaultValues(schema.getTypeMap(), schema, transformInputValue_js_1.serializeInputValue), schema, schemaMapper, (type) => (0, graphql_1.isLeafType)(type)), schema, schemaMapper), schema, transformInputValue_js_1.parseInputValue), schema, schemaMapper, (type) => !(0, graphql_1.isLeafType)(type)), schema, schemaMapper), schema, schemaMapper);
      const originalDirectives = schema.getDirectives();
      const newDirectives = mapDirectives(originalDirectives, schema, schemaMapper);
      const { typeMap, directives } = (0, rewire_js_1.rewireTypes)(newTypeMap, newDirectives);
      return new graphql_1.GraphQLSchema({
        ...schema.toConfig(),
        query: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(newTypeMap, schema.getQueryType())),
        mutation: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(newTypeMap, schema.getMutationType())),
        subscription: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(newTypeMap, schema.getSubscriptionType())),
        types: Object.values(typeMap),
        directives
      });
    }
    exports2.mapSchema = mapSchema;
    function mapTypes(originalTypeMap, schema, schemaMapper, testFn = () => true) {
      const newTypeMap = {};
      for (const typeName in originalTypeMap) {
        if (!typeName.startsWith("__")) {
          const originalType = originalTypeMap[typeName];
          if (originalType == null || !testFn(originalType)) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          const typeMapper = getTypeMapper(schema, schemaMapper, typeName);
          if (typeMapper == null) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          const maybeNewType = typeMapper(originalType, schema);
          if (maybeNewType === void 0) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          newTypeMap[typeName] = maybeNewType;
        }
      }
      return newTypeMap;
    }
    function mapEnumValues(originalTypeMap, schema, schemaMapper) {
      const enumValueMapper = getEnumValueMapper(schemaMapper);
      if (!enumValueMapper) {
        return originalTypeMap;
      }
      return mapTypes(originalTypeMap, schema, {
        [Interfaces_js_1.MapperKind.ENUM_TYPE]: (type) => {
          const config = type.toConfig();
          const originalEnumValueConfigMap = config.values;
          const newEnumValueConfigMap = {};
          for (const externalValue in originalEnumValueConfigMap) {
            const originalEnumValueConfig = originalEnumValueConfigMap[externalValue];
            const mappedEnumValue = enumValueMapper(originalEnumValueConfig, type.name, schema, externalValue);
            if (mappedEnumValue === void 0) {
              newEnumValueConfigMap[externalValue] = originalEnumValueConfig;
            } else if (Array.isArray(mappedEnumValue)) {
              const [newExternalValue, newEnumValueConfig] = mappedEnumValue;
              newEnumValueConfigMap[newExternalValue] = newEnumValueConfig === void 0 ? originalEnumValueConfig : newEnumValueConfig;
            } else if (mappedEnumValue !== null) {
              newEnumValueConfigMap[externalValue] = mappedEnumValue;
            }
          }
          return correctASTNodes(new graphql_1.GraphQLEnumType({
            ...config,
            values: newEnumValueConfigMap
          }));
        }
      }, (type) => (0, graphql_1.isEnumType)(type));
    }
    function mapDefaultValues(originalTypeMap, schema, fn) {
      const newTypeMap = mapArguments(originalTypeMap, schema, {
        [Interfaces_js_1.MapperKind.ARGUMENT]: (argumentConfig) => {
          if (argumentConfig.defaultValue === void 0) {
            return argumentConfig;
          }
          const maybeNewType = getNewType(originalTypeMap, argumentConfig.type);
          if (maybeNewType != null) {
            return {
              ...argumentConfig,
              defaultValue: fn(maybeNewType, argumentConfig.defaultValue)
            };
          }
        }
      });
      return mapFields(newTypeMap, schema, {
        [Interfaces_js_1.MapperKind.INPUT_OBJECT_FIELD]: (inputFieldConfig) => {
          if (inputFieldConfig.defaultValue === void 0) {
            return inputFieldConfig;
          }
          const maybeNewType = getNewType(newTypeMap, inputFieldConfig.type);
          if (maybeNewType != null) {
            return {
              ...inputFieldConfig,
              defaultValue: fn(maybeNewType, inputFieldConfig.defaultValue)
            };
          }
        }
      });
    }
    function getNewType(newTypeMap, type) {
      if ((0, graphql_1.isListType)(type)) {
        const newType = getNewType(newTypeMap, type.ofType);
        return newType != null ? new graphql_1.GraphQLList(newType) : null;
      } else if ((0, graphql_1.isNonNullType)(type)) {
        const newType = getNewType(newTypeMap, type.ofType);
        return newType != null ? new graphql_1.GraphQLNonNull(newType) : null;
      } else if ((0, graphql_1.isNamedType)(type)) {
        const newType = newTypeMap[type.name];
        return newType != null ? newType : null;
      }
      return null;
    }
    function mapFields(originalTypeMap, schema, schemaMapper) {
      const newTypeMap = {};
      for (const typeName in originalTypeMap) {
        if (!typeName.startsWith("__")) {
          const originalType = originalTypeMap[typeName];
          if (!(0, graphql_1.isObjectType)(originalType) && !(0, graphql_1.isInterfaceType)(originalType) && !(0, graphql_1.isInputObjectType)(originalType)) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          const fieldMapper = getFieldMapper(schema, schemaMapper, typeName);
          if (fieldMapper == null) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          const config = originalType.toConfig();
          const originalFieldConfigMap = config.fields;
          const newFieldConfigMap = {};
          for (const fieldName in originalFieldConfigMap) {
            const originalFieldConfig = originalFieldConfigMap[fieldName];
            const mappedField = fieldMapper(originalFieldConfig, fieldName, typeName, schema);
            if (mappedField === void 0) {
              newFieldConfigMap[fieldName] = originalFieldConfig;
            } else if (Array.isArray(mappedField)) {
              const [newFieldName, newFieldConfig] = mappedField;
              if (newFieldConfig.astNode != null) {
                newFieldConfig.astNode = {
                  ...newFieldConfig.astNode,
                  name: {
                    ...newFieldConfig.astNode.name,
                    value: newFieldName
                  }
                };
              }
              newFieldConfigMap[newFieldName] = newFieldConfig === void 0 ? originalFieldConfig : newFieldConfig;
            } else if (mappedField !== null) {
              newFieldConfigMap[fieldName] = mappedField;
            }
          }
          if ((0, graphql_1.isObjectType)(originalType)) {
            newTypeMap[typeName] = correctASTNodes(new graphql_1.GraphQLObjectType({
              ...config,
              fields: newFieldConfigMap
            }));
          } else if ((0, graphql_1.isInterfaceType)(originalType)) {
            newTypeMap[typeName] = correctASTNodes(new graphql_1.GraphQLInterfaceType({
              ...config,
              fields: newFieldConfigMap
            }));
          } else {
            newTypeMap[typeName] = correctASTNodes(new graphql_1.GraphQLInputObjectType({
              ...config,
              fields: newFieldConfigMap
            }));
          }
        }
      }
      return newTypeMap;
    }
    function mapArguments(originalTypeMap, schema, schemaMapper) {
      const newTypeMap = {};
      for (const typeName in originalTypeMap) {
        if (!typeName.startsWith("__")) {
          const originalType = originalTypeMap[typeName];
          if (!(0, graphql_1.isObjectType)(originalType) && !(0, graphql_1.isInterfaceType)(originalType)) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          const argumentMapper = getArgumentMapper(schemaMapper);
          if (argumentMapper == null) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          const config = originalType.toConfig();
          const originalFieldConfigMap = config.fields;
          const newFieldConfigMap = {};
          for (const fieldName in originalFieldConfigMap) {
            const originalFieldConfig = originalFieldConfigMap[fieldName];
            const originalArgumentConfigMap = originalFieldConfig.args;
            if (originalArgumentConfigMap == null) {
              newFieldConfigMap[fieldName] = originalFieldConfig;
              continue;
            }
            const argumentNames = Object.keys(originalArgumentConfigMap);
            if (!argumentNames.length) {
              newFieldConfigMap[fieldName] = originalFieldConfig;
              continue;
            }
            const newArgumentConfigMap = {};
            for (const argumentName of argumentNames) {
              const originalArgumentConfig = originalArgumentConfigMap[argumentName];
              const mappedArgument = argumentMapper(originalArgumentConfig, fieldName, typeName, schema);
              if (mappedArgument === void 0) {
                newArgumentConfigMap[argumentName] = originalArgumentConfig;
              } else if (Array.isArray(mappedArgument)) {
                const [newArgumentName, newArgumentConfig] = mappedArgument;
                newArgumentConfigMap[newArgumentName] = newArgumentConfig;
              } else if (mappedArgument !== null) {
                newArgumentConfigMap[argumentName] = mappedArgument;
              }
            }
            newFieldConfigMap[fieldName] = {
              ...originalFieldConfig,
              args: newArgumentConfigMap
            };
          }
          if ((0, graphql_1.isObjectType)(originalType)) {
            newTypeMap[typeName] = new graphql_1.GraphQLObjectType({
              ...config,
              fields: newFieldConfigMap
            });
          } else if ((0, graphql_1.isInterfaceType)(originalType)) {
            newTypeMap[typeName] = new graphql_1.GraphQLInterfaceType({
              ...config,
              fields: newFieldConfigMap
            });
          } else {
            newTypeMap[typeName] = new graphql_1.GraphQLInputObjectType({
              ...config,
              fields: newFieldConfigMap
            });
          }
        }
      }
      return newTypeMap;
    }
    function mapDirectives(originalDirectives, schema, schemaMapper) {
      const directiveMapper = getDirectiveMapper(schemaMapper);
      if (directiveMapper == null) {
        return originalDirectives.slice();
      }
      const newDirectives = [];
      for (const directive of originalDirectives) {
        const mappedDirective = directiveMapper(directive, schema);
        if (mappedDirective === void 0) {
          newDirectives.push(directive);
        } else if (mappedDirective !== null) {
          newDirectives.push(mappedDirective);
        }
      }
      return newDirectives;
    }
    function getTypeSpecifiers(schema, typeName) {
      var _a, _b, _c;
      const type = schema.getType(typeName);
      const specifiers = [Interfaces_js_1.MapperKind.TYPE];
      if ((0, graphql_1.isObjectType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_TYPE, Interfaces_js_1.MapperKind.OBJECT_TYPE);
        if (typeName === ((_a = schema.getQueryType()) === null || _a === void 0 ? void 0 : _a.name)) {
          specifiers.push(Interfaces_js_1.MapperKind.ROOT_OBJECT, Interfaces_js_1.MapperKind.QUERY);
        } else if (typeName === ((_b = schema.getMutationType()) === null || _b === void 0 ? void 0 : _b.name)) {
          specifiers.push(Interfaces_js_1.MapperKind.ROOT_OBJECT, Interfaces_js_1.MapperKind.MUTATION);
        } else if (typeName === ((_c = schema.getSubscriptionType()) === null || _c === void 0 ? void 0 : _c.name)) {
          specifiers.push(Interfaces_js_1.MapperKind.ROOT_OBJECT, Interfaces_js_1.MapperKind.SUBSCRIPTION);
        }
      } else if ((0, graphql_1.isInputObjectType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.INPUT_OBJECT_TYPE);
      } else if ((0, graphql_1.isInterfaceType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_TYPE, Interfaces_js_1.MapperKind.ABSTRACT_TYPE, Interfaces_js_1.MapperKind.INTERFACE_TYPE);
      } else if ((0, graphql_1.isUnionType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_TYPE, Interfaces_js_1.MapperKind.ABSTRACT_TYPE, Interfaces_js_1.MapperKind.UNION_TYPE);
      } else if ((0, graphql_1.isEnumType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.ENUM_TYPE);
      } else if ((0, graphql_1.isScalarType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.SCALAR_TYPE);
      }
      return specifiers;
    }
    function getTypeMapper(schema, schemaMapper, typeName) {
      const specifiers = getTypeSpecifiers(schema, typeName);
      let typeMapper;
      const stack = [...specifiers];
      while (!typeMapper && stack.length > 0) {
        const next = stack.pop();
        typeMapper = schemaMapper[next];
      }
      return typeMapper != null ? typeMapper : null;
    }
    function getFieldSpecifiers(schema, typeName) {
      var _a, _b, _c;
      const type = schema.getType(typeName);
      const specifiers = [Interfaces_js_1.MapperKind.FIELD];
      if ((0, graphql_1.isObjectType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_FIELD, Interfaces_js_1.MapperKind.OBJECT_FIELD);
        if (typeName === ((_a = schema.getQueryType()) === null || _a === void 0 ? void 0 : _a.name)) {
          specifiers.push(Interfaces_js_1.MapperKind.ROOT_FIELD, Interfaces_js_1.MapperKind.QUERY_ROOT_FIELD);
        } else if (typeName === ((_b = schema.getMutationType()) === null || _b === void 0 ? void 0 : _b.name)) {
          specifiers.push(Interfaces_js_1.MapperKind.ROOT_FIELD, Interfaces_js_1.MapperKind.MUTATION_ROOT_FIELD);
        } else if (typeName === ((_c = schema.getSubscriptionType()) === null || _c === void 0 ? void 0 : _c.name)) {
          specifiers.push(Interfaces_js_1.MapperKind.ROOT_FIELD, Interfaces_js_1.MapperKind.SUBSCRIPTION_ROOT_FIELD);
        }
      } else if ((0, graphql_1.isInterfaceType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_FIELD, Interfaces_js_1.MapperKind.INTERFACE_FIELD);
      } else if ((0, graphql_1.isInputObjectType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.INPUT_OBJECT_FIELD);
      }
      return specifiers;
    }
    function getFieldMapper(schema, schemaMapper, typeName) {
      const specifiers = getFieldSpecifiers(schema, typeName);
      let fieldMapper;
      const stack = [...specifiers];
      while (!fieldMapper && stack.length > 0) {
        const next = stack.pop();
        fieldMapper = schemaMapper[next];
      }
      return fieldMapper !== null && fieldMapper !== void 0 ? fieldMapper : null;
    }
    function getArgumentMapper(schemaMapper) {
      const argumentMapper = schemaMapper[Interfaces_js_1.MapperKind.ARGUMENT];
      return argumentMapper != null ? argumentMapper : null;
    }
    function getDirectiveMapper(schemaMapper) {
      const directiveMapper = schemaMapper[Interfaces_js_1.MapperKind.DIRECTIVE];
      return directiveMapper != null ? directiveMapper : null;
    }
    function getEnumValueMapper(schemaMapper) {
      const enumValueMapper = schemaMapper[Interfaces_js_1.MapperKind.ENUM_VALUE];
      return enumValueMapper != null ? enumValueMapper : null;
    }
    function correctASTNodes(type) {
      if ((0, graphql_1.isObjectType)(type)) {
        const config = type.toConfig();
        if (config.astNode != null) {
          const fields = [];
          for (const fieldName in config.fields) {
            const fieldConfig = config.fields[fieldName];
            if (fieldConfig.astNode != null) {
              fields.push(fieldConfig.astNode);
            }
          }
          config.astNode = {
            ...config.astNode,
            kind: graphql_1.Kind.OBJECT_TYPE_DEFINITION,
            fields
          };
        }
        if (config.extensionASTNodes != null) {
          config.extensionASTNodes = config.extensionASTNodes.map((node) => ({
            ...node,
            kind: graphql_1.Kind.OBJECT_TYPE_EXTENSION,
            fields: void 0
          }));
        }
        return new graphql_1.GraphQLObjectType(config);
      } else if ((0, graphql_1.isInterfaceType)(type)) {
        const config = type.toConfig();
        if (config.astNode != null) {
          const fields = [];
          for (const fieldName in config.fields) {
            const fieldConfig = config.fields[fieldName];
            if (fieldConfig.astNode != null) {
              fields.push(fieldConfig.astNode);
            }
          }
          config.astNode = {
            ...config.astNode,
            kind: graphql_1.Kind.INTERFACE_TYPE_DEFINITION,
            fields
          };
        }
        if (config.extensionASTNodes != null) {
          config.extensionASTNodes = config.extensionASTNodes.map((node) => ({
            ...node,
            kind: graphql_1.Kind.INTERFACE_TYPE_EXTENSION,
            fields: void 0
          }));
        }
        return new graphql_1.GraphQLInterfaceType(config);
      } else if ((0, graphql_1.isInputObjectType)(type)) {
        const config = type.toConfig();
        if (config.astNode != null) {
          const fields = [];
          for (const fieldName in config.fields) {
            const fieldConfig = config.fields[fieldName];
            if (fieldConfig.astNode != null) {
              fields.push(fieldConfig.astNode);
            }
          }
          config.astNode = {
            ...config.astNode,
            kind: graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION,
            fields
          };
        }
        if (config.extensionASTNodes != null) {
          config.extensionASTNodes = config.extensionASTNodes.map((node) => ({
            ...node,
            kind: graphql_1.Kind.INPUT_OBJECT_TYPE_EXTENSION,
            fields: void 0
          }));
        }
        return new graphql_1.GraphQLInputObjectType(config);
      } else if ((0, graphql_1.isEnumType)(type)) {
        const config = type.toConfig();
        if (config.astNode != null) {
          const values = [];
          for (const enumKey in config.values) {
            const enumValueConfig = config.values[enumKey];
            if (enumValueConfig.astNode != null) {
              values.push(enumValueConfig.astNode);
            }
          }
          config.astNode = {
            ...config.astNode,
            values
          };
        }
        if (config.extensionASTNodes != null) {
          config.extensionASTNodes = config.extensionASTNodes.map((node) => ({
            ...node,
            values: void 0
          }));
        }
        return new graphql_1.GraphQLEnumType(config);
      } else {
        return type;
      }
    }
    exports2.correctASTNodes = correctASTNodes;
  }
});

// ../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/filterSchema.js
var require_filterSchema2 = __commonJS({
  "../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/filterSchema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.filterSchema = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var Interfaces_js_1 = require_Interfaces2();
    var mapSchema_js_1 = require_mapSchema2();
    function filterSchema({ schema, typeFilter = () => true, fieldFilter = void 0, rootFieldFilter = void 0, objectFieldFilter = void 0, interfaceFieldFilter = void 0, inputObjectFieldFilter = void 0, argumentFilter = void 0 }) {
      const filteredSchema = (0, mapSchema_js_1.mapSchema)(schema, {
        [Interfaces_js_1.MapperKind.QUERY]: (type) => filterRootFields(type, "Query", rootFieldFilter, argumentFilter),
        [Interfaces_js_1.MapperKind.MUTATION]: (type) => filterRootFields(type, "Mutation", rootFieldFilter, argumentFilter),
        [Interfaces_js_1.MapperKind.SUBSCRIPTION]: (type) => filterRootFields(type, "Subscription", rootFieldFilter, argumentFilter),
        [Interfaces_js_1.MapperKind.OBJECT_TYPE]: (type) => typeFilter(type.name, type) ? filterElementFields(graphql_1.GraphQLObjectType, type, objectFieldFilter || fieldFilter, argumentFilter) : null,
        [Interfaces_js_1.MapperKind.INTERFACE_TYPE]: (type) => typeFilter(type.name, type) ? filterElementFields(graphql_1.GraphQLInterfaceType, type, interfaceFieldFilter || fieldFilter, argumentFilter) : null,
        [Interfaces_js_1.MapperKind.INPUT_OBJECT_TYPE]: (type) => typeFilter(type.name, type) ? filterElementFields(graphql_1.GraphQLInputObjectType, type, inputObjectFieldFilter || fieldFilter) : null,
        [Interfaces_js_1.MapperKind.UNION_TYPE]: (type) => typeFilter(type.name, type) ? void 0 : null,
        [Interfaces_js_1.MapperKind.ENUM_TYPE]: (type) => typeFilter(type.name, type) ? void 0 : null,
        [Interfaces_js_1.MapperKind.SCALAR_TYPE]: (type) => typeFilter(type.name, type) ? void 0 : null
      });
      return filteredSchema;
    }
    exports2.filterSchema = filterSchema;
    function filterRootFields(type, operation, rootFieldFilter, argumentFilter) {
      if (rootFieldFilter || argumentFilter) {
        const config = type.toConfig();
        for (const fieldName in config.fields) {
          const field = config.fields[fieldName];
          if (rootFieldFilter && !rootFieldFilter(operation, fieldName, config.fields[fieldName])) {
            delete config.fields[fieldName];
          } else if (argumentFilter && field.args) {
            for (const argName in field.args) {
              if (!argumentFilter(operation, fieldName, argName, field.args[argName])) {
                delete field.args[argName];
              }
            }
          }
        }
        return new graphql_1.GraphQLObjectType(config);
      }
      return type;
    }
    function filterElementFields(ElementConstructor, type, fieldFilter, argumentFilter) {
      if (fieldFilter || argumentFilter) {
        const config = type.toConfig();
        for (const fieldName in config.fields) {
          const field = config.fields[fieldName];
          if (fieldFilter && !fieldFilter(type.name, fieldName, config.fields[fieldName])) {
            delete config.fields[fieldName];
          } else if (argumentFilter && "args" in field) {
            for (const argName in field.args) {
              if (!argumentFilter(type.name, fieldName, argName, field.args[argName])) {
                delete field.args[argName];
              }
            }
          }
        }
        return new ElementConstructor(config);
      }
    }
  }
});

// ../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/heal.js
var require_heal2 = __commonJS({
  "../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/heal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.healTypes = exports2.healSchema = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function healSchema(schema) {
      healTypes(schema.getTypeMap(), schema.getDirectives());
      return schema;
    }
    exports2.healSchema = healSchema;
    function healTypes(originalTypeMap, directives) {
      const actualNamedTypeMap = /* @__PURE__ */ Object.create(null);
      for (const typeName in originalTypeMap) {
        const namedType = originalTypeMap[typeName];
        if (namedType == null || typeName.startsWith("__")) {
          continue;
        }
        const actualName = namedType.name;
        if (actualName.startsWith("__")) {
          continue;
        }
        if (actualName in actualNamedTypeMap) {
          throw new Error(`Duplicate schema type name ${actualName}`);
        }
        actualNamedTypeMap[actualName] = namedType;
      }
      for (const typeName in actualNamedTypeMap) {
        const namedType = actualNamedTypeMap[typeName];
        originalTypeMap[typeName] = namedType;
      }
      for (const decl of directives) {
        decl.args = decl.args.filter((arg) => {
          arg.type = healType(arg.type);
          return arg.type !== null;
        });
      }
      for (const typeName in originalTypeMap) {
        const namedType = originalTypeMap[typeName];
        if (!typeName.startsWith("__") && typeName in actualNamedTypeMap) {
          if (namedType != null) {
            healNamedType(namedType);
          }
        }
      }
      for (const typeName in originalTypeMap) {
        if (!typeName.startsWith("__") && !(typeName in actualNamedTypeMap)) {
          delete originalTypeMap[typeName];
        }
      }
      function healNamedType(type) {
        if ((0, graphql_1.isObjectType)(type)) {
          healFields(type);
          healInterfaces(type);
          return;
        } else if ((0, graphql_1.isInterfaceType)(type)) {
          healFields(type);
          if ("getInterfaces" in type) {
            healInterfaces(type);
          }
          return;
        } else if ((0, graphql_1.isUnionType)(type)) {
          healUnderlyingTypes(type);
          return;
        } else if ((0, graphql_1.isInputObjectType)(type)) {
          healInputFields(type);
          return;
        } else if ((0, graphql_1.isLeafType)(type)) {
          return;
        }
        throw new Error(`Unexpected schema type: ${type}`);
      }
      function healFields(type) {
        const fieldMap = type.getFields();
        for (const [key, field] of Object.entries(fieldMap)) {
          field.args.map((arg) => {
            arg.type = healType(arg.type);
            return arg.type === null ? null : arg;
          }).filter(Boolean);
          field.type = healType(field.type);
          if (field.type === null) {
            delete fieldMap[key];
          }
        }
      }
      function healInterfaces(type) {
        if ("getInterfaces" in type) {
          const interfaces = type.getInterfaces();
          interfaces.push(...interfaces.splice(0).map((iface) => healType(iface)).filter(Boolean));
        }
      }
      function healInputFields(type) {
        const fieldMap = type.getFields();
        for (const [key, field] of Object.entries(fieldMap)) {
          field.type = healType(field.type);
          if (field.type === null) {
            delete fieldMap[key];
          }
        }
      }
      function healUnderlyingTypes(type) {
        const types = type.getTypes();
        types.push(...types.splice(0).map((t) => healType(t)).filter(Boolean));
      }
      function healType(type) {
        if ((0, graphql_1.isListType)(type)) {
          const healedType = healType(type.ofType);
          return healedType != null ? new graphql_1.GraphQLList(healedType) : null;
        } else if ((0, graphql_1.isNonNullType)(type)) {
          const healedType = healType(type.ofType);
          return healedType != null ? new graphql_1.GraphQLNonNull(healedType) : null;
        } else if ((0, graphql_1.isNamedType)(type)) {
          const officialType = originalTypeMap[type.name];
          if (officialType && type !== officialType) {
            return officialType;
          }
        }
        return type;
      }
    }
    exports2.healTypes = healTypes;
  }
});

// ../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/getResolversFromSchema.js
var require_getResolversFromSchema2 = __commonJS({
  "../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/getResolversFromSchema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getResolversFromSchema = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function getResolversFromSchema(schema, includeDefaultMergedResolver) {
      var _a, _b;
      const resolvers = /* @__PURE__ */ Object.create(null);
      const typeMap = schema.getTypeMap();
      for (const typeName in typeMap) {
        if (!typeName.startsWith("__")) {
          const type = typeMap[typeName];
          if ((0, graphql_1.isScalarType)(type)) {
            if (!(0, graphql_1.isSpecifiedScalarType)(type)) {
              const config = type.toConfig();
              delete config.astNode;
              resolvers[typeName] = new graphql_1.GraphQLScalarType(config);
            }
          } else if ((0, graphql_1.isEnumType)(type)) {
            resolvers[typeName] = {};
            const values = type.getValues();
            for (const value of values) {
              resolvers[typeName][value.name] = value.value;
            }
          } else if ((0, graphql_1.isInterfaceType)(type)) {
            if (type.resolveType != null) {
              resolvers[typeName] = {
                __resolveType: type.resolveType
              };
            }
          } else if ((0, graphql_1.isUnionType)(type)) {
            if (type.resolveType != null) {
              resolvers[typeName] = {
                __resolveType: type.resolveType
              };
            }
          } else if ((0, graphql_1.isObjectType)(type)) {
            resolvers[typeName] = {};
            if (type.isTypeOf != null) {
              resolvers[typeName].__isTypeOf = type.isTypeOf;
            }
            const fields = type.getFields();
            for (const fieldName in fields) {
              const field = fields[fieldName];
              if (field.subscribe != null) {
                resolvers[typeName][fieldName] = resolvers[typeName][fieldName] || {};
                resolvers[typeName][fieldName].subscribe = field.subscribe;
              }
              if (field.resolve != null && ((_a = field.resolve) === null || _a === void 0 ? void 0 : _a.name) !== "defaultFieldResolver") {
                switch ((_b = field.resolve) === null || _b === void 0 ? void 0 : _b.name) {
                  case "defaultMergedResolver":
                    if (!includeDefaultMergedResolver) {
                      continue;
                    }
                    break;
                  case "defaultFieldResolver":
                    continue;
                }
                resolvers[typeName][fieldName] = resolvers[typeName][fieldName] || {};
                resolvers[typeName][fieldName].resolve = field.resolve;
              }
            }
          }
        }
      }
      return resolvers;
    }
    exports2.getResolversFromSchema = getResolversFromSchema;
  }
});

// ../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/forEachField.js
var require_forEachField2 = __commonJS({
  "../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/forEachField.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.forEachField = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function forEachField(schema, fn) {
      const typeMap = schema.getTypeMap();
      for (const typeName in typeMap) {
        const type = typeMap[typeName];
        if (!(0, graphql_1.getNamedType)(type).name.startsWith("__") && (0, graphql_1.isObjectType)(type)) {
          const fields = type.getFields();
          for (const fieldName in fields) {
            const field = fields[fieldName];
            fn(field, typeName, fieldName);
          }
        }
      }
    }
    exports2.forEachField = forEachField;
  }
});

// ../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/forEachDefaultValue.js
var require_forEachDefaultValue2 = __commonJS({
  "../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/forEachDefaultValue.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.forEachDefaultValue = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function forEachDefaultValue(schema, fn) {
      const typeMap = schema.getTypeMap();
      for (const typeName in typeMap) {
        const type = typeMap[typeName];
        if (!(0, graphql_1.getNamedType)(type).name.startsWith("__")) {
          if ((0, graphql_1.isObjectType)(type)) {
            const fields = type.getFields();
            for (const fieldName in fields) {
              const field = fields[fieldName];
              for (const arg of field.args) {
                arg.defaultValue = fn(arg.type, arg.defaultValue);
              }
            }
          } else if ((0, graphql_1.isInputObjectType)(type)) {
            const fields = type.getFields();
            for (const fieldName in fields) {
              const field = fields[fieldName];
              field.defaultValue = fn(field.type, field.defaultValue);
            }
          }
        }
      }
    }
    exports2.forEachDefaultValue = forEachDefaultValue;
  }
});

// ../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/addTypes.js
var require_addTypes2 = __commonJS({
  "../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/addTypes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.addTypes = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var getObjectTypeFromTypeMap_js_1 = require_getObjectTypeFromTypeMap2();
    var rewire_js_1 = require_rewire2();
    function addTypes(schema, newTypesOrDirectives) {
      const config = schema.toConfig();
      const originalTypeMap = {};
      for (const type of config.types) {
        originalTypeMap[type.name] = type;
      }
      const originalDirectiveMap = {};
      for (const directive of config.directives) {
        originalDirectiveMap[directive.name] = directive;
      }
      for (const newTypeOrDirective of newTypesOrDirectives) {
        if ((0, graphql_1.isNamedType)(newTypeOrDirective)) {
          originalTypeMap[newTypeOrDirective.name] = newTypeOrDirective;
        } else if ((0, graphql_1.isDirective)(newTypeOrDirective)) {
          originalDirectiveMap[newTypeOrDirective.name] = newTypeOrDirective;
        }
      }
      const { typeMap, directives } = (0, rewire_js_1.rewireTypes)(originalTypeMap, Object.values(originalDirectiveMap));
      return new graphql_1.GraphQLSchema({
        ...config,
        query: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, schema.getQueryType()),
        mutation: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, schema.getMutationType()),
        subscription: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, schema.getSubscriptionType()),
        types: Object.values(typeMap),
        directives
      });
    }
    exports2.addTypes = addTypes;
  }
});

// ../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/prune.js
var require_prune2 = __commonJS({
  "../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/prune.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.pruneSchema = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var mapSchema_js_1 = require_mapSchema2();
    var Interfaces_js_1 = require_Interfaces2();
    var rootTypes_js_1 = require_rootTypes2();
    var get_implementing_types_js_1 = require_get_implementing_types2();
    function pruneSchema(schema, options = {}) {
      const { skipEmptyCompositeTypePruning, skipEmptyUnionPruning, skipPruning, skipUnimplementedInterfacesPruning, skipUnusedTypesPruning } = options;
      let prunedTypes = [];
      let prunedSchema = schema;
      do {
        let visited = visitSchema(prunedSchema);
        if (skipPruning) {
          const revisit = [];
          for (const typeName in prunedSchema.getTypeMap()) {
            if (typeName.startsWith("__")) {
              continue;
            }
            const type = prunedSchema.getType(typeName);
            if (type && skipPruning(type)) {
              revisit.push(typeName);
            }
          }
          visited = visitQueue(revisit, prunedSchema, visited);
        }
        prunedTypes = [];
        prunedSchema = (0, mapSchema_js_1.mapSchema)(prunedSchema, {
          [Interfaces_js_1.MapperKind.TYPE]: (type) => {
            if (!visited.has(type.name) && !(0, graphql_1.isSpecifiedScalarType)(type)) {
              if ((0, graphql_1.isUnionType)(type) || (0, graphql_1.isInputObjectType)(type) || (0, graphql_1.isInterfaceType)(type) || (0, graphql_1.isObjectType)(type) || (0, graphql_1.isScalarType)(type)) {
                if (skipUnusedTypesPruning) {
                  return type;
                }
                if ((0, graphql_1.isUnionType)(type) && skipEmptyUnionPruning && !Object.keys(type.getTypes()).length) {
                  return type;
                }
                if ((0, graphql_1.isInputObjectType)(type) || (0, graphql_1.isInterfaceType)(type) || (0, graphql_1.isObjectType)(type)) {
                  if (skipEmptyCompositeTypePruning && !Object.keys(type.getFields()).length) {
                    return type;
                  }
                }
                if ((0, graphql_1.isInterfaceType)(type) && skipUnimplementedInterfacesPruning) {
                  return type;
                }
              }
              prunedTypes.push(type.name);
              visited.delete(type.name);
              return null;
            }
            return type;
          }
        });
      } while (prunedTypes.length);
      return prunedSchema;
    }
    exports2.pruneSchema = pruneSchema;
    function visitSchema(schema) {
      const queue = [];
      for (const type of (0, rootTypes_js_1.getRootTypes)(schema)) {
        queue.push(type.name);
      }
      return visitQueue(queue, schema);
    }
    function visitQueue(queue, schema, visited = /* @__PURE__ */ new Set()) {
      const revisit = /* @__PURE__ */ new Map();
      while (queue.length) {
        const typeName = queue.pop();
        if (visited.has(typeName) && revisit[typeName] !== true) {
          continue;
        }
        const type = schema.getType(typeName);
        if (type) {
          if ((0, graphql_1.isUnionType)(type)) {
            queue.push(...type.getTypes().map((type2) => type2.name));
          }
          if ((0, graphql_1.isInterfaceType)(type) && revisit[typeName] === true) {
            queue.push(...(0, get_implementing_types_js_1.getImplementingTypes)(type.name, schema));
            revisit[typeName] = false;
          }
          if ("getInterfaces" in type) {
            queue.push(...type.getInterfaces().map((iface) => iface.name));
          }
          if ("getFields" in type) {
            const fields = type.getFields();
            const entries = Object.entries(fields);
            if (!entries.length) {
              continue;
            }
            for (const [, field] of entries) {
              if ((0, graphql_1.isObjectType)(type)) {
                queue.push(...field.args.map((arg) => (0, graphql_1.getNamedType)(arg.type).name));
              }
              const namedType = (0, graphql_1.getNamedType)(field.type);
              queue.push(namedType.name);
              if ((0, graphql_1.isInterfaceType)(namedType) && !(namedType.name in revisit)) {
                revisit[namedType.name] = true;
              }
            }
          }
          visited.add(typeName);
        }
      }
      return visited;
    }
  }
});

// ../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/mergeDeep.js
var require_mergeDeep2 = __commonJS({
  "../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/mergeDeep.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeDeep = void 0;
    var helpers_js_1 = require_helpers2();
    function mergeDeep(sources, respectPrototype = false) {
      const target = sources[0] || {};
      const output = {};
      if (respectPrototype) {
        Object.setPrototypeOf(output, Object.create(Object.getPrototypeOf(target)));
      }
      for (const source of sources) {
        if (isObject(target) && isObject(source)) {
          if (respectPrototype) {
            const outputPrototype = Object.getPrototypeOf(output);
            const sourcePrototype = Object.getPrototypeOf(source);
            if (sourcePrototype) {
              for (const key of Object.getOwnPropertyNames(sourcePrototype)) {
                const descriptor = Object.getOwnPropertyDescriptor(sourcePrototype, key);
                if ((0, helpers_js_1.isSome)(descriptor)) {
                  Object.defineProperty(outputPrototype, key, descriptor);
                }
              }
            }
          }
          for (const key in source) {
            if (isObject(source[key])) {
              if (!(key in output)) {
                Object.assign(output, { [key]: source[key] });
              } else {
                output[key] = mergeDeep([output[key], source[key]], respectPrototype);
              }
            } else {
              Object.assign(output, { [key]: source[key] });
            }
          }
        }
      }
      return output;
    }
    exports2.mergeDeep = mergeDeep;
    function isObject(item) {
      return item && typeof item === "object" && !Array.isArray(item);
    }
  }
});

// ../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/selectionSets.js
var require_selectionSets2 = __commonJS({
  "../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/selectionSets.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseSelectionSet = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function parseSelectionSet(selectionSet, options) {
      const query = (0, graphql_1.parse)(selectionSet, options).definitions[0];
      return query.selectionSet;
    }
    exports2.parseSelectionSet = parseSelectionSet;
  }
});

// ../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/getResponseKeyFromInfo.js
var require_getResponseKeyFromInfo2 = __commonJS({
  "../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/getResponseKeyFromInfo.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getResponseKeyFromInfo = void 0;
    function getResponseKeyFromInfo(info) {
      return info.fieldNodes[0].alias != null ? info.fieldNodes[0].alias.value : info.fieldName;
    }
    exports2.getResponseKeyFromInfo = getResponseKeyFromInfo;
  }
});

// ../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/fields.js
var require_fields3 = __commonJS({
  "../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/fields.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.modifyObjectFields = exports2.selectObjectFields = exports2.removeObjectFields = exports2.appendObjectFields = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var Interfaces_js_1 = require_Interfaces2();
    var mapSchema_js_1 = require_mapSchema2();
    var addTypes_js_1 = require_addTypes2();
    function appendObjectFields(schema, typeName, additionalFields) {
      if (schema.getType(typeName) == null) {
        return (0, addTypes_js_1.addTypes)(schema, [
          new graphql_1.GraphQLObjectType({
            name: typeName,
            fields: additionalFields
          })
        ]);
      }
      return (0, mapSchema_js_1.mapSchema)(schema, {
        [Interfaces_js_1.MapperKind.OBJECT_TYPE]: (type) => {
          if (type.name === typeName) {
            const config = type.toConfig();
            const originalFieldConfigMap = config.fields;
            const newFieldConfigMap = {};
            for (const fieldName in originalFieldConfigMap) {
              newFieldConfigMap[fieldName] = originalFieldConfigMap[fieldName];
            }
            for (const fieldName in additionalFields) {
              newFieldConfigMap[fieldName] = additionalFields[fieldName];
            }
            return (0, mapSchema_js_1.correctASTNodes)(new graphql_1.GraphQLObjectType({
              ...config,
              fields: newFieldConfigMap
            }));
          }
        }
      });
    }
    exports2.appendObjectFields = appendObjectFields;
    function removeObjectFields(schema, typeName, testFn) {
      const removedFields = {};
      const newSchema = (0, mapSchema_js_1.mapSchema)(schema, {
        [Interfaces_js_1.MapperKind.OBJECT_TYPE]: (type) => {
          if (type.name === typeName) {
            const config = type.toConfig();
            const originalFieldConfigMap = config.fields;
            const newFieldConfigMap = {};
            for (const fieldName in originalFieldConfigMap) {
              const originalFieldConfig = originalFieldConfigMap[fieldName];
              if (testFn(fieldName, originalFieldConfig)) {
                removedFields[fieldName] = originalFieldConfig;
              } else {
                newFieldConfigMap[fieldName] = originalFieldConfig;
              }
            }
            return (0, mapSchema_js_1.correctASTNodes)(new graphql_1.GraphQLObjectType({
              ...config,
              fields: newFieldConfigMap
            }));
          }
        }
      });
      return [newSchema, removedFields];
    }
    exports2.removeObjectFields = removeObjectFields;
    function selectObjectFields(schema, typeName, testFn) {
      const selectedFields = {};
      (0, mapSchema_js_1.mapSchema)(schema, {
        [Interfaces_js_1.MapperKind.OBJECT_TYPE]: (type) => {
          if (type.name === typeName) {
            const config = type.toConfig();
            const originalFieldConfigMap = config.fields;
            for (const fieldName in originalFieldConfigMap) {
              const originalFieldConfig = originalFieldConfigMap[fieldName];
              if (testFn(fieldName, originalFieldConfig)) {
                selectedFields[fieldName] = originalFieldConfig;
              }
            }
          }
          return void 0;
        }
      });
      return selectedFields;
    }
    exports2.selectObjectFields = selectObjectFields;
    function modifyObjectFields(schema, typeName, testFn, newFields) {
      const removedFields = {};
      const newSchema = (0, mapSchema_js_1.mapSchema)(schema, {
        [Interfaces_js_1.MapperKind.OBJECT_TYPE]: (type) => {
          if (type.name === typeName) {
            const config = type.toConfig();
            const originalFieldConfigMap = config.fields;
            const newFieldConfigMap = {};
            for (const fieldName in originalFieldConfigMap) {
              const originalFieldConfig = originalFieldConfigMap[fieldName];
              if (testFn(fieldName, originalFieldConfig)) {
                removedFields[fieldName] = originalFieldConfig;
              } else {
                newFieldConfigMap[fieldName] = originalFieldConfig;
              }
            }
            for (const fieldName in newFields) {
              const fieldConfig = newFields[fieldName];
              newFieldConfigMap[fieldName] = fieldConfig;
            }
            return (0, mapSchema_js_1.correctASTNodes)(new graphql_1.GraphQLObjectType({
              ...config,
              fields: newFieldConfigMap
            }));
          }
        }
      });
      return [newSchema, removedFields];
    }
    exports2.modifyObjectFields = modifyObjectFields;
  }
});

// ../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/renameType.js
var require_renameType2 = __commonJS({
  "../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/renameType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.renameType = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function renameType(type, newTypeName) {
      if ((0, graphql_1.isObjectType)(type)) {
        return new graphql_1.GraphQLObjectType({
          ...type.toConfig(),
          name: newTypeName,
          astNode: type.astNode == null ? type.astNode : {
            ...type.astNode,
            name: {
              ...type.astNode.name,
              value: newTypeName
            }
          },
          extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map((node) => ({
            ...node,
            name: {
              ...node.name,
              value: newTypeName
            }
          }))
        });
      } else if ((0, graphql_1.isInterfaceType)(type)) {
        return new graphql_1.GraphQLInterfaceType({
          ...type.toConfig(),
          name: newTypeName,
          astNode: type.astNode == null ? type.astNode : {
            ...type.astNode,
            name: {
              ...type.astNode.name,
              value: newTypeName
            }
          },
          extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map((node) => ({
            ...node,
            name: {
              ...node.name,
              value: newTypeName
            }
          }))
        });
      } else if ((0, graphql_1.isUnionType)(type)) {
        return new graphql_1.GraphQLUnionType({
          ...type.toConfig(),
          name: newTypeName,
          astNode: type.astNode == null ? type.astNode : {
            ...type.astNode,
            name: {
              ...type.astNode.name,
              value: newTypeName
            }
          },
          extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map((node) => ({
            ...node,
            name: {
              ...node.name,
              value: newTypeName
            }
          }))
        });
      } else if ((0, graphql_1.isInputObjectType)(type)) {
        return new graphql_1.GraphQLInputObjectType({
          ...type.toConfig(),
          name: newTypeName,
          astNode: type.astNode == null ? type.astNode : {
            ...type.astNode,
            name: {
              ...type.astNode.name,
              value: newTypeName
            }
          },
          extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map((node) => ({
            ...node,
            name: {
              ...node.name,
              value: newTypeName
            }
          }))
        });
      } else if ((0, graphql_1.isEnumType)(type)) {
        return new graphql_1.GraphQLEnumType({
          ...type.toConfig(),
          name: newTypeName,
          astNode: type.astNode == null ? type.astNode : {
            ...type.astNode,
            name: {
              ...type.astNode.name,
              value: newTypeName
            }
          },
          extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map((node) => ({
            ...node,
            name: {
              ...node.name,
              value: newTypeName
            }
          }))
        });
      } else if ((0, graphql_1.isScalarType)(type)) {
        return new graphql_1.GraphQLScalarType({
          ...type.toConfig(),
          name: newTypeName,
          astNode: type.astNode == null ? type.astNode : {
            ...type.astNode,
            name: {
              ...type.astNode.name,
              value: newTypeName
            }
          },
          extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map((node) => ({
            ...node,
            name: {
              ...node.name,
              value: newTypeName
            }
          }))
        });
      }
      throw new Error(`Unknown type ${type}.`);
    }
    exports2.renameType = renameType;
  }
});

// ../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/mapAsyncIterator.js
var require_mapAsyncIterator2 = __commonJS({
  "../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/mapAsyncIterator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mapAsyncIterator = void 0;
    function mapAsyncIterator2(iterator, callback, rejectCallback) {
      let $return;
      let abruptClose;
      if (typeof iterator.return === "function") {
        $return = iterator.return;
        abruptClose = (error) => {
          const rethrow = () => Promise.reject(error);
          return $return.call(iterator).then(rethrow, rethrow);
        };
      }
      function mapResult(result) {
        return result.done ? result : asyncMapValue(result.value, callback).then(iteratorResult, abruptClose);
      }
      let mapReject;
      if (rejectCallback) {
        const reject = rejectCallback;
        mapReject = (error) => asyncMapValue(error, reject).then(iteratorResult, abruptClose);
      }
      return {
        next() {
          return iterator.next().then(mapResult, mapReject);
        },
        return() {
          return $return ? $return.call(iterator).then(mapResult, mapReject) : Promise.resolve({ value: void 0, done: true });
        },
        throw(error) {
          if (typeof iterator.throw === "function") {
            return iterator.throw(error).then(mapResult, mapReject);
          }
          return Promise.reject(error).catch(abruptClose);
        },
        [Symbol.asyncIterator]() {
          return this;
        }
      };
    }
    exports2.mapAsyncIterator = mapAsyncIterator2;
    function asyncMapValue(value, callback) {
      return new Promise((resolve) => resolve(callback(value)));
    }
    function iteratorResult(value) {
      return { value, done: false };
    }
  }
});

// ../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/updateArgument.js
var require_updateArgument2 = __commonJS({
  "../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/updateArgument.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createVariableNameGenerator = exports2.updateArgument = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var astFromType_js_1 = require_astFromType2();
    function updateArgument(argumentNodes, variableDefinitionsMap, variableValues, argName, varName, type, value) {
      argumentNodes[argName] = {
        kind: graphql_1.Kind.ARGUMENT,
        name: {
          kind: graphql_1.Kind.NAME,
          value: argName
        },
        value: {
          kind: graphql_1.Kind.VARIABLE,
          name: {
            kind: graphql_1.Kind.NAME,
            value: varName
          }
        }
      };
      variableDefinitionsMap[varName] = {
        kind: graphql_1.Kind.VARIABLE_DEFINITION,
        variable: {
          kind: graphql_1.Kind.VARIABLE,
          name: {
            kind: graphql_1.Kind.NAME,
            value: varName
          }
        },
        type: (0, astFromType_js_1.astFromType)(type)
      };
      if (value !== void 0) {
        variableValues[varName] = value;
        return;
      }
      if (varName in variableValues) {
        delete variableValues[varName];
      }
    }
    exports2.updateArgument = updateArgument;
    function createVariableNameGenerator(variableDefinitionMap) {
      let varCounter = 0;
      return (argName) => {
        let varName;
        do {
          varName = `_v${(varCounter++).toString()}_${argName}`;
        } while (varName in variableDefinitionMap);
        return varName;
      };
    }
    exports2.createVariableNameGenerator = createVariableNameGenerator;
  }
});

// ../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/implementsAbstractType.js
var require_implementsAbstractType2 = __commonJS({
  "../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/implementsAbstractType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.implementsAbstractType = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function implementsAbstractType(schema, typeA, typeB) {
      if (typeB == null || typeA == null) {
        return false;
      } else if (typeA === typeB) {
        return true;
      } else if ((0, graphql_1.isCompositeType)(typeA) && (0, graphql_1.isCompositeType)(typeB)) {
        return (0, graphql_1.doTypesOverlap)(schema, typeA, typeB);
      }
      return false;
    }
    exports2.implementsAbstractType = implementsAbstractType;
  }
});

// ../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/observableToAsyncIterable.js
var require_observableToAsyncIterable2 = __commonJS({
  "../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/observableToAsyncIterable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.observableToAsyncIterable = void 0;
    function observableToAsyncIterable(observable) {
      const pullQueue = [];
      const pushQueue = [];
      let listening = true;
      const pushValue = (value) => {
        if (pullQueue.length !== 0) {
          pullQueue.shift()({ value, done: false });
        } else {
          pushQueue.push({ value, done: false });
        }
      };
      const pushError = (error) => {
        if (pullQueue.length !== 0) {
          pullQueue.shift()({ value: { errors: [error] }, done: false });
        } else {
          pushQueue.push({ value: { errors: [error] }, done: false });
        }
      };
      const pushDone = () => {
        if (pullQueue.length !== 0) {
          pullQueue.shift()({ done: true });
        } else {
          pushQueue.push({ done: true });
        }
      };
      const pullValue = () => new Promise((resolve) => {
        if (pushQueue.length !== 0) {
          const element = pushQueue.shift();
          resolve(element);
        } else {
          pullQueue.push(resolve);
        }
      });
      const subscription = observable.subscribe({
        next(value) {
          pushValue(value);
        },
        error(err) {
          pushError(err);
        },
        complete() {
          pushDone();
        }
      });
      const emptyQueue = () => {
        if (listening) {
          listening = false;
          subscription.unsubscribe();
          for (const resolve of pullQueue) {
            resolve({ value: void 0, done: true });
          }
          pullQueue.length = 0;
          pushQueue.length = 0;
        }
      };
      return {
        next() {
          return listening ? pullValue() : this.return();
        },
        return() {
          emptyQueue();
          return Promise.resolve({ value: void 0, done: true });
        },
        throw(error) {
          emptyQueue();
          return Promise.reject(error);
        },
        [Symbol.asyncIterator]() {
          return this;
        }
      };
    }
    exports2.observableToAsyncIterable = observableToAsyncIterable;
  }
});

// ../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/getOperationASTFromRequest.js
var require_getOperationASTFromRequest2 = __commonJS({
  "../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/getOperationASTFromRequest.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getOperationASTFromRequest = exports2.getOperationASTFromDocument = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var memoize_js_1 = require_memoize2();
    function getOperationASTFromDocument(documentNode, operationName) {
      const doc = (0, graphql_1.getOperationAST)(documentNode, operationName);
      if (!doc) {
        throw new Error(`Cannot infer operation ${operationName || ""}`);
      }
      return doc;
    }
    exports2.getOperationASTFromDocument = getOperationASTFromDocument;
    exports2.getOperationASTFromRequest = (0, memoize_js_1.memoize1)(function getOperationASTFromRequest(request) {
      return getOperationASTFromDocument(request.document, request.operationName);
    });
  }
});

// ../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/collectFields.js
var require_collectFields2 = __commonJS({
  "../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/collectFields.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.collectSubFields = exports2.collectFields = void 0;
    var memoize_js_1 = require_memoize2();
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function collectFields2(schema, fragments, variableValues, runtimeType, selectionSet, fields, visitedFragmentNames) {
      for (const selection of selectionSet.selections) {
        switch (selection.kind) {
          case graphql_1.Kind.FIELD: {
            if (!shouldIncludeNode2(variableValues, selection)) {
              continue;
            }
            const name = getFieldEntryKey2(selection);
            const fieldList = fields.get(name);
            if (fieldList !== void 0) {
              fieldList.push(selection);
            } else {
              fields.set(name, [selection]);
            }
            break;
          }
          case graphql_1.Kind.INLINE_FRAGMENT: {
            if (!shouldIncludeNode2(variableValues, selection) || !doesFragmentConditionMatch2(schema, selection, runtimeType)) {
              continue;
            }
            collectFields2(schema, fragments, variableValues, runtimeType, selection.selectionSet, fields, visitedFragmentNames);
            break;
          }
          case graphql_1.Kind.FRAGMENT_SPREAD: {
            const fragName = selection.name.value;
            if (visitedFragmentNames.has(fragName) || !shouldIncludeNode2(variableValues, selection)) {
              continue;
            }
            visitedFragmentNames.add(fragName);
            const fragment = fragments[fragName];
            if (!fragment || !doesFragmentConditionMatch2(schema, fragment, runtimeType)) {
              continue;
            }
            collectFields2(schema, fragments, variableValues, runtimeType, fragment.selectionSet, fields, visitedFragmentNames);
            break;
          }
        }
      }
      return fields;
    }
    exports2.collectFields = collectFields2;
    function shouldIncludeNode2(variableValues, node) {
      const skip = (0, graphql_1.getDirectiveValues)(graphql_1.GraphQLSkipDirective, node, variableValues);
      if ((skip === null || skip === void 0 ? void 0 : skip["if"]) === true) {
        return false;
      }
      const include = (0, graphql_1.getDirectiveValues)(graphql_1.GraphQLIncludeDirective, node, variableValues);
      if ((include === null || include === void 0 ? void 0 : include["if"]) === false) {
        return false;
      }
      return true;
    }
    function doesFragmentConditionMatch2(schema, fragment, type) {
      const typeConditionNode = fragment.typeCondition;
      if (!typeConditionNode) {
        return true;
      }
      const conditionalType = (0, graphql_1.typeFromAST)(schema, typeConditionNode);
      if (conditionalType === type) {
        return true;
      }
      if ((0, graphql_1.isAbstractType)(conditionalType)) {
        const possibleTypes = schema.getPossibleTypes(conditionalType);
        return possibleTypes.includes(type);
      }
      return false;
    }
    function getFieldEntryKey2(node) {
      return node.alias ? node.alias.value : node.name.value;
    }
    exports2.collectSubFields = (0, memoize_js_1.memoize5)(function collectSubFields(schema, fragments, variableValues, type, fieldNodes) {
      const subFieldNodes = /* @__PURE__ */ new Map();
      const visitedFragmentNames = /* @__PURE__ */ new Set();
      for (const fieldNode of fieldNodes) {
        if (fieldNode.selectionSet) {
          collectFields2(schema, fragments, variableValues, type, fieldNode.selectionSet, subFieldNodes, visitedFragmentNames);
        }
      }
      return subFieldNodes;
    });
  }
});

// ../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/visitResult.js
var require_visitResult2 = __commonJS({
  "../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/visitResult.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.visitResult = exports2.visitErrors = exports2.visitData = void 0;
    var getOperationASTFromRequest_js_1 = require_getOperationASTFromRequest2();
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var collectFields_js_1 = require_collectFields2();
    function visitData(data, enter, leave) {
      if (Array.isArray(data)) {
        return data.map((value) => visitData(value, enter, leave));
      } else if (typeof data === "object") {
        const newData = enter != null ? enter(data) : data;
        if (newData != null) {
          for (const key in newData) {
            const value = newData[key];
            Object.defineProperty(newData, key, {
              value: visitData(value, enter, leave)
            });
          }
        }
        return leave != null ? leave(newData) : newData;
      }
      return data;
    }
    exports2.visitData = visitData;
    function visitErrors(errors, visitor) {
      return errors.map((error) => visitor(error));
    }
    exports2.visitErrors = visitErrors;
    function visitResult(result, request, schema, resultVisitorMap, errorVisitorMap) {
      const fragments = request.document.definitions.reduce((acc, def) => {
        if (def.kind === graphql_1.Kind.FRAGMENT_DEFINITION) {
          acc[def.name.value] = def;
        }
        return acc;
      }, {});
      const variableValues = request.variables || {};
      const errorInfo = {
        segmentInfoMap: /* @__PURE__ */ new Map(),
        unpathedErrors: /* @__PURE__ */ new Set()
      };
      const data = result.data;
      const errors = result.errors;
      const visitingErrors = errors != null && errorVisitorMap != null;
      const operationDocumentNode = (0, getOperationASTFromRequest_js_1.getOperationASTFromRequest)(request);
      if (data != null && operationDocumentNode != null) {
        result.data = visitRoot(data, operationDocumentNode, schema, fragments, variableValues, resultVisitorMap, visitingErrors ? errors : void 0, errorInfo);
      }
      if (errors != null && errorVisitorMap) {
        result.errors = visitErrorsByType(errors, errorVisitorMap, errorInfo);
      }
      return result;
    }
    exports2.visitResult = visitResult;
    function visitErrorsByType(errors, errorVisitorMap, errorInfo) {
      const segmentInfoMap = errorInfo.segmentInfoMap;
      const unpathedErrors = errorInfo.unpathedErrors;
      const unpathedErrorVisitor = errorVisitorMap["__unpathed"];
      return errors.map((originalError) => {
        const pathSegmentsInfo = segmentInfoMap.get(originalError);
        const newError = pathSegmentsInfo == null ? originalError : pathSegmentsInfo.reduceRight((acc, segmentInfo) => {
          const typeName = segmentInfo.type.name;
          const typeVisitorMap = errorVisitorMap[typeName];
          if (typeVisitorMap == null) {
            return acc;
          }
          const errorVisitor = typeVisitorMap[segmentInfo.fieldName];
          return errorVisitor == null ? acc : errorVisitor(acc, segmentInfo.pathIndex);
        }, originalError);
        if (unpathedErrorVisitor && unpathedErrors.has(originalError)) {
          return unpathedErrorVisitor(newError);
        }
        return newError;
      });
    }
    function getOperationRootType2(schema, operationDef) {
      switch (operationDef.operation) {
        case "query":
          return schema.getQueryType();
        case "mutation":
          return schema.getMutationType();
        case "subscription":
          return schema.getSubscriptionType();
      }
    }
    function visitRoot(root, operation, schema, fragments, variableValues, resultVisitorMap, errors, errorInfo) {
      const operationRootType = getOperationRootType2(schema, operation);
      const collectedFields = (0, collectFields_js_1.collectFields)(schema, fragments, variableValues, operationRootType, operation.selectionSet, /* @__PURE__ */ new Map(), /* @__PURE__ */ new Set());
      return visitObjectValue(root, operationRootType, collectedFields, schema, fragments, variableValues, resultVisitorMap, 0, errors, errorInfo);
    }
    function visitObjectValue(object, type, fieldNodeMap, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo) {
      var _a;
      const fieldMap = type.getFields();
      const typeVisitorMap = resultVisitorMap === null || resultVisitorMap === void 0 ? void 0 : resultVisitorMap[type.name];
      const enterObject = typeVisitorMap === null || typeVisitorMap === void 0 ? void 0 : typeVisitorMap.__enter;
      const newObject = enterObject != null ? enterObject(object) : object;
      let sortedErrors;
      let errorMap = null;
      if (errors != null) {
        sortedErrors = sortErrorsByPathSegment(errors, pathIndex);
        errorMap = sortedErrors.errorMap;
        for (const error of sortedErrors.unpathedErrors) {
          errorInfo.unpathedErrors.add(error);
        }
      }
      for (const [responseKey, subFieldNodes] of fieldNodeMap) {
        const fieldName = subFieldNodes[0].name.value;
        let fieldType = (_a = fieldMap[fieldName]) === null || _a === void 0 ? void 0 : _a.type;
        if (fieldType == null) {
          switch (fieldName) {
            case "__typename":
              fieldType = graphql_1.TypeNameMetaFieldDef.type;
              break;
            case "__schema":
              fieldType = graphql_1.SchemaMetaFieldDef.type;
              break;
          }
        }
        const newPathIndex = pathIndex + 1;
        let fieldErrors;
        if (errorMap) {
          fieldErrors = errorMap[responseKey];
          if (fieldErrors != null) {
            delete errorMap[responseKey];
          }
          addPathSegmentInfo(type, fieldName, newPathIndex, fieldErrors, errorInfo);
        }
        const newValue = visitFieldValue(object[responseKey], fieldType, subFieldNodes, schema, fragments, variableValues, resultVisitorMap, newPathIndex, fieldErrors, errorInfo);
        updateObject(newObject, responseKey, newValue, typeVisitorMap, fieldName);
      }
      const oldTypename = newObject.__typename;
      if (oldTypename != null) {
        updateObject(newObject, "__typename", oldTypename, typeVisitorMap, "__typename");
      }
      if (errorMap) {
        for (const errorsKey in errorMap) {
          const errors2 = errorMap[errorsKey];
          for (const error of errors2) {
            errorInfo.unpathedErrors.add(error);
          }
        }
      }
      const leaveObject = typeVisitorMap === null || typeVisitorMap === void 0 ? void 0 : typeVisitorMap.__leave;
      return leaveObject != null ? leaveObject(newObject) : newObject;
    }
    function updateObject(object, responseKey, newValue, typeVisitorMap, fieldName) {
      if (typeVisitorMap == null) {
        object[responseKey] = newValue;
        return;
      }
      const fieldVisitor = typeVisitorMap[fieldName];
      if (fieldVisitor == null) {
        object[responseKey] = newValue;
        return;
      }
      const visitedValue = fieldVisitor(newValue);
      if (visitedValue === void 0) {
        delete object[responseKey];
        return;
      }
      object[responseKey] = visitedValue;
    }
    function visitListValue(list, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo) {
      return list.map((listMember) => visitFieldValue(listMember, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex + 1, errors, errorInfo));
    }
    function visitFieldValue(value, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors = [], errorInfo) {
      if (value == null) {
        return value;
      }
      const nullableType = (0, graphql_1.getNullableType)(returnType);
      if ((0, graphql_1.isListType)(nullableType)) {
        return visitListValue(value, nullableType.ofType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);
      } else if ((0, graphql_1.isAbstractType)(nullableType)) {
        const finalType = schema.getType(value.__typename);
        const collectedFields = (0, collectFields_js_1.collectSubFields)(schema, fragments, variableValues, finalType, fieldNodes);
        return visitObjectValue(value, finalType, collectedFields, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);
      } else if ((0, graphql_1.isObjectType)(nullableType)) {
        const collectedFields = (0, collectFields_js_1.collectSubFields)(schema, fragments, variableValues, nullableType, fieldNodes);
        return visitObjectValue(value, nullableType, collectedFields, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);
      }
      const typeVisitorMap = resultVisitorMap === null || resultVisitorMap === void 0 ? void 0 : resultVisitorMap[nullableType.name];
      if (typeVisitorMap == null) {
        return value;
      }
      const visitedValue = typeVisitorMap(value);
      return visitedValue === void 0 ? value : visitedValue;
    }
    function sortErrorsByPathSegment(errors, pathIndex) {
      var _a;
      const errorMap = /* @__PURE__ */ Object.create(null);
      const unpathedErrors = /* @__PURE__ */ new Set();
      for (const error of errors) {
        const pathSegment = (_a = error.path) === null || _a === void 0 ? void 0 : _a[pathIndex];
        if (pathSegment == null) {
          unpathedErrors.add(error);
          continue;
        }
        if (pathSegment in errorMap) {
          errorMap[pathSegment].push(error);
        } else {
          errorMap[pathSegment] = [error];
        }
      }
      return {
        errorMap,
        unpathedErrors
      };
    }
    function addPathSegmentInfo(type, fieldName, pathIndex, errors = [], errorInfo) {
      for (const error of errors) {
        const segmentInfo = {
          type,
          fieldName,
          pathIndex
        };
        const pathSegmentsInfo = errorInfo.segmentInfoMap.get(error);
        if (pathSegmentsInfo == null) {
          errorInfo.segmentInfoMap.set(error, [segmentInfo]);
        } else {
          pathSegmentsInfo.push(segmentInfo);
        }
      }
    }
  }
});

// ../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/valueMatchesCriteria.js
var require_valueMatchesCriteria2 = __commonJS({
  "../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/valueMatchesCriteria.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.valueMatchesCriteria = void 0;
    function valueMatchesCriteria(value, criteria) {
      if (value == null) {
        return value === criteria;
      } else if (Array.isArray(value)) {
        return Array.isArray(criteria) && value.every((val, index) => valueMatchesCriteria(val, criteria[index]));
      } else if (typeof value === "object") {
        return typeof criteria === "object" && criteria && Object.keys(criteria).every((propertyName) => valueMatchesCriteria(value[propertyName], criteria[propertyName]));
      } else if (criteria instanceof RegExp) {
        return criteria.test(value);
      }
      return value === criteria;
    }
    exports2.valueMatchesCriteria = valueMatchesCriteria;
  }
});

// ../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/isAsyncIterable.js
var require_isAsyncIterable2 = __commonJS({
  "../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/isAsyncIterable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isAsyncIterable = void 0;
    function isAsyncIterable2(value) {
      return typeof value === "object" && value != null && Symbol.asyncIterator in value && typeof value[Symbol.asyncIterator] === "function";
    }
    exports2.isAsyncIterable = isAsyncIterable2;
  }
});

// ../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/isDocumentNode.js
var require_isDocumentNode2 = __commonJS({
  "../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/isDocumentNode.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isDocumentNode = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function isDocumentNode(object) {
      return object && typeof object === "object" && "kind" in object && object.kind === graphql_1.Kind.DOCUMENT;
    }
    exports2.isDocumentNode = isDocumentNode;
  }
});

// ../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/executor.js
var require_executor2 = __commonJS({
  "../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/executor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/withCancel.js
var require_withCancel2 = __commonJS({
  "../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/withCancel.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.withCancel = exports2.getAsyncIterableWithCancel = exports2.getAsyncIteratorWithCancel = void 0;
    var memoize_js_1 = require_memoize2();
    async function defaultAsyncIteratorReturn(value) {
      return { value, done: true };
    }
    var proxyMethodFactory = (0, memoize_js_1.memoize2)(function proxyMethodFactory2(target, targetMethod) {
      return function proxyMethod(...args) {
        return Reflect.apply(targetMethod, target, args);
      };
    });
    function getAsyncIteratorWithCancel(asyncIterator, onCancel) {
      return new Proxy(asyncIterator, {
        has(asyncIterator2, prop) {
          if (prop === "return") {
            return true;
          }
          return Reflect.has(asyncIterator2, prop);
        },
        get(asyncIterator2, prop, receiver) {
          const existingPropValue = Reflect.get(asyncIterator2, prop, receiver);
          if (prop === "return") {
            const existingReturn = existingPropValue || defaultAsyncIteratorReturn;
            return async function returnWithCancel(value) {
              const returnValue = await onCancel(value);
              return Reflect.apply(existingReturn, asyncIterator2, [returnValue]);
            };
          } else if (typeof existingPropValue === "function") {
            return proxyMethodFactory(asyncIterator2, existingPropValue);
          }
          return existingPropValue;
        }
      });
    }
    exports2.getAsyncIteratorWithCancel = getAsyncIteratorWithCancel;
    function getAsyncIterableWithCancel(asyncIterable, onCancel) {
      return new Proxy(asyncIterable, {
        get(asyncIterable2, prop, receiver) {
          const existingPropValue = Reflect.get(asyncIterable2, prop, receiver);
          if (Symbol.asyncIterator === prop) {
            return function asyncIteratorFactory() {
              const asyncIterator = Reflect.apply(existingPropValue, asyncIterable2, []);
              return getAsyncIteratorWithCancel(asyncIterator, onCancel);
            };
          } else if (typeof existingPropValue === "function") {
            return proxyMethodFactory(asyncIterable2, existingPropValue);
          }
          return existingPropValue;
        }
      });
    }
    exports2.getAsyncIterableWithCancel = getAsyncIterableWithCancel;
    exports2.withCancel = getAsyncIterableWithCancel;
  }
});

// ../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/fixSchemaAst.js
var require_fixSchemaAst2 = __commonJS({
  "../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/fixSchemaAst.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fixSchemaAst = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var print_schema_with_directives_js_1 = require_print_schema_with_directives2();
    function buildFixedSchema(schema, options) {
      const document2 = (0, print_schema_with_directives_js_1.getDocumentNodeFromSchema)(schema);
      return (0, graphql_1.buildASTSchema)(document2, {
        ...options || {}
      });
    }
    function fixSchemaAst(schema, options) {
      let schemaWithValidAst = void 0;
      if (!schema.astNode || !schema.extensionASTNodes) {
        schemaWithValidAst = buildFixedSchema(schema, options);
      }
      if (!schema.astNode && (schemaWithValidAst === null || schemaWithValidAst === void 0 ? void 0 : schemaWithValidAst.astNode)) {
        schema.astNode = schemaWithValidAst.astNode;
      }
      if (!schema.extensionASTNodes && (schemaWithValidAst === null || schemaWithValidAst === void 0 ? void 0 : schemaWithValidAst.astNode)) {
        schema.extensionASTNodes = schemaWithValidAst.extensionASTNodes;
      }
      return schema;
    }
    exports2.fixSchemaAst = fixSchemaAst;
  }
});

// ../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/index.js
var require_cjs5 = __commonJS({
  "../../../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_loaders2(), exports2);
    tslib_1.__exportStar(require_helpers2(), exports2);
    tslib_1.__exportStar(require_get_directives2(), exports2);
    tslib_1.__exportStar(require_get_fields_with_directives2(), exports2);
    tslib_1.__exportStar(require_get_implementing_types2(), exports2);
    tslib_1.__exportStar(require_print_schema_with_directives2(), exports2);
    tslib_1.__exportStar(require_get_fields_with_directives2(), exports2);
    tslib_1.__exportStar(require_validate_documents2(), exports2);
    tslib_1.__exportStar(require_parse_graphql_json2(), exports2);
    tslib_1.__exportStar(require_parse_graphql_sdl2(), exports2);
    tslib_1.__exportStar(require_build_operation_for_field2(), exports2);
    tslib_1.__exportStar(require_types4(), exports2);
    tslib_1.__exportStar(require_filterSchema2(), exports2);
    tslib_1.__exportStar(require_heal2(), exports2);
    tslib_1.__exportStar(require_getResolversFromSchema2(), exports2);
    tslib_1.__exportStar(require_forEachField2(), exports2);
    tslib_1.__exportStar(require_forEachDefaultValue2(), exports2);
    tslib_1.__exportStar(require_mapSchema2(), exports2);
    tslib_1.__exportStar(require_addTypes2(), exports2);
    tslib_1.__exportStar(require_rewire2(), exports2);
    tslib_1.__exportStar(require_prune2(), exports2);
    tslib_1.__exportStar(require_mergeDeep2(), exports2);
    tslib_1.__exportStar(require_Interfaces2(), exports2);
    tslib_1.__exportStar(require_stub2(), exports2);
    tslib_1.__exportStar(require_selectionSets2(), exports2);
    tslib_1.__exportStar(require_getResponseKeyFromInfo2(), exports2);
    tslib_1.__exportStar(require_fields3(), exports2);
    tslib_1.__exportStar(require_renameType2(), exports2);
    tslib_1.__exportStar(require_transformInputValue2(), exports2);
    tslib_1.__exportStar(require_mapAsyncIterator2(), exports2);
    tslib_1.__exportStar(require_updateArgument2(), exports2);
    tslib_1.__exportStar(require_implementsAbstractType2(), exports2);
    tslib_1.__exportStar(require_errors2(), exports2);
    tslib_1.__exportStar(require_observableToAsyncIterable2(), exports2);
    tslib_1.__exportStar(require_visitResult2(), exports2);
    tslib_1.__exportStar(require_getArgumentValues2(), exports2);
    tslib_1.__exportStar(require_valueMatchesCriteria2(), exports2);
    tslib_1.__exportStar(require_isAsyncIterable2(), exports2);
    tslib_1.__exportStar(require_isDocumentNode2(), exports2);
    tslib_1.__exportStar(require_astFromValueUntyped2(), exports2);
    tslib_1.__exportStar(require_executor2(), exports2);
    tslib_1.__exportStar(require_withCancel2(), exports2);
    tslib_1.__exportStar(require_AggregateError2(), exports2);
    tslib_1.__exportStar(require_rootTypes2(), exports2);
    tslib_1.__exportStar(require_comments2(), exports2);
    tslib_1.__exportStar(require_collectFields2(), exports2);
    tslib_1.__exportStar(require_inspect2(), exports2);
    tslib_1.__exportStar(require_memoize2(), exports2);
    tslib_1.__exportStar(require_fixSchemaAst2(), exports2);
    tslib_1.__exportStar(require_getOperationASTFromRequest2(), exports2);
  }
});

// ../../../node_modules/@graphql-tools/schema/cjs/assertResolversPresent.js
var require_assertResolversPresent2 = __commonJS({
  "../../../node_modules/@graphql-tools/schema/cjs/assertResolversPresent.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.assertResolversPresent = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var utils_1 = require_cjs5();
    function assertResolversPresent(schema, resolverValidationOptions = {}) {
      const { requireResolversForArgs, requireResolversForNonScalar, requireResolversForAllFields } = resolverValidationOptions;
      if (requireResolversForAllFields && (requireResolversForArgs || requireResolversForNonScalar)) {
        throw new TypeError("requireResolversForAllFields takes precedence over the more specific assertions. Please configure either requireResolversForAllFields or requireResolversForArgs / requireResolversForNonScalar, but not a combination of them.");
      }
      (0, utils_1.forEachField)(schema, (field, typeName, fieldName) => {
        if (requireResolversForAllFields) {
          expectResolver("requireResolversForAllFields", requireResolversForAllFields, field, typeName, fieldName);
        }
        if (requireResolversForArgs && field.args.length > 0) {
          expectResolver("requireResolversForArgs", requireResolversForArgs, field, typeName, fieldName);
        }
        if (requireResolversForNonScalar !== "ignore" && !(0, graphql_1.isScalarType)((0, graphql_1.getNamedType)(field.type))) {
          expectResolver("requireResolversForNonScalar", requireResolversForNonScalar, field, typeName, fieldName);
        }
      });
    }
    exports2.assertResolversPresent = assertResolversPresent;
    function expectResolver(validator, behavior, field, typeName, fieldName) {
      if (!field.resolve) {
        const message = `Resolver missing for "${typeName}.${fieldName}".
To disable this validator, use:
  resolverValidationOptions: {
    ${validator}: 'ignore'
  }`;
        if (behavior === "error") {
          throw new Error(message);
        }
        if (behavior === "warn") {
          console.warn(message);
        }
        return;
      }
      if (typeof field.resolve !== "function") {
        throw new Error(`Resolver "${typeName}.${fieldName}" must be a function`);
      }
    }
  }
});

// ../../../node_modules/@graphql-tools/schema/cjs/chainResolvers.js
var require_chainResolvers2 = __commonJS({
  "../../../node_modules/@graphql-tools/schema/cjs/chainResolvers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.chainResolvers = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function chainResolvers(resolvers) {
      return (root, args, ctx, info) => resolvers.reduce((prev, curResolver) => {
        if (curResolver != null) {
          return curResolver(prev, args, ctx, info);
        }
        return (0, graphql_1.defaultFieldResolver)(prev, args, ctx, info);
      }, root);
    }
    exports2.chainResolvers = chainResolvers;
  }
});

// ../../../node_modules/@graphql-tools/schema/cjs/checkForResolveTypeResolver.js
var require_checkForResolveTypeResolver2 = __commonJS({
  "../../../node_modules/@graphql-tools/schema/cjs/checkForResolveTypeResolver.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.checkForResolveTypeResolver = void 0;
    var utils_1 = require_cjs5();
    function checkForResolveTypeResolver(schema, requireResolversForResolveType) {
      (0, utils_1.mapSchema)(schema, {
        [utils_1.MapperKind.ABSTRACT_TYPE]: (type) => {
          if (!type.resolveType) {
            const message = `Type "${type.name}" is missing a "__resolveType" resolver. Pass 'ignore' into "resolverValidationOptions.requireResolversForResolveType" to disable this error.`;
            if (requireResolversForResolveType === "error") {
              throw new Error(message);
            }
            if (requireResolversForResolveType === "warn") {
              console.warn(message);
            }
          }
          return void 0;
        }
      });
    }
    exports2.checkForResolveTypeResolver = checkForResolveTypeResolver;
  }
});

// ../../../node_modules/@graphql-tools/schema/cjs/extendResolversFromInterfaces.js
var require_extendResolversFromInterfaces2 = __commonJS({
  "../../../node_modules/@graphql-tools/schema/cjs/extendResolversFromInterfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.extendResolversFromInterfaces = void 0;
    function extendResolversFromInterfaces(schema, resolvers) {
      const extendedResolvers = {};
      const typeMap = schema.getTypeMap();
      for (const typeName in typeMap) {
        const type = typeMap[typeName];
        if ("getInterfaces" in type) {
          extendedResolvers[typeName] = {};
          for (const iFace of type.getInterfaces()) {
            if (resolvers[iFace.name]) {
              for (const fieldName in resolvers[iFace.name]) {
                if (fieldName === "__isTypeOf" || !fieldName.startsWith("__")) {
                  extendedResolvers[typeName][fieldName] = resolvers[iFace.name][fieldName];
                }
              }
            }
          }
          const typeResolvers = resolvers[typeName];
          extendedResolvers[typeName] = {
            ...extendedResolvers[typeName],
            ...typeResolvers
          };
        } else {
          const typeResolvers = resolvers[typeName];
          if (typeResolvers != null) {
            extendedResolvers[typeName] = typeResolvers;
          }
        }
      }
      return extendedResolvers;
    }
    exports2.extendResolversFromInterfaces = extendResolversFromInterfaces;
  }
});

// ../../../node_modules/@graphql-tools/schema/cjs/addResolversToSchema.js
var require_addResolversToSchema2 = __commonJS({
  "../../../node_modules/@graphql-tools/schema/cjs/addResolversToSchema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.addResolversToSchema = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var utils_1 = require_cjs5();
    var checkForResolveTypeResolver_js_1 = require_checkForResolveTypeResolver2();
    var extendResolversFromInterfaces_js_1 = require_extendResolversFromInterfaces2();
    function addResolversToSchema(schemaOrOptions, legacyInputResolvers, legacyInputValidationOptions) {
      const options = (0, graphql_1.isSchema)(schemaOrOptions) ? {
        schema: schemaOrOptions,
        resolvers: legacyInputResolvers !== null && legacyInputResolvers !== void 0 ? legacyInputResolvers : {},
        resolverValidationOptions: legacyInputValidationOptions
      } : schemaOrOptions;
      let { schema, resolvers: inputResolvers, defaultFieldResolver: defaultFieldResolver2, resolverValidationOptions = {}, inheritResolversFromInterfaces = false, updateResolversInPlace = false } = options;
      const { requireResolversToMatchSchema = "error", requireResolversForResolveType } = resolverValidationOptions;
      const resolvers = inheritResolversFromInterfaces ? (0, extendResolversFromInterfaces_js_1.extendResolversFromInterfaces)(schema, inputResolvers) : inputResolvers;
      for (const typeName in resolvers) {
        const resolverValue = resolvers[typeName];
        const resolverType = typeof resolverValue;
        if (resolverType !== "object") {
          throw new Error(`"${typeName}" defined in resolvers, but has invalid value "${resolverValue}". The resolver's value must be of type object.`);
        }
        const type = schema.getType(typeName);
        if (type == null) {
          if (requireResolversToMatchSchema === "ignore") {
            continue;
          }
          throw new Error(`"${typeName}" defined in resolvers, but not in schema`);
        } else if ((0, graphql_1.isSpecifiedScalarType)(type)) {
          for (const fieldName in resolverValue) {
            if (fieldName.startsWith("__")) {
              type[fieldName.substring(2)] = resolverValue[fieldName];
            } else {
              type[fieldName] = resolverValue[fieldName];
            }
          }
        } else if ((0, graphql_1.isEnumType)(type)) {
          const values = type.getValues();
          for (const fieldName in resolverValue) {
            if (!fieldName.startsWith("__") && !values.some((value) => value.name === fieldName) && requireResolversToMatchSchema && requireResolversToMatchSchema !== "ignore") {
              throw new Error(`${type.name}.${fieldName} was defined in resolvers, but not present within ${type.name}`);
            }
          }
        } else if ((0, graphql_1.isUnionType)(type)) {
          for (const fieldName in resolverValue) {
            if (!fieldName.startsWith("__") && requireResolversToMatchSchema && requireResolversToMatchSchema !== "ignore") {
              throw new Error(`${type.name}.${fieldName} was defined in resolvers, but ${type.name} is not an object or interface type`);
            }
          }
        } else if ((0, graphql_1.isObjectType)(type) || (0, graphql_1.isInterfaceType)(type)) {
          for (const fieldName in resolverValue) {
            if (!fieldName.startsWith("__")) {
              const fields = type.getFields();
              const field = fields[fieldName];
              if (field == null) {
                if (requireResolversToMatchSchema && requireResolversToMatchSchema !== "ignore") {
                  throw new Error(`${typeName}.${fieldName} defined in resolvers, but not in schema`);
                }
              } else {
                const fieldResolve = resolverValue[fieldName];
                if (typeof fieldResolve !== "function" && typeof fieldResolve !== "object") {
                  throw new Error(`Resolver ${typeName}.${fieldName} must be object or function`);
                }
              }
            }
          }
        }
      }
      schema = updateResolversInPlace ? addResolversToExistingSchema(schema, resolvers, defaultFieldResolver2) : createNewSchemaWithResolvers(schema, resolvers, defaultFieldResolver2);
      if (requireResolversForResolveType && requireResolversForResolveType !== "ignore") {
        (0, checkForResolveTypeResolver_js_1.checkForResolveTypeResolver)(schema, requireResolversForResolveType);
      }
      return schema;
    }
    exports2.addResolversToSchema = addResolversToSchema;
    function addResolversToExistingSchema(schema, resolvers, defaultFieldResolver2) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
      const typeMap = schema.getTypeMap();
      for (const typeName in resolvers) {
        const type = schema.getType(typeName);
        const resolverValue = resolvers[typeName];
        if ((0, graphql_1.isScalarType)(type)) {
          for (const fieldName in resolverValue) {
            if (fieldName.startsWith("__")) {
              type[fieldName.substring(2)] = resolverValue[fieldName];
            } else if (fieldName === "astNode" && type.astNode != null) {
              type.astNode = {
                ...type.astNode,
                description: (_b = (_a = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.astNode.description,
                directives: ((_c = type.astNode.directives) !== null && _c !== void 0 ? _c : []).concat((_e = (_d = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _d === void 0 ? void 0 : _d.directives) !== null && _e !== void 0 ? _e : [])
              };
            } else if (fieldName === "extensionASTNodes" && type.extensionASTNodes != null) {
              type.extensionASTNodes = type.extensionASTNodes.concat((_f = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _f !== void 0 ? _f : []);
            } else if (fieldName === "extensions" && type.extensions != null && resolverValue.extensions != null) {
              type.extensions = Object.assign(/* @__PURE__ */ Object.create(null), type.extensions, resolverValue.extensions);
            } else {
              type[fieldName] = resolverValue[fieldName];
            }
          }
        } else if ((0, graphql_1.isEnumType)(type)) {
          const config = type.toConfig();
          const enumValueConfigMap = config.values;
          for (const fieldName in resolverValue) {
            if (fieldName.startsWith("__")) {
              config[fieldName.substring(2)] = resolverValue[fieldName];
            } else if (fieldName === "astNode" && config.astNode != null) {
              config.astNode = {
                ...config.astNode,
                description: (_h = (_g = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _g === void 0 ? void 0 : _g.description) !== null && _h !== void 0 ? _h : config.astNode.description,
                directives: ((_j = config.astNode.directives) !== null && _j !== void 0 ? _j : []).concat((_l = (_k = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _k === void 0 ? void 0 : _k.directives) !== null && _l !== void 0 ? _l : [])
              };
            } else if (fieldName === "extensionASTNodes" && config.extensionASTNodes != null) {
              config.extensionASTNodes = config.extensionASTNodes.concat((_m = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _m !== void 0 ? _m : []);
            } else if (fieldName === "extensions" && type.extensions != null && resolverValue.extensions != null) {
              type.extensions = Object.assign(/* @__PURE__ */ Object.create(null), type.extensions, resolverValue.extensions);
            } else if (enumValueConfigMap[fieldName]) {
              enumValueConfigMap[fieldName].value = resolverValue[fieldName];
            }
          }
          typeMap[typeName] = new graphql_1.GraphQLEnumType(config);
        } else if ((0, graphql_1.isUnionType)(type)) {
          for (const fieldName in resolverValue) {
            if (fieldName.startsWith("__")) {
              type[fieldName.substring(2)] = resolverValue[fieldName];
            }
          }
        } else if ((0, graphql_1.isObjectType)(type) || (0, graphql_1.isInterfaceType)(type)) {
          for (const fieldName in resolverValue) {
            if (fieldName.startsWith("__")) {
              type[fieldName.substring(2)] = resolverValue[fieldName];
              continue;
            }
            const fields = type.getFields();
            const field = fields[fieldName];
            if (field != null) {
              const fieldResolve = resolverValue[fieldName];
              if (typeof fieldResolve === "function") {
                field.resolve = fieldResolve.bind(resolverValue);
              } else {
                setFieldProperties(field, fieldResolve);
              }
            }
          }
        }
      }
      (0, utils_1.forEachDefaultValue)(schema, utils_1.serializeInputValue);
      (0, utils_1.healSchema)(schema);
      (0, utils_1.forEachDefaultValue)(schema, utils_1.parseInputValue);
      if (defaultFieldResolver2 != null) {
        (0, utils_1.forEachField)(schema, (field) => {
          if (!field.resolve) {
            field.resolve = defaultFieldResolver2;
          }
        });
      }
      return schema;
    }
    function createNewSchemaWithResolvers(schema, resolvers, defaultFieldResolver2) {
      schema = (0, utils_1.mapSchema)(schema, {
        [utils_1.MapperKind.SCALAR_TYPE]: (type) => {
          var _a, _b, _c, _d, _e, _f;
          const config = type.toConfig();
          const resolverValue = resolvers[type.name];
          if (!(0, graphql_1.isSpecifiedScalarType)(type) && resolverValue != null) {
            for (const fieldName in resolverValue) {
              if (fieldName.startsWith("__")) {
                config[fieldName.substring(2)] = resolverValue[fieldName];
              } else if (fieldName === "astNode" && config.astNode != null) {
                config.astNode = {
                  ...config.astNode,
                  description: (_b = (_a = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : config.astNode.description,
                  directives: ((_c = config.astNode.directives) !== null && _c !== void 0 ? _c : []).concat((_e = (_d = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _d === void 0 ? void 0 : _d.directives) !== null && _e !== void 0 ? _e : [])
                };
              } else if (fieldName === "extensionASTNodes" && config.extensionASTNodes != null) {
                config.extensionASTNodes = config.extensionASTNodes.concat((_f = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _f !== void 0 ? _f : []);
              } else if (fieldName === "extensions" && config.extensions != null && resolverValue.extensions != null) {
                config.extensions = Object.assign(/* @__PURE__ */ Object.create(null), type.extensions, resolverValue.extensions);
              } else {
                config[fieldName] = resolverValue[fieldName];
              }
            }
            return new graphql_1.GraphQLScalarType(config);
          }
        },
        [utils_1.MapperKind.ENUM_TYPE]: (type) => {
          var _a, _b, _c, _d, _e, _f;
          const resolverValue = resolvers[type.name];
          const config = type.toConfig();
          const enumValueConfigMap = config.values;
          if (resolverValue != null) {
            for (const fieldName in resolverValue) {
              if (fieldName.startsWith("__")) {
                config[fieldName.substring(2)] = resolverValue[fieldName];
              } else if (fieldName === "astNode" && config.astNode != null) {
                config.astNode = {
                  ...config.astNode,
                  description: (_b = (_a = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : config.astNode.description,
                  directives: ((_c = config.astNode.directives) !== null && _c !== void 0 ? _c : []).concat((_e = (_d = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _d === void 0 ? void 0 : _d.directives) !== null && _e !== void 0 ? _e : [])
                };
              } else if (fieldName === "extensionASTNodes" && config.extensionASTNodes != null) {
                config.extensionASTNodes = config.extensionASTNodes.concat((_f = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _f !== void 0 ? _f : []);
              } else if (fieldName === "extensions" && config.extensions != null && resolverValue.extensions != null) {
                config.extensions = Object.assign(/* @__PURE__ */ Object.create(null), type.extensions, resolverValue.extensions);
              } else if (enumValueConfigMap[fieldName]) {
                enumValueConfigMap[fieldName].value = resolverValue[fieldName];
              }
            }
            return new graphql_1.GraphQLEnumType(config);
          }
        },
        [utils_1.MapperKind.UNION_TYPE]: (type) => {
          const resolverValue = resolvers[type.name];
          if (resolverValue != null) {
            const config = type.toConfig();
            if (resolverValue["__resolveType"]) {
              config.resolveType = resolverValue["__resolveType"];
            }
            return new graphql_1.GraphQLUnionType(config);
          }
        },
        [utils_1.MapperKind.OBJECT_TYPE]: (type) => {
          const resolverValue = resolvers[type.name];
          if (resolverValue != null) {
            const config = type.toConfig();
            if (resolverValue["__isTypeOf"]) {
              config.isTypeOf = resolverValue["__isTypeOf"];
            }
            return new graphql_1.GraphQLObjectType(config);
          }
        },
        [utils_1.MapperKind.INTERFACE_TYPE]: (type) => {
          const resolverValue = resolvers[type.name];
          if (resolverValue != null) {
            const config = type.toConfig();
            if (resolverValue["__resolveType"]) {
              config.resolveType = resolverValue["__resolveType"];
            }
            return new graphql_1.GraphQLInterfaceType(config);
          }
        },
        [utils_1.MapperKind.COMPOSITE_FIELD]: (fieldConfig, fieldName, typeName) => {
          const resolverValue = resolvers[typeName];
          if (resolverValue != null) {
            const fieldResolve = resolverValue[fieldName];
            if (fieldResolve != null) {
              const newFieldConfig = { ...fieldConfig };
              if (typeof fieldResolve === "function") {
                newFieldConfig.resolve = fieldResolve.bind(resolverValue);
              } else {
                setFieldProperties(newFieldConfig, fieldResolve);
              }
              return newFieldConfig;
            }
          }
        }
      });
      if (defaultFieldResolver2 != null) {
        schema = (0, utils_1.mapSchema)(schema, {
          [utils_1.MapperKind.OBJECT_FIELD]: (fieldConfig) => ({
            ...fieldConfig,
            resolve: fieldConfig.resolve != null ? fieldConfig.resolve : defaultFieldResolver2
          })
        });
      }
      return schema;
    }
    function setFieldProperties(field, propertiesObj) {
      for (const propertyName in propertiesObj) {
        field[propertyName] = propertiesObj[propertyName];
      }
    }
  }
});

// ../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/loaders.js
var require_loaders3 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/loaders.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/helpers.js
var require_helpers3 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/helpers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.assertSome = exports2.isSome = exports2.compareNodes = exports2.nodeToString = exports2.compareStrings = exports2.isValidPath = exports2.isDocumentString = exports2.asArray = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var asArray = (fns) => Array.isArray(fns) ? fns : fns ? [fns] : [];
    exports2.asArray = asArray;
    var invalidDocRegex = /\.[a-z0-9]+$/i;
    function isDocumentString(str) {
      if (typeof str !== "string") {
        return false;
      }
      if (invalidDocRegex.test(str)) {
        return false;
      }
      try {
        (0, graphql_1.parse)(str);
        return true;
      } catch (e) {
      }
      return false;
    }
    exports2.isDocumentString = isDocumentString;
    var invalidPathRegex = /[!%^<=>`]/;
    function isValidPath(str) {
      return typeof str === "string" && !invalidPathRegex.test(str);
    }
    exports2.isValidPath = isValidPath;
    function compareStrings(a, b) {
      if (String(a) < String(b)) {
        return -1;
      }
      if (String(a) > String(b)) {
        return 1;
      }
      return 0;
    }
    exports2.compareStrings = compareStrings;
    function nodeToString(a) {
      var _a, _b;
      let name;
      if ("alias" in a) {
        name = (_a = a.alias) === null || _a === void 0 ? void 0 : _a.value;
      }
      if (name == null && "name" in a) {
        name = (_b = a.name) === null || _b === void 0 ? void 0 : _b.value;
      }
      if (name == null) {
        name = a.kind;
      }
      return name;
    }
    exports2.nodeToString = nodeToString;
    function compareNodes(a, b, customFn) {
      const aStr = nodeToString(a);
      const bStr = nodeToString(b);
      if (typeof customFn === "function") {
        return customFn(aStr, bStr);
      }
      return compareStrings(aStr, bStr);
    }
    exports2.compareNodes = compareNodes;
    function isSome(input) {
      return input != null;
    }
    exports2.isSome = isSome;
    function assertSome(input, message = "Value should be something") {
      if (input == null) {
        throw new Error(message);
      }
    }
    exports2.assertSome = assertSome;
  }
});

// ../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/errors.js
var require_errors3 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/errors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.relocatedError = exports2.createGraphQLError = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function createGraphQLError(message, options) {
      if (graphql_1.versionInfo.major >= 17) {
        return new graphql_1.GraphQLError(message, options);
      }
      return new graphql_1.GraphQLError(message, options === null || options === void 0 ? void 0 : options.nodes, options === null || options === void 0 ? void 0 : options.source, options === null || options === void 0 ? void 0 : options.positions, options === null || options === void 0 ? void 0 : options.path, options === null || options === void 0 ? void 0 : options.originalError, options === null || options === void 0 ? void 0 : options.extensions);
    }
    exports2.createGraphQLError = createGraphQLError;
    function relocatedError(originalError, path) {
      return createGraphQLError(originalError.message, {
        nodes: originalError.nodes,
        source: originalError.source,
        positions: originalError.positions,
        path: path == null ? originalError.path : path,
        originalError,
        extensions: originalError.extensions
      });
    }
    exports2.relocatedError = relocatedError;
  }
});

// ../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/AggregateError.js
var require_AggregateError3 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/AggregateError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isAggregateError = exports2.AggregateError = void 0;
    var AggregateErrorImpl;
    exports2.AggregateError = AggregateErrorImpl;
    if (typeof AggregateError === "undefined") {
      class AggregateErrorClass extends Error {
        constructor(errors, message = "") {
          super(message);
          this.errors = errors;
          this.name = "AggregateError";
          Error.captureStackTrace(this, AggregateErrorClass);
        }
      }
      exports2.AggregateError = AggregateErrorImpl = function(errors, message) {
        return new AggregateErrorClass(errors, message);
      };
    } else {
      exports2.AggregateError = AggregateErrorImpl = AggregateError;
    }
    function isAggregateError(error) {
      return "errors" in error && Array.isArray(error["errors"]);
    }
    exports2.isAggregateError = isAggregateError;
  }
});

// ../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/inspect.js
var require_inspect3 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/inspect.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.inspect = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var AggregateError_js_1 = require_AggregateError3();
    var MAX_RECURSIVE_DEPTH2 = 3;
    function inspect2(value) {
      return formatValue2(value, []);
    }
    exports2.inspect = inspect2;
    function formatValue2(value, seenValues) {
      switch (typeof value) {
        case "string":
          return JSON.stringify(value);
        case "function":
          return value.name ? `[function ${value.name}]` : "[function]";
        case "object":
          return formatObjectValue2(value, seenValues);
        default:
          return String(value);
      }
    }
    function formatError2(value) {
      if (value instanceof graphql_1.GraphQLError) {
        return value.toString();
      }
      return `${value.name}: ${value.message};
 ${value.stack}`;
    }
    function formatObjectValue2(value, previouslySeenValues) {
      if (value === null) {
        return "null";
      }
      if (value instanceof Error) {
        if ((0, AggregateError_js_1.isAggregateError)(value)) {
          return formatError2(value) + "\n" + formatArray2(value.errors, previouslySeenValues);
        }
        return formatError2(value);
      }
      if (previouslySeenValues.includes(value)) {
        return "[Circular]";
      }
      const seenValues = [...previouslySeenValues, value];
      if (isJSONable2(value)) {
        const jsonValue = value.toJSON();
        if (jsonValue !== value) {
          return typeof jsonValue === "string" ? jsonValue : formatValue2(jsonValue, seenValues);
        }
      } else if (Array.isArray(value)) {
        return formatArray2(value, seenValues);
      }
      return formatObject2(value, seenValues);
    }
    function isJSONable2(value) {
      return typeof value.toJSON === "function";
    }
    function formatObject2(object, seenValues) {
      const entries = Object.entries(object);
      if (entries.length === 0) {
        return "{}";
      }
      if (seenValues.length > MAX_RECURSIVE_DEPTH2) {
        return "[" + getObjectTag2(object) + "]";
      }
      const properties = entries.map(([key, value]) => key + ": " + formatValue2(value, seenValues));
      return "{ " + properties.join(", ") + " }";
    }
    function formatArray2(array, seenValues) {
      if (array.length === 0) {
        return "[]";
      }
      if (seenValues.length > MAX_RECURSIVE_DEPTH2) {
        return "[Array]";
      }
      const len = array.length;
      const remaining = array.length;
      const items = [];
      for (let i = 0; i < len; ++i) {
        items.push(formatValue2(array[i], seenValues));
      }
      if (remaining === 1) {
        items.push("... 1 more item");
      } else if (remaining > 1) {
        items.push(`... ${remaining} more items`);
      }
      return "[" + items.join(", ") + "]";
    }
    function getObjectTag2(object) {
      const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
      if (tag === "Object" && typeof object.constructor === "function") {
        const name = object.constructor.name;
        if (typeof name === "string" && name !== "") {
          return name;
        }
      }
      return tag;
    }
  }
});

// ../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/getArgumentValues.js
var require_getArgumentValues3 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/getArgumentValues.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getArgumentValues = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var errors_js_1 = require_errors3();
    var inspect_js_1 = require_inspect3();
    function getArgumentValues2(def, node, variableValues = {}) {
      var _a;
      const variableMap = Object.entries(variableValues).reduce((prev, [key, value]) => ({
        ...prev,
        [key]: value
      }), {});
      const coercedValues = {};
      const argumentNodes = (_a = node.arguments) !== null && _a !== void 0 ? _a : [];
      const argNodeMap = argumentNodes.reduce((prev, arg) => ({
        ...prev,
        [arg.name.value]: arg
      }), {});
      for (const { name, type: argType, defaultValue } of def.args) {
        const argumentNode = argNodeMap[name];
        if (!argumentNode) {
          if (defaultValue !== void 0) {
            coercedValues[name] = defaultValue;
          } else if ((0, graphql_1.isNonNullType)(argType)) {
            throw (0, errors_js_1.createGraphQLError)(`Argument "${name}" of required type "${(0, inspect_js_1.inspect)(argType)}" was not provided.`, {
              nodes: [node]
            });
          }
          continue;
        }
        const valueNode = argumentNode.value;
        let isNull = valueNode.kind === graphql_1.Kind.NULL;
        if (valueNode.kind === graphql_1.Kind.VARIABLE) {
          const variableName = valueNode.name.value;
          if (variableValues == null || variableMap[variableName] == null) {
            if (defaultValue !== void 0) {
              coercedValues[name] = defaultValue;
            } else if ((0, graphql_1.isNonNullType)(argType)) {
              throw (0, errors_js_1.createGraphQLError)(`Argument "${name}" of required type "${(0, inspect_js_1.inspect)(argType)}" was provided the variable "$${variableName}" which was not provided a runtime value.`, {
                nodes: [valueNode]
              });
            }
            continue;
          }
          isNull = variableValues[variableName] == null;
        }
        if (isNull && (0, graphql_1.isNonNullType)(argType)) {
          throw (0, errors_js_1.createGraphQLError)(`Argument "${name}" of non-null type "${(0, inspect_js_1.inspect)(argType)}" must not be null.`, {
            nodes: [valueNode]
          });
        }
        const coercedValue = (0, graphql_1.valueFromAST)(valueNode, argType, variableValues);
        if (coercedValue === void 0) {
          throw (0, errors_js_1.createGraphQLError)(`Argument "${name}" has invalid value ${(0, graphql_1.print)(valueNode)}.`, {
            nodes: [valueNode]
          });
        }
        coercedValues[name] = coercedValue;
      }
      return coercedValues;
    }
    exports2.getArgumentValues = getArgumentValues2;
  }
});

// ../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/get-directives.js
var require_get_directives3 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/get-directives.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getDirective = exports2.getDirectives = exports2.getDirectiveInExtensions = exports2.getDirectivesInExtensions = void 0;
    var getArgumentValues_js_1 = require_getArgumentValues3();
    function getDirectivesInExtensions(node, pathToDirectivesInExtensions = ["directives"]) {
      return pathToDirectivesInExtensions.reduce((acc, pathSegment) => acc == null ? acc : acc[pathSegment], node === null || node === void 0 ? void 0 : node.extensions);
    }
    exports2.getDirectivesInExtensions = getDirectivesInExtensions;
    function _getDirectiveInExtensions(directivesInExtensions, directiveName) {
      const directiveInExtensions = directivesInExtensions.filter((directiveAnnotation) => directiveAnnotation.name === directiveName);
      if (!directiveInExtensions.length) {
        return void 0;
      }
      return directiveInExtensions.map((directive) => {
        var _a;
        return (_a = directive.args) !== null && _a !== void 0 ? _a : {};
      });
    }
    function getDirectiveInExtensions(node, directiveName, pathToDirectivesInExtensions = ["directives"]) {
      const directivesInExtensions = pathToDirectivesInExtensions.reduce((acc, pathSegment) => acc == null ? acc : acc[pathSegment], node === null || node === void 0 ? void 0 : node.extensions);
      if (directivesInExtensions === void 0) {
        return void 0;
      }
      if (Array.isArray(directivesInExtensions)) {
        return _getDirectiveInExtensions(directivesInExtensions, directiveName);
      }
      const reformattedDirectivesInExtensions = [];
      for (const [name, argsOrArrayOfArgs] of Object.entries(directivesInExtensions)) {
        if (Array.isArray(argsOrArrayOfArgs)) {
          for (const args of argsOrArrayOfArgs) {
            reformattedDirectivesInExtensions.push({ name, args });
          }
        } else {
          reformattedDirectivesInExtensions.push({ name, args: argsOrArrayOfArgs });
        }
      }
      return _getDirectiveInExtensions(reformattedDirectivesInExtensions, directiveName);
    }
    exports2.getDirectiveInExtensions = getDirectiveInExtensions;
    function getDirectives(schema, node, pathToDirectivesInExtensions = ["directives"]) {
      const directivesInExtensions = getDirectivesInExtensions(node, pathToDirectivesInExtensions);
      if (directivesInExtensions != null && directivesInExtensions.length > 0) {
        return directivesInExtensions;
      }
      const schemaDirectives = schema && schema.getDirectives ? schema.getDirectives() : [];
      const schemaDirectiveMap = schemaDirectives.reduce((schemaDirectiveMap2, schemaDirective) => {
        schemaDirectiveMap2[schemaDirective.name] = schemaDirective;
        return schemaDirectiveMap2;
      }, {});
      let astNodes = [];
      if (node.astNode) {
        astNodes.push(node.astNode);
      }
      if ("extensionASTNodes" in node && node.extensionASTNodes) {
        astNodes = [...astNodes, ...node.extensionASTNodes];
      }
      const result = [];
      for (const astNode of astNodes) {
        if (astNode.directives) {
          for (const directiveNode of astNode.directives) {
            const schemaDirective = schemaDirectiveMap[directiveNode.name.value];
            if (schemaDirective) {
              result.push({ name: directiveNode.name.value, args: (0, getArgumentValues_js_1.getArgumentValues)(schemaDirective, directiveNode) });
            }
          }
        }
      }
      return result;
    }
    exports2.getDirectives = getDirectives;
    function getDirective(schema, node, directiveName, pathToDirectivesInExtensions = ["directives"]) {
      const directiveInExtensions = getDirectiveInExtensions(node, directiveName, pathToDirectivesInExtensions);
      if (directiveInExtensions != null) {
        return directiveInExtensions;
      }
      const schemaDirective = schema && schema.getDirective ? schema.getDirective(directiveName) : void 0;
      if (schemaDirective == null) {
        return void 0;
      }
      let astNodes = [];
      if (node.astNode) {
        astNodes.push(node.astNode);
      }
      if ("extensionASTNodes" in node && node.extensionASTNodes) {
        astNodes = [...astNodes, ...node.extensionASTNodes];
      }
      const result = [];
      for (const astNode of astNodes) {
        if (astNode.directives) {
          for (const directiveNode of astNode.directives) {
            if (directiveNode.name.value === directiveName) {
              result.push((0, getArgumentValues_js_1.getArgumentValues)(schemaDirective, directiveNode));
            }
          }
        }
      }
      if (!result.length) {
        return void 0;
      }
      return result;
    }
    exports2.getDirective = getDirective;
  }
});

// ../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/get-fields-with-directives.js
var require_get_fields_with_directives3 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/get-fields-with-directives.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getFieldsWithDirectives = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function parseDirectiveValue(value) {
      switch (value.kind) {
        case graphql_1.Kind.INT:
          return parseInt(value.value);
        case graphql_1.Kind.FLOAT:
          return parseFloat(value.value);
        case graphql_1.Kind.BOOLEAN:
          return Boolean(value.value);
        case graphql_1.Kind.STRING:
        case graphql_1.Kind.ENUM:
          return value.value;
        case graphql_1.Kind.LIST:
          return value.values.map((v) => parseDirectiveValue(v));
        case graphql_1.Kind.OBJECT:
          return value.fields.reduce((prev, v) => ({ ...prev, [v.name.value]: parseDirectiveValue(v.value) }), {});
        case graphql_1.Kind.NULL:
          return null;
        default:
          return null;
      }
    }
    function getFieldsWithDirectives(documentNode, options = {}) {
      const result = {};
      let selected = ["ObjectTypeDefinition", "ObjectTypeExtension"];
      if (options.includeInputTypes) {
        selected = [...selected, "InputObjectTypeDefinition", "InputObjectTypeExtension"];
      }
      const allTypes = documentNode.definitions.filter((obj) => selected.includes(obj.kind));
      for (const type of allTypes) {
        const typeName = type.name.value;
        if (type.fields == null) {
          continue;
        }
        for (const field of type.fields) {
          if (field.directives && field.directives.length > 0) {
            const fieldName = field.name.value;
            const key = `${typeName}.${fieldName}`;
            const directives = field.directives.map((d) => ({
              name: d.name.value,
              args: (d.arguments || []).reduce((prev, arg) => ({ ...prev, [arg.name.value]: parseDirectiveValue(arg.value) }), {})
            }));
            result[key] = directives;
          }
        }
      }
      return result;
    }
    exports2.getFieldsWithDirectives = getFieldsWithDirectives;
  }
});

// ../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/get-implementing-types.js
var require_get_implementing_types3 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/get-implementing-types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getImplementingTypes = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function getImplementingTypes(interfaceName, schema) {
      const allTypesMap = schema.getTypeMap();
      const result = [];
      for (const graphqlTypeName in allTypesMap) {
        const graphqlType = allTypesMap[graphqlTypeName];
        if ((0, graphql_1.isObjectType)(graphqlType)) {
          const allInterfaces = graphqlType.getInterfaces();
          if (allInterfaces.find((int) => int.name === interfaceName)) {
            result.push(graphqlType.name);
          }
        }
      }
      return result;
    }
    exports2.getImplementingTypes = getImplementingTypes;
  }
});

// ../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/astFromType.js
var require_astFromType3 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/astFromType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.astFromType = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var inspect_js_1 = require_inspect3();
    function astFromType(type) {
      if ((0, graphql_1.isNonNullType)(type)) {
        const innerType = astFromType(type.ofType);
        if (innerType.kind === graphql_1.Kind.NON_NULL_TYPE) {
          throw new Error(`Invalid type node ${(0, inspect_js_1.inspect)(type)}. Inner type of non-null type cannot be a non-null type.`);
        }
        return {
          kind: graphql_1.Kind.NON_NULL_TYPE,
          type: innerType
        };
      } else if ((0, graphql_1.isListType)(type)) {
        return {
          kind: graphql_1.Kind.LIST_TYPE,
          type: astFromType(type.ofType)
        };
      }
      return {
        kind: graphql_1.Kind.NAMED_TYPE,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type.name
        }
      };
    }
    exports2.astFromType = astFromType;
  }
});

// ../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/astFromValueUntyped.js
var require_astFromValueUntyped3 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/astFromValueUntyped.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.astFromValueUntyped = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function astFromValueUntyped(value) {
      if (value === null) {
        return { kind: graphql_1.Kind.NULL };
      }
      if (value === void 0) {
        return null;
      }
      if (Array.isArray(value)) {
        const valuesNodes = [];
        for (const item of value) {
          const itemNode = astFromValueUntyped(item);
          if (itemNode != null) {
            valuesNodes.push(itemNode);
          }
        }
        return { kind: graphql_1.Kind.LIST, values: valuesNodes };
      }
      if (typeof value === "object") {
        const fieldNodes = [];
        for (const fieldName in value) {
          const fieldValue = value[fieldName];
          const ast = astFromValueUntyped(fieldValue);
          if (ast) {
            fieldNodes.push({
              kind: graphql_1.Kind.OBJECT_FIELD,
              name: { kind: graphql_1.Kind.NAME, value: fieldName },
              value: ast
            });
          }
        }
        return { kind: graphql_1.Kind.OBJECT, fields: fieldNodes };
      }
      if (typeof value === "boolean") {
        return { kind: graphql_1.Kind.BOOLEAN, value };
      }
      if (typeof value === "number" && isFinite(value)) {
        const stringNum = String(value);
        return integerStringRegExp2.test(stringNum) ? { kind: graphql_1.Kind.INT, value: stringNum } : { kind: graphql_1.Kind.FLOAT, value: stringNum };
      }
      if (typeof value === "string") {
        return { kind: graphql_1.Kind.STRING, value };
      }
      throw new TypeError(`Cannot convert value to AST: ${value}.`);
    }
    exports2.astFromValueUntyped = astFromValueUntyped;
    var integerStringRegExp2 = /^-?(?:0|[1-9][0-9]*)$/;
  }
});

// ../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/memoize.js
var require_memoize3 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/memoize.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.memoize2of4 = exports2.memoize5 = exports2.memoize4 = exports2.memoize3 = exports2.memoize2 = exports2.memoize1 = void 0;
    function memoize1(fn) {
      const memoize1cache = /* @__PURE__ */ new WeakMap();
      return function memoized(a1) {
        const cachedValue = memoize1cache.get(a1);
        if (cachedValue === void 0) {
          const newValue = fn(a1);
          memoize1cache.set(a1, newValue);
          return newValue;
        }
        return cachedValue;
      };
    }
    exports2.memoize1 = memoize1;
    function memoize2(fn) {
      const memoize2cache = /* @__PURE__ */ new WeakMap();
      return function memoized(a1, a2) {
        let cache2 = memoize2cache.get(a1);
        if (!cache2) {
          cache2 = /* @__PURE__ */ new WeakMap();
          memoize2cache.set(a1, cache2);
          const newValue = fn(a1, a2);
          cache2.set(a2, newValue);
          return newValue;
        }
        const cachedValue = cache2.get(a2);
        if (cachedValue === void 0) {
          const newValue = fn(a1, a2);
          cache2.set(a2, newValue);
          return newValue;
        }
        return cachedValue;
      };
    }
    exports2.memoize2 = memoize2;
    function memoize32(fn) {
      const memoize3Cache = /* @__PURE__ */ new WeakMap();
      return function memoized(a1, a2, a3) {
        let cache2 = memoize3Cache.get(a1);
        if (!cache2) {
          cache2 = /* @__PURE__ */ new WeakMap();
          memoize3Cache.set(a1, cache2);
          const cache32 = /* @__PURE__ */ new WeakMap();
          cache2.set(a2, cache32);
          const newValue = fn(a1, a2, a3);
          cache32.set(a3, newValue);
          return newValue;
        }
        let cache3 = cache2.get(a2);
        if (!cache3) {
          cache3 = /* @__PURE__ */ new WeakMap();
          cache2.set(a2, cache3);
          const newValue = fn(a1, a2, a3);
          cache3.set(a3, newValue);
          return newValue;
        }
        const cachedValue = cache3.get(a3);
        if (cachedValue === void 0) {
          const newValue = fn(a1, a2, a3);
          cache3.set(a3, newValue);
          return newValue;
        }
        return cachedValue;
      };
    }
    exports2.memoize3 = memoize32;
    function memoize4(fn) {
      const memoize4Cache = /* @__PURE__ */ new WeakMap();
      return function memoized(a1, a2, a3, a4) {
        let cache2 = memoize4Cache.get(a1);
        if (!cache2) {
          cache2 = /* @__PURE__ */ new WeakMap();
          memoize4Cache.set(a1, cache2);
          const cache32 = /* @__PURE__ */ new WeakMap();
          cache2.set(a2, cache32);
          const cache42 = /* @__PURE__ */ new WeakMap();
          cache32.set(a3, cache42);
          const newValue = fn(a1, a2, a3, a4);
          cache42.set(a4, newValue);
          return newValue;
        }
        let cache3 = cache2.get(a2);
        if (!cache3) {
          cache3 = /* @__PURE__ */ new WeakMap();
          cache2.set(a2, cache3);
          const cache42 = /* @__PURE__ */ new WeakMap();
          cache3.set(a3, cache42);
          const newValue = fn(a1, a2, a3, a4);
          cache42.set(a4, newValue);
          return newValue;
        }
        const cache4 = cache3.get(a3);
        if (!cache4) {
          const cache42 = /* @__PURE__ */ new WeakMap();
          cache3.set(a3, cache42);
          const newValue = fn(a1, a2, a3, a4);
          cache42.set(a4, newValue);
          return newValue;
        }
        const cachedValue = cache4.get(a4);
        if (cachedValue === void 0) {
          const newValue = fn(a1, a2, a3, a4);
          cache4.set(a4, newValue);
          return newValue;
        }
        return cachedValue;
      };
    }
    exports2.memoize4 = memoize4;
    function memoize5(fn) {
      const memoize5Cache = /* @__PURE__ */ new WeakMap();
      return function memoized(a1, a2, a3, a4, a5) {
        let cache2 = memoize5Cache.get(a1);
        if (!cache2) {
          cache2 = /* @__PURE__ */ new WeakMap();
          memoize5Cache.set(a1, cache2);
          const cache32 = /* @__PURE__ */ new WeakMap();
          cache2.set(a2, cache32);
          const cache42 = /* @__PURE__ */ new WeakMap();
          cache32.set(a3, cache42);
          const cache52 = /* @__PURE__ */ new WeakMap();
          cache42.set(a4, cache52);
          const newValue = fn(a1, a2, a3, a4, a5);
          cache52.set(a5, newValue);
          return newValue;
        }
        let cache3 = cache2.get(a2);
        if (!cache3) {
          cache3 = /* @__PURE__ */ new WeakMap();
          cache2.set(a2, cache3);
          const cache42 = /* @__PURE__ */ new WeakMap();
          cache3.set(a3, cache42);
          const cache52 = /* @__PURE__ */ new WeakMap();
          cache42.set(a4, cache52);
          const newValue = fn(a1, a2, a3, a4, a5);
          cache52.set(a5, newValue);
          return newValue;
        }
        let cache4 = cache3.get(a3);
        if (!cache4) {
          cache4 = /* @__PURE__ */ new WeakMap();
          cache3.set(a3, cache4);
          const cache52 = /* @__PURE__ */ new WeakMap();
          cache4.set(a4, cache52);
          const newValue = fn(a1, a2, a3, a4, a5);
          cache52.set(a5, newValue);
          return newValue;
        }
        let cache5 = cache4.get(a4);
        if (!cache5) {
          cache5 = /* @__PURE__ */ new WeakMap();
          cache4.set(a4, cache5);
          const newValue = fn(a1, a2, a3, a4, a5);
          cache5.set(a5, newValue);
          return newValue;
        }
        const cachedValue = cache5.get(a5);
        if (cachedValue === void 0) {
          const newValue = fn(a1, a2, a3, a4, a5);
          cache5.set(a5, newValue);
          return newValue;
        }
        return cachedValue;
      };
    }
    exports2.memoize5 = memoize5;
    var memoize2of4cache = /* @__PURE__ */ new WeakMap();
    function memoize2of4(fn) {
      return function memoized(a1, a2, a3, a4) {
        let cache2 = memoize2of4cache.get(a1);
        if (!cache2) {
          cache2 = /* @__PURE__ */ new WeakMap();
          memoize2of4cache.set(a1, cache2);
          const newValue = fn(a1, a2, a3, a4);
          cache2.set(a2, newValue);
          return newValue;
        }
        const cachedValue = cache2.get(a2);
        if (cachedValue === void 0) {
          const newValue = fn(a1, a2, a3, a4);
          cache2.set(a2, newValue);
          return newValue;
        }
        return cachedValue;
      };
    }
    exports2.memoize2of4 = memoize2of4;
  }
});

// ../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/rootTypes.js
var require_rootTypes3 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/rootTypes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getRootTypeMap = exports2.getRootTypes = exports2.getRootTypeNames = exports2.getDefinedRootType = void 0;
    var memoize_js_1 = require_memoize3();
    function getDefinedRootType(schema, operation) {
      const rootTypeMap = (0, exports2.getRootTypeMap)(schema);
      const rootType = rootTypeMap.get(operation);
      if (rootType == null) {
        throw new Error(`Root type for operation "${operation}" not defined by the given schema.`);
      }
      return rootType;
    }
    exports2.getDefinedRootType = getDefinedRootType;
    exports2.getRootTypeNames = (0, memoize_js_1.memoize1)(function getRootTypeNames(schema) {
      const rootTypes = (0, exports2.getRootTypes)(schema);
      return new Set([...rootTypes].map((type) => type.name));
    });
    exports2.getRootTypes = (0, memoize_js_1.memoize1)(function getRootTypes(schema) {
      const rootTypeMap = (0, exports2.getRootTypeMap)(schema);
      return new Set(rootTypeMap.values());
    });
    exports2.getRootTypeMap = (0, memoize_js_1.memoize1)(function getRootTypeMap(schema) {
      const rootTypeMap = /* @__PURE__ */ new Map();
      const queryType = schema.getQueryType();
      if (queryType) {
        rootTypeMap.set("query", queryType);
      }
      const mutationType = schema.getMutationType();
      if (mutationType) {
        rootTypeMap.set("mutation", mutationType);
      }
      const subscriptionType = schema.getSubscriptionType();
      if (subscriptionType) {
        rootTypeMap.set("subscription", subscriptionType);
      }
      return rootTypeMap;
    });
  }
});

// ../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/print-schema-with-directives.js
var require_print_schema_with_directives3 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/print-schema-with-directives.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.makeDirectiveNodes = exports2.makeDirectiveNode = exports2.makeDeprecatedDirective = exports2.astFromEnumValue = exports2.astFromInputField = exports2.astFromField = exports2.astFromScalarType = exports2.astFromEnumType = exports2.astFromInputObjectType = exports2.astFromUnionType = exports2.astFromInterfaceType = exports2.astFromObjectType = exports2.astFromArg = exports2.getDeprecatableDirectiveNodes = exports2.getDirectiveNodes = exports2.astFromDirective = exports2.astFromSchema = exports2.printSchemaWithDirectives = exports2.getDocumentNodeFromSchema = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var astFromType_js_1 = require_astFromType3();
    var get_directives_js_1 = require_get_directives3();
    var astFromValueUntyped_js_1 = require_astFromValueUntyped3();
    var helpers_js_1 = require_helpers3();
    var rootTypes_js_1 = require_rootTypes3();
    function getDocumentNodeFromSchema(schema, options = {}) {
      const pathToDirectivesInExtensions = options.pathToDirectivesInExtensions;
      const typesMap = schema.getTypeMap();
      const schemaNode = astFromSchema(schema, pathToDirectivesInExtensions);
      const definitions = schemaNode != null ? [schemaNode] : [];
      const directives = schema.getDirectives();
      for (const directive of directives) {
        if ((0, graphql_1.isSpecifiedDirective)(directive)) {
          continue;
        }
        definitions.push(astFromDirective(directive, schema, pathToDirectivesInExtensions));
      }
      for (const typeName in typesMap) {
        const type = typesMap[typeName];
        const isPredefinedScalar = (0, graphql_1.isSpecifiedScalarType)(type);
        const isIntrospection = (0, graphql_1.isIntrospectionType)(type);
        if (isPredefinedScalar || isIntrospection) {
          continue;
        }
        if ((0, graphql_1.isObjectType)(type)) {
          definitions.push(astFromObjectType(type, schema, pathToDirectivesInExtensions));
        } else if ((0, graphql_1.isInterfaceType)(type)) {
          definitions.push(astFromInterfaceType(type, schema, pathToDirectivesInExtensions));
        } else if ((0, graphql_1.isUnionType)(type)) {
          definitions.push(astFromUnionType(type, schema, pathToDirectivesInExtensions));
        } else if ((0, graphql_1.isInputObjectType)(type)) {
          definitions.push(astFromInputObjectType(type, schema, pathToDirectivesInExtensions));
        } else if ((0, graphql_1.isEnumType)(type)) {
          definitions.push(astFromEnumType(type, schema, pathToDirectivesInExtensions));
        } else if ((0, graphql_1.isScalarType)(type)) {
          definitions.push(astFromScalarType(type, schema, pathToDirectivesInExtensions));
        } else {
          throw new Error(`Unknown type ${type}.`);
        }
      }
      return {
        kind: graphql_1.Kind.DOCUMENT,
        definitions
      };
    }
    exports2.getDocumentNodeFromSchema = getDocumentNodeFromSchema;
    function printSchemaWithDirectives(schema, options = {}) {
      const documentNode = getDocumentNodeFromSchema(schema, options);
      return (0, graphql_1.print)(documentNode);
    }
    exports2.printSchemaWithDirectives = printSchemaWithDirectives;
    function astFromSchema(schema, pathToDirectivesInExtensions) {
      var _a, _b;
      const operationTypeMap = /* @__PURE__ */ new Map([
        ["query", void 0],
        ["mutation", void 0],
        ["subscription", void 0]
      ]);
      const nodes = [];
      if (schema.astNode != null) {
        nodes.push(schema.astNode);
      }
      if (schema.extensionASTNodes != null) {
        for (const extensionASTNode of schema.extensionASTNodes) {
          nodes.push(extensionASTNode);
        }
      }
      for (const node of nodes) {
        if (node.operationTypes) {
          for (const operationTypeDefinitionNode of node.operationTypes) {
            operationTypeMap.set(operationTypeDefinitionNode.operation, operationTypeDefinitionNode);
          }
        }
      }
      const rootTypeMap = (0, rootTypes_js_1.getRootTypeMap)(schema);
      for (const [operationTypeNode, operationTypeDefinitionNode] of operationTypeMap) {
        const rootType = rootTypeMap.get(operationTypeNode);
        if (rootType != null) {
          const rootTypeAST = (0, astFromType_js_1.astFromType)(rootType);
          if (operationTypeDefinitionNode != null) {
            operationTypeDefinitionNode.type = rootTypeAST;
          } else {
            operationTypeMap.set(operationTypeNode, {
              kind: graphql_1.Kind.OPERATION_TYPE_DEFINITION,
              operation: operationTypeNode,
              type: rootTypeAST
            });
          }
        }
      }
      const operationTypes = [...operationTypeMap.values()].filter(helpers_js_1.isSome);
      const directives = getDirectiveNodes(schema, schema, pathToDirectivesInExtensions);
      if (!operationTypes.length && !directives.length) {
        return null;
      }
      const schemaNode = {
        kind: operationTypes != null ? graphql_1.Kind.SCHEMA_DEFINITION : graphql_1.Kind.SCHEMA_EXTENSION,
        operationTypes,
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives
      };
      schemaNode.description = ((_b = (_a = schema.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : schema.description != null) ? {
        kind: graphql_1.Kind.STRING,
        value: schema.description,
        block: true
      } : void 0;
      return schemaNode;
    }
    exports2.astFromSchema = astFromSchema;
    function astFromDirective(directive, schema, pathToDirectivesInExtensions) {
      var _a, _b, _c, _d;
      return {
        kind: graphql_1.Kind.DIRECTIVE_DEFINITION,
        description: (_b = (_a = directive.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : directive.description ? {
          kind: graphql_1.Kind.STRING,
          value: directive.description
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: directive.name
        },
        arguments: (_c = directive.args) === null || _c === void 0 ? void 0 : _c.map((arg) => astFromArg(arg, schema, pathToDirectivesInExtensions)),
        repeatable: directive.isRepeatable,
        locations: ((_d = directive.locations) === null || _d === void 0 ? void 0 : _d.map((location) => ({
          kind: graphql_1.Kind.NAME,
          value: location
        }))) || []
      };
    }
    exports2.astFromDirective = astFromDirective;
    function getDirectiveNodes(entity, schema, pathToDirectivesInExtensions) {
      const directivesInExtensions = (0, get_directives_js_1.getDirectivesInExtensions)(entity, pathToDirectivesInExtensions);
      let nodes = [];
      if (entity.astNode != null) {
        nodes.push(entity.astNode);
      }
      if ("extensionASTNodes" in entity && entity.extensionASTNodes != null) {
        nodes = nodes.concat(entity.extensionASTNodes);
      }
      let directives;
      if (directivesInExtensions != null) {
        directives = makeDirectiveNodes(schema, directivesInExtensions);
      } else {
        directives = [];
        for (const node of nodes) {
          if (node.directives) {
            directives.push(...node.directives);
          }
        }
      }
      return directives;
    }
    exports2.getDirectiveNodes = getDirectiveNodes;
    function getDeprecatableDirectiveNodes(entity, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      let directiveNodesBesidesDeprecated = [];
      let deprecatedDirectiveNode = null;
      const directivesInExtensions = (0, get_directives_js_1.getDirectivesInExtensions)(entity, pathToDirectivesInExtensions);
      let directives;
      if (directivesInExtensions != null) {
        directives = makeDirectiveNodes(schema, directivesInExtensions);
      } else {
        directives = (_a = entity.astNode) === null || _a === void 0 ? void 0 : _a.directives;
      }
      if (directives != null) {
        directiveNodesBesidesDeprecated = directives.filter((directive) => directive.name.value !== "deprecated");
        if (entity.deprecationReason != null) {
          deprecatedDirectiveNode = (_b = directives.filter((directive) => directive.name.value === "deprecated")) === null || _b === void 0 ? void 0 : _b[0];
        }
      }
      if (entity.deprecationReason != null && deprecatedDirectiveNode == null) {
        deprecatedDirectiveNode = makeDeprecatedDirective(entity.deprecationReason);
      }
      return deprecatedDirectiveNode == null ? directiveNodesBesidesDeprecated : [deprecatedDirectiveNode].concat(directiveNodesBesidesDeprecated);
    }
    exports2.getDeprecatableDirectiveNodes = getDeprecatableDirectiveNodes;
    function astFromArg(arg, schema, pathToDirectivesInExtensions) {
      var _a, _b, _c;
      return {
        kind: graphql_1.Kind.INPUT_VALUE_DEFINITION,
        description: (_b = (_a = arg.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : arg.description ? {
          kind: graphql_1.Kind.STRING,
          value: arg.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: arg.name
        },
        type: (0, astFromType_js_1.astFromType)(arg.type),
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        defaultValue: arg.defaultValue !== void 0 ? (_c = (0, graphql_1.astFromValue)(arg.defaultValue, arg.type)) !== null && _c !== void 0 ? _c : void 0 : void 0,
        directives: getDeprecatableDirectiveNodes(arg, schema, pathToDirectivesInExtensions)
      };
    }
    exports2.astFromArg = astFromArg;
    function astFromObjectType(type, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      return {
        kind: graphql_1.Kind.OBJECT_TYPE_DEFINITION,
        description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description ? {
          kind: graphql_1.Kind.STRING,
          value: type.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type.name
        },
        fields: Object.values(type.getFields()).map((field) => astFromField(field, schema, pathToDirectivesInExtensions)),
        interfaces: Object.values(type.getInterfaces()).map((iFace) => (0, astFromType_js_1.astFromType)(iFace)),
        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)
      };
    }
    exports2.astFromObjectType = astFromObjectType;
    function astFromInterfaceType(type, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      const node = {
        kind: graphql_1.Kind.INTERFACE_TYPE_DEFINITION,
        description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description ? {
          kind: graphql_1.Kind.STRING,
          value: type.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type.name
        },
        fields: Object.values(type.getFields()).map((field) => astFromField(field, schema, pathToDirectivesInExtensions)),
        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)
      };
      if ("getInterfaces" in type) {
        node.interfaces = Object.values(type.getInterfaces()).map((iFace) => (0, astFromType_js_1.astFromType)(iFace));
      }
      return node;
    }
    exports2.astFromInterfaceType = astFromInterfaceType;
    function astFromUnionType(type, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      return {
        kind: graphql_1.Kind.UNION_TYPE_DEFINITION,
        description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description ? {
          kind: graphql_1.Kind.STRING,
          value: type.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type.name
        },
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions),
        types: type.getTypes().map((type2) => (0, astFromType_js_1.astFromType)(type2))
      };
    }
    exports2.astFromUnionType = astFromUnionType;
    function astFromInputObjectType(type, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      return {
        kind: graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION,
        description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description ? {
          kind: graphql_1.Kind.STRING,
          value: type.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type.name
        },
        fields: Object.values(type.getFields()).map((field) => astFromInputField(field, schema, pathToDirectivesInExtensions)),
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)
      };
    }
    exports2.astFromInputObjectType = astFromInputObjectType;
    function astFromEnumType(type, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      return {
        kind: graphql_1.Kind.ENUM_TYPE_DEFINITION,
        description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description ? {
          kind: graphql_1.Kind.STRING,
          value: type.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type.name
        },
        values: Object.values(type.getValues()).map((value) => astFromEnumValue(value, schema, pathToDirectivesInExtensions)),
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)
      };
    }
    exports2.astFromEnumType = astFromEnumType;
    function astFromScalarType(type, schema, pathToDirectivesInExtensions) {
      var _a, _b, _c;
      const directivesInExtensions = (0, get_directives_js_1.getDirectivesInExtensions)(type, pathToDirectivesInExtensions);
      const directives = directivesInExtensions ? makeDirectiveNodes(schema, directivesInExtensions) : ((_a = type.astNode) === null || _a === void 0 ? void 0 : _a.directives) || [];
      const specifiedByValue = type["specifiedByUrl"] || type["specifiedByURL"];
      if (specifiedByValue && !directives.some((directiveNode) => directiveNode.name.value === "specifiedBy")) {
        const specifiedByArgs = {
          url: specifiedByValue
        };
        directives.push(makeDirectiveNode("specifiedBy", specifiedByArgs));
      }
      return {
        kind: graphql_1.Kind.SCALAR_TYPE_DEFINITION,
        description: (_c = (_b = type.astNode) === null || _b === void 0 ? void 0 : _b.description) !== null && _c !== void 0 ? _c : type.description ? {
          kind: graphql_1.Kind.STRING,
          value: type.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type.name
        },
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives
      };
    }
    exports2.astFromScalarType = astFromScalarType;
    function astFromField(field, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      return {
        kind: graphql_1.Kind.FIELD_DEFINITION,
        description: (_b = (_a = field.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : field.description ? {
          kind: graphql_1.Kind.STRING,
          value: field.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: field.name
        },
        arguments: field.args.map((arg) => astFromArg(arg, schema, pathToDirectivesInExtensions)),
        type: (0, astFromType_js_1.astFromType)(field.type),
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: getDeprecatableDirectiveNodes(field, schema, pathToDirectivesInExtensions)
      };
    }
    exports2.astFromField = astFromField;
    function astFromInputField(field, schema, pathToDirectivesInExtensions) {
      var _a, _b, _c;
      return {
        kind: graphql_1.Kind.INPUT_VALUE_DEFINITION,
        description: (_b = (_a = field.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : field.description ? {
          kind: graphql_1.Kind.STRING,
          value: field.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: field.name
        },
        type: (0, astFromType_js_1.astFromType)(field.type),
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: getDeprecatableDirectiveNodes(field, schema, pathToDirectivesInExtensions),
        defaultValue: (_c = (0, graphql_1.astFromValue)(field.defaultValue, field.type)) !== null && _c !== void 0 ? _c : void 0
      };
    }
    exports2.astFromInputField = astFromInputField;
    function astFromEnumValue(value, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      return {
        kind: graphql_1.Kind.ENUM_VALUE_DEFINITION,
        description: (_b = (_a = value.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : value.description ? {
          kind: graphql_1.Kind.STRING,
          value: value.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: value.name
        },
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: getDeprecatableDirectiveNodes(value, schema, pathToDirectivesInExtensions)
      };
    }
    exports2.astFromEnumValue = astFromEnumValue;
    function makeDeprecatedDirective(deprecationReason) {
      return makeDirectiveNode("deprecated", { reason: deprecationReason }, graphql_1.GraphQLDeprecatedDirective);
    }
    exports2.makeDeprecatedDirective = makeDeprecatedDirective;
    function makeDirectiveNode(name, args, directive) {
      const directiveArguments = [];
      if (directive != null) {
        for (const arg of directive.args) {
          const argName = arg.name;
          const argValue = args[argName];
          if (argValue !== void 0) {
            const value = (0, graphql_1.astFromValue)(argValue, arg.type);
            if (value) {
              directiveArguments.push({
                kind: graphql_1.Kind.ARGUMENT,
                name: {
                  kind: graphql_1.Kind.NAME,
                  value: argName
                },
                value
              });
            }
          }
        }
      } else {
        for (const argName in args) {
          const argValue = args[argName];
          const value = (0, astFromValueUntyped_js_1.astFromValueUntyped)(argValue);
          if (value) {
            directiveArguments.push({
              kind: graphql_1.Kind.ARGUMENT,
              name: {
                kind: graphql_1.Kind.NAME,
                value: argName
              },
              value
            });
          }
        }
      }
      return {
        kind: graphql_1.Kind.DIRECTIVE,
        name: {
          kind: graphql_1.Kind.NAME,
          value: name
        },
        arguments: directiveArguments
      };
    }
    exports2.makeDirectiveNode = makeDirectiveNode;
    function makeDirectiveNodes(schema, directiveValues) {
      const directiveNodes = [];
      for (const directiveName in directiveValues) {
        const arrayOrSingleValue = directiveValues[directiveName];
        const directive = schema === null || schema === void 0 ? void 0 : schema.getDirective(directiveName);
        if (Array.isArray(arrayOrSingleValue)) {
          for (const value of arrayOrSingleValue) {
            directiveNodes.push(makeDirectiveNode(directiveName, value, directive));
          }
        } else {
          directiveNodes.push(makeDirectiveNode(directiveName, arrayOrSingleValue, directive));
        }
      }
      return directiveNodes;
    }
    exports2.makeDirectiveNodes = makeDirectiveNodes;
  }
});

// ../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/validate-documents.js
var require_validate_documents3 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/validate-documents.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createDefaultRules = exports2.checkValidationErrors = exports2.validateGraphQlDocuments = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var AggregateError_js_1 = require_AggregateError3();
    async function validateGraphQlDocuments(schema, documentFiles, effectiveRules = createDefaultRules()) {
      const allFragmentMap = /* @__PURE__ */ new Map();
      const documentFileObjectsToValidate = [];
      for (const documentFile of documentFiles) {
        if (documentFile.document) {
          const definitionsToValidate = [];
          for (const definitionNode of documentFile.document.definitions) {
            if (definitionNode.kind === graphql_1.Kind.FRAGMENT_DEFINITION) {
              allFragmentMap.set(definitionNode.name.value, definitionNode);
            } else {
              definitionsToValidate.push(definitionNode);
            }
          }
          documentFileObjectsToValidate.push({
            location: documentFile.location,
            document: {
              kind: graphql_1.Kind.DOCUMENT,
              definitions: definitionsToValidate
            }
          });
        }
      }
      const allErrors = [];
      const allFragmentsDocument = {
        kind: graphql_1.Kind.DOCUMENT,
        definitions: [...allFragmentMap.values()]
      };
      await Promise.all(documentFileObjectsToValidate.map(async (documentFile) => {
        const documentToValidate = (0, graphql_1.concatAST)([allFragmentsDocument, documentFile.document]);
        const errors = (0, graphql_1.validate)(schema, documentToValidate, effectiveRules);
        if (errors.length > 0) {
          allErrors.push({
            filePath: documentFile.location,
            errors
          });
        }
      }));
      return allErrors;
    }
    exports2.validateGraphQlDocuments = validateGraphQlDocuments;
    function checkValidationErrors(loadDocumentErrors) {
      if (loadDocumentErrors.length > 0) {
        const errors = [];
        for (const loadDocumentError of loadDocumentErrors) {
          for (const graphQLError of loadDocumentError.errors) {
            const error = new Error();
            error.name = "GraphQLDocumentError";
            error.message = `${error.name}: ${graphQLError.message}`;
            error.stack = error.message;
            if (graphQLError.locations) {
              for (const location of graphQLError.locations) {
                error.stack += `
    at ${loadDocumentError.filePath}:${location.line}:${location.column}`;
              }
            }
            errors.push(error);
          }
        }
        throw new AggregateError_js_1.AggregateError(errors, `GraphQL Document Validation failed with ${errors.length} errors;
  ${errors.map((error, index) => `Error ${index}: ${error.stack}`).join("\n\n")}`);
      }
    }
    exports2.checkValidationErrors = checkValidationErrors;
    function createDefaultRules() {
      let ignored = ["NoUnusedFragmentsRule", "NoUnusedVariablesRule", "KnownDirectivesRule"];
      if (graphql_1.versionInfo.major < 15) {
        ignored = ignored.map((rule) => rule.replace(/Rule$/, ""));
      }
      return graphql_1.specifiedRules.filter((f) => !ignored.includes(f.name));
    }
    exports2.createDefaultRules = createDefaultRules;
  }
});

// ../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/parse-graphql-json.js
var require_parse_graphql_json3 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/parse-graphql-json.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseGraphQLJSON = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function stripBOM(content) {
      content = content.toString();
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    }
    function parseBOM(content) {
      return JSON.parse(stripBOM(content));
    }
    function parseGraphQLJSON(location, jsonContent, options) {
      let parsedJson = parseBOM(jsonContent);
      if (parsedJson.data) {
        parsedJson = parsedJson.data;
      }
      if (parsedJson.kind === "Document") {
        return {
          location,
          document: parsedJson
        };
      } else if (parsedJson.__schema) {
        const schema = (0, graphql_1.buildClientSchema)(parsedJson, options);
        return {
          location,
          schema
        };
      } else if (typeof parsedJson === "string") {
        return {
          location,
          rawSDL: parsedJson
        };
      }
      throw new Error(`Not valid JSON content`);
    }
    exports2.parseGraphQLJSON = parseGraphQLJSON;
  }
});

// ../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/comments.js
var require_comments3 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/comments.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getBlockStringIndentation = exports2.dedentBlockStringValue = exports2.getLeadingCommentBlock = exports2.getComment = exports2.getDescription = exports2.printWithComments = exports2.printComment = exports2.pushComment = exports2.collectComment = exports2.resetComments = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var MAX_LINE_LENGTH2 = 80;
    var commentsRegistry = {};
    function resetComments() {
      commentsRegistry = {};
    }
    exports2.resetComments = resetComments;
    function collectComment(node) {
      var _a;
      const entityName = (_a = node.name) === null || _a === void 0 ? void 0 : _a.value;
      if (entityName == null) {
        return;
      }
      pushComment(node, entityName);
      switch (node.kind) {
        case "EnumTypeDefinition":
          if (node.values) {
            for (const value of node.values) {
              pushComment(value, entityName, value.name.value);
            }
          }
          break;
        case "ObjectTypeDefinition":
        case "InputObjectTypeDefinition":
        case "InterfaceTypeDefinition":
          if (node.fields) {
            for (const field of node.fields) {
              pushComment(field, entityName, field.name.value);
              if (isFieldDefinitionNode(field) && field.arguments) {
                for (const arg of field.arguments) {
                  pushComment(arg, entityName, field.name.value, arg.name.value);
                }
              }
            }
          }
          break;
      }
    }
    exports2.collectComment = collectComment;
    function pushComment(node, entity, field, argument) {
      const comment = getComment(node);
      if (typeof comment !== "string" || comment.length === 0) {
        return;
      }
      const keys = [entity];
      if (field) {
        keys.push(field);
        if (argument) {
          keys.push(argument);
        }
      }
      const path = keys.join(".");
      if (!commentsRegistry[path]) {
        commentsRegistry[path] = [];
      }
      commentsRegistry[path].push(comment);
    }
    exports2.pushComment = pushComment;
    function printComment(comment) {
      return "\n# " + comment.replace(/\n/g, "\n# ");
    }
    exports2.printComment = printComment;
    function join2(maybeArray, separator) {
      return maybeArray ? maybeArray.filter((x) => x).join(separator || "") : "";
    }
    function hasMultilineItems2(maybeArray) {
      var _a;
      return (_a = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes("\n"))) !== null && _a !== void 0 ? _a : false;
    }
    function addDescription(cb) {
      return (node, _key, _parent, path, ancestors) => {
        var _a;
        const keys = [];
        const parent = path.reduce((prev, key2) => {
          if (["fields", "arguments", "values"].includes(key2) && prev.name) {
            keys.push(prev.name.value);
          }
          return prev[key2];
        }, ancestors[0]);
        const key = [...keys, (_a = parent === null || parent === void 0 ? void 0 : parent.name) === null || _a === void 0 ? void 0 : _a.value].filter(Boolean).join(".");
        const items = [];
        if (node.kind.includes("Definition") && commentsRegistry[key]) {
          items.push(...commentsRegistry[key]);
        }
        return join2([...items.map(printComment), node.description, cb(node, _key, _parent, path, ancestors)], "\n");
      };
    }
    function indent2(maybeString) {
      return maybeString && `  ${maybeString.replace(/\n/g, "\n  ")}`;
    }
    function block2(array) {
      return array && array.length !== 0 ? `{
${indent2(join2(array, "\n"))}
}` : "";
    }
    function wrap2(start, maybeString, end) {
      return maybeString ? start + maybeString + (end || "") : "";
    }
    function printBlockString2(value, isDescription = false) {
      const escaped = value.replace(/"""/g, '\\"""');
      return (value[0] === " " || value[0] === "	") && value.indexOf("\n") === -1 ? `"""${escaped.replace(/"$/, '"\n')}"""` : `"""
${isDescription ? escaped : indent2(escaped)}
"""`;
    }
    var printDocASTReducer2 = {
      Name: { leave: (node) => node.value },
      Variable: { leave: (node) => "$" + node.name },
      // Document
      Document: {
        leave: (node) => join2(node.definitions, "\n\n")
      },
      OperationDefinition: {
        leave: (node) => {
          const varDefs = wrap2("(", join2(node.variableDefinitions, ", "), ")");
          const prefix = join2([node.operation, join2([node.name, varDefs]), join2(node.directives, " ")], " ");
          return prefix + " " + node.selectionSet;
        }
      },
      VariableDefinition: {
        leave: ({ variable, type, defaultValue, directives }) => variable + ": " + type + wrap2(" = ", defaultValue) + wrap2(" ", join2(directives, " "))
      },
      SelectionSet: { leave: ({ selections }) => block2(selections) },
      Field: {
        leave({ alias, name, arguments: args, directives, selectionSet }) {
          const prefix = wrap2("", alias, ": ") + name;
          let argsLine = prefix + wrap2("(", join2(args, ", "), ")");
          if (argsLine.length > MAX_LINE_LENGTH2) {
            argsLine = prefix + wrap2("(\n", indent2(join2(args, "\n")), "\n)");
          }
          return join2([argsLine, join2(directives, " "), selectionSet], " ");
        }
      },
      Argument: { leave: ({ name, value }) => name + ": " + value },
      // Fragments
      FragmentSpread: {
        leave: ({ name, directives }) => "..." + name + wrap2(" ", join2(directives, " "))
      },
      InlineFragment: {
        leave: ({ typeCondition, directives, selectionSet }) => join2(["...", wrap2("on ", typeCondition), join2(directives, " "), selectionSet], " ")
      },
      FragmentDefinition: {
        leave: ({ name, typeCondition, variableDefinitions, directives, selectionSet }) => (
          // Note: fragment variable definitions are experimental and may be changed
          // or removed in the future.
          `fragment ${name}${wrap2("(", join2(variableDefinitions, ", "), ")")} on ${typeCondition} ${wrap2("", join2(directives, " "), " ")}` + selectionSet
        )
      },
      // Value
      IntValue: { leave: ({ value }) => value },
      FloatValue: { leave: ({ value }) => value },
      StringValue: {
        leave: ({ value, block: isBlockString }) => {
          if (isBlockString) {
            return printBlockString2(value);
          }
          return JSON.stringify(value);
        }
      },
      BooleanValue: { leave: ({ value }) => value ? "true" : "false" },
      NullValue: { leave: () => "null" },
      EnumValue: { leave: ({ value }) => value },
      ListValue: { leave: ({ values }) => "[" + join2(values, ", ") + "]" },
      ObjectValue: { leave: ({ fields }) => "{" + join2(fields, ", ") + "}" },
      ObjectField: { leave: ({ name, value }) => name + ": " + value },
      // Directive
      Directive: {
        leave: ({ name, arguments: args }) => "@" + name + wrap2("(", join2(args, ", "), ")")
      },
      // Type
      NamedType: { leave: ({ name }) => name },
      ListType: { leave: ({ type }) => "[" + type + "]" },
      NonNullType: { leave: ({ type }) => type + "!" },
      // Type System Definitions
      SchemaDefinition: {
        leave: ({ directives, operationTypes }) => join2(["schema", join2(directives, " "), block2(operationTypes)], " ")
      },
      OperationTypeDefinition: {
        leave: ({ operation, type }) => operation + ": " + type
      },
      ScalarTypeDefinition: {
        leave: ({ name, directives }) => join2(["scalar", name, join2(directives, " ")], " ")
      },
      ObjectTypeDefinition: {
        leave: ({ name, interfaces, directives, fields }) => join2(["type", name, wrap2("implements ", join2(interfaces, " & ")), join2(directives, " "), block2(fields)], " ")
      },
      FieldDefinition: {
        leave: ({ name, arguments: args, type, directives }) => name + (hasMultilineItems2(args) ? wrap2("(\n", indent2(join2(args, "\n")), "\n)") : wrap2("(", join2(args, ", "), ")")) + ": " + type + wrap2(" ", join2(directives, " "))
      },
      InputValueDefinition: {
        leave: ({ name, type, defaultValue, directives }) => join2([name + ": " + type, wrap2("= ", defaultValue), join2(directives, " ")], " ")
      },
      InterfaceTypeDefinition: {
        leave: ({ name, interfaces, directives, fields }) => join2(["interface", name, wrap2("implements ", join2(interfaces, " & ")), join2(directives, " "), block2(fields)], " ")
      },
      UnionTypeDefinition: {
        leave: ({ name, directives, types }) => join2(["union", name, join2(directives, " "), wrap2("= ", join2(types, " | "))], " ")
      },
      EnumTypeDefinition: {
        leave: ({ name, directives, values }) => join2(["enum", name, join2(directives, " "), block2(values)], " ")
      },
      EnumValueDefinition: {
        leave: ({ name, directives }) => join2([name, join2(directives, " ")], " ")
      },
      InputObjectTypeDefinition: {
        leave: ({ name, directives, fields }) => join2(["input", name, join2(directives, " "), block2(fields)], " ")
      },
      DirectiveDefinition: {
        leave: ({ name, arguments: args, repeatable, locations }) => "directive @" + name + (hasMultilineItems2(args) ? wrap2("(\n", indent2(join2(args, "\n")), "\n)") : wrap2("(", join2(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join2(locations, " | ")
      },
      SchemaExtension: {
        leave: ({ directives, operationTypes }) => join2(["extend schema", join2(directives, " "), block2(operationTypes)], " ")
      },
      ScalarTypeExtension: {
        leave: ({ name, directives }) => join2(["extend scalar", name, join2(directives, " ")], " ")
      },
      ObjectTypeExtension: {
        leave: ({ name, interfaces, directives, fields }) => join2(["extend type", name, wrap2("implements ", join2(interfaces, " & ")), join2(directives, " "), block2(fields)], " ")
      },
      InterfaceTypeExtension: {
        leave: ({ name, interfaces, directives, fields }) => join2(["extend interface", name, wrap2("implements ", join2(interfaces, " & ")), join2(directives, " "), block2(fields)], " ")
      },
      UnionTypeExtension: {
        leave: ({ name, directives, types }) => join2(["extend union", name, join2(directives, " "), wrap2("= ", join2(types, " | "))], " ")
      },
      EnumTypeExtension: {
        leave: ({ name, directives, values }) => join2(["extend enum", name, join2(directives, " "), block2(values)], " ")
      },
      InputObjectTypeExtension: {
        leave: ({ name, directives, fields }) => join2(["extend input", name, join2(directives, " "), block2(fields)], " ")
      }
    };
    var printDocASTReducerWithComments = Object.keys(printDocASTReducer2).reduce((prev, key) => ({
      ...prev,
      [key]: {
        leave: addDescription(printDocASTReducer2[key].leave)
      }
    }), {});
    function printWithComments(ast) {
      return (0, graphql_1.visit)(ast, printDocASTReducerWithComments);
    }
    exports2.printWithComments = printWithComments;
    function isFieldDefinitionNode(node) {
      return node.kind === "FieldDefinition";
    }
    function getDescription(node, options) {
      if (node.description != null) {
        return node.description.value;
      }
      if (options === null || options === void 0 ? void 0 : options.commentDescriptions) {
        return getComment(node);
      }
    }
    exports2.getDescription = getDescription;
    function getComment(node) {
      const rawValue = getLeadingCommentBlock(node);
      if (rawValue !== void 0) {
        return dedentBlockStringValue(`
${rawValue}`);
      }
    }
    exports2.getComment = getComment;
    function getLeadingCommentBlock(node) {
      const loc = node.loc;
      if (!loc) {
        return;
      }
      const comments = [];
      let token = loc.startToken.prev;
      while (token != null && token.kind === graphql_1.TokenKind.COMMENT && token.next != null && token.prev != null && token.line + 1 === token.next.line && token.line !== token.prev.line) {
        const value = String(token.value);
        comments.push(value);
        token = token.prev;
      }
      return comments.length > 0 ? comments.reverse().join("\n") : void 0;
    }
    exports2.getLeadingCommentBlock = getLeadingCommentBlock;
    function dedentBlockStringValue(rawString) {
      const lines = rawString.split(/\r\n|[\n\r]/g);
      const commonIndent = getBlockStringIndentation(lines);
      if (commonIndent !== 0) {
        for (let i = 1; i < lines.length; i++) {
          lines[i] = lines[i].slice(commonIndent);
        }
      }
      while (lines.length > 0 && isBlank(lines[0])) {
        lines.shift();
      }
      while (lines.length > 0 && isBlank(lines[lines.length - 1])) {
        lines.pop();
      }
      return lines.join("\n");
    }
    exports2.dedentBlockStringValue = dedentBlockStringValue;
    function getBlockStringIndentation(lines) {
      let commonIndent = null;
      for (let i = 1; i < lines.length; i++) {
        const line = lines[i];
        const indent3 = leadingWhitespace2(line);
        if (indent3 === line.length) {
          continue;
        }
        if (commonIndent === null || indent3 < commonIndent) {
          commonIndent = indent3;
          if (commonIndent === 0) {
            break;
          }
        }
      }
      return commonIndent === null ? 0 : commonIndent;
    }
    exports2.getBlockStringIndentation = getBlockStringIndentation;
    function leadingWhitespace2(str) {
      let i = 0;
      while (i < str.length && (str[i] === " " || str[i] === "	")) {
        i++;
      }
      return i;
    }
    function isBlank(str) {
      return leadingWhitespace2(str) === str.length;
    }
  }
});

// ../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/parse-graphql-sdl.js
var require_parse_graphql_sdl3 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/parse-graphql-sdl.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isDescribable = exports2.transformCommentsToDescriptions = exports2.parseGraphQLSDL = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var comments_js_1 = require_comments3();
    function parseGraphQLSDL(location, rawSDL, options = {}) {
      let document2;
      try {
        if (options.commentDescriptions && rawSDL.includes("#")) {
          document2 = transformCommentsToDescriptions(rawSDL, options);
          if (options.noLocation) {
            document2 = (0, graphql_1.parse)((0, graphql_1.print)(document2), options);
          }
        } else {
          document2 = (0, graphql_1.parse)(new graphql_1.Source(rawSDL, location), options);
        }
      } catch (e) {
        if (e.message.includes("EOF") && rawSDL.replace(/(\#[^*]*)/g, "").trim() === "") {
          document2 = {
            kind: graphql_1.Kind.DOCUMENT,
            definitions: []
          };
        } else {
          throw e;
        }
      }
      return {
        location,
        document: document2
      };
    }
    exports2.parseGraphQLSDL = parseGraphQLSDL;
    function transformCommentsToDescriptions(sourceSdl, options = {}) {
      const parsedDoc = (0, graphql_1.parse)(sourceSdl, {
        ...options,
        noLocation: false
      });
      const modifiedDoc = (0, graphql_1.visit)(parsedDoc, {
        leave: (node) => {
          if (isDescribable(node)) {
            const rawValue = (0, comments_js_1.getLeadingCommentBlock)(node);
            if (rawValue !== void 0) {
              const commentsBlock = (0, comments_js_1.dedentBlockStringValue)("\n" + rawValue);
              const isBlock = commentsBlock.includes("\n");
              if (!node.description) {
                return {
                  ...node,
                  description: {
                    kind: graphql_1.Kind.STRING,
                    value: commentsBlock,
                    block: isBlock
                  }
                };
              } else {
                return {
                  ...node,
                  description: {
                    ...node.description,
                    value: node.description.value + "\n" + commentsBlock,
                    block: true
                  }
                };
              }
            }
          }
        }
      });
      return modifiedDoc;
    }
    exports2.transformCommentsToDescriptions = transformCommentsToDescriptions;
    function isDescribable(node) {
      return (0, graphql_1.isTypeSystemDefinitionNode)(node) || node.kind === graphql_1.Kind.FIELD_DEFINITION || node.kind === graphql_1.Kind.INPUT_VALUE_DEFINITION || node.kind === graphql_1.Kind.ENUM_VALUE_DEFINITION;
    }
    exports2.isDescribable = isDescribable;
  }
});

// ../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/build-operation-for-field.js
var require_build_operation_for_field3 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/build-operation-for-field.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.buildOperationNodeForField = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var rootTypes_js_1 = require_rootTypes3();
    var operationVariables = [];
    var fieldTypeMap = /* @__PURE__ */ new Map();
    function addOperationVariable(variable) {
      operationVariables.push(variable);
    }
    function resetOperationVariables() {
      operationVariables = [];
    }
    function resetFieldMap() {
      fieldTypeMap = /* @__PURE__ */ new Map();
    }
    function buildOperationNodeForField({ schema, kind, field, models, ignore = [], depthLimit, circularReferenceDepth, argNames, selectedFields = true }) {
      resetOperationVariables();
      resetFieldMap();
      const rootTypeNames = (0, rootTypes_js_1.getRootTypeNames)(schema);
      const operationNode = buildOperationAndCollectVariables({
        schema,
        fieldName: field,
        kind,
        models: models || [],
        ignore,
        depthLimit: depthLimit || Infinity,
        circularReferenceDepth: circularReferenceDepth || 1,
        argNames,
        selectedFields,
        rootTypeNames
      });
      operationNode.variableDefinitions = [...operationVariables];
      resetOperationVariables();
      resetFieldMap();
      return operationNode;
    }
    exports2.buildOperationNodeForField = buildOperationNodeForField;
    function buildOperationAndCollectVariables({ schema, fieldName, kind, models, ignore, depthLimit, circularReferenceDepth, argNames, selectedFields, rootTypeNames }) {
      const type = (0, rootTypes_js_1.getDefinedRootType)(schema, kind);
      const field = type.getFields()[fieldName];
      const operationName = `${fieldName}_${kind}`;
      if (field.args) {
        for (const arg of field.args) {
          const argName = arg.name;
          if (!argNames || argNames.includes(argName)) {
            addOperationVariable(resolveVariable(arg, argName));
          }
        }
      }
      return {
        kind: graphql_1.Kind.OPERATION_DEFINITION,
        operation: kind,
        name: {
          kind: graphql_1.Kind.NAME,
          value: operationName
        },
        variableDefinitions: [],
        selectionSet: {
          kind: graphql_1.Kind.SELECTION_SET,
          selections: [
            resolveField({
              type,
              field,
              models,
              firstCall: true,
              path: [],
              ancestors: [],
              ignore,
              depthLimit,
              circularReferenceDepth,
              schema,
              depth: 0,
              argNames,
              selectedFields,
              rootTypeNames
            })
          ]
        }
      };
    }
    function resolveSelectionSet({ parent, type, models, firstCall, path, ancestors, ignore, depthLimit, circularReferenceDepth, schema, depth, argNames, selectedFields, rootTypeNames }) {
      if (typeof selectedFields === "boolean" && depth > depthLimit) {
        return;
      }
      if ((0, graphql_1.isUnionType)(type)) {
        const types = type.getTypes();
        return {
          kind: graphql_1.Kind.SELECTION_SET,
          selections: types.filter((t) => !hasCircularRef([...ancestors, t], {
            depth: circularReferenceDepth
          })).map((t) => {
            return {
              kind: graphql_1.Kind.INLINE_FRAGMENT,
              typeCondition: {
                kind: graphql_1.Kind.NAMED_TYPE,
                name: {
                  kind: graphql_1.Kind.NAME,
                  value: t.name
                }
              },
              selectionSet: resolveSelectionSet({
                parent: type,
                type: t,
                models,
                path,
                ancestors,
                ignore,
                depthLimit,
                circularReferenceDepth,
                schema,
                depth,
                argNames,
                selectedFields,
                rootTypeNames
              })
            };
          }).filter((fragmentNode) => {
            var _a, _b;
            return ((_b = (_a = fragmentNode === null || fragmentNode === void 0 ? void 0 : fragmentNode.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length) > 0;
          })
        };
      }
      if ((0, graphql_1.isInterfaceType)(type)) {
        const types = Object.values(schema.getTypeMap()).filter((t) => (0, graphql_1.isObjectType)(t) && t.getInterfaces().includes(type));
        return {
          kind: graphql_1.Kind.SELECTION_SET,
          selections: types.filter((t) => !hasCircularRef([...ancestors, t], {
            depth: circularReferenceDepth
          })).map((t) => {
            return {
              kind: graphql_1.Kind.INLINE_FRAGMENT,
              typeCondition: {
                kind: graphql_1.Kind.NAMED_TYPE,
                name: {
                  kind: graphql_1.Kind.NAME,
                  value: t.name
                }
              },
              selectionSet: resolveSelectionSet({
                parent: type,
                type: t,
                models,
                path,
                ancestors,
                ignore,
                depthLimit,
                circularReferenceDepth,
                schema,
                depth,
                argNames,
                selectedFields,
                rootTypeNames
              })
            };
          }).filter((fragmentNode) => {
            var _a, _b;
            return ((_b = (_a = fragmentNode === null || fragmentNode === void 0 ? void 0 : fragmentNode.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length) > 0;
          })
        };
      }
      if ((0, graphql_1.isObjectType)(type) && !rootTypeNames.has(type.name)) {
        const isIgnored = ignore.includes(type.name) || ignore.includes(`${parent.name}.${path[path.length - 1]}`);
        const isModel = models.includes(type.name);
        if (!firstCall && isModel && !isIgnored) {
          return {
            kind: graphql_1.Kind.SELECTION_SET,
            selections: [
              {
                kind: graphql_1.Kind.FIELD,
                name: {
                  kind: graphql_1.Kind.NAME,
                  value: "id"
                }
              }
            ]
          };
        }
        const fields = type.getFields();
        return {
          kind: graphql_1.Kind.SELECTION_SET,
          selections: Object.keys(fields).filter((fieldName) => {
            return !hasCircularRef([...ancestors, (0, graphql_1.getNamedType)(fields[fieldName].type)], {
              depth: circularReferenceDepth
            });
          }).map((fieldName) => {
            const selectedSubFields = typeof selectedFields === "object" ? selectedFields[fieldName] : true;
            if (selectedSubFields) {
              return resolveField({
                type,
                field: fields[fieldName],
                models,
                path: [...path, fieldName],
                ancestors,
                ignore,
                depthLimit,
                circularReferenceDepth,
                schema,
                depth,
                argNames,
                selectedFields: selectedSubFields,
                rootTypeNames
              });
            }
            return null;
          }).filter((f) => {
            var _a, _b;
            if (f == null) {
              return false;
            } else if ("selectionSet" in f) {
              return !!((_b = (_a = f.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length);
            }
            return true;
          })
        };
      }
    }
    function resolveVariable(arg, name) {
      function resolveVariableType(type) {
        if ((0, graphql_1.isListType)(type)) {
          return {
            kind: graphql_1.Kind.LIST_TYPE,
            type: resolveVariableType(type.ofType)
          };
        }
        if ((0, graphql_1.isNonNullType)(type)) {
          return {
            kind: graphql_1.Kind.NON_NULL_TYPE,
            // for v16 compatibility
            type: resolveVariableType(type.ofType)
          };
        }
        return {
          kind: graphql_1.Kind.NAMED_TYPE,
          name: {
            kind: graphql_1.Kind.NAME,
            value: type.name
          }
        };
      }
      return {
        kind: graphql_1.Kind.VARIABLE_DEFINITION,
        variable: {
          kind: graphql_1.Kind.VARIABLE,
          name: {
            kind: graphql_1.Kind.NAME,
            value: name || arg.name
          }
        },
        type: resolveVariableType(arg.type)
      };
    }
    function getArgumentName(name, path) {
      return [...path, name].join("_");
    }
    function resolveField({ type, field, models, firstCall, path, ancestors, ignore, depthLimit, circularReferenceDepth, schema, depth, argNames, selectedFields, rootTypeNames }) {
      const namedType = (0, graphql_1.getNamedType)(field.type);
      let args = [];
      let removeField = false;
      if (field.args && field.args.length) {
        args = field.args.map((arg) => {
          const argumentName = getArgumentName(arg.name, path);
          if (argNames && !argNames.includes(argumentName)) {
            if ((0, graphql_1.isNonNullType)(arg.type)) {
              removeField = true;
            }
            return null;
          }
          if (!firstCall) {
            addOperationVariable(resolveVariable(arg, argumentName));
          }
          return {
            kind: graphql_1.Kind.ARGUMENT,
            name: {
              kind: graphql_1.Kind.NAME,
              value: arg.name
            },
            value: {
              kind: graphql_1.Kind.VARIABLE,
              name: {
                kind: graphql_1.Kind.NAME,
                value: getArgumentName(arg.name, path)
              }
            }
          };
        }).filter(Boolean);
      }
      if (removeField) {
        return null;
      }
      const fieldPath = [...path, field.name];
      const fieldPathStr = fieldPath.join(".");
      let fieldName = field.name;
      if (fieldTypeMap.has(fieldPathStr) && fieldTypeMap.get(fieldPathStr) !== field.type.toString()) {
        fieldName += field.type.toString().replace("!", "NonNull");
      }
      fieldTypeMap.set(fieldPathStr, field.type.toString());
      if (!(0, graphql_1.isScalarType)(namedType) && !(0, graphql_1.isEnumType)(namedType)) {
        return {
          kind: graphql_1.Kind.FIELD,
          name: {
            kind: graphql_1.Kind.NAME,
            value: field.name
          },
          ...fieldName !== field.name && { alias: { kind: graphql_1.Kind.NAME, value: fieldName } },
          selectionSet: resolveSelectionSet({
            parent: type,
            type: namedType,
            models,
            firstCall,
            path: fieldPath,
            ancestors: [...ancestors, type],
            ignore,
            depthLimit,
            circularReferenceDepth,
            schema,
            depth: depth + 1,
            argNames,
            selectedFields,
            rootTypeNames
          }) || void 0,
          arguments: args
        };
      }
      return {
        kind: graphql_1.Kind.FIELD,
        name: {
          kind: graphql_1.Kind.NAME,
          value: field.name
        },
        ...fieldName !== field.name && { alias: { kind: graphql_1.Kind.NAME, value: fieldName } },
        arguments: args
      };
    }
    function hasCircularRef(types, config = {
      depth: 1
    }) {
      const type = types[types.length - 1];
      if ((0, graphql_1.isScalarType)(type)) {
        return false;
      }
      const size = types.filter((t) => t.name === type.name).length;
      return size > config.depth;
    }
  }
});

// ../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/types.js
var require_types5 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DirectiveLocation = void 0;
    var DirectiveLocation2;
    (function(DirectiveLocation3) {
      DirectiveLocation3["QUERY"] = "QUERY";
      DirectiveLocation3["MUTATION"] = "MUTATION";
      DirectiveLocation3["SUBSCRIPTION"] = "SUBSCRIPTION";
      DirectiveLocation3["FIELD"] = "FIELD";
      DirectiveLocation3["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
      DirectiveLocation3["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
      DirectiveLocation3["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
      DirectiveLocation3["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
      DirectiveLocation3["SCHEMA"] = "SCHEMA";
      DirectiveLocation3["SCALAR"] = "SCALAR";
      DirectiveLocation3["OBJECT"] = "OBJECT";
      DirectiveLocation3["FIELD_DEFINITION"] = "FIELD_DEFINITION";
      DirectiveLocation3["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
      DirectiveLocation3["INTERFACE"] = "INTERFACE";
      DirectiveLocation3["UNION"] = "UNION";
      DirectiveLocation3["ENUM"] = "ENUM";
      DirectiveLocation3["ENUM_VALUE"] = "ENUM_VALUE";
      DirectiveLocation3["INPUT_OBJECT"] = "INPUT_OBJECT";
      DirectiveLocation3["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
    })(DirectiveLocation2 = exports2.DirectiveLocation || (exports2.DirectiveLocation = {}));
  }
});

// ../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/Interfaces.js
var require_Interfaces3 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/Interfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MapperKind = void 0;
    var MapperKind;
    (function(MapperKind2) {
      MapperKind2["TYPE"] = "MapperKind.TYPE";
      MapperKind2["SCALAR_TYPE"] = "MapperKind.SCALAR_TYPE";
      MapperKind2["ENUM_TYPE"] = "MapperKind.ENUM_TYPE";
      MapperKind2["COMPOSITE_TYPE"] = "MapperKind.COMPOSITE_TYPE";
      MapperKind2["OBJECT_TYPE"] = "MapperKind.OBJECT_TYPE";
      MapperKind2["INPUT_OBJECT_TYPE"] = "MapperKind.INPUT_OBJECT_TYPE";
      MapperKind2["ABSTRACT_TYPE"] = "MapperKind.ABSTRACT_TYPE";
      MapperKind2["UNION_TYPE"] = "MapperKind.UNION_TYPE";
      MapperKind2["INTERFACE_TYPE"] = "MapperKind.INTERFACE_TYPE";
      MapperKind2["ROOT_OBJECT"] = "MapperKind.ROOT_OBJECT";
      MapperKind2["QUERY"] = "MapperKind.QUERY";
      MapperKind2["MUTATION"] = "MapperKind.MUTATION";
      MapperKind2["SUBSCRIPTION"] = "MapperKind.SUBSCRIPTION";
      MapperKind2["DIRECTIVE"] = "MapperKind.DIRECTIVE";
      MapperKind2["FIELD"] = "MapperKind.FIELD";
      MapperKind2["COMPOSITE_FIELD"] = "MapperKind.COMPOSITE_FIELD";
      MapperKind2["OBJECT_FIELD"] = "MapperKind.OBJECT_FIELD";
      MapperKind2["ROOT_FIELD"] = "MapperKind.ROOT_FIELD";
      MapperKind2["QUERY_ROOT_FIELD"] = "MapperKind.QUERY_ROOT_FIELD";
      MapperKind2["MUTATION_ROOT_FIELD"] = "MapperKind.MUTATION_ROOT_FIELD";
      MapperKind2["SUBSCRIPTION_ROOT_FIELD"] = "MapperKind.SUBSCRIPTION_ROOT_FIELD";
      MapperKind2["INTERFACE_FIELD"] = "MapperKind.INTERFACE_FIELD";
      MapperKind2["INPUT_OBJECT_FIELD"] = "MapperKind.INPUT_OBJECT_FIELD";
      MapperKind2["ARGUMENT"] = "MapperKind.ARGUMENT";
      MapperKind2["ENUM_VALUE"] = "MapperKind.ENUM_VALUE";
    })(MapperKind = exports2.MapperKind || (exports2.MapperKind = {}));
  }
});

// ../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/getObjectTypeFromTypeMap.js
var require_getObjectTypeFromTypeMap3 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/getObjectTypeFromTypeMap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getObjectTypeFromTypeMap = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function getObjectTypeFromTypeMap(typeMap, type) {
      if (type) {
        const maybeObjectType = typeMap[type.name];
        if ((0, graphql_1.isObjectType)(maybeObjectType)) {
          return maybeObjectType;
        }
      }
    }
    exports2.getObjectTypeFromTypeMap = getObjectTypeFromTypeMap;
  }
});

// ../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/stub.js
var require_stub3 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/stub.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getBuiltInForStub = exports2.isNamedStub = exports2.createStub = exports2.createNamedStub = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function createNamedStub(name, type) {
      let constructor;
      if (type === "object") {
        constructor = graphql_1.GraphQLObjectType;
      } else if (type === "interface") {
        constructor = graphql_1.GraphQLInterfaceType;
      } else {
        constructor = graphql_1.GraphQLInputObjectType;
      }
      return new constructor({
        name,
        fields: {
          _fake: {
            type: graphql_1.GraphQLString
          }
        }
      });
    }
    exports2.createNamedStub = createNamedStub;
    function createStub(node, type) {
      switch (node.kind) {
        case graphql_1.Kind.LIST_TYPE:
          return new graphql_1.GraphQLList(createStub(node.type, type));
        case graphql_1.Kind.NON_NULL_TYPE:
          return new graphql_1.GraphQLNonNull(createStub(node.type, type));
        default:
          if (type === "output") {
            return createNamedStub(node.name.value, "object");
          }
          return createNamedStub(node.name.value, "input");
      }
    }
    exports2.createStub = createStub;
    function isNamedStub(type) {
      if ("getFields" in type) {
        const fields = type.getFields();
        for (const fieldName in fields) {
          const field = fields[fieldName];
          return field.name === "_fake";
        }
      }
      return false;
    }
    exports2.isNamedStub = isNamedStub;
    function getBuiltInForStub(type) {
      switch (type.name) {
        case graphql_1.GraphQLInt.name:
          return graphql_1.GraphQLInt;
        case graphql_1.GraphQLFloat.name:
          return graphql_1.GraphQLFloat;
        case graphql_1.GraphQLString.name:
          return graphql_1.GraphQLString;
        case graphql_1.GraphQLBoolean.name:
          return graphql_1.GraphQLBoolean;
        case graphql_1.GraphQLID.name:
          return graphql_1.GraphQLID;
        default:
          return type;
      }
    }
    exports2.getBuiltInForStub = getBuiltInForStub;
  }
});

// ../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/rewire.js
var require_rewire3 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/rewire.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.rewireTypes = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var stub_js_1 = require_stub3();
    function rewireTypes(originalTypeMap, directives) {
      const referenceTypeMap = /* @__PURE__ */ Object.create(null);
      for (const typeName in originalTypeMap) {
        referenceTypeMap[typeName] = originalTypeMap[typeName];
      }
      const newTypeMap = /* @__PURE__ */ Object.create(null);
      for (const typeName in referenceTypeMap) {
        const namedType = referenceTypeMap[typeName];
        if (namedType == null || typeName.startsWith("__")) {
          continue;
        }
        const newName = namedType.name;
        if (newName.startsWith("__")) {
          continue;
        }
        if (newTypeMap[newName] != null) {
          throw new Error(`Duplicate schema type name ${newName}`);
        }
        newTypeMap[newName] = namedType;
      }
      for (const typeName in newTypeMap) {
        newTypeMap[typeName] = rewireNamedType(newTypeMap[typeName]);
      }
      const newDirectives = directives.map((directive) => rewireDirective(directive));
      return {
        typeMap: newTypeMap,
        directives: newDirectives
      };
      function rewireDirective(directive) {
        if ((0, graphql_1.isSpecifiedDirective)(directive)) {
          return directive;
        }
        const directiveConfig = directive.toConfig();
        directiveConfig.args = rewireArgs(directiveConfig.args);
        return new graphql_1.GraphQLDirective(directiveConfig);
      }
      function rewireArgs(args) {
        const rewiredArgs = {};
        for (const argName in args) {
          const arg = args[argName];
          const rewiredArgType = rewireType(arg.type);
          if (rewiredArgType != null) {
            arg.type = rewiredArgType;
            rewiredArgs[argName] = arg;
          }
        }
        return rewiredArgs;
      }
      function rewireNamedType(type) {
        if ((0, graphql_1.isObjectType)(type)) {
          const config = type.toConfig();
          const newConfig = {
            ...config,
            fields: () => rewireFields(config.fields),
            interfaces: () => rewireNamedTypes(config.interfaces)
          };
          return new graphql_1.GraphQLObjectType(newConfig);
        } else if ((0, graphql_1.isInterfaceType)(type)) {
          const config = type.toConfig();
          const newConfig = {
            ...config,
            fields: () => rewireFields(config.fields)
          };
          if ("interfaces" in newConfig) {
            newConfig.interfaces = () => rewireNamedTypes(config.interfaces);
          }
          return new graphql_1.GraphQLInterfaceType(newConfig);
        } else if ((0, graphql_1.isUnionType)(type)) {
          const config = type.toConfig();
          const newConfig = {
            ...config,
            types: () => rewireNamedTypes(config.types)
          };
          return new graphql_1.GraphQLUnionType(newConfig);
        } else if ((0, graphql_1.isInputObjectType)(type)) {
          const config = type.toConfig();
          const newConfig = {
            ...config,
            fields: () => rewireInputFields(config.fields)
          };
          return new graphql_1.GraphQLInputObjectType(newConfig);
        } else if ((0, graphql_1.isEnumType)(type)) {
          const enumConfig = type.toConfig();
          return new graphql_1.GraphQLEnumType(enumConfig);
        } else if ((0, graphql_1.isScalarType)(type)) {
          if ((0, graphql_1.isSpecifiedScalarType)(type)) {
            return type;
          }
          const scalarConfig = type.toConfig();
          return new graphql_1.GraphQLScalarType(scalarConfig);
        }
        throw new Error(`Unexpected schema type: ${type}`);
      }
      function rewireFields(fields) {
        const rewiredFields = {};
        for (const fieldName in fields) {
          const field = fields[fieldName];
          const rewiredFieldType = rewireType(field.type);
          if (rewiredFieldType != null && field.args) {
            field.type = rewiredFieldType;
            field.args = rewireArgs(field.args);
            rewiredFields[fieldName] = field;
          }
        }
        return rewiredFields;
      }
      function rewireInputFields(fields) {
        const rewiredFields = {};
        for (const fieldName in fields) {
          const field = fields[fieldName];
          const rewiredFieldType = rewireType(field.type);
          if (rewiredFieldType != null) {
            field.type = rewiredFieldType;
            rewiredFields[fieldName] = field;
          }
        }
        return rewiredFields;
      }
      function rewireNamedTypes(namedTypes) {
        const rewiredTypes = [];
        for (const namedType of namedTypes) {
          const rewiredType = rewireType(namedType);
          if (rewiredType != null) {
            rewiredTypes.push(rewiredType);
          }
        }
        return rewiredTypes;
      }
      function rewireType(type) {
        if ((0, graphql_1.isListType)(type)) {
          const rewiredType = rewireType(type.ofType);
          return rewiredType != null ? new graphql_1.GraphQLList(rewiredType) : null;
        } else if ((0, graphql_1.isNonNullType)(type)) {
          const rewiredType = rewireType(type.ofType);
          return rewiredType != null ? new graphql_1.GraphQLNonNull(rewiredType) : null;
        } else if ((0, graphql_1.isNamedType)(type)) {
          let rewiredType = referenceTypeMap[type.name];
          if (rewiredType === void 0) {
            rewiredType = (0, stub_js_1.isNamedStub)(type) ? (0, stub_js_1.getBuiltInForStub)(type) : rewireNamedType(type);
            newTypeMap[rewiredType.name] = referenceTypeMap[type.name] = rewiredType;
          }
          return rewiredType != null ? newTypeMap[rewiredType.name] : null;
        }
        return null;
      }
    }
    exports2.rewireTypes = rewireTypes;
  }
});

// ../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/transformInputValue.js
var require_transformInputValue3 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/transformInputValue.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseInputValueLiteral = exports2.parseInputValue = exports2.serializeInputValue = exports2.transformInputValue = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function transformInputValue(type, value, inputLeafValueTransformer = null, inputObjectValueTransformer = null) {
      if (value == null) {
        return value;
      }
      const nullableType = (0, graphql_1.getNullableType)(type);
      if ((0, graphql_1.isLeafType)(nullableType)) {
        return inputLeafValueTransformer != null ? inputLeafValueTransformer(nullableType, value) : value;
      } else if ((0, graphql_1.isListType)(nullableType)) {
        return value.map((listMember) => transformInputValue(nullableType.ofType, listMember, inputLeafValueTransformer, inputObjectValueTransformer));
      } else if ((0, graphql_1.isInputObjectType)(nullableType)) {
        const fields = nullableType.getFields();
        const newValue = {};
        for (const key in value) {
          const field = fields[key];
          if (field != null) {
            newValue[key] = transformInputValue(field.type, value[key], inputLeafValueTransformer, inputObjectValueTransformer);
          }
        }
        return inputObjectValueTransformer != null ? inputObjectValueTransformer(nullableType, newValue) : newValue;
      }
    }
    exports2.transformInputValue = transformInputValue;
    function serializeInputValue(type, value) {
      return transformInputValue(type, value, (t, v) => {
        try {
          return t.serialize(v);
        } catch (_a) {
          return v;
        }
      });
    }
    exports2.serializeInputValue = serializeInputValue;
    function parseInputValue(type, value) {
      return transformInputValue(type, value, (t, v) => {
        try {
          return t.parseValue(v);
        } catch (_a) {
          return v;
        }
      });
    }
    exports2.parseInputValue = parseInputValue;
    function parseInputValueLiteral(type, value) {
      return transformInputValue(type, value, (t, v) => t.parseLiteral(v, {}));
    }
    exports2.parseInputValueLiteral = parseInputValueLiteral;
  }
});

// ../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/mapSchema.js
var require_mapSchema3 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/mapSchema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.correctASTNodes = exports2.mapSchema = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var getObjectTypeFromTypeMap_js_1 = require_getObjectTypeFromTypeMap3();
    var Interfaces_js_1 = require_Interfaces3();
    var rewire_js_1 = require_rewire3();
    var transformInputValue_js_1 = require_transformInputValue3();
    function mapSchema(schema, schemaMapper = {}) {
      const newTypeMap = mapArguments(mapFields(mapTypes(mapDefaultValues(mapEnumValues(mapTypes(mapDefaultValues(schema.getTypeMap(), schema, transformInputValue_js_1.serializeInputValue), schema, schemaMapper, (type) => (0, graphql_1.isLeafType)(type)), schema, schemaMapper), schema, transformInputValue_js_1.parseInputValue), schema, schemaMapper, (type) => !(0, graphql_1.isLeafType)(type)), schema, schemaMapper), schema, schemaMapper);
      const originalDirectives = schema.getDirectives();
      const newDirectives = mapDirectives(originalDirectives, schema, schemaMapper);
      const { typeMap, directives } = (0, rewire_js_1.rewireTypes)(newTypeMap, newDirectives);
      return new graphql_1.GraphQLSchema({
        ...schema.toConfig(),
        query: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(newTypeMap, schema.getQueryType())),
        mutation: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(newTypeMap, schema.getMutationType())),
        subscription: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(newTypeMap, schema.getSubscriptionType())),
        types: Object.values(typeMap),
        directives
      });
    }
    exports2.mapSchema = mapSchema;
    function mapTypes(originalTypeMap, schema, schemaMapper, testFn = () => true) {
      const newTypeMap = {};
      for (const typeName in originalTypeMap) {
        if (!typeName.startsWith("__")) {
          const originalType = originalTypeMap[typeName];
          if (originalType == null || !testFn(originalType)) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          const typeMapper = getTypeMapper(schema, schemaMapper, typeName);
          if (typeMapper == null) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          const maybeNewType = typeMapper(originalType, schema);
          if (maybeNewType === void 0) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          newTypeMap[typeName] = maybeNewType;
        }
      }
      return newTypeMap;
    }
    function mapEnumValues(originalTypeMap, schema, schemaMapper) {
      const enumValueMapper = getEnumValueMapper(schemaMapper);
      if (!enumValueMapper) {
        return originalTypeMap;
      }
      return mapTypes(originalTypeMap, schema, {
        [Interfaces_js_1.MapperKind.ENUM_TYPE]: (type) => {
          const config = type.toConfig();
          const originalEnumValueConfigMap = config.values;
          const newEnumValueConfigMap = {};
          for (const externalValue in originalEnumValueConfigMap) {
            const originalEnumValueConfig = originalEnumValueConfigMap[externalValue];
            const mappedEnumValue = enumValueMapper(originalEnumValueConfig, type.name, schema, externalValue);
            if (mappedEnumValue === void 0) {
              newEnumValueConfigMap[externalValue] = originalEnumValueConfig;
            } else if (Array.isArray(mappedEnumValue)) {
              const [newExternalValue, newEnumValueConfig] = mappedEnumValue;
              newEnumValueConfigMap[newExternalValue] = newEnumValueConfig === void 0 ? originalEnumValueConfig : newEnumValueConfig;
            } else if (mappedEnumValue !== null) {
              newEnumValueConfigMap[externalValue] = mappedEnumValue;
            }
          }
          return correctASTNodes(new graphql_1.GraphQLEnumType({
            ...config,
            values: newEnumValueConfigMap
          }));
        }
      }, (type) => (0, graphql_1.isEnumType)(type));
    }
    function mapDefaultValues(originalTypeMap, schema, fn) {
      const newTypeMap = mapArguments(originalTypeMap, schema, {
        [Interfaces_js_1.MapperKind.ARGUMENT]: (argumentConfig) => {
          if (argumentConfig.defaultValue === void 0) {
            return argumentConfig;
          }
          const maybeNewType = getNewType(originalTypeMap, argumentConfig.type);
          if (maybeNewType != null) {
            return {
              ...argumentConfig,
              defaultValue: fn(maybeNewType, argumentConfig.defaultValue)
            };
          }
        }
      });
      return mapFields(newTypeMap, schema, {
        [Interfaces_js_1.MapperKind.INPUT_OBJECT_FIELD]: (inputFieldConfig) => {
          if (inputFieldConfig.defaultValue === void 0) {
            return inputFieldConfig;
          }
          const maybeNewType = getNewType(newTypeMap, inputFieldConfig.type);
          if (maybeNewType != null) {
            return {
              ...inputFieldConfig,
              defaultValue: fn(maybeNewType, inputFieldConfig.defaultValue)
            };
          }
        }
      });
    }
    function getNewType(newTypeMap, type) {
      if ((0, graphql_1.isListType)(type)) {
        const newType = getNewType(newTypeMap, type.ofType);
        return newType != null ? new graphql_1.GraphQLList(newType) : null;
      } else if ((0, graphql_1.isNonNullType)(type)) {
        const newType = getNewType(newTypeMap, type.ofType);
        return newType != null ? new graphql_1.GraphQLNonNull(newType) : null;
      } else if ((0, graphql_1.isNamedType)(type)) {
        const newType = newTypeMap[type.name];
        return newType != null ? newType : null;
      }
      return null;
    }
    function mapFields(originalTypeMap, schema, schemaMapper) {
      const newTypeMap = {};
      for (const typeName in originalTypeMap) {
        if (!typeName.startsWith("__")) {
          const originalType = originalTypeMap[typeName];
          if (!(0, graphql_1.isObjectType)(originalType) && !(0, graphql_1.isInterfaceType)(originalType) && !(0, graphql_1.isInputObjectType)(originalType)) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          const fieldMapper = getFieldMapper(schema, schemaMapper, typeName);
          if (fieldMapper == null) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          const config = originalType.toConfig();
          const originalFieldConfigMap = config.fields;
          const newFieldConfigMap = {};
          for (const fieldName in originalFieldConfigMap) {
            const originalFieldConfig = originalFieldConfigMap[fieldName];
            const mappedField = fieldMapper(originalFieldConfig, fieldName, typeName, schema);
            if (mappedField === void 0) {
              newFieldConfigMap[fieldName] = originalFieldConfig;
            } else if (Array.isArray(mappedField)) {
              const [newFieldName, newFieldConfig] = mappedField;
              if (newFieldConfig.astNode != null) {
                newFieldConfig.astNode = {
                  ...newFieldConfig.astNode,
                  name: {
                    ...newFieldConfig.astNode.name,
                    value: newFieldName
                  }
                };
              }
              newFieldConfigMap[newFieldName] = newFieldConfig === void 0 ? originalFieldConfig : newFieldConfig;
            } else if (mappedField !== null) {
              newFieldConfigMap[fieldName] = mappedField;
            }
          }
          if ((0, graphql_1.isObjectType)(originalType)) {
            newTypeMap[typeName] = correctASTNodes(new graphql_1.GraphQLObjectType({
              ...config,
              fields: newFieldConfigMap
            }));
          } else if ((0, graphql_1.isInterfaceType)(originalType)) {
            newTypeMap[typeName] = correctASTNodes(new graphql_1.GraphQLInterfaceType({
              ...config,
              fields: newFieldConfigMap
            }));
          } else {
            newTypeMap[typeName] = correctASTNodes(new graphql_1.GraphQLInputObjectType({
              ...config,
              fields: newFieldConfigMap
            }));
          }
        }
      }
      return newTypeMap;
    }
    function mapArguments(originalTypeMap, schema, schemaMapper) {
      const newTypeMap = {};
      for (const typeName in originalTypeMap) {
        if (!typeName.startsWith("__")) {
          const originalType = originalTypeMap[typeName];
          if (!(0, graphql_1.isObjectType)(originalType) && !(0, graphql_1.isInterfaceType)(originalType)) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          const argumentMapper = getArgumentMapper(schemaMapper);
          if (argumentMapper == null) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          const config = originalType.toConfig();
          const originalFieldConfigMap = config.fields;
          const newFieldConfigMap = {};
          for (const fieldName in originalFieldConfigMap) {
            const originalFieldConfig = originalFieldConfigMap[fieldName];
            const originalArgumentConfigMap = originalFieldConfig.args;
            if (originalArgumentConfigMap == null) {
              newFieldConfigMap[fieldName] = originalFieldConfig;
              continue;
            }
            const argumentNames = Object.keys(originalArgumentConfigMap);
            if (!argumentNames.length) {
              newFieldConfigMap[fieldName] = originalFieldConfig;
              continue;
            }
            const newArgumentConfigMap = {};
            for (const argumentName of argumentNames) {
              const originalArgumentConfig = originalArgumentConfigMap[argumentName];
              const mappedArgument = argumentMapper(originalArgumentConfig, fieldName, typeName, schema);
              if (mappedArgument === void 0) {
                newArgumentConfigMap[argumentName] = originalArgumentConfig;
              } else if (Array.isArray(mappedArgument)) {
                const [newArgumentName, newArgumentConfig] = mappedArgument;
                newArgumentConfigMap[newArgumentName] = newArgumentConfig;
              } else if (mappedArgument !== null) {
                newArgumentConfigMap[argumentName] = mappedArgument;
              }
            }
            newFieldConfigMap[fieldName] = {
              ...originalFieldConfig,
              args: newArgumentConfigMap
            };
          }
          if ((0, graphql_1.isObjectType)(originalType)) {
            newTypeMap[typeName] = new graphql_1.GraphQLObjectType({
              ...config,
              fields: newFieldConfigMap
            });
          } else if ((0, graphql_1.isInterfaceType)(originalType)) {
            newTypeMap[typeName] = new graphql_1.GraphQLInterfaceType({
              ...config,
              fields: newFieldConfigMap
            });
          } else {
            newTypeMap[typeName] = new graphql_1.GraphQLInputObjectType({
              ...config,
              fields: newFieldConfigMap
            });
          }
        }
      }
      return newTypeMap;
    }
    function mapDirectives(originalDirectives, schema, schemaMapper) {
      const directiveMapper = getDirectiveMapper(schemaMapper);
      if (directiveMapper == null) {
        return originalDirectives.slice();
      }
      const newDirectives = [];
      for (const directive of originalDirectives) {
        const mappedDirective = directiveMapper(directive, schema);
        if (mappedDirective === void 0) {
          newDirectives.push(directive);
        } else if (mappedDirective !== null) {
          newDirectives.push(mappedDirective);
        }
      }
      return newDirectives;
    }
    function getTypeSpecifiers(schema, typeName) {
      var _a, _b, _c;
      const type = schema.getType(typeName);
      const specifiers = [Interfaces_js_1.MapperKind.TYPE];
      if ((0, graphql_1.isObjectType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_TYPE, Interfaces_js_1.MapperKind.OBJECT_TYPE);
        if (typeName === ((_a = schema.getQueryType()) === null || _a === void 0 ? void 0 : _a.name)) {
          specifiers.push(Interfaces_js_1.MapperKind.ROOT_OBJECT, Interfaces_js_1.MapperKind.QUERY);
        } else if (typeName === ((_b = schema.getMutationType()) === null || _b === void 0 ? void 0 : _b.name)) {
          specifiers.push(Interfaces_js_1.MapperKind.ROOT_OBJECT, Interfaces_js_1.MapperKind.MUTATION);
        } else if (typeName === ((_c = schema.getSubscriptionType()) === null || _c === void 0 ? void 0 : _c.name)) {
          specifiers.push(Interfaces_js_1.MapperKind.ROOT_OBJECT, Interfaces_js_1.MapperKind.SUBSCRIPTION);
        }
      } else if ((0, graphql_1.isInputObjectType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.INPUT_OBJECT_TYPE);
      } else if ((0, graphql_1.isInterfaceType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_TYPE, Interfaces_js_1.MapperKind.ABSTRACT_TYPE, Interfaces_js_1.MapperKind.INTERFACE_TYPE);
      } else if ((0, graphql_1.isUnionType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_TYPE, Interfaces_js_1.MapperKind.ABSTRACT_TYPE, Interfaces_js_1.MapperKind.UNION_TYPE);
      } else if ((0, graphql_1.isEnumType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.ENUM_TYPE);
      } else if ((0, graphql_1.isScalarType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.SCALAR_TYPE);
      }
      return specifiers;
    }
    function getTypeMapper(schema, schemaMapper, typeName) {
      const specifiers = getTypeSpecifiers(schema, typeName);
      let typeMapper;
      const stack = [...specifiers];
      while (!typeMapper && stack.length > 0) {
        const next = stack.pop();
        typeMapper = schemaMapper[next];
      }
      return typeMapper != null ? typeMapper : null;
    }
    function getFieldSpecifiers(schema, typeName) {
      var _a, _b, _c;
      const type = schema.getType(typeName);
      const specifiers = [Interfaces_js_1.MapperKind.FIELD];
      if ((0, graphql_1.isObjectType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_FIELD, Interfaces_js_1.MapperKind.OBJECT_FIELD);
        if (typeName === ((_a = schema.getQueryType()) === null || _a === void 0 ? void 0 : _a.name)) {
          specifiers.push(Interfaces_js_1.MapperKind.ROOT_FIELD, Interfaces_js_1.MapperKind.QUERY_ROOT_FIELD);
        } else if (typeName === ((_b = schema.getMutationType()) === null || _b === void 0 ? void 0 : _b.name)) {
          specifiers.push(Interfaces_js_1.MapperKind.ROOT_FIELD, Interfaces_js_1.MapperKind.MUTATION_ROOT_FIELD);
        } else if (typeName === ((_c = schema.getSubscriptionType()) === null || _c === void 0 ? void 0 : _c.name)) {
          specifiers.push(Interfaces_js_1.MapperKind.ROOT_FIELD, Interfaces_js_1.MapperKind.SUBSCRIPTION_ROOT_FIELD);
        }
      } else if ((0, graphql_1.isInterfaceType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_FIELD, Interfaces_js_1.MapperKind.INTERFACE_FIELD);
      } else if ((0, graphql_1.isInputObjectType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.INPUT_OBJECT_FIELD);
      }
      return specifiers;
    }
    function getFieldMapper(schema, schemaMapper, typeName) {
      const specifiers = getFieldSpecifiers(schema, typeName);
      let fieldMapper;
      const stack = [...specifiers];
      while (!fieldMapper && stack.length > 0) {
        const next = stack.pop();
        fieldMapper = schemaMapper[next];
      }
      return fieldMapper !== null && fieldMapper !== void 0 ? fieldMapper : null;
    }
    function getArgumentMapper(schemaMapper) {
      const argumentMapper = schemaMapper[Interfaces_js_1.MapperKind.ARGUMENT];
      return argumentMapper != null ? argumentMapper : null;
    }
    function getDirectiveMapper(schemaMapper) {
      const directiveMapper = schemaMapper[Interfaces_js_1.MapperKind.DIRECTIVE];
      return directiveMapper != null ? directiveMapper : null;
    }
    function getEnumValueMapper(schemaMapper) {
      const enumValueMapper = schemaMapper[Interfaces_js_1.MapperKind.ENUM_VALUE];
      return enumValueMapper != null ? enumValueMapper : null;
    }
    function correctASTNodes(type) {
      if ((0, graphql_1.isObjectType)(type)) {
        const config = type.toConfig();
        if (config.astNode != null) {
          const fields = [];
          for (const fieldName in config.fields) {
            const fieldConfig = config.fields[fieldName];
            if (fieldConfig.astNode != null) {
              fields.push(fieldConfig.astNode);
            }
          }
          config.astNode = {
            ...config.astNode,
            kind: graphql_1.Kind.OBJECT_TYPE_DEFINITION,
            fields
          };
        }
        if (config.extensionASTNodes != null) {
          config.extensionASTNodes = config.extensionASTNodes.map((node) => ({
            ...node,
            kind: graphql_1.Kind.OBJECT_TYPE_EXTENSION,
            fields: void 0
          }));
        }
        return new graphql_1.GraphQLObjectType(config);
      } else if ((0, graphql_1.isInterfaceType)(type)) {
        const config = type.toConfig();
        if (config.astNode != null) {
          const fields = [];
          for (const fieldName in config.fields) {
            const fieldConfig = config.fields[fieldName];
            if (fieldConfig.astNode != null) {
              fields.push(fieldConfig.astNode);
            }
          }
          config.astNode = {
            ...config.astNode,
            kind: graphql_1.Kind.INTERFACE_TYPE_DEFINITION,
            fields
          };
        }
        if (config.extensionASTNodes != null) {
          config.extensionASTNodes = config.extensionASTNodes.map((node) => ({
            ...node,
            kind: graphql_1.Kind.INTERFACE_TYPE_EXTENSION,
            fields: void 0
          }));
        }
        return new graphql_1.GraphQLInterfaceType(config);
      } else if ((0, graphql_1.isInputObjectType)(type)) {
        const config = type.toConfig();
        if (config.astNode != null) {
          const fields = [];
          for (const fieldName in config.fields) {
            const fieldConfig = config.fields[fieldName];
            if (fieldConfig.astNode != null) {
              fields.push(fieldConfig.astNode);
            }
          }
          config.astNode = {
            ...config.astNode,
            kind: graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION,
            fields
          };
        }
        if (config.extensionASTNodes != null) {
          config.extensionASTNodes = config.extensionASTNodes.map((node) => ({
            ...node,
            kind: graphql_1.Kind.INPUT_OBJECT_TYPE_EXTENSION,
            fields: void 0
          }));
        }
        return new graphql_1.GraphQLInputObjectType(config);
      } else if ((0, graphql_1.isEnumType)(type)) {
        const config = type.toConfig();
        if (config.astNode != null) {
          const values = [];
          for (const enumKey in config.values) {
            const enumValueConfig = config.values[enumKey];
            if (enumValueConfig.astNode != null) {
              values.push(enumValueConfig.astNode);
            }
          }
          config.astNode = {
            ...config.astNode,
            values
          };
        }
        if (config.extensionASTNodes != null) {
          config.extensionASTNodes = config.extensionASTNodes.map((node) => ({
            ...node,
            values: void 0
          }));
        }
        return new graphql_1.GraphQLEnumType(config);
      } else {
        return type;
      }
    }
    exports2.correctASTNodes = correctASTNodes;
  }
});

// ../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/filterSchema.js
var require_filterSchema3 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/filterSchema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.filterSchema = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var Interfaces_js_1 = require_Interfaces3();
    var mapSchema_js_1 = require_mapSchema3();
    function filterSchema({ schema, typeFilter = () => true, fieldFilter = void 0, rootFieldFilter = void 0, objectFieldFilter = void 0, interfaceFieldFilter = void 0, inputObjectFieldFilter = void 0, argumentFilter = void 0 }) {
      const filteredSchema = (0, mapSchema_js_1.mapSchema)(schema, {
        [Interfaces_js_1.MapperKind.QUERY]: (type) => filterRootFields(type, "Query", rootFieldFilter, argumentFilter),
        [Interfaces_js_1.MapperKind.MUTATION]: (type) => filterRootFields(type, "Mutation", rootFieldFilter, argumentFilter),
        [Interfaces_js_1.MapperKind.SUBSCRIPTION]: (type) => filterRootFields(type, "Subscription", rootFieldFilter, argumentFilter),
        [Interfaces_js_1.MapperKind.OBJECT_TYPE]: (type) => typeFilter(type.name, type) ? filterElementFields(graphql_1.GraphQLObjectType, type, objectFieldFilter || fieldFilter, argumentFilter) : null,
        [Interfaces_js_1.MapperKind.INTERFACE_TYPE]: (type) => typeFilter(type.name, type) ? filterElementFields(graphql_1.GraphQLInterfaceType, type, interfaceFieldFilter || fieldFilter, argumentFilter) : null,
        [Interfaces_js_1.MapperKind.INPUT_OBJECT_TYPE]: (type) => typeFilter(type.name, type) ? filterElementFields(graphql_1.GraphQLInputObjectType, type, inputObjectFieldFilter || fieldFilter) : null,
        [Interfaces_js_1.MapperKind.UNION_TYPE]: (type) => typeFilter(type.name, type) ? void 0 : null,
        [Interfaces_js_1.MapperKind.ENUM_TYPE]: (type) => typeFilter(type.name, type) ? void 0 : null,
        [Interfaces_js_1.MapperKind.SCALAR_TYPE]: (type) => typeFilter(type.name, type) ? void 0 : null
      });
      return filteredSchema;
    }
    exports2.filterSchema = filterSchema;
    function filterRootFields(type, operation, rootFieldFilter, argumentFilter) {
      if (rootFieldFilter || argumentFilter) {
        const config = type.toConfig();
        for (const fieldName in config.fields) {
          const field = config.fields[fieldName];
          if (rootFieldFilter && !rootFieldFilter(operation, fieldName, config.fields[fieldName])) {
            delete config.fields[fieldName];
          } else if (argumentFilter && field.args) {
            for (const argName in field.args) {
              if (!argumentFilter(operation, fieldName, argName, field.args[argName])) {
                delete field.args[argName];
              }
            }
          }
        }
        return new graphql_1.GraphQLObjectType(config);
      }
      return type;
    }
    function filterElementFields(ElementConstructor, type, fieldFilter, argumentFilter) {
      if (fieldFilter || argumentFilter) {
        const config = type.toConfig();
        for (const fieldName in config.fields) {
          const field = config.fields[fieldName];
          if (fieldFilter && !fieldFilter(type.name, fieldName, config.fields[fieldName])) {
            delete config.fields[fieldName];
          } else if (argumentFilter && "args" in field) {
            for (const argName in field.args) {
              if (!argumentFilter(type.name, fieldName, argName, field.args[argName])) {
                delete field.args[argName];
              }
            }
          }
        }
        return new ElementConstructor(config);
      }
    }
  }
});

// ../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/heal.js
var require_heal3 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/heal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.healTypes = exports2.healSchema = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function healSchema(schema) {
      healTypes(schema.getTypeMap(), schema.getDirectives());
      return schema;
    }
    exports2.healSchema = healSchema;
    function healTypes(originalTypeMap, directives) {
      const actualNamedTypeMap = /* @__PURE__ */ Object.create(null);
      for (const typeName in originalTypeMap) {
        const namedType = originalTypeMap[typeName];
        if (namedType == null || typeName.startsWith("__")) {
          continue;
        }
        const actualName = namedType.name;
        if (actualName.startsWith("__")) {
          continue;
        }
        if (actualName in actualNamedTypeMap) {
          throw new Error(`Duplicate schema type name ${actualName}`);
        }
        actualNamedTypeMap[actualName] = namedType;
      }
      for (const typeName in actualNamedTypeMap) {
        const namedType = actualNamedTypeMap[typeName];
        originalTypeMap[typeName] = namedType;
      }
      for (const decl of directives) {
        decl.args = decl.args.filter((arg) => {
          arg.type = healType(arg.type);
          return arg.type !== null;
        });
      }
      for (const typeName in originalTypeMap) {
        const namedType = originalTypeMap[typeName];
        if (!typeName.startsWith("__") && typeName in actualNamedTypeMap) {
          if (namedType != null) {
            healNamedType(namedType);
          }
        }
      }
      for (const typeName in originalTypeMap) {
        if (!typeName.startsWith("__") && !(typeName in actualNamedTypeMap)) {
          delete originalTypeMap[typeName];
        }
      }
      function healNamedType(type) {
        if ((0, graphql_1.isObjectType)(type)) {
          healFields(type);
          healInterfaces(type);
          return;
        } else if ((0, graphql_1.isInterfaceType)(type)) {
          healFields(type);
          if ("getInterfaces" in type) {
            healInterfaces(type);
          }
          return;
        } else if ((0, graphql_1.isUnionType)(type)) {
          healUnderlyingTypes(type);
          return;
        } else if ((0, graphql_1.isInputObjectType)(type)) {
          healInputFields(type);
          return;
        } else if ((0, graphql_1.isLeafType)(type)) {
          return;
        }
        throw new Error(`Unexpected schema type: ${type}`);
      }
      function healFields(type) {
        const fieldMap = type.getFields();
        for (const [key, field] of Object.entries(fieldMap)) {
          field.args.map((arg) => {
            arg.type = healType(arg.type);
            return arg.type === null ? null : arg;
          }).filter(Boolean);
          field.type = healType(field.type);
          if (field.type === null) {
            delete fieldMap[key];
          }
        }
      }
      function healInterfaces(type) {
        if ("getInterfaces" in type) {
          const interfaces = type.getInterfaces();
          interfaces.push(...interfaces.splice(0).map((iface) => healType(iface)).filter(Boolean));
        }
      }
      function healInputFields(type) {
        const fieldMap = type.getFields();
        for (const [key, field] of Object.entries(fieldMap)) {
          field.type = healType(field.type);
          if (field.type === null) {
            delete fieldMap[key];
          }
        }
      }
      function healUnderlyingTypes(type) {
        const types = type.getTypes();
        types.push(...types.splice(0).map((t) => healType(t)).filter(Boolean));
      }
      function healType(type) {
        if ((0, graphql_1.isListType)(type)) {
          const healedType = healType(type.ofType);
          return healedType != null ? new graphql_1.GraphQLList(healedType) : null;
        } else if ((0, graphql_1.isNonNullType)(type)) {
          const healedType = healType(type.ofType);
          return healedType != null ? new graphql_1.GraphQLNonNull(healedType) : null;
        } else if ((0, graphql_1.isNamedType)(type)) {
          const officialType = originalTypeMap[type.name];
          if (officialType && type !== officialType) {
            return officialType;
          }
        }
        return type;
      }
    }
    exports2.healTypes = healTypes;
  }
});

// ../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/getResolversFromSchema.js
var require_getResolversFromSchema3 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/getResolversFromSchema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getResolversFromSchema = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function getResolversFromSchema(schema, includeDefaultMergedResolver) {
      var _a, _b;
      const resolvers = /* @__PURE__ */ Object.create(null);
      const typeMap = schema.getTypeMap();
      for (const typeName in typeMap) {
        if (!typeName.startsWith("__")) {
          const type = typeMap[typeName];
          if ((0, graphql_1.isScalarType)(type)) {
            if (!(0, graphql_1.isSpecifiedScalarType)(type)) {
              const config = type.toConfig();
              delete config.astNode;
              resolvers[typeName] = new graphql_1.GraphQLScalarType(config);
            }
          } else if ((0, graphql_1.isEnumType)(type)) {
            resolvers[typeName] = {};
            const values = type.getValues();
            for (const value of values) {
              resolvers[typeName][value.name] = value.value;
            }
          } else if ((0, graphql_1.isInterfaceType)(type)) {
            if (type.resolveType != null) {
              resolvers[typeName] = {
                __resolveType: type.resolveType
              };
            }
          } else if ((0, graphql_1.isUnionType)(type)) {
            if (type.resolveType != null) {
              resolvers[typeName] = {
                __resolveType: type.resolveType
              };
            }
          } else if ((0, graphql_1.isObjectType)(type)) {
            resolvers[typeName] = {};
            if (type.isTypeOf != null) {
              resolvers[typeName].__isTypeOf = type.isTypeOf;
            }
            const fields = type.getFields();
            for (const fieldName in fields) {
              const field = fields[fieldName];
              if (field.subscribe != null) {
                resolvers[typeName][fieldName] = resolvers[typeName][fieldName] || {};
                resolvers[typeName][fieldName].subscribe = field.subscribe;
              }
              if (field.resolve != null && ((_a = field.resolve) === null || _a === void 0 ? void 0 : _a.name) !== "defaultFieldResolver") {
                switch ((_b = field.resolve) === null || _b === void 0 ? void 0 : _b.name) {
                  case "defaultMergedResolver":
                    if (!includeDefaultMergedResolver) {
                      continue;
                    }
                    break;
                  case "defaultFieldResolver":
                    continue;
                }
                resolvers[typeName][fieldName] = resolvers[typeName][fieldName] || {};
                resolvers[typeName][fieldName].resolve = field.resolve;
              }
            }
          }
        }
      }
      return resolvers;
    }
    exports2.getResolversFromSchema = getResolversFromSchema;
  }
});

// ../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/forEachField.js
var require_forEachField3 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/forEachField.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.forEachField = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function forEachField(schema, fn) {
      const typeMap = schema.getTypeMap();
      for (const typeName in typeMap) {
        const type = typeMap[typeName];
        if (!(0, graphql_1.getNamedType)(type).name.startsWith("__") && (0, graphql_1.isObjectType)(type)) {
          const fields = type.getFields();
          for (const fieldName in fields) {
            const field = fields[fieldName];
            fn(field, typeName, fieldName);
          }
        }
      }
    }
    exports2.forEachField = forEachField;
  }
});

// ../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/forEachDefaultValue.js
var require_forEachDefaultValue3 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/forEachDefaultValue.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.forEachDefaultValue = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function forEachDefaultValue(schema, fn) {
      const typeMap = schema.getTypeMap();
      for (const typeName in typeMap) {
        const type = typeMap[typeName];
        if (!(0, graphql_1.getNamedType)(type).name.startsWith("__")) {
          if ((0, graphql_1.isObjectType)(type)) {
            const fields = type.getFields();
            for (const fieldName in fields) {
              const field = fields[fieldName];
              for (const arg of field.args) {
                arg.defaultValue = fn(arg.type, arg.defaultValue);
              }
            }
          } else if ((0, graphql_1.isInputObjectType)(type)) {
            const fields = type.getFields();
            for (const fieldName in fields) {
              const field = fields[fieldName];
              field.defaultValue = fn(field.type, field.defaultValue);
            }
          }
        }
      }
    }
    exports2.forEachDefaultValue = forEachDefaultValue;
  }
});

// ../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/addTypes.js
var require_addTypes3 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/addTypes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.addTypes = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var getObjectTypeFromTypeMap_js_1 = require_getObjectTypeFromTypeMap3();
    var rewire_js_1 = require_rewire3();
    function addTypes(schema, newTypesOrDirectives) {
      const config = schema.toConfig();
      const originalTypeMap = {};
      for (const type of config.types) {
        originalTypeMap[type.name] = type;
      }
      const originalDirectiveMap = {};
      for (const directive of config.directives) {
        originalDirectiveMap[directive.name] = directive;
      }
      for (const newTypeOrDirective of newTypesOrDirectives) {
        if ((0, graphql_1.isNamedType)(newTypeOrDirective)) {
          originalTypeMap[newTypeOrDirective.name] = newTypeOrDirective;
        } else if ((0, graphql_1.isDirective)(newTypeOrDirective)) {
          originalDirectiveMap[newTypeOrDirective.name] = newTypeOrDirective;
        }
      }
      const { typeMap, directives } = (0, rewire_js_1.rewireTypes)(originalTypeMap, Object.values(originalDirectiveMap));
      return new graphql_1.GraphQLSchema({
        ...config,
        query: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, schema.getQueryType()),
        mutation: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, schema.getMutationType()),
        subscription: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, schema.getSubscriptionType()),
        types: Object.values(typeMap),
        directives
      });
    }
    exports2.addTypes = addTypes;
  }
});

// ../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/prune.js
var require_prune3 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/prune.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.pruneSchema = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var mapSchema_js_1 = require_mapSchema3();
    var Interfaces_js_1 = require_Interfaces3();
    var rootTypes_js_1 = require_rootTypes3();
    var get_implementing_types_js_1 = require_get_implementing_types3();
    function pruneSchema(schema, options = {}) {
      const { skipEmptyCompositeTypePruning, skipEmptyUnionPruning, skipPruning, skipUnimplementedInterfacesPruning, skipUnusedTypesPruning } = options;
      let prunedTypes = [];
      let prunedSchema = schema;
      do {
        let visited = visitSchema(prunedSchema);
        if (skipPruning) {
          const revisit = [];
          for (const typeName in prunedSchema.getTypeMap()) {
            if (typeName.startsWith("__")) {
              continue;
            }
            const type = prunedSchema.getType(typeName);
            if (type && skipPruning(type)) {
              revisit.push(typeName);
            }
          }
          visited = visitQueue(revisit, prunedSchema, visited);
        }
        prunedTypes = [];
        prunedSchema = (0, mapSchema_js_1.mapSchema)(prunedSchema, {
          [Interfaces_js_1.MapperKind.TYPE]: (type) => {
            if (!visited.has(type.name) && !(0, graphql_1.isSpecifiedScalarType)(type)) {
              if ((0, graphql_1.isUnionType)(type) || (0, graphql_1.isInputObjectType)(type) || (0, graphql_1.isInterfaceType)(type) || (0, graphql_1.isObjectType)(type) || (0, graphql_1.isScalarType)(type)) {
                if (skipUnusedTypesPruning) {
                  return type;
                }
                if ((0, graphql_1.isUnionType)(type) && skipEmptyUnionPruning && !Object.keys(type.getTypes()).length) {
                  return type;
                }
                if ((0, graphql_1.isInputObjectType)(type) || (0, graphql_1.isInterfaceType)(type) || (0, graphql_1.isObjectType)(type)) {
                  if (skipEmptyCompositeTypePruning && !Object.keys(type.getFields()).length) {
                    return type;
                  }
                }
                if ((0, graphql_1.isInterfaceType)(type) && skipUnimplementedInterfacesPruning) {
                  return type;
                }
              }
              prunedTypes.push(type.name);
              visited.delete(type.name);
              return null;
            }
            return type;
          }
        });
      } while (prunedTypes.length);
      return prunedSchema;
    }
    exports2.pruneSchema = pruneSchema;
    function visitSchema(schema) {
      const queue = [];
      for (const type of (0, rootTypes_js_1.getRootTypes)(schema)) {
        queue.push(type.name);
      }
      return visitQueue(queue, schema);
    }
    function visitQueue(queue, schema, visited = /* @__PURE__ */ new Set()) {
      const revisit = /* @__PURE__ */ new Map();
      while (queue.length) {
        const typeName = queue.pop();
        if (visited.has(typeName) && revisit[typeName] !== true) {
          continue;
        }
        const type = schema.getType(typeName);
        if (type) {
          if ((0, graphql_1.isUnionType)(type)) {
            queue.push(...type.getTypes().map((type2) => type2.name));
          }
          if ((0, graphql_1.isInterfaceType)(type) && revisit[typeName] === true) {
            queue.push(...(0, get_implementing_types_js_1.getImplementingTypes)(type.name, schema));
            revisit[typeName] = false;
          }
          if ("getInterfaces" in type) {
            queue.push(...type.getInterfaces().map((iface) => iface.name));
          }
          if ("getFields" in type) {
            const fields = type.getFields();
            const entries = Object.entries(fields);
            if (!entries.length) {
              continue;
            }
            for (const [, field] of entries) {
              if ((0, graphql_1.isObjectType)(type)) {
                queue.push(...field.args.map((arg) => (0, graphql_1.getNamedType)(arg.type).name));
              }
              const namedType = (0, graphql_1.getNamedType)(field.type);
              queue.push(namedType.name);
              if ((0, graphql_1.isInterfaceType)(namedType) && !(namedType.name in revisit)) {
                revisit[namedType.name] = true;
              }
            }
          }
          visited.add(typeName);
        }
      }
      return visited;
    }
  }
});

// ../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/mergeDeep.js
var require_mergeDeep3 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/mergeDeep.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeDeep = void 0;
    var helpers_js_1 = require_helpers3();
    function mergeDeep(sources, respectPrototype = false) {
      const target = sources[0] || {};
      const output = {};
      if (respectPrototype) {
        Object.setPrototypeOf(output, Object.create(Object.getPrototypeOf(target)));
      }
      for (const source of sources) {
        if (isObject(target) && isObject(source)) {
          if (respectPrototype) {
            const outputPrototype = Object.getPrototypeOf(output);
            const sourcePrototype = Object.getPrototypeOf(source);
            if (sourcePrototype) {
              for (const key of Object.getOwnPropertyNames(sourcePrototype)) {
                const descriptor = Object.getOwnPropertyDescriptor(sourcePrototype, key);
                if ((0, helpers_js_1.isSome)(descriptor)) {
                  Object.defineProperty(outputPrototype, key, descriptor);
                }
              }
            }
          }
          for (const key in source) {
            if (isObject(source[key])) {
              if (!(key in output)) {
                Object.assign(output, { [key]: source[key] });
              } else {
                output[key] = mergeDeep([output[key], source[key]], respectPrototype);
              }
            } else {
              Object.assign(output, { [key]: source[key] });
            }
          }
        }
      }
      return output;
    }
    exports2.mergeDeep = mergeDeep;
    function isObject(item) {
      return item && typeof item === "object" && !Array.isArray(item);
    }
  }
});

// ../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/selectionSets.js
var require_selectionSets3 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/selectionSets.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseSelectionSet = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function parseSelectionSet(selectionSet, options) {
      const query = (0, graphql_1.parse)(selectionSet, options).definitions[0];
      return query.selectionSet;
    }
    exports2.parseSelectionSet = parseSelectionSet;
  }
});

// ../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/getResponseKeyFromInfo.js
var require_getResponseKeyFromInfo3 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/getResponseKeyFromInfo.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getResponseKeyFromInfo = void 0;
    function getResponseKeyFromInfo(info) {
      return info.fieldNodes[0].alias != null ? info.fieldNodes[0].alias.value : info.fieldName;
    }
    exports2.getResponseKeyFromInfo = getResponseKeyFromInfo;
  }
});

// ../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/fields.js
var require_fields4 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/fields.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.modifyObjectFields = exports2.selectObjectFields = exports2.removeObjectFields = exports2.appendObjectFields = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var Interfaces_js_1 = require_Interfaces3();
    var mapSchema_js_1 = require_mapSchema3();
    var addTypes_js_1 = require_addTypes3();
    function appendObjectFields(schema, typeName, additionalFields) {
      if (schema.getType(typeName) == null) {
        return (0, addTypes_js_1.addTypes)(schema, [
          new graphql_1.GraphQLObjectType({
            name: typeName,
            fields: additionalFields
          })
        ]);
      }
      return (0, mapSchema_js_1.mapSchema)(schema, {
        [Interfaces_js_1.MapperKind.OBJECT_TYPE]: (type) => {
          if (type.name === typeName) {
            const config = type.toConfig();
            const originalFieldConfigMap = config.fields;
            const newFieldConfigMap = {};
            for (const fieldName in originalFieldConfigMap) {
              newFieldConfigMap[fieldName] = originalFieldConfigMap[fieldName];
            }
            for (const fieldName in additionalFields) {
              newFieldConfigMap[fieldName] = additionalFields[fieldName];
            }
            return (0, mapSchema_js_1.correctASTNodes)(new graphql_1.GraphQLObjectType({
              ...config,
              fields: newFieldConfigMap
            }));
          }
        }
      });
    }
    exports2.appendObjectFields = appendObjectFields;
    function removeObjectFields(schema, typeName, testFn) {
      const removedFields = {};
      const newSchema = (0, mapSchema_js_1.mapSchema)(schema, {
        [Interfaces_js_1.MapperKind.OBJECT_TYPE]: (type) => {
          if (type.name === typeName) {
            const config = type.toConfig();
            const originalFieldConfigMap = config.fields;
            const newFieldConfigMap = {};
            for (const fieldName in originalFieldConfigMap) {
              const originalFieldConfig = originalFieldConfigMap[fieldName];
              if (testFn(fieldName, originalFieldConfig)) {
                removedFields[fieldName] = originalFieldConfig;
              } else {
                newFieldConfigMap[fieldName] = originalFieldConfig;
              }
            }
            return (0, mapSchema_js_1.correctASTNodes)(new graphql_1.GraphQLObjectType({
              ...config,
              fields: newFieldConfigMap
            }));
          }
        }
      });
      return [newSchema, removedFields];
    }
    exports2.removeObjectFields = removeObjectFields;
    function selectObjectFields(schema, typeName, testFn) {
      const selectedFields = {};
      (0, mapSchema_js_1.mapSchema)(schema, {
        [Interfaces_js_1.MapperKind.OBJECT_TYPE]: (type) => {
          if (type.name === typeName) {
            const config = type.toConfig();
            const originalFieldConfigMap = config.fields;
            for (const fieldName in originalFieldConfigMap) {
              const originalFieldConfig = originalFieldConfigMap[fieldName];
              if (testFn(fieldName, originalFieldConfig)) {
                selectedFields[fieldName] = originalFieldConfig;
              }
            }
          }
          return void 0;
        }
      });
      return selectedFields;
    }
    exports2.selectObjectFields = selectObjectFields;
    function modifyObjectFields(schema, typeName, testFn, newFields) {
      const removedFields = {};
      const newSchema = (0, mapSchema_js_1.mapSchema)(schema, {
        [Interfaces_js_1.MapperKind.OBJECT_TYPE]: (type) => {
          if (type.name === typeName) {
            const config = type.toConfig();
            const originalFieldConfigMap = config.fields;
            const newFieldConfigMap = {};
            for (const fieldName in originalFieldConfigMap) {
              const originalFieldConfig = originalFieldConfigMap[fieldName];
              if (testFn(fieldName, originalFieldConfig)) {
                removedFields[fieldName] = originalFieldConfig;
              } else {
                newFieldConfigMap[fieldName] = originalFieldConfig;
              }
            }
            for (const fieldName in newFields) {
              const fieldConfig = newFields[fieldName];
              newFieldConfigMap[fieldName] = fieldConfig;
            }
            return (0, mapSchema_js_1.correctASTNodes)(new graphql_1.GraphQLObjectType({
              ...config,
              fields: newFieldConfigMap
            }));
          }
        }
      });
      return [newSchema, removedFields];
    }
    exports2.modifyObjectFields = modifyObjectFields;
  }
});

// ../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/renameType.js
var require_renameType3 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/renameType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.renameType = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function renameType(type, newTypeName) {
      if ((0, graphql_1.isObjectType)(type)) {
        return new graphql_1.GraphQLObjectType({
          ...type.toConfig(),
          name: newTypeName,
          astNode: type.astNode == null ? type.astNode : {
            ...type.astNode,
            name: {
              ...type.astNode.name,
              value: newTypeName
            }
          },
          extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map((node) => ({
            ...node,
            name: {
              ...node.name,
              value: newTypeName
            }
          }))
        });
      } else if ((0, graphql_1.isInterfaceType)(type)) {
        return new graphql_1.GraphQLInterfaceType({
          ...type.toConfig(),
          name: newTypeName,
          astNode: type.astNode == null ? type.astNode : {
            ...type.astNode,
            name: {
              ...type.astNode.name,
              value: newTypeName
            }
          },
          extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map((node) => ({
            ...node,
            name: {
              ...node.name,
              value: newTypeName
            }
          }))
        });
      } else if ((0, graphql_1.isUnionType)(type)) {
        return new graphql_1.GraphQLUnionType({
          ...type.toConfig(),
          name: newTypeName,
          astNode: type.astNode == null ? type.astNode : {
            ...type.astNode,
            name: {
              ...type.astNode.name,
              value: newTypeName
            }
          },
          extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map((node) => ({
            ...node,
            name: {
              ...node.name,
              value: newTypeName
            }
          }))
        });
      } else if ((0, graphql_1.isInputObjectType)(type)) {
        return new graphql_1.GraphQLInputObjectType({
          ...type.toConfig(),
          name: newTypeName,
          astNode: type.astNode == null ? type.astNode : {
            ...type.astNode,
            name: {
              ...type.astNode.name,
              value: newTypeName
            }
          },
          extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map((node) => ({
            ...node,
            name: {
              ...node.name,
              value: newTypeName
            }
          }))
        });
      } else if ((0, graphql_1.isEnumType)(type)) {
        return new graphql_1.GraphQLEnumType({
          ...type.toConfig(),
          name: newTypeName,
          astNode: type.astNode == null ? type.astNode : {
            ...type.astNode,
            name: {
              ...type.astNode.name,
              value: newTypeName
            }
          },
          extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map((node) => ({
            ...node,
            name: {
              ...node.name,
              value: newTypeName
            }
          }))
        });
      } else if ((0, graphql_1.isScalarType)(type)) {
        return new graphql_1.GraphQLScalarType({
          ...type.toConfig(),
          name: newTypeName,
          astNode: type.astNode == null ? type.astNode : {
            ...type.astNode,
            name: {
              ...type.astNode.name,
              value: newTypeName
            }
          },
          extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map((node) => ({
            ...node,
            name: {
              ...node.name,
              value: newTypeName
            }
          }))
        });
      }
      throw new Error(`Unknown type ${type}.`);
    }
    exports2.renameType = renameType;
  }
});

// ../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/mapAsyncIterator.js
var require_mapAsyncIterator3 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/mapAsyncIterator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mapAsyncIterator = void 0;
    function mapAsyncIterator2(iterator, callback, rejectCallback) {
      let $return;
      let abruptClose;
      if (typeof iterator.return === "function") {
        $return = iterator.return;
        abruptClose = (error) => {
          const rethrow = () => Promise.reject(error);
          return $return.call(iterator).then(rethrow, rethrow);
        };
      }
      function mapResult(result) {
        return result.done ? result : asyncMapValue(result.value, callback).then(iteratorResult, abruptClose);
      }
      let mapReject;
      if (rejectCallback) {
        const reject = rejectCallback;
        mapReject = (error) => asyncMapValue(error, reject).then(iteratorResult, abruptClose);
      }
      return {
        next() {
          return iterator.next().then(mapResult, mapReject);
        },
        return() {
          return $return ? $return.call(iterator).then(mapResult, mapReject) : Promise.resolve({ value: void 0, done: true });
        },
        throw(error) {
          if (typeof iterator.throw === "function") {
            return iterator.throw(error).then(mapResult, mapReject);
          }
          return Promise.reject(error).catch(abruptClose);
        },
        [Symbol.asyncIterator]() {
          return this;
        }
      };
    }
    exports2.mapAsyncIterator = mapAsyncIterator2;
    function asyncMapValue(value, callback) {
      return new Promise((resolve) => resolve(callback(value)));
    }
    function iteratorResult(value) {
      return { value, done: false };
    }
  }
});

// ../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/updateArgument.js
var require_updateArgument3 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/updateArgument.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createVariableNameGenerator = exports2.updateArgument = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var astFromType_js_1 = require_astFromType3();
    function updateArgument(argumentNodes, variableDefinitionsMap, variableValues, argName, varName, type, value) {
      argumentNodes[argName] = {
        kind: graphql_1.Kind.ARGUMENT,
        name: {
          kind: graphql_1.Kind.NAME,
          value: argName
        },
        value: {
          kind: graphql_1.Kind.VARIABLE,
          name: {
            kind: graphql_1.Kind.NAME,
            value: varName
          }
        }
      };
      variableDefinitionsMap[varName] = {
        kind: graphql_1.Kind.VARIABLE_DEFINITION,
        variable: {
          kind: graphql_1.Kind.VARIABLE,
          name: {
            kind: graphql_1.Kind.NAME,
            value: varName
          }
        },
        type: (0, astFromType_js_1.astFromType)(type)
      };
      if (value !== void 0) {
        variableValues[varName] = value;
        return;
      }
      if (varName in variableValues) {
        delete variableValues[varName];
      }
    }
    exports2.updateArgument = updateArgument;
    function createVariableNameGenerator(variableDefinitionMap) {
      let varCounter = 0;
      return (argName) => {
        let varName;
        do {
          varName = `_v${(varCounter++).toString()}_${argName}`;
        } while (varName in variableDefinitionMap);
        return varName;
      };
    }
    exports2.createVariableNameGenerator = createVariableNameGenerator;
  }
});

// ../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/implementsAbstractType.js
var require_implementsAbstractType3 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/implementsAbstractType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.implementsAbstractType = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function implementsAbstractType(schema, typeA, typeB) {
      if (typeB == null || typeA == null) {
        return false;
      } else if (typeA === typeB) {
        return true;
      } else if ((0, graphql_1.isCompositeType)(typeA) && (0, graphql_1.isCompositeType)(typeB)) {
        return (0, graphql_1.doTypesOverlap)(schema, typeA, typeB);
      }
      return false;
    }
    exports2.implementsAbstractType = implementsAbstractType;
  }
});

// ../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/observableToAsyncIterable.js
var require_observableToAsyncIterable3 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/observableToAsyncIterable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.observableToAsyncIterable = void 0;
    function observableToAsyncIterable(observable) {
      const pullQueue = [];
      const pushQueue = [];
      let listening = true;
      const pushValue = (value) => {
        if (pullQueue.length !== 0) {
          pullQueue.shift()({ value, done: false });
        } else {
          pushQueue.push({ value, done: false });
        }
      };
      const pushError = (error) => {
        if (pullQueue.length !== 0) {
          pullQueue.shift()({ value: { errors: [error] }, done: false });
        } else {
          pushQueue.push({ value: { errors: [error] }, done: false });
        }
      };
      const pushDone = () => {
        if (pullQueue.length !== 0) {
          pullQueue.shift()({ done: true });
        } else {
          pushQueue.push({ done: true });
        }
      };
      const pullValue = () => new Promise((resolve) => {
        if (pushQueue.length !== 0) {
          const element = pushQueue.shift();
          resolve(element);
        } else {
          pullQueue.push(resolve);
        }
      });
      const subscription = observable.subscribe({
        next(value) {
          pushValue(value);
        },
        error(err) {
          pushError(err);
        },
        complete() {
          pushDone();
        }
      });
      const emptyQueue = () => {
        if (listening) {
          listening = false;
          subscription.unsubscribe();
          for (const resolve of pullQueue) {
            resolve({ value: void 0, done: true });
          }
          pullQueue.length = 0;
          pushQueue.length = 0;
        }
      };
      return {
        next() {
          return listening ? pullValue() : this.return();
        },
        return() {
          emptyQueue();
          return Promise.resolve({ value: void 0, done: true });
        },
        throw(error) {
          emptyQueue();
          return Promise.reject(error);
        },
        [Symbol.asyncIterator]() {
          return this;
        }
      };
    }
    exports2.observableToAsyncIterable = observableToAsyncIterable;
  }
});

// ../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/getOperationASTFromRequest.js
var require_getOperationASTFromRequest3 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/getOperationASTFromRequest.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getOperationASTFromRequest = exports2.getOperationASTFromDocument = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var memoize_js_1 = require_memoize3();
    function getOperationASTFromDocument(documentNode, operationName) {
      const doc = (0, graphql_1.getOperationAST)(documentNode, operationName);
      if (!doc) {
        throw new Error(`Cannot infer operation ${operationName || ""}`);
      }
      return doc;
    }
    exports2.getOperationASTFromDocument = getOperationASTFromDocument;
    exports2.getOperationASTFromRequest = (0, memoize_js_1.memoize1)(function getOperationASTFromRequest(request) {
      return getOperationASTFromDocument(request.document, request.operationName);
    });
  }
});

// ../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/collectFields.js
var require_collectFields3 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/collectFields.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.collectSubFields = exports2.collectFields = void 0;
    var memoize_js_1 = require_memoize3();
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function collectFields2(schema, fragments, variableValues, runtimeType, selectionSet, fields, visitedFragmentNames) {
      for (const selection of selectionSet.selections) {
        switch (selection.kind) {
          case graphql_1.Kind.FIELD: {
            if (!shouldIncludeNode2(variableValues, selection)) {
              continue;
            }
            const name = getFieldEntryKey2(selection);
            const fieldList = fields.get(name);
            if (fieldList !== void 0) {
              fieldList.push(selection);
            } else {
              fields.set(name, [selection]);
            }
            break;
          }
          case graphql_1.Kind.INLINE_FRAGMENT: {
            if (!shouldIncludeNode2(variableValues, selection) || !doesFragmentConditionMatch2(schema, selection, runtimeType)) {
              continue;
            }
            collectFields2(schema, fragments, variableValues, runtimeType, selection.selectionSet, fields, visitedFragmentNames);
            break;
          }
          case graphql_1.Kind.FRAGMENT_SPREAD: {
            const fragName = selection.name.value;
            if (visitedFragmentNames.has(fragName) || !shouldIncludeNode2(variableValues, selection)) {
              continue;
            }
            visitedFragmentNames.add(fragName);
            const fragment = fragments[fragName];
            if (!fragment || !doesFragmentConditionMatch2(schema, fragment, runtimeType)) {
              continue;
            }
            collectFields2(schema, fragments, variableValues, runtimeType, fragment.selectionSet, fields, visitedFragmentNames);
            break;
          }
        }
      }
      return fields;
    }
    exports2.collectFields = collectFields2;
    function shouldIncludeNode2(variableValues, node) {
      const skip = (0, graphql_1.getDirectiveValues)(graphql_1.GraphQLSkipDirective, node, variableValues);
      if ((skip === null || skip === void 0 ? void 0 : skip["if"]) === true) {
        return false;
      }
      const include = (0, graphql_1.getDirectiveValues)(graphql_1.GraphQLIncludeDirective, node, variableValues);
      if ((include === null || include === void 0 ? void 0 : include["if"]) === false) {
        return false;
      }
      return true;
    }
    function doesFragmentConditionMatch2(schema, fragment, type) {
      const typeConditionNode = fragment.typeCondition;
      if (!typeConditionNode) {
        return true;
      }
      const conditionalType = (0, graphql_1.typeFromAST)(schema, typeConditionNode);
      if (conditionalType === type) {
        return true;
      }
      if ((0, graphql_1.isAbstractType)(conditionalType)) {
        const possibleTypes = schema.getPossibleTypes(conditionalType);
        return possibleTypes.includes(type);
      }
      return false;
    }
    function getFieldEntryKey2(node) {
      return node.alias ? node.alias.value : node.name.value;
    }
    exports2.collectSubFields = (0, memoize_js_1.memoize5)(function collectSubFields(schema, fragments, variableValues, type, fieldNodes) {
      const subFieldNodes = /* @__PURE__ */ new Map();
      const visitedFragmentNames = /* @__PURE__ */ new Set();
      for (const fieldNode of fieldNodes) {
        if (fieldNode.selectionSet) {
          collectFields2(schema, fragments, variableValues, type, fieldNode.selectionSet, subFieldNodes, visitedFragmentNames);
        }
      }
      return subFieldNodes;
    });
  }
});

// ../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/visitResult.js
var require_visitResult3 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/visitResult.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.visitResult = exports2.visitErrors = exports2.visitData = void 0;
    var getOperationASTFromRequest_js_1 = require_getOperationASTFromRequest3();
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var collectFields_js_1 = require_collectFields3();
    function visitData(data, enter, leave) {
      if (Array.isArray(data)) {
        return data.map((value) => visitData(value, enter, leave));
      } else if (typeof data === "object") {
        const newData = enter != null ? enter(data) : data;
        if (newData != null) {
          for (const key in newData) {
            const value = newData[key];
            Object.defineProperty(newData, key, {
              value: visitData(value, enter, leave)
            });
          }
        }
        return leave != null ? leave(newData) : newData;
      }
      return data;
    }
    exports2.visitData = visitData;
    function visitErrors(errors, visitor) {
      return errors.map((error) => visitor(error));
    }
    exports2.visitErrors = visitErrors;
    function visitResult(result, request, schema, resultVisitorMap, errorVisitorMap) {
      const fragments = request.document.definitions.reduce((acc, def) => {
        if (def.kind === graphql_1.Kind.FRAGMENT_DEFINITION) {
          acc[def.name.value] = def;
        }
        return acc;
      }, {});
      const variableValues = request.variables || {};
      const errorInfo = {
        segmentInfoMap: /* @__PURE__ */ new Map(),
        unpathedErrors: /* @__PURE__ */ new Set()
      };
      const data = result.data;
      const errors = result.errors;
      const visitingErrors = errors != null && errorVisitorMap != null;
      const operationDocumentNode = (0, getOperationASTFromRequest_js_1.getOperationASTFromRequest)(request);
      if (data != null && operationDocumentNode != null) {
        result.data = visitRoot(data, operationDocumentNode, schema, fragments, variableValues, resultVisitorMap, visitingErrors ? errors : void 0, errorInfo);
      }
      if (errors != null && errorVisitorMap) {
        result.errors = visitErrorsByType(errors, errorVisitorMap, errorInfo);
      }
      return result;
    }
    exports2.visitResult = visitResult;
    function visitErrorsByType(errors, errorVisitorMap, errorInfo) {
      const segmentInfoMap = errorInfo.segmentInfoMap;
      const unpathedErrors = errorInfo.unpathedErrors;
      const unpathedErrorVisitor = errorVisitorMap["__unpathed"];
      return errors.map((originalError) => {
        const pathSegmentsInfo = segmentInfoMap.get(originalError);
        const newError = pathSegmentsInfo == null ? originalError : pathSegmentsInfo.reduceRight((acc, segmentInfo) => {
          const typeName = segmentInfo.type.name;
          const typeVisitorMap = errorVisitorMap[typeName];
          if (typeVisitorMap == null) {
            return acc;
          }
          const errorVisitor = typeVisitorMap[segmentInfo.fieldName];
          return errorVisitor == null ? acc : errorVisitor(acc, segmentInfo.pathIndex);
        }, originalError);
        if (unpathedErrorVisitor && unpathedErrors.has(originalError)) {
          return unpathedErrorVisitor(newError);
        }
        return newError;
      });
    }
    function getOperationRootType2(schema, operationDef) {
      switch (operationDef.operation) {
        case "query":
          return schema.getQueryType();
        case "mutation":
          return schema.getMutationType();
        case "subscription":
          return schema.getSubscriptionType();
      }
    }
    function visitRoot(root, operation, schema, fragments, variableValues, resultVisitorMap, errors, errorInfo) {
      const operationRootType = getOperationRootType2(schema, operation);
      const collectedFields = (0, collectFields_js_1.collectFields)(schema, fragments, variableValues, operationRootType, operation.selectionSet, /* @__PURE__ */ new Map(), /* @__PURE__ */ new Set());
      return visitObjectValue(root, operationRootType, collectedFields, schema, fragments, variableValues, resultVisitorMap, 0, errors, errorInfo);
    }
    function visitObjectValue(object, type, fieldNodeMap, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo) {
      var _a;
      const fieldMap = type.getFields();
      const typeVisitorMap = resultVisitorMap === null || resultVisitorMap === void 0 ? void 0 : resultVisitorMap[type.name];
      const enterObject = typeVisitorMap === null || typeVisitorMap === void 0 ? void 0 : typeVisitorMap.__enter;
      const newObject = enterObject != null ? enterObject(object) : object;
      let sortedErrors;
      let errorMap = null;
      if (errors != null) {
        sortedErrors = sortErrorsByPathSegment(errors, pathIndex);
        errorMap = sortedErrors.errorMap;
        for (const error of sortedErrors.unpathedErrors) {
          errorInfo.unpathedErrors.add(error);
        }
      }
      for (const [responseKey, subFieldNodes] of fieldNodeMap) {
        const fieldName = subFieldNodes[0].name.value;
        let fieldType = (_a = fieldMap[fieldName]) === null || _a === void 0 ? void 0 : _a.type;
        if (fieldType == null) {
          switch (fieldName) {
            case "__typename":
              fieldType = graphql_1.TypeNameMetaFieldDef.type;
              break;
            case "__schema":
              fieldType = graphql_1.SchemaMetaFieldDef.type;
              break;
          }
        }
        const newPathIndex = pathIndex + 1;
        let fieldErrors;
        if (errorMap) {
          fieldErrors = errorMap[responseKey];
          if (fieldErrors != null) {
            delete errorMap[responseKey];
          }
          addPathSegmentInfo(type, fieldName, newPathIndex, fieldErrors, errorInfo);
        }
        const newValue = visitFieldValue(object[responseKey], fieldType, subFieldNodes, schema, fragments, variableValues, resultVisitorMap, newPathIndex, fieldErrors, errorInfo);
        updateObject(newObject, responseKey, newValue, typeVisitorMap, fieldName);
      }
      const oldTypename = newObject.__typename;
      if (oldTypename != null) {
        updateObject(newObject, "__typename", oldTypename, typeVisitorMap, "__typename");
      }
      if (errorMap) {
        for (const errorsKey in errorMap) {
          const errors2 = errorMap[errorsKey];
          for (const error of errors2) {
            errorInfo.unpathedErrors.add(error);
          }
        }
      }
      const leaveObject = typeVisitorMap === null || typeVisitorMap === void 0 ? void 0 : typeVisitorMap.__leave;
      return leaveObject != null ? leaveObject(newObject) : newObject;
    }
    function updateObject(object, responseKey, newValue, typeVisitorMap, fieldName) {
      if (typeVisitorMap == null) {
        object[responseKey] = newValue;
        return;
      }
      const fieldVisitor = typeVisitorMap[fieldName];
      if (fieldVisitor == null) {
        object[responseKey] = newValue;
        return;
      }
      const visitedValue = fieldVisitor(newValue);
      if (visitedValue === void 0) {
        delete object[responseKey];
        return;
      }
      object[responseKey] = visitedValue;
    }
    function visitListValue(list, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo) {
      return list.map((listMember) => visitFieldValue(listMember, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex + 1, errors, errorInfo));
    }
    function visitFieldValue(value, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors = [], errorInfo) {
      if (value == null) {
        return value;
      }
      const nullableType = (0, graphql_1.getNullableType)(returnType);
      if ((0, graphql_1.isListType)(nullableType)) {
        return visitListValue(value, nullableType.ofType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);
      } else if ((0, graphql_1.isAbstractType)(nullableType)) {
        const finalType = schema.getType(value.__typename);
        const collectedFields = (0, collectFields_js_1.collectSubFields)(schema, fragments, variableValues, finalType, fieldNodes);
        return visitObjectValue(value, finalType, collectedFields, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);
      } else if ((0, graphql_1.isObjectType)(nullableType)) {
        const collectedFields = (0, collectFields_js_1.collectSubFields)(schema, fragments, variableValues, nullableType, fieldNodes);
        return visitObjectValue(value, nullableType, collectedFields, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);
      }
      const typeVisitorMap = resultVisitorMap === null || resultVisitorMap === void 0 ? void 0 : resultVisitorMap[nullableType.name];
      if (typeVisitorMap == null) {
        return value;
      }
      const visitedValue = typeVisitorMap(value);
      return visitedValue === void 0 ? value : visitedValue;
    }
    function sortErrorsByPathSegment(errors, pathIndex) {
      var _a;
      const errorMap = /* @__PURE__ */ Object.create(null);
      const unpathedErrors = /* @__PURE__ */ new Set();
      for (const error of errors) {
        const pathSegment = (_a = error.path) === null || _a === void 0 ? void 0 : _a[pathIndex];
        if (pathSegment == null) {
          unpathedErrors.add(error);
          continue;
        }
        if (pathSegment in errorMap) {
          errorMap[pathSegment].push(error);
        } else {
          errorMap[pathSegment] = [error];
        }
      }
      return {
        errorMap,
        unpathedErrors
      };
    }
    function addPathSegmentInfo(type, fieldName, pathIndex, errors = [], errorInfo) {
      for (const error of errors) {
        const segmentInfo = {
          type,
          fieldName,
          pathIndex
        };
        const pathSegmentsInfo = errorInfo.segmentInfoMap.get(error);
        if (pathSegmentsInfo == null) {
          errorInfo.segmentInfoMap.set(error, [segmentInfo]);
        } else {
          pathSegmentsInfo.push(segmentInfo);
        }
      }
    }
  }
});

// ../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/valueMatchesCriteria.js
var require_valueMatchesCriteria3 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/valueMatchesCriteria.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.valueMatchesCriteria = void 0;
    function valueMatchesCriteria(value, criteria) {
      if (value == null) {
        return value === criteria;
      } else if (Array.isArray(value)) {
        return Array.isArray(criteria) && value.every((val, index) => valueMatchesCriteria(val, criteria[index]));
      } else if (typeof value === "object") {
        return typeof criteria === "object" && criteria && Object.keys(criteria).every((propertyName) => valueMatchesCriteria(value[propertyName], criteria[propertyName]));
      } else if (criteria instanceof RegExp) {
        return criteria.test(value);
      }
      return value === criteria;
    }
    exports2.valueMatchesCriteria = valueMatchesCriteria;
  }
});

// ../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/isAsyncIterable.js
var require_isAsyncIterable3 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/isAsyncIterable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isAsyncIterable = void 0;
    function isAsyncIterable2(value) {
      return typeof value === "object" && value != null && Symbol.asyncIterator in value && typeof value[Symbol.asyncIterator] === "function";
    }
    exports2.isAsyncIterable = isAsyncIterable2;
  }
});

// ../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/isDocumentNode.js
var require_isDocumentNode3 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/isDocumentNode.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isDocumentNode = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function isDocumentNode(object) {
      return object && typeof object === "object" && "kind" in object && object.kind === graphql_1.Kind.DOCUMENT;
    }
    exports2.isDocumentNode = isDocumentNode;
  }
});

// ../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/executor.js
var require_executor3 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/executor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/withCancel.js
var require_withCancel3 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/withCancel.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.withCancel = exports2.getAsyncIterableWithCancel = exports2.getAsyncIteratorWithCancel = void 0;
    var memoize_js_1 = require_memoize3();
    async function defaultAsyncIteratorReturn(value) {
      return { value, done: true };
    }
    var proxyMethodFactory = (0, memoize_js_1.memoize2)(function proxyMethodFactory2(target, targetMethod) {
      return function proxyMethod(...args) {
        return Reflect.apply(targetMethod, target, args);
      };
    });
    function getAsyncIteratorWithCancel(asyncIterator, onCancel) {
      return new Proxy(asyncIterator, {
        has(asyncIterator2, prop) {
          if (prop === "return") {
            return true;
          }
          return Reflect.has(asyncIterator2, prop);
        },
        get(asyncIterator2, prop, receiver) {
          const existingPropValue = Reflect.get(asyncIterator2, prop, receiver);
          if (prop === "return") {
            const existingReturn = existingPropValue || defaultAsyncIteratorReturn;
            return async function returnWithCancel(value) {
              const returnValue = await onCancel(value);
              return Reflect.apply(existingReturn, asyncIterator2, [returnValue]);
            };
          } else if (typeof existingPropValue === "function") {
            return proxyMethodFactory(asyncIterator2, existingPropValue);
          }
          return existingPropValue;
        }
      });
    }
    exports2.getAsyncIteratorWithCancel = getAsyncIteratorWithCancel;
    function getAsyncIterableWithCancel(asyncIterable, onCancel) {
      return new Proxy(asyncIterable, {
        get(asyncIterable2, prop, receiver) {
          const existingPropValue = Reflect.get(asyncIterable2, prop, receiver);
          if (Symbol.asyncIterator === prop) {
            return function asyncIteratorFactory() {
              const asyncIterator = Reflect.apply(existingPropValue, asyncIterable2, []);
              return getAsyncIteratorWithCancel(asyncIterator, onCancel);
            };
          } else if (typeof existingPropValue === "function") {
            return proxyMethodFactory(asyncIterable2, existingPropValue);
          }
          return existingPropValue;
        }
      });
    }
    exports2.getAsyncIterableWithCancel = getAsyncIterableWithCancel;
    exports2.withCancel = getAsyncIterableWithCancel;
  }
});

// ../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/fixSchemaAst.js
var require_fixSchemaAst3 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/fixSchemaAst.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fixSchemaAst = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var print_schema_with_directives_js_1 = require_print_schema_with_directives3();
    function buildFixedSchema(schema, options) {
      const document2 = (0, print_schema_with_directives_js_1.getDocumentNodeFromSchema)(schema);
      return (0, graphql_1.buildASTSchema)(document2, {
        ...options || {}
      });
    }
    function fixSchemaAst(schema, options) {
      let schemaWithValidAst = void 0;
      if (!schema.astNode || !schema.extensionASTNodes) {
        schemaWithValidAst = buildFixedSchema(schema, options);
      }
      if (!schema.astNode && (schemaWithValidAst === null || schemaWithValidAst === void 0 ? void 0 : schemaWithValidAst.astNode)) {
        schema.astNode = schemaWithValidAst.astNode;
      }
      if (!schema.extensionASTNodes && (schemaWithValidAst === null || schemaWithValidAst === void 0 ? void 0 : schemaWithValidAst.astNode)) {
        schema.extensionASTNodes = schemaWithValidAst.extensionASTNodes;
      }
      return schema;
    }
    exports2.fixSchemaAst = fixSchemaAst;
  }
});

// ../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/index.js
var require_cjs6 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_loaders3(), exports2);
    tslib_1.__exportStar(require_helpers3(), exports2);
    tslib_1.__exportStar(require_get_directives3(), exports2);
    tslib_1.__exportStar(require_get_fields_with_directives3(), exports2);
    tslib_1.__exportStar(require_get_implementing_types3(), exports2);
    tslib_1.__exportStar(require_print_schema_with_directives3(), exports2);
    tslib_1.__exportStar(require_get_fields_with_directives3(), exports2);
    tslib_1.__exportStar(require_validate_documents3(), exports2);
    tslib_1.__exportStar(require_parse_graphql_json3(), exports2);
    tslib_1.__exportStar(require_parse_graphql_sdl3(), exports2);
    tslib_1.__exportStar(require_build_operation_for_field3(), exports2);
    tslib_1.__exportStar(require_types5(), exports2);
    tslib_1.__exportStar(require_filterSchema3(), exports2);
    tslib_1.__exportStar(require_heal3(), exports2);
    tslib_1.__exportStar(require_getResolversFromSchema3(), exports2);
    tslib_1.__exportStar(require_forEachField3(), exports2);
    tslib_1.__exportStar(require_forEachDefaultValue3(), exports2);
    tslib_1.__exportStar(require_mapSchema3(), exports2);
    tslib_1.__exportStar(require_addTypes3(), exports2);
    tslib_1.__exportStar(require_rewire3(), exports2);
    tslib_1.__exportStar(require_prune3(), exports2);
    tslib_1.__exportStar(require_mergeDeep3(), exports2);
    tslib_1.__exportStar(require_Interfaces3(), exports2);
    tslib_1.__exportStar(require_stub3(), exports2);
    tslib_1.__exportStar(require_selectionSets3(), exports2);
    tslib_1.__exportStar(require_getResponseKeyFromInfo3(), exports2);
    tslib_1.__exportStar(require_fields4(), exports2);
    tslib_1.__exportStar(require_renameType3(), exports2);
    tslib_1.__exportStar(require_transformInputValue3(), exports2);
    tslib_1.__exportStar(require_mapAsyncIterator3(), exports2);
    tslib_1.__exportStar(require_updateArgument3(), exports2);
    tslib_1.__exportStar(require_implementsAbstractType3(), exports2);
    tslib_1.__exportStar(require_errors3(), exports2);
    tslib_1.__exportStar(require_observableToAsyncIterable3(), exports2);
    tslib_1.__exportStar(require_visitResult3(), exports2);
    tslib_1.__exportStar(require_getArgumentValues3(), exports2);
    tslib_1.__exportStar(require_valueMatchesCriteria3(), exports2);
    tslib_1.__exportStar(require_isAsyncIterable3(), exports2);
    tslib_1.__exportStar(require_isDocumentNode3(), exports2);
    tslib_1.__exportStar(require_astFromValueUntyped3(), exports2);
    tslib_1.__exportStar(require_executor3(), exports2);
    tslib_1.__exportStar(require_withCancel3(), exports2);
    tslib_1.__exportStar(require_AggregateError3(), exports2);
    tslib_1.__exportStar(require_rootTypes3(), exports2);
    tslib_1.__exportStar(require_comments3(), exports2);
    tslib_1.__exportStar(require_collectFields3(), exports2);
    tslib_1.__exportStar(require_inspect3(), exports2);
    tslib_1.__exportStar(require_memoize3(), exports2);
    tslib_1.__exportStar(require_fixSchemaAst3(), exports2);
    tslib_1.__exportStar(require_getOperationASTFromRequest3(), exports2);
  }
});

// ../../../node_modules/@graphql-tools/merge/cjs/merge-resolvers.js
var require_merge_resolvers2 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/cjs/merge-resolvers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeResolvers = void 0;
    var utils_1 = require_cjs6();
    function mergeResolvers(resolversDefinitions, options) {
      if (!resolversDefinitions || Array.isArray(resolversDefinitions) && resolversDefinitions.length === 0) {
        return {};
      }
      if (!Array.isArray(resolversDefinitions)) {
        return resolversDefinitions;
      }
      if (resolversDefinitions.length === 1) {
        return resolversDefinitions[0] || {};
      }
      const resolvers = new Array();
      for (let resolversDefinition of resolversDefinitions) {
        if (Array.isArray(resolversDefinition)) {
          resolversDefinition = mergeResolvers(resolversDefinition);
        }
        if (typeof resolversDefinition === "object" && resolversDefinition) {
          resolvers.push(resolversDefinition);
        }
      }
      const result = (0, utils_1.mergeDeep)(resolvers, true);
      if (options === null || options === void 0 ? void 0 : options.exclusions) {
        for (const exclusion of options.exclusions) {
          const [typeName, fieldName] = exclusion.split(".");
          if (!fieldName || fieldName === "*") {
            delete result[typeName];
          } else if (result[typeName]) {
            delete result[typeName][fieldName];
          }
        }
      }
      return result;
    }
    exports2.mergeResolvers = mergeResolvers;
  }
});

// ../../../node_modules/@graphql-tools/merge/cjs/typedefs-mergers/arguments.js
var require_arguments2 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/cjs/typedefs-mergers/arguments.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeArguments = void 0;
    var utils_1 = require_cjs6();
    function mergeArguments(args1, args2, config) {
      const result = deduplicateArguments([...args2, ...args1].filter(utils_1.isSome));
      if (config && config.sort) {
        result.sort(utils_1.compareNodes);
      }
      return result;
    }
    exports2.mergeArguments = mergeArguments;
    function deduplicateArguments(args) {
      return args.reduce((acc, current) => {
        const dup = acc.find((arg) => arg.name.value === current.name.value);
        if (!dup) {
          return acc.concat([current]);
        }
        return acc;
      }, []);
    }
  }
});

// ../../../node_modules/@graphql-tools/merge/cjs/typedefs-mergers/directives.js
var require_directives3 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/cjs/typedefs-mergers/directives.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeDirective = exports2.mergeDirectives = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var utils_1 = require_cjs6();
    function directiveAlreadyExists(directivesArr, otherDirective) {
      return !!directivesArr.find((directive) => directive.name.value === otherDirective.name.value);
    }
    function nameAlreadyExists(name, namesArr) {
      return namesArr.some(({ value }) => value === name.value);
    }
    function mergeArguments(a1, a2) {
      const result = [...a2];
      for (const argument of a1) {
        const existingIndex = result.findIndex((a) => a.name.value === argument.name.value);
        if (existingIndex > -1) {
          const existingArg = result[existingIndex];
          if (existingArg.value.kind === "ListValue") {
            const source = existingArg.value.values;
            const target = argument.value.values;
            existingArg.value.values = deduplicateLists(source, target, (targetVal, source2) => {
              const value = targetVal.value;
              return !value || !source2.some((sourceVal) => sourceVal.value === value);
            });
          } else {
            existingArg.value = argument.value;
          }
        } else {
          result.push(argument);
        }
      }
      return result;
    }
    function deduplicateDirectives(directives) {
      return directives.map((directive, i, all) => {
        const firstAt = all.findIndex((d) => d.name.value === directive.name.value);
        if (firstAt !== i) {
          const dup = all[firstAt];
          directive.arguments = mergeArguments(directive.arguments, dup.arguments);
          return null;
        }
        return directive;
      }).filter(utils_1.isSome);
    }
    function mergeDirectives(d1 = [], d2 = [], config) {
      const reverseOrder = config && config.reverseDirectives;
      const asNext = reverseOrder ? d1 : d2;
      const asFirst = reverseOrder ? d2 : d1;
      const result = deduplicateDirectives([...asNext]);
      for (const directive of asFirst) {
        if (directiveAlreadyExists(result, directive)) {
          const existingDirectiveIndex = result.findIndex((d) => d.name.value === directive.name.value);
          const existingDirective = result[existingDirectiveIndex];
          result[existingDirectiveIndex].arguments = mergeArguments(directive.arguments || [], existingDirective.arguments || []);
        } else {
          result.push(directive);
        }
      }
      return result;
    }
    exports2.mergeDirectives = mergeDirectives;
    function validateInputs(node, existingNode) {
      const printedNode = (0, graphql_1.print)({
        ...node,
        description: void 0
      });
      const printedExistingNode = (0, graphql_1.print)({
        ...existingNode,
        description: void 0
      });
      const leaveInputs = new RegExp("(directive @w*d*)|( on .*$)", "g");
      const sameArguments = printedNode.replace(leaveInputs, "") === printedExistingNode.replace(leaveInputs, "");
      if (!sameArguments) {
        throw new Error(`Unable to merge GraphQL directive "${node.name.value}". 
Existing directive:  
	${printedExistingNode} 
Received directive: 
	${printedNode}`);
      }
    }
    function mergeDirective(node, existingNode) {
      if (existingNode) {
        validateInputs(node, existingNode);
        return {
          ...node,
          locations: [
            ...existingNode.locations,
            ...node.locations.filter((name) => !nameAlreadyExists(name, existingNode.locations))
          ]
        };
      }
      return node;
    }
    exports2.mergeDirective = mergeDirective;
    function deduplicateLists(source, target, filterFn) {
      return source.concat(target.filter((val) => filterFn(val, source)));
    }
  }
});

// ../../../node_modules/@graphql-tools/merge/cjs/typedefs-mergers/enum-values.js
var require_enum_values2 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/cjs/typedefs-mergers/enum-values.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeEnumValues = void 0;
    var directives_js_1 = require_directives3();
    var utils_1 = require_cjs6();
    function mergeEnumValues(first, second, config) {
      if (config === null || config === void 0 ? void 0 : config.consistentEnumMerge) {
        const reversed = [];
        if (first) {
          reversed.push(...first);
        }
        first = second;
        second = reversed;
      }
      const enumValueMap = /* @__PURE__ */ new Map();
      if (first) {
        for (const firstValue of first) {
          enumValueMap.set(firstValue.name.value, firstValue);
        }
      }
      if (second) {
        for (const secondValue of second) {
          const enumValue = secondValue.name.value;
          if (enumValueMap.has(enumValue)) {
            const firstValue = enumValueMap.get(enumValue);
            firstValue.description = secondValue.description || firstValue.description;
            firstValue.directives = (0, directives_js_1.mergeDirectives)(secondValue.directives, firstValue.directives);
          } else {
            enumValueMap.set(enumValue, secondValue);
          }
        }
      }
      const result = [...enumValueMap.values()];
      if (config && config.sort) {
        result.sort(utils_1.compareNodes);
      }
      return result;
    }
    exports2.mergeEnumValues = mergeEnumValues;
  }
});

// ../../../node_modules/@graphql-tools/merge/cjs/typedefs-mergers/enum.js
var require_enum2 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/cjs/typedefs-mergers/enum.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeEnum = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var directives_js_1 = require_directives3();
    var enum_values_js_1 = require_enum_values2();
    function mergeEnum(e1, e2, config) {
      if (e2) {
        return {
          name: e1.name,
          description: e1["description"] || e2["description"],
          kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || e1.kind === "EnumTypeDefinition" || e2.kind === "EnumTypeDefinition" ? "EnumTypeDefinition" : "EnumTypeExtension",
          loc: e1.loc,
          directives: (0, directives_js_1.mergeDirectives)(e1.directives, e2.directives, config),
          values: (0, enum_values_js_1.mergeEnumValues)(e1.values, e2.values, config)
        };
      }
      return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? {
        ...e1,
        kind: graphql_1.Kind.ENUM_TYPE_DEFINITION
      } : e1;
    }
    exports2.mergeEnum = mergeEnum;
  }
});

// ../../../node_modules/@graphql-tools/merge/cjs/typedefs-mergers/utils.js
var require_utils4 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/cjs/typedefs-mergers/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defaultStringComparator = exports2.CompareVal = exports2.printTypeNode = exports2.isNonNullTypeNode = exports2.isListTypeNode = exports2.isWrappingTypeNode = exports2.extractType = exports2.isSourceTypes = exports2.isStringTypes = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function isStringTypes(types) {
      return typeof types === "string";
    }
    exports2.isStringTypes = isStringTypes;
    function isSourceTypes(types) {
      return types instanceof graphql_1.Source;
    }
    exports2.isSourceTypes = isSourceTypes;
    function extractType(type) {
      let visitedType = type;
      while (visitedType.kind === graphql_1.Kind.LIST_TYPE || visitedType.kind === "NonNullType") {
        visitedType = visitedType.type;
      }
      return visitedType;
    }
    exports2.extractType = extractType;
    function isWrappingTypeNode(type) {
      return type.kind !== graphql_1.Kind.NAMED_TYPE;
    }
    exports2.isWrappingTypeNode = isWrappingTypeNode;
    function isListTypeNode(type) {
      return type.kind === graphql_1.Kind.LIST_TYPE;
    }
    exports2.isListTypeNode = isListTypeNode;
    function isNonNullTypeNode(type) {
      return type.kind === graphql_1.Kind.NON_NULL_TYPE;
    }
    exports2.isNonNullTypeNode = isNonNullTypeNode;
    function printTypeNode(type) {
      if (isListTypeNode(type)) {
        return `[${printTypeNode(type.type)}]`;
      }
      if (isNonNullTypeNode(type)) {
        return `${printTypeNode(type.type)}!`;
      }
      return type.name.value;
    }
    exports2.printTypeNode = printTypeNode;
    var CompareVal;
    (function(CompareVal2) {
      CompareVal2[CompareVal2["A_SMALLER_THAN_B"] = -1] = "A_SMALLER_THAN_B";
      CompareVal2[CompareVal2["A_EQUALS_B"] = 0] = "A_EQUALS_B";
      CompareVal2[CompareVal2["A_GREATER_THAN_B"] = 1] = "A_GREATER_THAN_B";
    })(CompareVal = exports2.CompareVal || (exports2.CompareVal = {}));
    function defaultStringComparator(a, b) {
      if (a == null && b == null) {
        return CompareVal.A_EQUALS_B;
      }
      if (a == null) {
        return CompareVal.A_SMALLER_THAN_B;
      }
      if (b == null) {
        return CompareVal.A_GREATER_THAN_B;
      }
      if (a < b)
        return CompareVal.A_SMALLER_THAN_B;
      if (a > b)
        return CompareVal.A_GREATER_THAN_B;
      return CompareVal.A_EQUALS_B;
    }
    exports2.defaultStringComparator = defaultStringComparator;
  }
});

// ../../../node_modules/@graphql-tools/merge/cjs/typedefs-mergers/fields.js
var require_fields5 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/cjs/typedefs-mergers/fields.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeFields = void 0;
    var utils_js_1 = require_utils4();
    var directives_js_1 = require_directives3();
    var utils_1 = require_cjs6();
    var arguments_js_1 = require_arguments2();
    function fieldAlreadyExists(fieldsArr, otherField, config) {
      const result = fieldsArr.find((field) => field.name.value === otherField.name.value);
      if (result && !(config === null || config === void 0 ? void 0 : config.ignoreFieldConflicts)) {
        const t1 = (0, utils_js_1.extractType)(result.type);
        const t2 = (0, utils_js_1.extractType)(otherField.type);
        if (t1.name.value !== t2.name.value) {
          throw new Error(`Field "${otherField.name.value}" already defined with a different type. Declared as "${t1.name.value}", but you tried to override with "${t2.name.value}"`);
        }
      }
      return !!result;
    }
    function mergeFields(type, f1, f2, config) {
      const result = [];
      if (f2 != null) {
        result.push(...f2);
      }
      if (f1 != null) {
        for (const field of f1) {
          if (fieldAlreadyExists(result, field, config)) {
            const existing = result.find((f) => f.name.value === field.name.value);
            if (!(config === null || config === void 0 ? void 0 : config.ignoreFieldConflicts)) {
              if (config === null || config === void 0 ? void 0 : config.throwOnConflict) {
                preventConflicts(type, existing, field, false);
              } else {
                preventConflicts(type, existing, field, true);
              }
              if ((0, utils_js_1.isNonNullTypeNode)(field.type) && !(0, utils_js_1.isNonNullTypeNode)(existing.type)) {
                existing.type = field.type;
              }
            }
            existing.arguments = (0, arguments_js_1.mergeArguments)(field["arguments"] || [], existing.arguments || [], config);
            existing.directives = (0, directives_js_1.mergeDirectives)(field.directives, existing.directives, config);
            existing.description = field.description || existing.description;
          } else {
            result.push(field);
          }
        }
      }
      if (config && config.sort) {
        result.sort(utils_1.compareNodes);
      }
      if (config && config.exclusions) {
        const exclusions = config.exclusions;
        return result.filter((field) => !exclusions.includes(`${type.name.value}.${field.name.value}`));
      }
      return result;
    }
    exports2.mergeFields = mergeFields;
    function preventConflicts(type, a, b, ignoreNullability = false) {
      const aType = (0, utils_js_1.printTypeNode)(a.type);
      const bType = (0, utils_js_1.printTypeNode)(b.type);
      if (aType !== bType && !safeChangeForFieldType(a.type, b.type, ignoreNullability)) {
        throw new Error(`Field '${type.name.value}.${a.name.value}' changed type from '${aType}' to '${bType}'`);
      }
    }
    function safeChangeForFieldType(oldType, newType, ignoreNullability = false) {
      if (!(0, utils_js_1.isWrappingTypeNode)(oldType) && !(0, utils_js_1.isWrappingTypeNode)(newType)) {
        return oldType.toString() === newType.toString();
      }
      if ((0, utils_js_1.isNonNullTypeNode)(newType)) {
        const ofType = (0, utils_js_1.isNonNullTypeNode)(oldType) ? oldType.type : oldType;
        return safeChangeForFieldType(ofType, newType.type);
      }
      if ((0, utils_js_1.isNonNullTypeNode)(oldType)) {
        return safeChangeForFieldType(newType, oldType, ignoreNullability);
      }
      if ((0, utils_js_1.isListTypeNode)(oldType)) {
        return (0, utils_js_1.isListTypeNode)(newType) && safeChangeForFieldType(oldType.type, newType.type) || (0, utils_js_1.isNonNullTypeNode)(newType) && safeChangeForFieldType(oldType, newType["type"]);
      }
      return false;
    }
  }
});

// ../../../node_modules/@graphql-tools/merge/cjs/typedefs-mergers/input-type.js
var require_input_type2 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/cjs/typedefs-mergers/input-type.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeInputType = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var fields_js_1 = require_fields5();
    var directives_js_1 = require_directives3();
    function mergeInputType(node, existingNode, config) {
      if (existingNode) {
        try {
          return {
            name: node.name,
            description: node["description"] || existingNode["description"],
            kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || node.kind === "InputObjectTypeDefinition" || existingNode.kind === "InputObjectTypeDefinition" ? "InputObjectTypeDefinition" : "InputObjectTypeExtension",
            loc: node.loc,
            fields: (0, fields_js_1.mergeFields)(node, node.fields, existingNode.fields, config),
            directives: (0, directives_js_1.mergeDirectives)(node.directives, existingNode.directives, config)
          };
        } catch (e) {
          throw new Error(`Unable to merge GraphQL input type "${node.name.value}": ${e.message}`);
        }
      }
      return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? {
        ...node,
        kind: graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION
      } : node;
    }
    exports2.mergeInputType = mergeInputType;
  }
});

// ../../../node_modules/@graphql-tools/merge/cjs/typedefs-mergers/interface.js
var require_interface2 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/cjs/typedefs-mergers/interface.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeInterface = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var fields_js_1 = require_fields5();
    var directives_js_1 = require_directives3();
    var index_js_1 = require_typedefs_mergers2();
    function mergeInterface(node, existingNode, config) {
      if (existingNode) {
        try {
          return {
            name: node.name,
            description: node["description"] || existingNode["description"],
            kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || node.kind === "InterfaceTypeDefinition" || existingNode.kind === "InterfaceTypeDefinition" ? "InterfaceTypeDefinition" : "InterfaceTypeExtension",
            loc: node.loc,
            fields: (0, fields_js_1.mergeFields)(node, node.fields, existingNode.fields, config),
            directives: (0, directives_js_1.mergeDirectives)(node.directives, existingNode.directives, config),
            interfaces: node["interfaces"] ? (0, index_js_1.mergeNamedTypeArray)(node["interfaces"], existingNode["interfaces"], config) : void 0
          };
        } catch (e) {
          throw new Error(`Unable to merge GraphQL interface "${node.name.value}": ${e.message}`);
        }
      }
      return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? {
        ...node,
        kind: graphql_1.Kind.INTERFACE_TYPE_DEFINITION
      } : node;
    }
    exports2.mergeInterface = mergeInterface;
  }
});

// ../../../node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-named-type-array.js
var require_merge_named_type_array2 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-named-type-array.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeNamedTypeArray = void 0;
    var utils_1 = require_cjs6();
    function alreadyExists(arr, other) {
      return !!arr.find((i) => i.name.value === other.name.value);
    }
    function mergeNamedTypeArray(first = [], second = [], config = {}) {
      const result = [...second, ...first.filter((d) => !alreadyExists(second, d))];
      if (config && config.sort) {
        result.sort(utils_1.compareNodes);
      }
      return result;
    }
    exports2.mergeNamedTypeArray = mergeNamedTypeArray;
  }
});

// ../../../node_modules/@graphql-tools/merge/cjs/typedefs-mergers/type.js
var require_type2 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/cjs/typedefs-mergers/type.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeType = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var fields_js_1 = require_fields5();
    var directives_js_1 = require_directives3();
    var merge_named_type_array_js_1 = require_merge_named_type_array2();
    function mergeType(node, existingNode, config) {
      if (existingNode) {
        try {
          return {
            name: node.name,
            description: node["description"] || existingNode["description"],
            kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || node.kind === "ObjectTypeDefinition" || existingNode.kind === "ObjectTypeDefinition" ? "ObjectTypeDefinition" : "ObjectTypeExtension",
            loc: node.loc,
            fields: (0, fields_js_1.mergeFields)(node, node.fields, existingNode.fields, config),
            directives: (0, directives_js_1.mergeDirectives)(node.directives, existingNode.directives, config),
            interfaces: (0, merge_named_type_array_js_1.mergeNamedTypeArray)(node.interfaces, existingNode.interfaces, config)
          };
        } catch (e) {
          throw new Error(`Unable to merge GraphQL type "${node.name.value}": ${e.message}`);
        }
      }
      return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? {
        ...node,
        kind: graphql_1.Kind.OBJECT_TYPE_DEFINITION
      } : node;
    }
    exports2.mergeType = mergeType;
  }
});

// ../../../node_modules/@graphql-tools/merge/cjs/typedefs-mergers/scalar.js
var require_scalar2 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/cjs/typedefs-mergers/scalar.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeScalar = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var directives_js_1 = require_directives3();
    function mergeScalar(node, existingNode, config) {
      if (existingNode) {
        return {
          name: node.name,
          description: node["description"] || existingNode["description"],
          kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || node.kind === "ScalarTypeDefinition" || existingNode.kind === "ScalarTypeDefinition" ? "ScalarTypeDefinition" : "ScalarTypeExtension",
          loc: node.loc,
          directives: (0, directives_js_1.mergeDirectives)(node.directives, existingNode.directives, config)
        };
      }
      return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? {
        ...node,
        kind: graphql_1.Kind.SCALAR_TYPE_DEFINITION
      } : node;
    }
    exports2.mergeScalar = mergeScalar;
  }
});

// ../../../node_modules/@graphql-tools/merge/cjs/typedefs-mergers/union.js
var require_union2 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/cjs/typedefs-mergers/union.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeUnion = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var directives_js_1 = require_directives3();
    var merge_named_type_array_js_1 = require_merge_named_type_array2();
    function mergeUnion(first, second, config) {
      if (second) {
        return {
          name: first.name,
          description: first["description"] || second["description"],
          // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
          directives: (0, directives_js_1.mergeDirectives)(first.directives, second.directives, config),
          kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || first.kind === "UnionTypeDefinition" || second.kind === "UnionTypeDefinition" ? graphql_1.Kind.UNION_TYPE_DEFINITION : graphql_1.Kind.UNION_TYPE_EXTENSION,
          loc: first.loc,
          types: (0, merge_named_type_array_js_1.mergeNamedTypeArray)(first.types, second.types, config)
        };
      }
      return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? {
        ...first,
        kind: graphql_1.Kind.UNION_TYPE_DEFINITION
      } : first;
    }
    exports2.mergeUnion = mergeUnion;
  }
});

// ../../../node_modules/@graphql-tools/merge/cjs/typedefs-mergers/schema-def.js
var require_schema_def2 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/cjs/typedefs-mergers/schema-def.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeSchemaDefs = exports2.DEFAULT_OPERATION_TYPE_NAME_MAP = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var directives_js_1 = require_directives3();
    exports2.DEFAULT_OPERATION_TYPE_NAME_MAP = {
      query: "Query",
      mutation: "Mutation",
      subscription: "Subscription"
    };
    function mergeOperationTypes(opNodeList = [], existingOpNodeList = []) {
      const finalOpNodeList = [];
      for (const opNodeType in exports2.DEFAULT_OPERATION_TYPE_NAME_MAP) {
        const opNode = opNodeList.find((n) => n.operation === opNodeType) || existingOpNodeList.find((n) => n.operation === opNodeType);
        if (opNode) {
          finalOpNodeList.push(opNode);
        }
      }
      return finalOpNodeList;
    }
    function mergeSchemaDefs(node, existingNode, config) {
      if (existingNode) {
        return {
          kind: node.kind === graphql_1.Kind.SCHEMA_DEFINITION || existingNode.kind === graphql_1.Kind.SCHEMA_DEFINITION ? graphql_1.Kind.SCHEMA_DEFINITION : graphql_1.Kind.SCHEMA_EXTENSION,
          description: node["description"] || existingNode["description"],
          directives: (0, directives_js_1.mergeDirectives)(node.directives, existingNode.directives, config),
          operationTypes: mergeOperationTypes(node.operationTypes, existingNode.operationTypes)
        };
      }
      return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? {
        ...node,
        kind: graphql_1.Kind.SCHEMA_DEFINITION
      } : node;
    }
    exports2.mergeSchemaDefs = mergeSchemaDefs;
  }
});

// ../../../node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-nodes.js
var require_merge_nodes2 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-nodes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeGraphQLNodes = exports2.isNamedDefinitionNode = exports2.schemaDefSymbol = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var type_js_1 = require_type2();
    var enum_js_1 = require_enum2();
    var scalar_js_1 = require_scalar2();
    var union_js_1 = require_union2();
    var input_type_js_1 = require_input_type2();
    var interface_js_1 = require_interface2();
    var directives_js_1 = require_directives3();
    var schema_def_js_1 = require_schema_def2();
    var utils_1 = require_cjs6();
    exports2.schemaDefSymbol = "SCHEMA_DEF_SYMBOL";
    function isNamedDefinitionNode(definitionNode) {
      return "name" in definitionNode;
    }
    exports2.isNamedDefinitionNode = isNamedDefinitionNode;
    function mergeGraphQLNodes(nodes, config) {
      var _a, _b, _c;
      const mergedResultMap = {};
      for (const nodeDefinition of nodes) {
        if (isNamedDefinitionNode(nodeDefinition)) {
          const name = (_a = nodeDefinition.name) === null || _a === void 0 ? void 0 : _a.value;
          if (config === null || config === void 0 ? void 0 : config.commentDescriptions) {
            (0, utils_1.collectComment)(nodeDefinition);
          }
          if (name == null) {
            continue;
          }
          if (((_b = config === null || config === void 0 ? void 0 : config.exclusions) === null || _b === void 0 ? void 0 : _b.includes(name + ".*")) || ((_c = config === null || config === void 0 ? void 0 : config.exclusions) === null || _c === void 0 ? void 0 : _c.includes(name))) {
            delete mergedResultMap[name];
          } else {
            switch (nodeDefinition.kind) {
              case graphql_1.Kind.OBJECT_TYPE_DEFINITION:
              case graphql_1.Kind.OBJECT_TYPE_EXTENSION:
                mergedResultMap[name] = (0, type_js_1.mergeType)(nodeDefinition, mergedResultMap[name], config);
                break;
              case graphql_1.Kind.ENUM_TYPE_DEFINITION:
              case graphql_1.Kind.ENUM_TYPE_EXTENSION:
                mergedResultMap[name] = (0, enum_js_1.mergeEnum)(nodeDefinition, mergedResultMap[name], config);
                break;
              case graphql_1.Kind.UNION_TYPE_DEFINITION:
              case graphql_1.Kind.UNION_TYPE_EXTENSION:
                mergedResultMap[name] = (0, union_js_1.mergeUnion)(nodeDefinition, mergedResultMap[name], config);
                break;
              case graphql_1.Kind.SCALAR_TYPE_DEFINITION:
              case graphql_1.Kind.SCALAR_TYPE_EXTENSION:
                mergedResultMap[name] = (0, scalar_js_1.mergeScalar)(nodeDefinition, mergedResultMap[name], config);
                break;
              case graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION:
              case graphql_1.Kind.INPUT_OBJECT_TYPE_EXTENSION:
                mergedResultMap[name] = (0, input_type_js_1.mergeInputType)(nodeDefinition, mergedResultMap[name], config);
                break;
              case graphql_1.Kind.INTERFACE_TYPE_DEFINITION:
              case graphql_1.Kind.INTERFACE_TYPE_EXTENSION:
                mergedResultMap[name] = (0, interface_js_1.mergeInterface)(nodeDefinition, mergedResultMap[name], config);
                break;
              case graphql_1.Kind.DIRECTIVE_DEFINITION:
                mergedResultMap[name] = (0, directives_js_1.mergeDirective)(nodeDefinition, mergedResultMap[name]);
                break;
            }
          }
        } else if (nodeDefinition.kind === graphql_1.Kind.SCHEMA_DEFINITION || nodeDefinition.kind === graphql_1.Kind.SCHEMA_EXTENSION) {
          mergedResultMap[exports2.schemaDefSymbol] = (0, schema_def_js_1.mergeSchemaDefs)(nodeDefinition, mergedResultMap[exports2.schemaDefSymbol], config);
        }
      }
      return mergedResultMap;
    }
    exports2.mergeGraphQLNodes = mergeGraphQLNodes;
  }
});

// ../../../node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-typedefs.js
var require_merge_typedefs2 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-typedefs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeGraphQLTypes = exports2.mergeTypeDefs = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var utils_js_1 = require_utils4();
    var merge_nodes_js_1 = require_merge_nodes2();
    var utils_1 = require_cjs6();
    var schema_def_js_1 = require_schema_def2();
    function mergeTypeDefs(typeSource, config) {
      (0, utils_1.resetComments)();
      const doc = {
        kind: graphql_1.Kind.DOCUMENT,
        definitions: mergeGraphQLTypes(typeSource, {
          useSchemaDefinition: true,
          forceSchemaDefinition: false,
          throwOnConflict: false,
          commentDescriptions: false,
          ...config
        })
      };
      let result;
      if (config === null || config === void 0 ? void 0 : config.commentDescriptions) {
        result = (0, utils_1.printWithComments)(doc);
      } else {
        result = doc;
      }
      (0, utils_1.resetComments)();
      return result;
    }
    exports2.mergeTypeDefs = mergeTypeDefs;
    function visitTypeSources(typeSource, options, allNodes = [], visitedTypeSources = /* @__PURE__ */ new Set()) {
      if (typeSource && !visitedTypeSources.has(typeSource)) {
        visitedTypeSources.add(typeSource);
        if (typeof typeSource === "function") {
          visitTypeSources(typeSource(), options, allNodes, visitedTypeSources);
        } else if (Array.isArray(typeSource)) {
          for (const type of typeSource) {
            visitTypeSources(type, options, allNodes, visitedTypeSources);
          }
        } else if ((0, graphql_1.isSchema)(typeSource)) {
          const documentNode = (0, utils_1.getDocumentNodeFromSchema)(typeSource, options);
          visitTypeSources(documentNode.definitions, options, allNodes, visitedTypeSources);
        } else if ((0, utils_js_1.isStringTypes)(typeSource) || (0, utils_js_1.isSourceTypes)(typeSource)) {
          const documentNode = (0, graphql_1.parse)(typeSource, options);
          visitTypeSources(documentNode.definitions, options, allNodes, visitedTypeSources);
        } else if (typeof typeSource === "object" && (0, graphql_1.isDefinitionNode)(typeSource)) {
          allNodes.push(typeSource);
        } else if ((0, utils_1.isDocumentNode)(typeSource)) {
          visitTypeSources(typeSource.definitions, options, allNodes, visitedTypeSources);
        } else {
          throw new Error(`typeDefs must contain only strings, documents, schemas, or functions, got ${typeof typeSource}`);
        }
      }
      return allNodes;
    }
    function mergeGraphQLTypes(typeSource, config) {
      var _a, _b, _c;
      (0, utils_1.resetComments)();
      const allNodes = visitTypeSources(typeSource, config);
      const mergedNodes = (0, merge_nodes_js_1.mergeGraphQLNodes)(allNodes, config);
      if (config === null || config === void 0 ? void 0 : config.useSchemaDefinition) {
        const schemaDef = mergedNodes[merge_nodes_js_1.schemaDefSymbol] || {
          kind: graphql_1.Kind.SCHEMA_DEFINITION,
          operationTypes: []
        };
        const operationTypes = schemaDef.operationTypes;
        for (const opTypeDefNodeType in schema_def_js_1.DEFAULT_OPERATION_TYPE_NAME_MAP) {
          const opTypeDefNode = operationTypes.find((operationType) => operationType.operation === opTypeDefNodeType);
          if (!opTypeDefNode) {
            const possibleRootTypeName = schema_def_js_1.DEFAULT_OPERATION_TYPE_NAME_MAP[opTypeDefNodeType];
            const existingPossibleRootType = mergedNodes[possibleRootTypeName];
            if (existingPossibleRootType != null && existingPossibleRootType.name != null) {
              operationTypes.push({
                kind: graphql_1.Kind.OPERATION_TYPE_DEFINITION,
                type: {
                  kind: graphql_1.Kind.NAMED_TYPE,
                  name: existingPossibleRootType.name
                },
                operation: opTypeDefNodeType
              });
            }
          }
        }
        if (((_a = schemaDef === null || schemaDef === void 0 ? void 0 : schemaDef.operationTypes) === null || _a === void 0 ? void 0 : _a.length) != null && schemaDef.operationTypes.length > 0) {
          mergedNodes[merge_nodes_js_1.schemaDefSymbol] = schemaDef;
        }
      }
      if ((config === null || config === void 0 ? void 0 : config.forceSchemaDefinition) && !((_c = (_b = mergedNodes[merge_nodes_js_1.schemaDefSymbol]) === null || _b === void 0 ? void 0 : _b.operationTypes) === null || _c === void 0 ? void 0 : _c.length)) {
        mergedNodes[merge_nodes_js_1.schemaDefSymbol] = {
          kind: graphql_1.Kind.SCHEMA_DEFINITION,
          operationTypes: [
            {
              kind: graphql_1.Kind.OPERATION_TYPE_DEFINITION,
              operation: "query",
              type: {
                kind: graphql_1.Kind.NAMED_TYPE,
                name: {
                  kind: graphql_1.Kind.NAME,
                  value: "Query"
                }
              }
            }
          ]
        };
      }
      const mergedNodeDefinitions = Object.values(mergedNodes);
      if (config === null || config === void 0 ? void 0 : config.sort) {
        const sortFn = typeof config.sort === "function" ? config.sort : utils_js_1.defaultStringComparator;
        mergedNodeDefinitions.sort((a, b) => {
          var _a2, _b2;
          return sortFn((_a2 = a.name) === null || _a2 === void 0 ? void 0 : _a2.value, (_b2 = b.name) === null || _b2 === void 0 ? void 0 : _b2.value);
        });
      }
      return mergedNodeDefinitions;
    }
    exports2.mergeGraphQLTypes = mergeGraphQLTypes;
  }
});

// ../../../node_modules/@graphql-tools/merge/cjs/typedefs-mergers/index.js
var require_typedefs_mergers2 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/cjs/typedefs-mergers/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_arguments2(), exports2);
    tslib_1.__exportStar(require_directives3(), exports2);
    tslib_1.__exportStar(require_enum_values2(), exports2);
    tslib_1.__exportStar(require_enum2(), exports2);
    tslib_1.__exportStar(require_fields5(), exports2);
    tslib_1.__exportStar(require_input_type2(), exports2);
    tslib_1.__exportStar(require_interface2(), exports2);
    tslib_1.__exportStar(require_merge_named_type_array2(), exports2);
    tslib_1.__exportStar(require_merge_nodes2(), exports2);
    tslib_1.__exportStar(require_merge_typedefs2(), exports2);
    tslib_1.__exportStar(require_scalar2(), exports2);
    tslib_1.__exportStar(require_type2(), exports2);
    tslib_1.__exportStar(require_union2(), exports2);
    tslib_1.__exportStar(require_utils4(), exports2);
  }
});

// ../../../node_modules/@graphql-tools/merge/cjs/extensions.js
var require_extensions2 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/cjs/extensions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.extractExtensionsFromSchema = exports2.applyExtensions = exports2.mergeExtensions = exports2.travelSchemaPossibleExtensions = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var utils_1 = require_cjs6();
    function travelSchemaPossibleExtensions(schema, hooks) {
      hooks.onSchema(schema);
      const typesMap = schema.getTypeMap();
      for (const [, type] of Object.entries(typesMap)) {
        const isPredefinedScalar = (0, graphql_1.isScalarType)(type) && (0, graphql_1.isSpecifiedScalarType)(type);
        const isIntrospection = (0, graphql_1.isIntrospectionType)(type);
        if (isPredefinedScalar || isIntrospection) {
          continue;
        }
        if ((0, graphql_1.isObjectType)(type)) {
          hooks.onObjectType(type);
          const fields = type.getFields();
          for (const [, field] of Object.entries(fields)) {
            hooks.onObjectField(type, field);
            const args = field.args || [];
            for (const arg of args) {
              hooks.onObjectFieldArg(type, field, arg);
            }
          }
        } else if ((0, graphql_1.isInterfaceType)(type)) {
          hooks.onInterface(type);
          const fields = type.getFields();
          for (const [, field] of Object.entries(fields)) {
            hooks.onInterfaceField(type, field);
            const args = field.args || [];
            for (const arg of args) {
              hooks.onInterfaceFieldArg(type, field, arg);
            }
          }
        } else if ((0, graphql_1.isInputObjectType)(type)) {
          hooks.onInputType(type);
          const fields = type.getFields();
          for (const [, field] of Object.entries(fields)) {
            hooks.onInputFieldType(type, field);
          }
        } else if ((0, graphql_1.isUnionType)(type)) {
          hooks.onUnion(type);
        } else if ((0, graphql_1.isScalarType)(type)) {
          hooks.onScalar(type);
        } else if ((0, graphql_1.isEnumType)(type)) {
          hooks.onEnum(type);
          for (const value of type.getValues()) {
            hooks.onEnumValue(type, value);
          }
        }
      }
    }
    exports2.travelSchemaPossibleExtensions = travelSchemaPossibleExtensions;
    function mergeExtensions(extensions) {
      return (0, utils_1.mergeDeep)(extensions);
    }
    exports2.mergeExtensions = mergeExtensions;
    function applyExtensionObject(obj, extensions) {
      if (!obj) {
        return;
      }
      obj.extensions = (0, utils_1.mergeDeep)([obj.extensions || {}, extensions || {}]);
    }
    function applyExtensions(schema, extensions) {
      applyExtensionObject(schema, extensions.schemaExtensions);
      for (const [typeName, data] of Object.entries(extensions.types || {})) {
        const type = schema.getType(typeName);
        if (type) {
          applyExtensionObject(type, data.extensions);
          if (data.type === "object" || data.type === "interface") {
            for (const [fieldName, fieldData] of Object.entries(data.fields)) {
              const field = type.getFields()[fieldName];
              if (field) {
                applyExtensionObject(field, fieldData.extensions);
                for (const [arg, argData] of Object.entries(fieldData.arguments)) {
                  applyExtensionObject(field.args.find((a) => a.name === arg), argData);
                }
              }
            }
          } else if (data.type === "input") {
            for (const [fieldName, fieldData] of Object.entries(data.fields)) {
              const field = type.getFields()[fieldName];
              applyExtensionObject(field, fieldData.extensions);
            }
          } else if (data.type === "enum") {
            for (const [valueName, valueData] of Object.entries(data.values)) {
              const value = type.getValue(valueName);
              applyExtensionObject(value, valueData);
            }
          }
        }
      }
      return schema;
    }
    exports2.applyExtensions = applyExtensions;
    function extractExtensionsFromSchema(schema) {
      const result = {
        schemaExtensions: {},
        types: {}
      };
      travelSchemaPossibleExtensions(schema, {
        onSchema: (schema2) => result.schemaExtensions = schema2.extensions || {},
        onObjectType: (type) => result.types[type.name] = { fields: {}, type: "object", extensions: type.extensions || {} },
        onObjectField: (type, field) => result.types[type.name].fields[field.name] = {
          arguments: {},
          extensions: field.extensions || {}
        },
        onObjectFieldArg: (type, field, arg) => result.types[type.name].fields[field.name].arguments[arg.name] = arg.extensions || {},
        onInterface: (type) => result.types[type.name] = { fields: {}, type: "interface", extensions: type.extensions || {} },
        onInterfaceField: (type, field) => result.types[type.name].fields[field.name] = {
          arguments: {},
          extensions: field.extensions || {}
        },
        onInterfaceFieldArg: (type, field, arg) => result.types[type.name].fields[field.name].arguments[arg.name] = arg.extensions || {},
        onEnum: (type) => result.types[type.name] = { values: {}, type: "enum", extensions: type.extensions || {} },
        onEnumValue: (type, value) => result.types[type.name].values[value.name] = value.extensions || {},
        onScalar: (type) => result.types[type.name] = { type: "scalar", extensions: type.extensions || {} },
        onUnion: (type) => result.types[type.name] = { type: "union", extensions: type.extensions || {} },
        onInputType: (type) => result.types[type.name] = { fields: {}, type: "input", extensions: type.extensions || {} },
        onInputFieldType: (type, field) => result.types[type.name].fields[field.name] = { extensions: field.extensions || {} }
      });
      return result;
    }
    exports2.extractExtensionsFromSchema = extractExtensionsFromSchema;
  }
});

// ../../../node_modules/@graphql-tools/merge/cjs/index.js
var require_cjs7 = __commonJS({
  "../../../node_modules/@graphql-tools/merge/cjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_merge_resolvers2(), exports2);
    tslib_1.__exportStar(require_typedefs_mergers2(), exports2);
    tslib_1.__exportStar(require_extensions2(), exports2);
  }
});

// ../../../node_modules/@graphql-tools/schema/cjs/makeExecutableSchema.js
var require_makeExecutableSchema2 = __commonJS({
  "../../../node_modules/@graphql-tools/schema/cjs/makeExecutableSchema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.makeExecutableSchema = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var utils_1 = require_cjs5();
    var addResolversToSchema_js_1 = require_addResolversToSchema2();
    var assertResolversPresent_js_1 = require_assertResolversPresent2();
    var merge_1 = require_cjs7();
    function makeExecutableSchema({ typeDefs, resolvers = {}, resolverValidationOptions = {}, parseOptions = {}, inheritResolversFromInterfaces = false, pruningOptions, updateResolversInPlace = false, schemaExtensions }) {
      if (typeof resolverValidationOptions !== "object") {
        throw new Error("Expected `resolverValidationOptions` to be an object");
      }
      if (!typeDefs) {
        throw new Error("Must provide typeDefs");
      }
      let schema;
      if ((0, graphql_1.isSchema)(typeDefs)) {
        schema = typeDefs;
      } else if (parseOptions === null || parseOptions === void 0 ? void 0 : parseOptions.commentDescriptions) {
        const mergedTypeDefs = (0, merge_1.mergeTypeDefs)(typeDefs, {
          ...parseOptions,
          commentDescriptions: true
        });
        schema = (0, graphql_1.buildSchema)(mergedTypeDefs, parseOptions);
      } else {
        const mergedTypeDefs = (0, merge_1.mergeTypeDefs)(typeDefs, parseOptions);
        schema = (0, graphql_1.buildASTSchema)(mergedTypeDefs, parseOptions);
      }
      if (pruningOptions) {
        schema = (0, utils_1.pruneSchema)(schema);
      }
      schema = (0, addResolversToSchema_js_1.addResolversToSchema)({
        schema,
        resolvers: (0, merge_1.mergeResolvers)(resolvers),
        resolverValidationOptions,
        inheritResolversFromInterfaces,
        updateResolversInPlace
      });
      if (Object.keys(resolverValidationOptions).length > 0) {
        (0, assertResolversPresent_js_1.assertResolversPresent)(schema, resolverValidationOptions);
      }
      if (schemaExtensions) {
        schemaExtensions = (0, merge_1.mergeExtensions)((0, utils_1.asArray)(schemaExtensions));
        (0, merge_1.applyExtensions)(schema, schemaExtensions);
      }
      return schema;
    }
    exports2.makeExecutableSchema = makeExecutableSchema;
  }
});

// ../../../node_modules/@graphql-tools/schema/cjs/types.js
var require_types6 = __commonJS({
  "../../../node_modules/@graphql-tools/schema/cjs/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../../node_modules/@graphql-tools/schema/cjs/merge-schemas.js
var require_merge_schemas2 = __commonJS({
  "../../../node_modules/@graphql-tools/schema/cjs/merge-schemas.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeSchemas = void 0;
    var merge_1 = require_cjs7();
    var utils_1 = require_cjs5();
    var makeExecutableSchema_js_1 = require_makeExecutableSchema2();
    function mergeSchemas(config) {
      const extractedTypeDefs = (0, utils_1.asArray)(config.typeDefs || []);
      const extractedResolvers = (0, utils_1.asArray)(config.resolvers || []);
      const extractedSchemaExtensions = (0, utils_1.asArray)(config.schemaExtensions || []);
      const schemas = config.schemas || [];
      for (const schema of schemas) {
        extractedTypeDefs.push(schema);
        extractedResolvers.push((0, utils_1.getResolversFromSchema)(schema, true));
        extractedSchemaExtensions.push((0, merge_1.extractExtensionsFromSchema)(schema));
      }
      return (0, makeExecutableSchema_js_1.makeExecutableSchema)({
        parseOptions: config,
        ...config,
        typeDefs: extractedTypeDefs,
        resolvers: extractedResolvers,
        schemaExtensions: extractedSchemaExtensions
      });
    }
    exports2.mergeSchemas = mergeSchemas;
  }
});

// ../../../node_modules/@graphql-tools/schema/cjs/index.js
var require_cjs8 = __commonJS({
  "../../../node_modules/@graphql-tools/schema/cjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.extendResolversFromInterfaces = exports2.checkForResolveTypeResolver = exports2.addResolversToSchema = exports2.chainResolvers = exports2.assertResolversPresent = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var assertResolversPresent_js_1 = require_assertResolversPresent2();
    Object.defineProperty(exports2, "assertResolversPresent", { enumerable: true, get: function() {
      return assertResolversPresent_js_1.assertResolversPresent;
    } });
    var chainResolvers_js_1 = require_chainResolvers2();
    Object.defineProperty(exports2, "chainResolvers", { enumerable: true, get: function() {
      return chainResolvers_js_1.chainResolvers;
    } });
    var addResolversToSchema_js_1 = require_addResolversToSchema2();
    Object.defineProperty(exports2, "addResolversToSchema", { enumerable: true, get: function() {
      return addResolversToSchema_js_1.addResolversToSchema;
    } });
    var checkForResolveTypeResolver_js_1 = require_checkForResolveTypeResolver2();
    Object.defineProperty(exports2, "checkForResolveTypeResolver", { enumerable: true, get: function() {
      return checkForResolveTypeResolver_js_1.checkForResolveTypeResolver;
    } });
    var extendResolversFromInterfaces_js_1 = require_extendResolversFromInterfaces2();
    Object.defineProperty(exports2, "extendResolversFromInterfaces", { enumerable: true, get: function() {
      return extendResolversFromInterfaces_js_1.extendResolversFromInterfaces;
    } });
    tslib_1.__exportStar(require_makeExecutableSchema2(), exports2);
    tslib_1.__exportStar(require_types6(), exports2);
    tslib_1.__exportStar(require_merge_schemas2(), exports2);
  }
});

// ../../../node_modules/loglevel/lib/loglevel.js
var require_loglevel = __commonJS({
  "../../../node_modules/loglevel/lib/loglevel.js"(exports2, module2) {
    (function(root, definition) {
      "use strict";
      if (typeof define === "function" && define.amd) {
        define(definition);
      } else if (typeof module2 === "object" && module2.exports) {
        module2.exports = definition();
      } else {
        root.log = definition();
      }
    })(exports2, function() {
      "use strict";
      var noop = function() {
      };
      var undefinedType = "undefined";
      var isIE = typeof window !== undefinedType && typeof window.navigator !== undefinedType && /Trident\/|MSIE /.test(window.navigator.userAgent);
      var logMethods = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
      ];
      function bindMethod(obj, methodName) {
        var method = obj[methodName];
        if (typeof method.bind === "function") {
          return method.bind(obj);
        } else {
          try {
            return Function.prototype.bind.call(method, obj);
          } catch (e) {
            return function() {
              return Function.prototype.apply.apply(method, [obj, arguments]);
            };
          }
        }
      }
      function traceForIE() {
        if (console.log) {
          if (console.log.apply) {
            console.log.apply(console, arguments);
          } else {
            Function.prototype.apply.apply(console.log, [console, arguments]);
          }
        }
        if (console.trace)
          console.trace();
      }
      function realMethod(methodName) {
        if (methodName === "debug") {
          methodName = "log";
        }
        if (typeof console === undefinedType) {
          return false;
        } else if (methodName === "trace" && isIE) {
          return traceForIE;
        } else if (console[methodName] !== void 0) {
          return bindMethod(console, methodName);
        } else if (console.log !== void 0) {
          return bindMethod(console, "log");
        } else {
          return noop;
        }
      }
      function replaceLoggingMethods(level, loggerName) {
        for (var i = 0; i < logMethods.length; i++) {
          var methodName = logMethods[i];
          this[methodName] = i < level ? noop : this.methodFactory(methodName, level, loggerName);
        }
        this.log = this.debug;
      }
      function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {
        return function() {
          if (typeof console !== undefinedType) {
            replaceLoggingMethods.call(this, level, loggerName);
            this[methodName].apply(this, arguments);
          }
        };
      }
      function defaultMethodFactory(methodName, level, loggerName) {
        return realMethod(methodName) || enableLoggingWhenConsoleArrives.apply(this, arguments);
      }
      function Logger(name, defaultLevel, factory) {
        var self2 = this;
        var currentLevel;
        defaultLevel = defaultLevel == null ? "WARN" : defaultLevel;
        var storageKey = "loglevel";
        if (typeof name === "string") {
          storageKey += ":" + name;
        } else if (typeof name === "symbol") {
          storageKey = void 0;
        }
        function persistLevelIfPossible(levelNum) {
          var levelName = (logMethods[levelNum] || "silent").toUpperCase();
          if (typeof window === undefinedType || !storageKey)
            return;
          try {
            window.localStorage[storageKey] = levelName;
            return;
          } catch (ignore) {
          }
          try {
            window.document.cookie = encodeURIComponent(storageKey) + "=" + levelName + ";";
          } catch (ignore) {
          }
        }
        function getPersistedLevel() {
          var storedLevel;
          if (typeof window === undefinedType || !storageKey)
            return;
          try {
            storedLevel = window.localStorage[storageKey];
          } catch (ignore) {
          }
          if (typeof storedLevel === undefinedType) {
            try {
              var cookie = window.document.cookie;
              var location = cookie.indexOf(
                encodeURIComponent(storageKey) + "="
              );
              if (location !== -1) {
                storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];
              }
            } catch (ignore) {
            }
          }
          if (self2.levels[storedLevel] === void 0) {
            storedLevel = void 0;
          }
          return storedLevel;
        }
        function clearPersistedLevel() {
          if (typeof window === undefinedType || !storageKey)
            return;
          try {
            window.localStorage.removeItem(storageKey);
            return;
          } catch (ignore) {
          }
          try {
            window.document.cookie = encodeURIComponent(storageKey) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
          } catch (ignore) {
          }
        }
        self2.name = name;
        self2.levels = {
          "TRACE": 0,
          "DEBUG": 1,
          "INFO": 2,
          "WARN": 3,
          "ERROR": 4,
          "SILENT": 5
        };
        self2.methodFactory = factory || defaultMethodFactory;
        self2.getLevel = function() {
          return currentLevel;
        };
        self2.setLevel = function(level, persist) {
          if (typeof level === "string" && self2.levels[level.toUpperCase()] !== void 0) {
            level = self2.levels[level.toUpperCase()];
          }
          if (typeof level === "number" && level >= 0 && level <= self2.levels.SILENT) {
            currentLevel = level;
            if (persist !== false) {
              persistLevelIfPossible(level);
            }
            replaceLoggingMethods.call(self2, level, name);
            if (typeof console === undefinedType && level < self2.levels.SILENT) {
              return "No console available for logging";
            }
          } else {
            throw "log.setLevel() called with invalid level: " + level;
          }
        };
        self2.setDefaultLevel = function(level) {
          defaultLevel = level;
          if (!getPersistedLevel()) {
            self2.setLevel(level, false);
          }
        };
        self2.resetLevel = function() {
          self2.setLevel(defaultLevel, false);
          clearPersistedLevel();
        };
        self2.enableAll = function(persist) {
          self2.setLevel(self2.levels.TRACE, persist);
        };
        self2.disableAll = function(persist) {
          self2.setLevel(self2.levels.SILENT, persist);
        };
        var initialLevel = getPersistedLevel();
        if (initialLevel == null) {
          initialLevel = defaultLevel;
        }
        self2.setLevel(initialLevel, false);
      }
      var defaultLogger = new Logger();
      var _loggersByName = {};
      defaultLogger.getLogger = function getLogger(name) {
        if (typeof name !== "symbol" && typeof name !== "string" || name === "") {
          throw new TypeError("You must supply a name when creating a logger.");
        }
        var logger = _loggersByName[name];
        if (!logger) {
          logger = _loggersByName[name] = new Logger(
            name,
            defaultLogger.getLevel(),
            defaultLogger.methodFactory
          );
        }
        return logger;
      };
      var _log = typeof window !== undefinedType ? window.log : void 0;
      defaultLogger.noConflict = function() {
        if (typeof window !== undefinedType && window.log === defaultLogger) {
          window.log = _log;
        }
        return defaultLogger;
      };
      defaultLogger.getLoggers = function getLoggers() {
        return _loggersByName;
      };
      defaultLogger["default"] = defaultLogger;
      return defaultLogger;
    });
  }
});

// ../../../node_modules/@josephg/resolvable/index.js
var require_resolvable = __commonJS({
  "../../../node_modules/@josephg/resolvable/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var resolvablePromise = () => {
      let resolve;
      let reject;
      const promise = new Promise((_resolve, _reject) => {
        resolve = _resolve;
        reject = _reject;
      });
      promise.resolve = resolve;
      promise.reject = reject;
      return promise;
    };
    exports2.default = resolvablePromise;
    module2.exports = resolvablePromise;
  }
});

// ../../../node_modules/apollo-server-core/dist/utils/schemaHash.js
var require_schemaHash = __commonJS({
  "../../../node_modules/apollo-server-core/dist/utils/schemaHash.js"(exports2) {
    "use strict";
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.generateSchemaHash = void 0;
    var language_1 = (init_language(), __toCommonJS(language_exports));
    var execution_1 = (init_execution(), __toCommonJS(execution_exports));
    var utilities_1 = (init_utilities(), __toCommonJS(utilities_exports));
    var fast_json_stable_stringify_1 = __importDefault2(require_fast_json_stable_stringify());
    var createSHA_1 = __importDefault2(require_createSHA());
    function generateSchemaHash(schema) {
      const introspectionQuery = (0, utilities_1.getIntrospectionQuery)();
      const document2 = (0, language_1.parse)(introspectionQuery);
      const result = (0, execution_1.execute)({
        schema,
        document: document2
      });
      if (result && typeof result.then === "function") {
        throw new Error([
          "The introspection query is resolving asynchronously; execution of an introspection query is not expected to return a `Promise`.",
          "",
          "Wrapped type resolvers should maintain the existing execution dynamics of the resolvers they wrap (i.e. async vs sync) or introspection types should be excluded from wrapping by checking them with `graphql/type`s, `isIntrospectionType` predicate function prior to wrapping."
        ].join("\n"));
      }
      if (!result || !result.data || !result.data.__schema) {
        throw new Error("Unable to generate server introspection document.");
      }
      const introspectionSchema = result.data.__schema;
      const stringifiedSchema = (0, fast_json_stable_stringify_1.default)(introspectionSchema);
      return (0, createSHA_1.default)("sha512").update(stringifiedSchema).digest("hex");
    }
    exports2.generateSchemaHash = generateSchemaHash;
  }
});

// ../../../node_modules/@apollographql/apollo-tools/lib/utilities/invariant.js
var require_invariant = __commonJS({
  "../../../node_modules/@apollographql/apollo-tools/lib/utilities/invariant.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.invariant = void 0;
    function invariant2(condition, message) {
      if (!condition) {
        throw new Error(message);
      }
    }
    exports2.invariant = invariant2;
  }
});

// ../../../node_modules/@apollographql/apollo-tools/lib/utilities/predicates.js
var require_predicates = __commonJS({
  "../../../node_modules/@apollographql/apollo-tools/lib/utilities/predicates.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isNotNullOrUndefined = void 0;
    function isNotNullOrUndefined(value) {
      return value !== null && typeof value !== "undefined";
    }
    exports2.isNotNullOrUndefined = isNotNullOrUndefined;
  }
});

// ../../../node_modules/@apollographql/apollo-tools/lib/utilities/graphql.js
var require_graphql = __commonJS({
  "../../../node_modules/@apollographql/apollo-tools/lib/utilities/graphql.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isDocumentNode = exports2.isNode = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function isNode2(maybeNode) {
      return maybeNode && typeof maybeNode.kind === "string";
    }
    exports2.isNode = isNode2;
    function isDocumentNode(node) {
      return isNode2(node) && node.kind === graphql_1.Kind.DOCUMENT;
    }
    exports2.isDocumentNode = isDocumentNode;
  }
});

// ../../../node_modules/@apollographql/apollo-tools/lib/utilities/index.js
var require_utilities = __commonJS({
  "../../../node_modules/@apollographql/apollo-tools/lib/utilities/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_invariant(), exports2);
    __exportStar2(require_predicates(), exports2);
    __exportStar2(require_graphql(), exports2);
  }
});

// ../../../node_modules/@apollographql/apollo-tools/lib/schema/resolverMap.js
var require_resolverMap = __commonJS({
  "../../../node_modules/@apollographql/apollo-tools/lib/schema/resolverMap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../../node_modules/@apollographql/apollo-tools/lib/schema/resolveObject.js
var require_resolveObject = __commonJS({
  "../../../node_modules/@apollographql/apollo-tools/lib/schema/resolveObject.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../../node_modules/@apollographql/apollo-tools/lib/schema/index.js
var require_schema = __commonJS({
  "../../../node_modules/@apollographql/apollo-tools/lib/schema/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_resolverMap(), exports2);
    __exportStar2(require_resolveObject(), exports2);
  }
});

// ../../../node_modules/@apollographql/apollo-tools/lib/buildServiceDefinition.js
var require_buildServiceDefinition = __commonJS({
  "../../../node_modules/@apollographql/apollo-tools/lib/buildServiceDefinition.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.buildServiceDefinition = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var graphql_2 = require_graphql();
    var predicates_1 = require_predicates();
    function flattened(arr) {
      return new Array().concat(...arr);
    }
    function buildServiceDefinition(modules) {
      const errors = [];
      const typeDefinitionsMap = /* @__PURE__ */ Object.create(null);
      const typeExtensionsMap = /* @__PURE__ */ Object.create(null);
      const directivesMap = /* @__PURE__ */ Object.create(null);
      const schemaDefinitions = [];
      const schemaExtensions = [];
      for (let module3 of modules) {
        if ((0, graphql_2.isNode)(module3) && (0, graphql_2.isDocumentNode)(module3)) {
          module3 = { typeDefs: module3 };
        }
        for (const definition of module3.typeDefs.definitions) {
          if ((0, graphql_1.isTypeDefinitionNode)(definition)) {
            const typeName = definition.name.value;
            if (typeDefinitionsMap[typeName]) {
              typeDefinitionsMap[typeName].push(definition);
            } else {
              typeDefinitionsMap[typeName] = [definition];
            }
          } else if ((0, graphql_1.isTypeExtensionNode)(definition)) {
            const typeName = definition.name.value;
            if (typeExtensionsMap[typeName]) {
              typeExtensionsMap[typeName].push(definition);
            } else {
              typeExtensionsMap[typeName] = [definition];
            }
          } else if (definition.kind === graphql_1.Kind.DIRECTIVE_DEFINITION) {
            const directiveName = definition.name.value;
            if (directivesMap[directiveName]) {
              directivesMap[directiveName].push(definition);
            } else {
              directivesMap[directiveName] = [definition];
            }
          } else if (definition.kind === graphql_1.Kind.SCHEMA_DEFINITION) {
            schemaDefinitions.push(definition);
          } else if (definition.kind === graphql_1.Kind.SCHEMA_EXTENSION) {
            schemaExtensions.push(definition);
          }
        }
      }
      for (const [typeName, typeDefinitions] of Object.entries(typeDefinitionsMap)) {
        if (typeDefinitions.length > 1) {
          errors.push(new graphql_1.GraphQLError(`Type "${typeName}" was defined more than once.`, typeDefinitions));
        }
      }
      for (const [directiveName, directives] of Object.entries(directivesMap)) {
        if (directives.length > 1) {
          errors.push(new graphql_1.GraphQLError(`Directive "${directiveName}" was defined more than once.`, directives));
        }
      }
      let operationTypeMap;
      if (schemaDefinitions.length > 0 || schemaExtensions.length > 0) {
        operationTypeMap = {};
        const schemaDefinition = schemaDefinitions[schemaDefinitions.length - 1];
        const operationTypes = flattened([schemaDefinition, ...schemaExtensions].map((node) => node.operationTypes).filter(predicates_1.isNotNullOrUndefined));
        for (const operationType of operationTypes) {
          const typeName = operationType.type.name.value;
          const operation = operationType.operation;
          if (operationTypeMap[operation]) {
            throw new graphql_1.GraphQLError(`Must provide only one ${operation} type in schema.`, [schemaDefinition]);
          }
          if (!(typeDefinitionsMap[typeName] || typeExtensionsMap[typeName])) {
            throw new graphql_1.GraphQLError(`Specified ${operation} type "${typeName}" not found in document.`, [schemaDefinition]);
          }
          operationTypeMap[operation] = typeName;
        }
      } else {
        operationTypeMap = {
          query: "Query",
          mutation: "Mutation",
          subscription: "Subscription"
        };
      }
      for (const [typeName, typeExtensions] of Object.entries(typeExtensionsMap)) {
        if (!typeDefinitionsMap[typeName]) {
          if (Object.values(operationTypeMap).includes(typeName)) {
            typeDefinitionsMap[typeName] = [
              {
                kind: graphql_1.Kind.OBJECT_TYPE_DEFINITION,
                name: {
                  kind: graphql_1.Kind.NAME,
                  value: typeName
                }
              }
            ];
          } else {
            errors.push(new graphql_1.GraphQLError(`Cannot extend type "${typeName}" because it does not exist in the existing schema.`, typeExtensions));
          }
        }
      }
      if (errors.length > 0) {
        return { errors };
      }
      try {
        const typeDefinitions = flattened(Object.values(typeDefinitionsMap));
        const directives = flattened(Object.values(directivesMap));
        let schema = (0, graphql_1.buildASTSchema)({
          kind: graphql_1.Kind.DOCUMENT,
          definitions: [...typeDefinitions, ...directives]
        });
        const typeExtensions = flattened(Object.values(typeExtensionsMap));
        if (typeExtensions.length > 0) {
          schema = (0, graphql_1.extendSchema)(schema, {
            kind: graphql_1.Kind.DOCUMENT,
            definitions: typeExtensions
          });
        }
        for (const module3 of modules) {
          if ("kind" in module3 || !module3.resolvers)
            continue;
          addResolversToSchema(schema, module3.resolvers);
        }
        return { schema };
      } catch (error) {
        return { errors: [error] };
      }
    }
    exports2.buildServiceDefinition = buildServiceDefinition;
    function addResolversToSchema(schema, resolvers) {
      for (const [typeName, fieldConfigs] of Object.entries(resolvers)) {
        const type = schema.getType(typeName);
        if (!(0, graphql_1.isObjectType)(type))
          continue;
        const fieldMap = type.getFields();
        for (const [fieldName, fieldConfig] of Object.entries(fieldConfigs)) {
          if (fieldName.startsWith("__")) {
            type[fieldName.substring(2)] = fieldConfig;
            continue;
          }
          const field = fieldMap[fieldName];
          if (!field)
            continue;
          if (typeof fieldConfig === "function") {
            field.resolve = fieldConfig;
          } else {
            if (fieldConfig.resolve) {
              field.resolve = fieldConfig.resolve;
            }
            if (fieldConfig.subscribe) {
              field.subscribe = fieldConfig.subscribe;
            }
          }
        }
      }
    }
  }
});

// ../../../node_modules/@apollographql/apollo-tools/lib/index.js
var require_lib = __commonJS({
  "../../../node_modules/@apollographql/apollo-tools/lib/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_utilities(), exports2);
    __exportStar2(require_schema(), exports2);
    __exportStar2(require_buildServiceDefinition(), exports2);
  }
});

// ../../../node_modules/apollo-server-core/dist/determineApolloConfig.js
var require_determineApolloConfig = __commonJS({
  "../../../node_modules/apollo-server-core/dist/determineApolloConfig.js"(exports2) {
    "use strict";
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.determineApolloConfig = void 0;
    var createSHA_1 = __importDefault2(require_createSHA());
    function determineApolloConfig(input) {
      var _a, _b;
      const apolloConfig = {};
      const { APOLLO_KEY, APOLLO_GRAPH_REF, APOLLO_GRAPH_ID, APOLLO_GRAPH_VARIANT } = process.env;
      if (input === null || input === void 0 ? void 0 : input.key) {
        apolloConfig.key = input.key;
      } else if (APOLLO_KEY) {
        apolloConfig.key = APOLLO_KEY;
      }
      if (apolloConfig.key) {
        apolloConfig.keyHash = (0, createSHA_1.default)("sha512").update(apolloConfig.key).digest("hex");
      }
      if (input === null || input === void 0 ? void 0 : input.graphRef) {
        apolloConfig.graphRef = input.graphRef;
      } else if (APOLLO_GRAPH_REF) {
        apolloConfig.graphRef = APOLLO_GRAPH_REF;
      }
      const graphId = (_a = input === null || input === void 0 ? void 0 : input.graphId) !== null && _a !== void 0 ? _a : APOLLO_GRAPH_ID;
      const graphVariant = (_b = input === null || input === void 0 ? void 0 : input.graphVariant) !== null && _b !== void 0 ? _b : APOLLO_GRAPH_VARIANT;
      if (apolloConfig.graphRef) {
        if (graphId) {
          throw new Error("Cannot specify both graph ref and graph ID. Please use `apollo.graphRef` or `APOLLO_GRAPH_REF` without also setting the graph ID.");
        }
        if (graphVariant) {
          throw new Error("Cannot specify both graph ref and graph variant. Please use `apollo.graphRef` or `APOLLO_GRAPH_REF` without also setting the graph variant.");
        }
      } else if (graphId) {
        apolloConfig.graphRef = graphVariant ? `${graphId}@${graphVariant}` : graphId;
      }
      return apolloConfig;
    }
    exports2.determineApolloConfig = determineApolloConfig;
  }
});

// browser-external:os
var require_os = __commonJS({
  "browser-external:os"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "os" has been externalized for browser compatibility. Cannot access "os.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// ../../../node_modules/util/support/isBufferBrowser.js
var require_isBufferBrowser = __commonJS({
  "../../../node_modules/util/support/isBufferBrowser.js"(exports2, module2) {
    module2.exports = function isBuffer(arg) {
      return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
    };
  }
});

// ../../../node_modules/util/node_modules/inherits/inherits_browser.js
var require_inherits_browser2 = __commonJS({
  "../../../node_modules/util/node_modules/inherits/inherits_browser.js"(exports2, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      };
    }
  }
});

// ../../../node_modules/util/util.js
var require_util = __commonJS({
  "../../../node_modules/util/util.js"(exports2) {
    var formatRegExp = /%[sdj%]/g;
    exports2.format = function(f) {
      if (!isString(f)) {
        var objects = [];
        for (var i = 0; i < arguments.length; i++) {
          objects.push(inspect2(arguments[i]));
        }
        return objects.join(" ");
      }
      var i = 1;
      var args = arguments;
      var len = args.length;
      var str = String(f).replace(formatRegExp, function(x2) {
        if (x2 === "%%")
          return "%";
        if (i >= len)
          return x2;
        switch (x2) {
          case "%s":
            return String(args[i++]);
          case "%d":
            return Number(args[i++]);
          case "%j":
            try {
              return JSON.stringify(args[i++]);
            } catch (_) {
              return "[Circular]";
            }
          default:
            return x2;
        }
      });
      for (var x = args[i]; i < len; x = args[++i]) {
        if (isNull(x) || !isObject(x)) {
          str += " " + x;
        } else {
          str += " " + inspect2(x);
        }
      }
      return str;
    };
    exports2.deprecate = function(fn, msg) {
      if (isUndefined(global.process)) {
        return function() {
          return exports2.deprecate(fn, msg).apply(this, arguments);
        };
      }
      if (process.noDeprecation === true) {
        return fn;
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (process.throwDeprecation) {
            throw new Error(msg);
          } else if (process.traceDeprecation) {
            console.trace(msg);
          } else {
            console.error(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated;
    };
    var debugs = {};
    var debugEnviron;
    exports2.debuglog = function(set) {
      if (isUndefined(debugEnviron))
        debugEnviron = process.env.NODE_DEBUG || "";
      set = set.toUpperCase();
      if (!debugs[set]) {
        if (new RegExp("\\b" + set + "\\b", "i").test(debugEnviron)) {
          var pid = process.pid;
          debugs[set] = function() {
            var msg = exports2.format.apply(exports2, arguments);
            console.error("%s %d: %s", set, pid, msg);
          };
        } else {
          debugs[set] = function() {
          };
        }
      }
      return debugs[set];
    };
    function inspect2(obj, opts) {
      var ctx = {
        seen: [],
        stylize: stylizeNoColor
      };
      if (arguments.length >= 3)
        ctx.depth = arguments[2];
      if (arguments.length >= 4)
        ctx.colors = arguments[3];
      if (isBoolean(opts)) {
        ctx.showHidden = opts;
      } else if (opts) {
        exports2._extend(ctx, opts);
      }
      if (isUndefined(ctx.showHidden))
        ctx.showHidden = false;
      if (isUndefined(ctx.depth))
        ctx.depth = 2;
      if (isUndefined(ctx.colors))
        ctx.colors = false;
      if (isUndefined(ctx.customInspect))
        ctx.customInspect = true;
      if (ctx.colors)
        ctx.stylize = stylizeWithColor;
      return formatValue2(ctx, obj, ctx.depth);
    }
    exports2.inspect = inspect2;
    inspect2.colors = {
      "bold": [1, 22],
      "italic": [3, 23],
      "underline": [4, 24],
      "inverse": [7, 27],
      "white": [37, 39],
      "grey": [90, 39],
      "black": [30, 39],
      "blue": [34, 39],
      "cyan": [36, 39],
      "green": [32, 39],
      "magenta": [35, 39],
      "red": [31, 39],
      "yellow": [33, 39]
    };
    inspect2.styles = {
      "special": "cyan",
      "number": "yellow",
      "boolean": "yellow",
      "undefined": "grey",
      "null": "bold",
      "string": "green",
      "date": "magenta",
      // "name": intentionally not styling
      "regexp": "red"
    };
    function stylizeWithColor(str, styleType) {
      var style = inspect2.styles[styleType];
      if (style) {
        return "\x1B[" + inspect2.colors[style][0] + "m" + str + "\x1B[" + inspect2.colors[style][1] + "m";
      } else {
        return str;
      }
    }
    function stylizeNoColor(str, styleType) {
      return str;
    }
    function arrayToHash(array) {
      var hash = {};
      array.forEach(function(val, idx) {
        hash[val] = true;
      });
      return hash;
    }
    function formatValue2(ctx, value, recurseTimes) {
      if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
      value.inspect !== exports2.inspect && // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx);
        if (!isString(ret)) {
          ret = formatValue2(ctx, ret, recurseTimes);
        }
        return ret;
      }
      var primitive = formatPrimitive(ctx, value);
      if (primitive) {
        return primitive;
      }
      var keys = Object.keys(value);
      var visibleKeys = arrayToHash(keys);
      if (ctx.showHidden) {
        keys = Object.getOwnPropertyNames(value);
      }
      if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
        return formatError2(value);
      }
      if (keys.length === 0) {
        if (isFunction(value)) {
          var name = value.name ? ": " + value.name : "";
          return ctx.stylize("[Function" + name + "]", "special");
        }
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        }
        if (isDate(value)) {
          return ctx.stylize(Date.prototype.toString.call(value), "date");
        }
        if (isError(value)) {
          return formatError2(value);
        }
      }
      var base = "", array = false, braces = ["{", "}"];
      if (isArray(value)) {
        array = true;
        braces = ["[", "]"];
      }
      if (isFunction(value)) {
        var n = value.name ? ": " + value.name : "";
        base = " [Function" + n + "]";
      }
      if (isRegExp(value)) {
        base = " " + RegExp.prototype.toString.call(value);
      }
      if (isDate(value)) {
        base = " " + Date.prototype.toUTCString.call(value);
      }
      if (isError(value)) {
        base = " " + formatError2(value);
      }
      if (keys.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base + braces[1];
      }
      if (recurseTimes < 0) {
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        } else {
          return ctx.stylize("[Object]", "special");
        }
      }
      ctx.seen.push(value);
      var output;
      if (array) {
        output = formatArray2(ctx, value, recurseTimes, visibleKeys, keys);
      } else {
        output = keys.map(function(key) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
        });
      }
      ctx.seen.pop();
      return reduceToSingleString(output, base, braces);
    }
    function formatPrimitive(ctx, value) {
      if (isUndefined(value))
        return ctx.stylize("undefined", "undefined");
      if (isString(value)) {
        var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return ctx.stylize(simple, "string");
      }
      if (isNumber(value))
        return ctx.stylize("" + value, "number");
      if (isBoolean(value))
        return ctx.stylize("" + value, "boolean");
      if (isNull(value))
        return ctx.stylize("null", "null");
    }
    function formatError2(value) {
      return "[" + Error.prototype.toString.call(value) + "]";
    }
    function formatArray2(ctx, value, recurseTimes, visibleKeys, keys) {
      var output = [];
      for (var i = 0, l = value.length; i < l; ++i) {
        if (hasOwnProperty2(value, String(i))) {
          output.push(formatProperty(
            ctx,
            value,
            recurseTimes,
            visibleKeys,
            String(i),
            true
          ));
        } else {
          output.push("");
        }
      }
      keys.forEach(function(key) {
        if (!key.match(/^\d+$/)) {
          output.push(formatProperty(
            ctx,
            value,
            recurseTimes,
            visibleKeys,
            key,
            true
          ));
        }
      });
      return output;
    }
    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
      var name, str, desc;
      desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize("[Getter/Setter]", "special");
        } else {
          str = ctx.stylize("[Getter]", "special");
        }
      } else {
        if (desc.set) {
          str = ctx.stylize("[Setter]", "special");
        }
      }
      if (!hasOwnProperty2(visibleKeys, key)) {
        name = "[" + key + "]";
      }
      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull(recurseTimes)) {
            str = formatValue2(ctx, desc.value, null);
          } else {
            str = formatValue2(ctx, desc.value, recurseTimes - 1);
          }
          if (str.indexOf("\n") > -1) {
            if (array) {
              str = str.split("\n").map(function(line) {
                return "  " + line;
              }).join("\n").substr(2);
            } else {
              str = "\n" + str.split("\n").map(function(line) {
                return "   " + line;
              }).join("\n");
            }
          }
        } else {
          str = ctx.stylize("[Circular]", "special");
        }
      }
      if (isUndefined(name)) {
        if (array && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify("" + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.substr(1, name.length - 2);
          name = ctx.stylize(name, "name");
        } else {
          name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
          name = ctx.stylize(name, "string");
        }
      }
      return name + ": " + str;
    }
    function reduceToSingleString(output, base, braces) {
      var numLinesEst = 0;
      var length = output.reduce(function(prev, cur) {
        numLinesEst++;
        if (cur.indexOf("\n") >= 0)
          numLinesEst++;
        return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      if (length > 60) {
        return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
      }
      return braces[0] + base + " " + output.join(", ") + " " + braces[1];
    }
    function isArray(ar) {
      return Array.isArray(ar);
    }
    exports2.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === "boolean";
    }
    exports2.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports2.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports2.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === "number";
    }
    exports2.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === "string";
    }
    exports2.isString = isString;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports2.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports2.isUndefined = isUndefined;
    function isRegExp(re) {
      return isObject(re) && objectToString(re) === "[object RegExp]";
    }
    exports2.isRegExp = isRegExp;
    function isObject(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports2.isObject = isObject;
    function isDate(d) {
      return isObject(d) && objectToString(d) === "[object Date]";
    }
    exports2.isDate = isDate;
    function isError(e) {
      return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
    }
    exports2.isError = isError;
    function isFunction(arg) {
      return typeof arg === "function";
    }
    exports2.isFunction = isFunction;
    function isPrimitive(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
      typeof arg === "undefined";
    }
    exports2.isPrimitive = isPrimitive;
    exports2.isBuffer = require_isBufferBrowser();
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
    function pad(n) {
      return n < 10 ? "0" + n.toString(10) : n.toString(10);
    }
    var months = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    function timestamp() {
      var d = /* @__PURE__ */ new Date();
      var time = [
        pad(d.getHours()),
        pad(d.getMinutes()),
        pad(d.getSeconds())
      ].join(":");
      return [d.getDate(), months[d.getMonth()], time].join(" ");
    }
    exports2.log = function() {
      console.log("%s - %s", timestamp(), exports2.format.apply(exports2, arguments));
    };
    exports2.inherits = require_inherits_browser2();
    exports2._extend = function(origin, add) {
      if (!add || !isObject(add))
        return origin;
      var keys = Object.keys(add);
      var i = keys.length;
      while (i--) {
        origin[keys[i]] = add[keys[i]];
      }
      return origin;
    };
    function hasOwnProperty2(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
  }
});

// browser-external:zlib
var require_zlib = __commonJS({
  "browser-external:zlib"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "zlib" has been externalized for browser compatibility. Cannot access "zlib.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// ../../../node_modules/retry/lib/retry_operation.js
var require_retry_operation = __commonJS({
  "../../../node_modules/retry/lib/retry_operation.js"(exports2, module2) {
    function RetryOperation(timeouts, options) {
      if (typeof options === "boolean") {
        options = { forever: options };
      }
      this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
      this._timeouts = timeouts;
      this._options = options || {};
      this._maxRetryTime = options && options.maxRetryTime || Infinity;
      this._fn = null;
      this._errors = [];
      this._attempts = 1;
      this._operationTimeout = null;
      this._operationTimeoutCb = null;
      this._timeout = null;
      this._operationStart = null;
      this._timer = null;
      if (this._options.forever) {
        this._cachedTimeouts = this._timeouts.slice(0);
      }
    }
    module2.exports = RetryOperation;
    RetryOperation.prototype.reset = function() {
      this._attempts = 1;
      this._timeouts = this._originalTimeouts.slice(0);
    };
    RetryOperation.prototype.stop = function() {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (this._timer) {
        clearTimeout(this._timer);
      }
      this._timeouts = [];
      this._cachedTimeouts = null;
    };
    RetryOperation.prototype.retry = function(err) {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (!err) {
        return false;
      }
      var currentTime = (/* @__PURE__ */ new Date()).getTime();
      if (err && currentTime - this._operationStart >= this._maxRetryTime) {
        this._errors.push(err);
        this._errors.unshift(new Error("RetryOperation timeout occurred"));
        return false;
      }
      this._errors.push(err);
      var timeout = this._timeouts.shift();
      if (timeout === void 0) {
        if (this._cachedTimeouts) {
          this._errors.splice(0, this._errors.length - 1);
          timeout = this._cachedTimeouts.slice(-1);
        } else {
          return false;
        }
      }
      var self2 = this;
      this._timer = setTimeout(function() {
        self2._attempts++;
        if (self2._operationTimeoutCb) {
          self2._timeout = setTimeout(function() {
            self2._operationTimeoutCb(self2._attempts);
          }, self2._operationTimeout);
          if (self2._options.unref) {
            self2._timeout.unref();
          }
        }
        self2._fn(self2._attempts);
      }, timeout);
      if (this._options.unref) {
        this._timer.unref();
      }
      return true;
    };
    RetryOperation.prototype.attempt = function(fn, timeoutOps) {
      this._fn = fn;
      if (timeoutOps) {
        if (timeoutOps.timeout) {
          this._operationTimeout = timeoutOps.timeout;
        }
        if (timeoutOps.cb) {
          this._operationTimeoutCb = timeoutOps.cb;
        }
      }
      var self2 = this;
      if (this._operationTimeoutCb) {
        this._timeout = setTimeout(function() {
          self2._operationTimeoutCb();
        }, self2._operationTimeout);
      }
      this._operationStart = (/* @__PURE__ */ new Date()).getTime();
      this._fn(this._attempts);
    };
    RetryOperation.prototype.try = function(fn) {
      console.log("Using RetryOperation.try() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = function(fn) {
      console.log("Using RetryOperation.start() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = RetryOperation.prototype.try;
    RetryOperation.prototype.errors = function() {
      return this._errors;
    };
    RetryOperation.prototype.attempts = function() {
      return this._attempts;
    };
    RetryOperation.prototype.mainError = function() {
      if (this._errors.length === 0) {
        return null;
      }
      var counts = {};
      var mainError = null;
      var mainErrorCount = 0;
      for (var i = 0; i < this._errors.length; i++) {
        var error = this._errors[i];
        var message = error.message;
        var count = (counts[message] || 0) + 1;
        counts[message] = count;
        if (count >= mainErrorCount) {
          mainError = error;
          mainErrorCount = count;
        }
      }
      return mainError;
    };
  }
});

// ../../../node_modules/retry/lib/retry.js
var require_retry = __commonJS({
  "../../../node_modules/retry/lib/retry.js"(exports2) {
    var RetryOperation = require_retry_operation();
    exports2.operation = function(options) {
      var timeouts = exports2.timeouts(options);
      return new RetryOperation(timeouts, {
        forever: options && (options.forever || options.retries === Infinity),
        unref: options && options.unref,
        maxRetryTime: options && options.maxRetryTime
      });
    };
    exports2.timeouts = function(options) {
      if (options instanceof Array) {
        return [].concat(options);
      }
      var opts = {
        retries: 10,
        factor: 2,
        minTimeout: 1 * 1e3,
        maxTimeout: Infinity,
        randomize: false
      };
      for (var key in options) {
        opts[key] = options[key];
      }
      if (opts.minTimeout > opts.maxTimeout) {
        throw new Error("minTimeout is greater than maxTimeout");
      }
      var timeouts = [];
      for (var i = 0; i < opts.retries; i++) {
        timeouts.push(this.createTimeout(i, opts));
      }
      if (options && options.forever && !timeouts.length) {
        timeouts.push(this.createTimeout(i, opts));
      }
      timeouts.sort(function(a, b) {
        return a - b;
      });
      return timeouts;
    };
    exports2.createTimeout = function(attempt, opts) {
      var random = opts.randomize ? Math.random() + 1 : 1;
      var timeout = Math.round(random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));
      timeout = Math.min(timeout, opts.maxTimeout);
      return timeout;
    };
    exports2.wrap = function(obj, options, methods) {
      if (options instanceof Array) {
        methods = options;
        options = null;
      }
      if (!methods) {
        methods = [];
        for (var key in obj) {
          if (typeof obj[key] === "function") {
            methods.push(key);
          }
        }
      }
      for (var i = 0; i < methods.length; i++) {
        var method = methods[i];
        var original = obj[method];
        obj[method] = (function retryWrapper(original2) {
          var op = exports2.operation(options);
          var args = Array.prototype.slice.call(arguments, 1);
          var callback = args.pop();
          args.push(function(err) {
            if (op.retry(err)) {
              return;
            }
            if (err) {
              arguments[0] = op.mainError();
            }
            callback.apply(this, arguments);
          });
          op.attempt(function() {
            original2.apply(obj, args);
          });
        }).bind(obj, original);
        obj[method].options = options;
      }
    };
  }
});

// ../../../node_modules/retry/index.js
var require_retry2 = __commonJS({
  "../../../node_modules/retry/index.js"(exports2, module2) {
    module2.exports = require_retry();
  }
});

// ../../../node_modules/async-retry/lib/index.js
var require_lib2 = __commonJS({
  "../../../node_modules/async-retry/lib/index.js"(exports2, module2) {
    var retrier = require_retry2();
    function retry(fn, opts) {
      function run(resolve, reject) {
        var options = opts || {};
        var op;
        if (!("randomize" in options)) {
          options.randomize = true;
        }
        op = retrier.operation(options);
        function bail(err) {
          reject(err || new Error("Aborted"));
        }
        function onError(err, num) {
          if (err.bail) {
            bail(err);
            return;
          }
          if (!op.retry(err)) {
            reject(op.mainError());
          } else if (options.onRetry) {
            options.onRetry(err, num);
          }
        }
        function runAttempt(num) {
          var val;
          try {
            val = fn(bail, num);
          } catch (err) {
            onError(err, num);
            return;
          }
          Promise.resolve(val).then(resolve).catch(function catchIt(err) {
            onError(err, num);
          });
        }
        op.attempt(runAttempt);
      }
      return new Promise(run);
    }
    module2.exports = retry;
  }
});

// ../../../node_modules/@protobufjs/aspromise/index.js
var require_aspromise = __commonJS({
  "../../../node_modules/@protobufjs/aspromise/index.js"(exports2, module2) {
    "use strict";
    module2.exports = asPromise;
    function asPromise(fn, ctx) {
      var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
      while (index < arguments.length)
        params[offset++] = arguments[index++];
      return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err) {
          if (pending) {
            pending = false;
            if (err)
              reject(err);
            else {
              var params2 = new Array(arguments.length - 1), offset2 = 0;
              while (offset2 < params2.length)
                params2[offset2++] = arguments[offset2];
              resolve.apply(null, params2);
            }
          }
        };
        try {
          fn.apply(ctx || null, params);
        } catch (err) {
          if (pending) {
            pending = false;
            reject(err);
          }
        }
      });
    }
  }
});

// ../../../node_modules/@protobufjs/base64/index.js
var require_base64 = __commonJS({
  "../../../node_modules/@protobufjs/base64/index.js"(exports2) {
    "use strict";
    var base64 = exports2;
    base64.length = function length(string) {
      var p = string.length;
      if (!p)
        return 0;
      var n = 0;
      while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
      return Math.ceil(string.length * 3) / 4 - n;
    };
    var b64 = new Array(64);
    var s64 = new Array(123);
    for (i = 0; i < 64; )
      s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
    var i;
    base64.encode = function encode(buffer, start, end) {
      var parts = null, chunk = [];
      var i2 = 0, j = 0, t;
      while (start < end) {
        var b = buffer[start++];
        switch (j) {
          case 0:
            chunk[i2++] = b64[b >> 2];
            t = (b & 3) << 4;
            j = 1;
            break;
          case 1:
            chunk[i2++] = b64[t | b >> 4];
            t = (b & 15) << 2;
            j = 2;
            break;
          case 2:
            chunk[i2++] = b64[t | b >> 6];
            chunk[i2++] = b64[b & 63];
            j = 0;
            break;
        }
        if (i2 > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i2 = 0;
        }
      }
      if (j) {
        chunk[i2++] = b64[t];
        chunk[i2++] = 61;
        if (j === 1)
          chunk[i2++] = 61;
      }
      if (parts) {
        if (i2)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i2));
    };
    var invalidEncoding = "invalid encoding";
    base64.decode = function decode(string, buffer, offset) {
      var start = offset;
      var j = 0, t;
      for (var i2 = 0; i2 < string.length; ) {
        var c = string.charCodeAt(i2++);
        if (c === 61 && j > 1)
          break;
        if ((c = s64[c]) === void 0)
          throw Error(invalidEncoding);
        switch (j) {
          case 0:
            t = c;
            j = 1;
            break;
          case 1:
            buffer[offset++] = t << 2 | (c & 48) >> 4;
            t = c;
            j = 2;
            break;
          case 2:
            buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
            t = c;
            j = 3;
            break;
          case 3:
            buffer[offset++] = (t & 3) << 6 | c;
            j = 0;
            break;
        }
      }
      if (j === 1)
        throw Error(invalidEncoding);
      return offset - start;
    };
    base64.test = function test(string) {
      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
    };
  }
});

// ../../../node_modules/@protobufjs/eventemitter/index.js
var require_eventemitter = __commonJS({
  "../../../node_modules/@protobufjs/eventemitter/index.js"(exports2, module2) {
    "use strict";
    module2.exports = EventEmitter;
    function EventEmitter() {
      this._listeners = {};
    }
    EventEmitter.prototype.on = function on(evt, fn, ctx) {
      (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn,
        ctx: ctx || this
      });
      return this;
    };
    EventEmitter.prototype.off = function off(evt, fn) {
      if (evt === void 0)
        this._listeners = {};
      else {
        if (fn === void 0)
          this._listeners[evt] = [];
        else {
          var listeners = this._listeners[evt];
          for (var i = 0; i < listeners.length; )
            if (listeners[i].fn === fn)
              listeners.splice(i, 1);
            else
              ++i;
        }
      }
      return this;
    };
    EventEmitter.prototype.emit = function emit(evt) {
      var listeners = this._listeners[evt];
      if (listeners) {
        var args = [], i = 1;
        for (; i < arguments.length; )
          args.push(arguments[i++]);
        for (i = 0; i < listeners.length; )
          listeners[i].fn.apply(listeners[i++].ctx, args);
      }
      return this;
    };
  }
});

// ../../../node_modules/@protobufjs/float/index.js
var require_float = __commonJS({
  "../../../node_modules/@protobufjs/float/index.js"(exports2, module2) {
    "use strict";
    module2.exports = factory(factory);
    function factory(exports3) {
      if (typeof Float32Array !== "undefined")
        (function() {
          var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
          function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
          }
          function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
          }
          exports3.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
          exports3.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
          function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
          }
          function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
          }
          exports3.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
          exports3.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
        })();
      else
        (function() {
          function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
              val = -val;
            if (val === 0)
              writeUint(1 / val > 0 ? (
                /* positive */
                0
              ) : (
                /* negative 0 */
                2147483648
              ), buf, pos);
            else if (isNaN(val))
              writeUint(2143289344, buf, pos);
            else if (val > 34028234663852886e22)
              writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 11754943508222875e-54)
              writeUint((sign << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf, pos);
            else {
              var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
              writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
          }
          exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
          exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
          function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
            return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 1401298464324817e-60 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
          }
          exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
          exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
        })();
      if (typeof Float64Array !== "undefined")
        (function() {
          var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
          function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
          }
          function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
          }
          exports3.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
          exports3.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
          function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
          }
          function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
          }
          exports3.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
          exports3.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
        })();
      else
        (function() {
          function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
              val = -val;
            if (val === 0) {
              writeUint(0, buf, pos + off0);
              writeUint(1 / val > 0 ? (
                /* positive */
                0
              ) : (
                /* negative 0 */
                2147483648
              ), buf, pos + off1);
            } else if (isNaN(val)) {
              writeUint(0, buf, pos + off0);
              writeUint(2146959360, buf, pos + off1);
            } else if (val > 17976931348623157e292) {
              writeUint(0, buf, pos + off0);
              writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
              var mantissa;
              if (val < 22250738585072014e-324) {
                mantissa = val / 5e-324;
                writeUint(mantissa >>> 0, buf, pos + off0);
                writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
              } else {
                var exponent = Math.floor(Math.log(val) / Math.LN2);
                if (exponent === 1024)
                  exponent = 1023;
                mantissa = val * Math.pow(2, -exponent);
                writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
              }
            }
          }
          exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
          exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
          function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);
            var sign = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
          }
          exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
          exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
        })();
      return exports3;
    }
    function writeUintLE(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    function writeUintBE(val, buf, pos) {
      buf[pos] = val >>> 24;
      buf[pos + 1] = val >>> 16 & 255;
      buf[pos + 2] = val >>> 8 & 255;
      buf[pos + 3] = val & 255;
    }
    function readUintLE(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
    }
    function readUintBE(buf, pos) {
      return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
    }
  }
});

// ../../../node_modules/@protobufjs/inquire/index.js
var require_inquire = __commonJS({
  "../../../node_modules/@protobufjs/inquire/index.js"(exports, module) {
    "use strict";
    module.exports = inquire;
    function inquire(moduleName) {
      try {
        var mod = eval("quire".replace(/^/, "re"))(moduleName);
        if (mod && (mod.length || Object.keys(mod).length))
          return mod;
      } catch (e) {
      }
      return null;
    }
  }
});

// ../../../node_modules/@protobufjs/utf8/index.js
var require_utf8 = __commonJS({
  "../../../node_modules/@protobufjs/utf8/index.js"(exports2) {
    "use strict";
    var utf8 = exports2;
    utf8.length = function utf8_length(string) {
      var len = 0, c = 0;
      for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128)
          len += 1;
        else if (c < 2048)
          len += 2;
        else if ((c & 64512) === 55296 && (string.charCodeAt(i + 1) & 64512) === 56320) {
          ++i;
          len += 4;
        } else
          len += 3;
      }
      return len;
    };
    utf8.read = function utf8_read(buffer, start, end) {
      var len = end - start;
      if (len < 1)
        return "";
      var parts = null, chunk = [], i = 0, t;
      while (start < end) {
        t = buffer[start++];
        if (t < 128)
          chunk[i++] = t;
        else if (t > 191 && t < 224)
          chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
          t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 65536;
          chunk[i++] = 55296 + (t >> 10);
          chunk[i++] = 56320 + (t & 1023);
        } else
          chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i = 0;
        }
      }
      if (parts) {
        if (i)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i));
    };
    utf8.write = function utf8_write(string, buffer, offset) {
      var start = offset, c1, c2;
      for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
          buffer[offset++] = c1;
        } else if (c1 < 2048) {
          buffer[offset++] = c1 >> 6 | 192;
          buffer[offset++] = c1 & 63 | 128;
        } else if ((c1 & 64512) === 55296 && ((c2 = string.charCodeAt(i + 1)) & 64512) === 56320) {
          c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
          ++i;
          buffer[offset++] = c1 >> 18 | 240;
          buffer[offset++] = c1 >> 12 & 63 | 128;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        } else {
          buffer[offset++] = c1 >> 12 | 224;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        }
      }
      return offset - start;
    };
  }
});

// ../../../node_modules/@protobufjs/pool/index.js
var require_pool = __commonJS({
  "../../../node_modules/@protobufjs/pool/index.js"(exports2, module2) {
    "use strict";
    module2.exports = pool;
    function pool(alloc, slice, size) {
      var SIZE = size || 8192;
      var MAX = SIZE >>> 1;
      var slab = null;
      var offset = SIZE;
      return function pool_alloc(size2) {
        if (size2 < 1 || size2 > MAX)
          return alloc(size2);
        if (offset + size2 > SIZE) {
          slab = alloc(SIZE);
          offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size2);
        if (offset & 7)
          offset = (offset | 7) + 1;
        return buf;
      };
    }
  }
});

// ../../../node_modules/apollo-reporting-protobuf/node_modules/@apollo/protobufjs/src/util/longbits.js
var require_longbits = __commonJS({
  "../../../node_modules/apollo-reporting-protobuf/node_modules/@apollo/protobufjs/src/util/longbits.js"(exports2, module2) {
    "use strict";
    module2.exports = LongBits;
    var util = require_minimal();
    function LongBits(lo, hi) {
      this.lo = lo >>> 0;
      this.hi = hi >>> 0;
    }
    var zero = LongBits.zero = new LongBits(0, 0);
    zero.toNumber = function() {
      return 0;
    };
    zero.zzEncode = zero.zzDecode = function() {
      return this;
    };
    zero.length = function() {
      return 1;
    };
    var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
    LongBits.fromNumber = function fromNumber(value) {
      if (value === 0)
        return zero;
      var sign = value < 0;
      if (sign)
        value = -value;
      var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
      if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
          lo = 0;
          if (++hi > 4294967295)
            hi = 0;
        }
      }
      return new LongBits(lo, hi);
    };
    LongBits.from = function from(value) {
      if (typeof value === "number")
        return LongBits.fromNumber(value);
      if (util.isString(value)) {
        if (util.Long)
          value = util.Long.fromString(value);
        else
          return LongBits.fromNumber(parseInt(value, 10));
      }
      return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
    };
    LongBits.prototype.toNumber = function toNumber(unsigned) {
      if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
        if (!lo)
          hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
    };
    LongBits.prototype.toLong = function toLong(unsigned) {
      return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
    };
    var charCodeAt = String.prototype.charCodeAt;
    LongBits.fromHash = function fromHash(hash) {
      if (hash === zeroHash)
        return zero;
      return new LongBits(
        (charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0,
        (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0
      );
    };
    LongBits.prototype.toHash = function toHash() {
      return String.fromCharCode(
        this.lo & 255,
        this.lo >>> 8 & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24,
        this.hi & 255,
        this.hi >>> 8 & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
      );
    };
    LongBits.prototype.zzEncode = function zzEncode() {
      var mask = this.hi >> 31;
      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
      this.lo = (this.lo << 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.zzDecode = function zzDecode() {
      var mask = -(this.lo & 1);
      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
      this.hi = (this.hi >>> 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.length = function length() {
      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    };
  }
});

// ../../../node_modules/apollo-reporting-protobuf/node_modules/@apollo/protobufjs/src/util/minimal.js
var require_minimal = __commonJS({
  "../../../node_modules/apollo-reporting-protobuf/node_modules/@apollo/protobufjs/src/util/minimal.js"(exports2) {
    "use strict";
    var util = exports2;
    util.asPromise = require_aspromise();
    util.base64 = require_base64();
    util.EventEmitter = require_eventemitter();
    util.float = require_float();
    util.inquire = require_inquire();
    util.utf8 = require_utf8();
    util.pool = require_pool();
    util.LongBits = require_longbits();
    util.global = typeof window !== "undefined" && window || typeof global !== "undefined" && global || typeof self !== "undefined" && self || exports2;
    util.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    );
    util.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    );
    util.isNode = Boolean(util.global.process && util.global.process.versions && util.global.process.versions.node);
    util.isInteger = Number.isInteger || /* istanbul ignore next */
    function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    };
    util.isString = function isString(value) {
      return typeof value === "string" || value instanceof String;
    };
    util.isObject = function isObject(value) {
      return value && typeof value === "object";
    };
    util.isset = /**
     * Checks if a property on a message is considered to be present.
     * @param {Object} obj Plain object or message instance
     * @param {string} prop Property name
     * @returns {boolean} `true` if considered to be present, otherwise `false`
     */
    util.isSet = function isSet(obj, prop) {
      var value = obj[prop];
      if (value != null && obj.hasOwnProperty(prop))
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
      return false;
    };
    util.Buffer = function() {
      try {
        var Buffer2 = util.inquire("buffer").Buffer;
        return Buffer2.prototype.utf8Write ? Buffer2 : (
          /* istanbul ignore next */
          null
        );
      } catch (e) {
        return null;
      }
    }();
    util._Buffer_from = null;
    util._Buffer_allocUnsafe = null;
    util.newBuffer = function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    };
    util.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util.Long = typeof process === "undefined" || process.env.ENABLE_LONG ? (
      /* istanbul ignore next */
      util.global.dcodeIO && /* istanbul ignore next */
      util.global.dcodeIO.Long || /* istanbul ignore next */
      util.global.Long || util.inquire("long")
    ) : void 0;
    util.key2Re = /^true|false|0|1$/;
    util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util.longToHash = function longToHash(value) {
      return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
    };
    util.longFromHash = function longFromHash(hash, unsigned) {
      var bits = util.LongBits.fromHash(hash);
      if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
      return bits.toNumber(Boolean(unsigned));
    };
    function merge(dst, src, ifNotSet) {
      for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === void 0 || !ifNotSet)
          dst[keys[i]] = src[keys[i]];
      return dst;
    }
    util.merge = merge;
    util.lcFirst = function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    };
    function newError(name) {
      function CustomError(message, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message, properties);
        Object.defineProperty(this, "message", { get: function() {
          return message;
        } });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge(this, properties);
      }
      (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;
      Object.defineProperty(CustomError.prototype, "name", { get: function() {
        return name;
      } });
      CustomError.prototype.toString = function toString() {
        return this.name + ": " + this.message;
      };
      return CustomError;
    }
    util.newError = newError;
    util.ProtocolError = newError("ProtocolError");
    util.oneOfGetter = function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;
      return function() {
        for (var keys = Object.keys(this), i2 = keys.length - 1; i2 > -1; --i2)
          if (fieldMap[keys[i2]] === 1 && this[keys[i2]] !== void 0 && this[keys[i2]] !== null)
            return keys[i2];
      };
    };
    util.oneOfSetter = function setOneOf(fieldNames) {
      return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
          if (fieldNames[i] !== name)
            delete this[fieldNames[i]];
      };
    };
    util.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util._configure = function() {
      var Buffer2 = util.Buffer;
      if (!Buffer2) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
      }
      util._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || /* istanbul ignore next */
      function Buffer_from(value, encoding) {
        return new Buffer2(value, encoding);
      };
      util._Buffer_allocUnsafe = Buffer2.allocUnsafe || /* istanbul ignore next */
      function Buffer_allocUnsafe(size) {
        return new Buffer2(size);
      };
    };
  }
});

// ../../../node_modules/apollo-reporting-protobuf/node_modules/@apollo/protobufjs/src/writer.js
var require_writer = __commonJS({
  "../../../node_modules/apollo-reporting-protobuf/node_modules/@apollo/protobufjs/src/writer.js"(exports2, module2) {
    "use strict";
    module2.exports = Writer;
    var util = require_minimal();
    var BufferWriter;
    var LongBits = util.LongBits;
    var base64 = util.base64;
    var utf8 = util.utf8;
    function Op(fn, len, val) {
      this.fn = fn;
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    function noop() {
    }
    function State(writer) {
      this.head = writer.head;
      this.tail = writer.tail;
      this.len = writer.len;
      this.next = writer.states;
    }
    function Writer() {
      this.len = 0;
      this.head = new Op(noop, 0, 0);
      this.tail = this.head;
      this.states = null;
    }
    Writer.create = util.Buffer ? function create_buffer_setup() {
      return (Writer.create = function create_buffer() {
        return new BufferWriter();
      })();
    } : function create_array() {
      return new Writer();
    };
    Writer.alloc = function alloc(size) {
      return new util.Array(size);
    };
    if (util.Array !== Array)
      Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);
    Writer.prototype._push = function push(fn, len, val) {
      this.tail = this.tail.next = new Op(fn, len, val);
      this.len += len;
      return this;
    };
    function writeByte(val, buf, pos) {
      buf[pos] = val & 255;
    }
    function writeVarint32(val, buf, pos) {
      while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
      }
      buf[pos] = val;
    }
    function VarintOp(len, val) {
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    VarintOp.prototype = Object.create(Op.prototype);
    VarintOp.prototype.fn = writeVarint32;
    Writer.prototype.uint32 = function write_uint32(value) {
      this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,
        value
      )).len;
      return this;
    };
    Writer.prototype.int32 = function write_int32(value) {
      return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
    };
    Writer.prototype.sint32 = function write_sint32(value) {
      return this.uint32((value << 1 ^ value >> 31) >>> 0);
    };
    function writeVarint64(val, buf, pos) {
      while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
      }
      while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
      }
      buf[pos++] = val.lo;
    }
    Writer.prototype.uint64 = function write_uint64(value) {
      var bits = LongBits.from(value);
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.int64 = Writer.prototype.uint64;
    Writer.prototype.sint64 = function write_sint64(value) {
      var bits = LongBits.from(value).zzEncode();
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.bool = function write_bool(value) {
      return this._push(writeByte, 1, value ? 1 : 0);
    };
    function writeFixed32(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    Writer.prototype.fixed32 = function write_fixed32(value) {
      return this._push(writeFixed32, 4, value >>> 0);
    };
    Writer.prototype.sfixed32 = Writer.prototype.fixed32;
    Writer.prototype.fixed64 = function write_fixed64(value) {
      var bits = LongBits.from(value);
      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
    };
    Writer.prototype.sfixed64 = Writer.prototype.fixed64;
    Writer.prototype.float = function write_float(value) {
      return this._push(util.float.writeFloatLE, 4, value);
    };
    Writer.prototype.double = function write_double(value) {
      return this._push(util.float.writeDoubleLE, 8, value);
    };
    var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
      buf.set(val, pos);
    } : function writeBytes_for(val, buf, pos) {
      for (var i = 0; i < val.length; ++i)
        buf[pos + i] = val[i];
    };
    Writer.prototype.bytes = function write_bytes(value) {
      var len = value.length >>> 0;
      if (!len)
        return this._push(writeByte, 1, 0);
      if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
      }
      return this.uint32(len)._push(writeBytes, len, value);
    };
    Writer.prototype.string = function write_string(value) {
      var len = utf8.length(value);
      return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
    };
    Writer.prototype.fork = function fork() {
      this.states = new State(this);
      this.head = this.tail = new Op(noop, 0, 0);
      this.len = 0;
      return this;
    };
    Writer.prototype.reset = function reset() {
      if (this.states) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
      } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len = 0;
      }
      return this;
    };
    Writer.prototype.ldelim = function ldelim() {
      var head = this.head, tail = this.tail, len = this.len;
      this.reset().uint32(len);
      if (len) {
        this.tail.next = head.next;
        this.tail = tail;
        this.len += len;
      }
      return this;
    };
    Writer.prototype.finish = function finish() {
      var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
      while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
      }
      return buf;
    };
    Writer._configure = function(BufferWriter_) {
      BufferWriter = BufferWriter_;
    };
  }
});

// ../../../node_modules/apollo-reporting-protobuf/node_modules/@apollo/protobufjs/src/writer_buffer.js
var require_writer_buffer = __commonJS({
  "../../../node_modules/apollo-reporting-protobuf/node_modules/@apollo/protobufjs/src/writer_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferWriter;
    var Writer = require_writer();
    (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
    var util = require_minimal();
    var Buffer2 = util.Buffer;
    function BufferWriter() {
      Writer.call(this);
    }
    BufferWriter.alloc = function alloc_buffer(size) {
      return (BufferWriter.alloc = util._Buffer_allocUnsafe)(size);
    };
    var writeBytesBuffer = Buffer2 && Buffer2.prototype instanceof Uint8Array && Buffer2.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
      buf.set(val, pos);
    } : function writeBytesBuffer_copy(val, buf, pos) {
      if (val.copy)
        val.copy(buf, pos, 0, val.length);
      else
        for (var i = 0; i < val.length; )
          buf[pos++] = val[i++];
    };
    BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
      if (util.isString(value))
        value = util._Buffer_from(value, "base64");
      var len = value.length >>> 0;
      this.uint32(len);
      if (len)
        this._push(writeBytesBuffer, len, value);
      return this;
    };
    function writeStringBuffer(val, buf, pos) {
      if (val.length < 40)
        util.utf8.write(val, buf, pos);
      else
        buf.utf8Write(val, pos);
    }
    BufferWriter.prototype.string = function write_string_buffer(value) {
      var len = Buffer2.byteLength(value);
      this.uint32(len);
      if (len)
        this._push(writeStringBuffer, len, value);
      return this;
    };
  }
});

// ../../../node_modules/apollo-reporting-protobuf/node_modules/@apollo/protobufjs/src/reader.js
var require_reader = __commonJS({
  "../../../node_modules/apollo-reporting-protobuf/node_modules/@apollo/protobufjs/src/reader.js"(exports2, module2) {
    "use strict";
    module2.exports = Reader;
    var util = require_minimal();
    var BufferReader;
    var LongBits = util.LongBits;
    var utf8 = util.utf8;
    function indexOutOfRange(reader, writeLength) {
      return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
    }
    function Reader(buffer) {
      this.buf = buffer;
      this.pos = 0;
      this.len = buffer.length;
    }
    var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer) {
      if (buffer instanceof Uint8Array || Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    } : function create_array2(buffer) {
      if (Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    };
    Reader.create = util.Buffer ? function create_buffer_setup(buffer) {
      return (Reader.create = function create_buffer(buffer2) {
        return util.Buffer.isBuffer(buffer2) ? new BufferReader(buffer2) : create_array(buffer2);
      })(buffer);
    } : create_array;
    Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */
    util.Array.prototype.slice;
    Reader.prototype.uint32 = /* @__PURE__ */ function read_uint32_setup() {
      var value = 4294967295;
      return function read_uint32() {
        value = (this.buf[this.pos] & 127) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        if ((this.pos += 5) > this.len) {
          this.pos = this.len;
          throw indexOutOfRange(this, 10);
        }
        return value;
      };
    }();
    Reader.prototype.int32 = function read_int32() {
      return this.uint32() | 0;
    };
    Reader.prototype.sint32 = function read_sint32() {
      var value = this.uint32();
      return value >>> 1 ^ -(value & 1) | 0;
    };
    function readLongVarint() {
      var bits = new LongBits(0, 0);
      var i = 0;
      if (this.len - this.pos > 4) {
        for (; i < 4; ++i) {
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
        i = 0;
      } else {
        for (; i < 3; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
      }
      if (this.len - this.pos > 4) {
        for (; i < 5; ++i) {
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      } else {
        for (; i < 5; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      }
      throw Error("invalid varint encoding");
    }
    Reader.prototype.bool = function read_bool() {
      return this.uint32() !== 0;
    };
    function readFixed32_end(buf, end) {
      return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
    }
    Reader.prototype.fixed32 = function read_fixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4);
    };
    Reader.prototype.sfixed32 = function read_sfixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4) | 0;
    };
    function readFixed64() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);
      return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
    }
    Reader.prototype.float = function read_float() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readFloatLE(this.buf, this.pos);
      this.pos += 4;
      return value;
    };
    Reader.prototype.double = function read_double() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readDoubleLE(this.buf, this.pos);
      this.pos += 8;
      return value;
    };
    Reader.prototype.bytes = function read_bytes() {
      var length = this.uint32(), start = this.pos, end = this.pos + length;
      if (end > this.len)
        throw indexOutOfRange(this, length);
      this.pos += length;
      if (Array.isArray(this.buf))
        return this.buf.slice(start, end);
      return start === end ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end);
    };
    Reader.prototype.string = function read_string() {
      var bytes = this.bytes();
      return utf8.read(bytes, 0, bytes.length);
    };
    Reader.prototype.skip = function skip(length) {
      if (typeof length === "number") {
        if (this.pos + length > this.len)
          throw indexOutOfRange(this, length);
        this.pos += length;
      } else {
        do {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
      }
      return this;
    };
    Reader.prototype.skipType = function(wireType) {
      switch (wireType) {
        case 0:
          this.skip();
          break;
        case 1:
          this.skip(8);
          break;
        case 2:
          this.skip(this.uint32());
          break;
        case 3:
          while ((wireType = this.uint32() & 7) !== 4) {
            this.skipType(wireType);
          }
          break;
        case 5:
          this.skip(4);
          break;
        default:
          throw Error("invalid wire type " + wireType + " at offset " + this.pos);
      }
      return this;
    };
    Reader._configure = function(BufferReader_) {
      BufferReader = BufferReader_;
      var fn = util.Long ? "toLong" : (
        /* istanbul ignore next */
        "toNumber"
      );
      util.merge(Reader.prototype, {
        int64: function read_int64() {
          return readLongVarint.call(this)[fn](false);
        },
        uint64: function read_uint64() {
          return readLongVarint.call(this)[fn](true);
        },
        sint64: function read_sint64() {
          return readLongVarint.call(this).zzDecode()[fn](false);
        },
        fixed64: function read_fixed64() {
          return readFixed64.call(this)[fn](true);
        },
        sfixed64: function read_sfixed64() {
          return readFixed64.call(this)[fn](false);
        }
      });
    };
  }
});

// ../../../node_modules/apollo-reporting-protobuf/node_modules/@apollo/protobufjs/src/reader_buffer.js
var require_reader_buffer = __commonJS({
  "../../../node_modules/apollo-reporting-protobuf/node_modules/@apollo/protobufjs/src/reader_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferReader;
    var Reader = require_reader();
    (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
    var util = require_minimal();
    function BufferReader(buffer) {
      Reader.call(this, buffer);
    }
    if (util.Buffer)
      BufferReader.prototype._slice = util.Buffer.prototype.slice;
    BufferReader.prototype.string = function read_string_buffer() {
      var len = this.uint32();
      return this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len));
    };
  }
});

// ../../../node_modules/apollo-reporting-protobuf/node_modules/@apollo/protobufjs/src/rpc/service.js
var require_service = __commonJS({
  "../../../node_modules/apollo-reporting-protobuf/node_modules/@apollo/protobufjs/src/rpc/service.js"(exports2, module2) {
    "use strict";
    module2.exports = Service;
    var util = require_minimal();
    (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
    function Service(rpcImpl, requestDelimited, responseDelimited) {
      if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");
      util.EventEmitter.call(this);
      this.rpcImpl = rpcImpl;
      this.requestDelimited = Boolean(requestDelimited);
      this.responseDelimited = Boolean(responseDelimited);
    }
    Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
      if (!request)
        throw TypeError("request must be specified");
      var self2 = this;
      if (!callback)
        return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
      if (!self2.rpcImpl) {
        setTimeout(function() {
          callback(Error("already ended"));
        }, 0);
        return void 0;
      }
      try {
        return self2.rpcImpl(
          method,
          requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
          function rpcCallback(err, response) {
            if (err) {
              self2.emit("error", err, method);
              return callback(err);
            }
            if (response === null) {
              self2.end(
                /* endedByRPC */
                true
              );
              return void 0;
            }
            if (!(response instanceof responseCtor)) {
              try {
                response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
              } catch (err2) {
                self2.emit("error", err2, method);
                return callback(err2);
              }
            }
            self2.emit("data", response, method);
            return callback(null, response);
          }
        );
      } catch (err) {
        self2.emit("error", err, method);
        setTimeout(function() {
          callback(err);
        }, 0);
        return void 0;
      }
    };
    Service.prototype.end = function end(endedByRPC) {
      if (this.rpcImpl) {
        if (!endedByRPC)
          this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
      }
      return this;
    };
  }
});

// ../../../node_modules/apollo-reporting-protobuf/node_modules/@apollo/protobufjs/src/rpc.js
var require_rpc = __commonJS({
  "../../../node_modules/apollo-reporting-protobuf/node_modules/@apollo/protobufjs/src/rpc.js"(exports2) {
    "use strict";
    var rpc = exports2;
    rpc.Service = require_service();
  }
});

// ../../../node_modules/apollo-reporting-protobuf/node_modules/@apollo/protobufjs/src/roots.js
var require_roots = __commonJS({
  "../../../node_modules/apollo-reporting-protobuf/node_modules/@apollo/protobufjs/src/roots.js"(exports2, module2) {
    "use strict";
    module2.exports = {};
  }
});

// ../../../node_modules/apollo-reporting-protobuf/node_modules/@apollo/protobufjs/src/index-minimal.js
var require_index_minimal = __commonJS({
  "../../../node_modules/apollo-reporting-protobuf/node_modules/@apollo/protobufjs/src/index-minimal.js"(exports2) {
    "use strict";
    var protobuf = exports2;
    protobuf.build = "minimal";
    protobuf.Writer = require_writer();
    protobuf.BufferWriter = require_writer_buffer();
    protobuf.Reader = require_reader();
    protobuf.BufferReader = require_reader_buffer();
    protobuf.util = require_minimal();
    protobuf.rpc = require_rpc();
    protobuf.roots = require_roots();
    protobuf.configure = configure;
    function configure() {
      protobuf.Reader._configure(protobuf.BufferReader);
      protobuf.util._configure();
    }
    protobuf.Writer._configure(protobuf.BufferWriter);
    configure();
  }
});

// ../../../node_modules/apollo-reporting-protobuf/node_modules/@apollo/protobufjs/minimal.js
var require_minimal2 = __commonJS({
  "../../../node_modules/apollo-reporting-protobuf/node_modules/@apollo/protobufjs/minimal.js"(exports2, module2) {
    "use strict";
    module2.exports = require_index_minimal();
  }
});

// ../../../node_modules/apollo-reporting-protobuf/generated/protobuf.js
var require_protobuf = __commonJS({
  "../../../node_modules/apollo-reporting-protobuf/generated/protobuf.js"(exports2, module2) {
    "use strict";
    var $protobuf = require_minimal2();
    var $Reader = $protobuf.Reader;
    var $Writer = $protobuf.Writer;
    var $util = $protobuf.util;
    var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
    $root.Trace = function() {
      function Trace(properties) {
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      Trace.prototype.startTime = null;
      Trace.prototype.endTime = null;
      Trace.prototype.durationNs = 0;
      Trace.prototype.root = null;
      Trace.prototype.isIncomplete = false;
      Trace.prototype.signature = "";
      Trace.prototype.unexecutedOperationBody = "";
      Trace.prototype.unexecutedOperationName = "";
      Trace.prototype.details = null;
      Trace.prototype.clientName = "";
      Trace.prototype.clientVersion = "";
      Trace.prototype.http = null;
      Trace.prototype.cachePolicy = null;
      Trace.prototype.queryPlan = null;
      Trace.prototype.fullQueryCacheHit = false;
      Trace.prototype.persistedQueryHit = false;
      Trace.prototype.persistedQueryRegister = false;
      Trace.prototype.registeredOperation = false;
      Trace.prototype.forbiddenOperation = false;
      Trace.prototype.fieldExecutionWeight = 0;
      Trace.create = function create(properties) {
        return new Trace(properties);
      };
      Trace.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.endTime != null && Object.hasOwnProperty.call(message, "endTime"))
          $root.google.protobuf.Timestamp.encode(message.endTime, writer.uint32(
            /* id 3, wireType 2 =*/
            26
          ).fork()).ldelim();
        if (message.startTime != null && Object.hasOwnProperty.call(message, "startTime"))
          $root.google.protobuf.Timestamp.encode(message.startTime, writer.uint32(
            /* id 4, wireType 2 =*/
            34
          ).fork()).ldelim();
        if (message.details != null && Object.hasOwnProperty.call(message, "details"))
          $root.Trace.Details.encode(message.details, writer.uint32(
            /* id 6, wireType 2 =*/
            50
          ).fork()).ldelim();
        if (message.clientName != null && Object.hasOwnProperty.call(message, "clientName"))
          writer.uint32(
            /* id 7, wireType 2 =*/
            58
          ).string(message.clientName);
        if (message.clientVersion != null && Object.hasOwnProperty.call(message, "clientVersion"))
          writer.uint32(
            /* id 8, wireType 2 =*/
            66
          ).string(message.clientVersion);
        if (message.http != null && Object.hasOwnProperty.call(message, "http"))
          $root.Trace.HTTP.encode(message.http, writer.uint32(
            /* id 10, wireType 2 =*/
            82
          ).fork()).ldelim();
        if (message.durationNs != null && Object.hasOwnProperty.call(message, "durationNs"))
          writer.uint32(
            /* id 11, wireType 0 =*/
            88
          ).uint64(message.durationNs);
        if (message.root != null && Object.hasOwnProperty.call(message, "root"))
          $root.Trace.Node.encode(message.root, writer.uint32(
            /* id 14, wireType 2 =*/
            114
          ).fork()).ldelim();
        if (message.cachePolicy != null && Object.hasOwnProperty.call(message, "cachePolicy"))
          $root.Trace.CachePolicy.encode(message.cachePolicy, writer.uint32(
            /* id 18, wireType 2 =*/
            146
          ).fork()).ldelim();
        if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
          writer.uint32(
            /* id 19, wireType 2 =*/
            154
          ).string(message.signature);
        if (message.fullQueryCacheHit != null && Object.hasOwnProperty.call(message, "fullQueryCacheHit"))
          writer.uint32(
            /* id 20, wireType 0 =*/
            160
          ).bool(message.fullQueryCacheHit);
        if (message.persistedQueryHit != null && Object.hasOwnProperty.call(message, "persistedQueryHit"))
          writer.uint32(
            /* id 21, wireType 0 =*/
            168
          ).bool(message.persistedQueryHit);
        if (message.persistedQueryRegister != null && Object.hasOwnProperty.call(message, "persistedQueryRegister"))
          writer.uint32(
            /* id 22, wireType 0 =*/
            176
          ).bool(message.persistedQueryRegister);
        if (message.registeredOperation != null && Object.hasOwnProperty.call(message, "registeredOperation"))
          writer.uint32(
            /* id 24, wireType 0 =*/
            192
          ).bool(message.registeredOperation);
        if (message.forbiddenOperation != null && Object.hasOwnProperty.call(message, "forbiddenOperation"))
          writer.uint32(
            /* id 25, wireType 0 =*/
            200
          ).bool(message.forbiddenOperation);
        if (message.queryPlan != null && Object.hasOwnProperty.call(message, "queryPlan"))
          $root.Trace.QueryPlanNode.encode(message.queryPlan, writer.uint32(
            /* id 26, wireType 2 =*/
            210
          ).fork()).ldelim();
        if (message.unexecutedOperationBody != null && Object.hasOwnProperty.call(message, "unexecutedOperationBody"))
          writer.uint32(
            /* id 27, wireType 2 =*/
            218
          ).string(message.unexecutedOperationBody);
        if (message.unexecutedOperationName != null && Object.hasOwnProperty.call(message, "unexecutedOperationName"))
          writer.uint32(
            /* id 28, wireType 2 =*/
            226
          ).string(message.unexecutedOperationName);
        if (message.fieldExecutionWeight != null && Object.hasOwnProperty.call(message, "fieldExecutionWeight"))
          writer.uint32(
            /* id 31, wireType 1 =*/
            249
          ).double(message.fieldExecutionWeight);
        if (message.isIncomplete != null && Object.hasOwnProperty.call(message, "isIncomplete"))
          writer.uint32(
            /* id 33, wireType 0 =*/
            264
          ).bool(message.isIncomplete);
        return writer;
      };
      Trace.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };
      Trace.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace();
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 4:
              message.startTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
              break;
            case 3:
              message.endTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
              break;
            case 11:
              message.durationNs = reader.uint64();
              break;
            case 14:
              message.root = $root.Trace.Node.decode(reader, reader.uint32());
              break;
            case 33:
              message.isIncomplete = reader.bool();
              break;
            case 19:
              message.signature = reader.string();
              break;
            case 27:
              message.unexecutedOperationBody = reader.string();
              break;
            case 28:
              message.unexecutedOperationName = reader.string();
              break;
            case 6:
              message.details = $root.Trace.Details.decode(reader, reader.uint32());
              break;
            case 7:
              message.clientName = reader.string();
              break;
            case 8:
              message.clientVersion = reader.string();
              break;
            case 10:
              message.http = $root.Trace.HTTP.decode(reader, reader.uint32());
              break;
            case 18:
              message.cachePolicy = $root.Trace.CachePolicy.decode(reader, reader.uint32());
              break;
            case 26:
              message.queryPlan = $root.Trace.QueryPlanNode.decode(reader, reader.uint32());
              break;
            case 20:
              message.fullQueryCacheHit = reader.bool();
              break;
            case 21:
              message.persistedQueryHit = reader.bool();
              break;
            case 22:
              message.persistedQueryRegister = reader.bool();
              break;
            case 24:
              message.registeredOperation = reader.bool();
              break;
            case 25:
              message.forbiddenOperation = reader.bool();
              break;
            case 31:
              message.fieldExecutionWeight = reader.double();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };
      Trace.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      Trace.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.startTime != null && message.hasOwnProperty("startTime")) {
          var error = $root.google.protobuf.Timestamp.verify(message.startTime);
          if (error)
            return "startTime." + error;
        }
        if (message.endTime != null && message.hasOwnProperty("endTime")) {
          var error = $root.google.protobuf.Timestamp.verify(message.endTime);
          if (error)
            return "endTime." + error;
        }
        if (message.durationNs != null && message.hasOwnProperty("durationNs")) {
          if (!$util.isInteger(message.durationNs) && !(message.durationNs && $util.isInteger(message.durationNs.low) && $util.isInteger(message.durationNs.high)))
            return "durationNs: integer|Long expected";
        }
        if (message.root != null && message.hasOwnProperty("root")) {
          var error = $root.Trace.Node.verify(message.root);
          if (error)
            return "root." + error;
        }
        if (message.isIncomplete != null && message.hasOwnProperty("isIncomplete")) {
          if (typeof message.isIncomplete !== "boolean")
            return "isIncomplete: boolean expected";
        }
        if (message.signature != null && message.hasOwnProperty("signature")) {
          if (!$util.isString(message.signature))
            return "signature: string expected";
        }
        if (message.unexecutedOperationBody != null && message.hasOwnProperty("unexecutedOperationBody")) {
          if (!$util.isString(message.unexecutedOperationBody))
            return "unexecutedOperationBody: string expected";
        }
        if (message.unexecutedOperationName != null && message.hasOwnProperty("unexecutedOperationName")) {
          if (!$util.isString(message.unexecutedOperationName))
            return "unexecutedOperationName: string expected";
        }
        if (message.details != null && message.hasOwnProperty("details")) {
          var error = $root.Trace.Details.verify(message.details);
          if (error)
            return "details." + error;
        }
        if (message.clientName != null && message.hasOwnProperty("clientName")) {
          if (!$util.isString(message.clientName))
            return "clientName: string expected";
        }
        if (message.clientVersion != null && message.hasOwnProperty("clientVersion")) {
          if (!$util.isString(message.clientVersion))
            return "clientVersion: string expected";
        }
        if (message.http != null && message.hasOwnProperty("http")) {
          var error = $root.Trace.HTTP.verify(message.http);
          if (error)
            return "http." + error;
        }
        if (message.cachePolicy != null && message.hasOwnProperty("cachePolicy")) {
          var error = $root.Trace.CachePolicy.verify(message.cachePolicy);
          if (error)
            return "cachePolicy." + error;
        }
        if (message.queryPlan != null && message.hasOwnProperty("queryPlan")) {
          var error = $root.Trace.QueryPlanNode.verify(message.queryPlan);
          if (error)
            return "queryPlan." + error;
        }
        if (message.fullQueryCacheHit != null && message.hasOwnProperty("fullQueryCacheHit")) {
          if (typeof message.fullQueryCacheHit !== "boolean")
            return "fullQueryCacheHit: boolean expected";
        }
        if (message.persistedQueryHit != null && message.hasOwnProperty("persistedQueryHit")) {
          if (typeof message.persistedQueryHit !== "boolean")
            return "persistedQueryHit: boolean expected";
        }
        if (message.persistedQueryRegister != null && message.hasOwnProperty("persistedQueryRegister")) {
          if (typeof message.persistedQueryRegister !== "boolean")
            return "persistedQueryRegister: boolean expected";
        }
        if (message.registeredOperation != null && message.hasOwnProperty("registeredOperation")) {
          if (typeof message.registeredOperation !== "boolean")
            return "registeredOperation: boolean expected";
        }
        if (message.forbiddenOperation != null && message.hasOwnProperty("forbiddenOperation")) {
          if (typeof message.forbiddenOperation !== "boolean")
            return "forbiddenOperation: boolean expected";
        }
        if (message.fieldExecutionWeight != null && message.hasOwnProperty("fieldExecutionWeight")) {
          if (typeof message.fieldExecutionWeight !== "number")
            return "fieldExecutionWeight: number expected";
        }
        return null;
      };
      Trace.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.defaults) {
          object.endTime = null;
          object.startTime = null;
          object.details = null;
          object.clientName = "";
          object.clientVersion = "";
          object.http = null;
          object.durationNs = 0;
          object.root = null;
          object.cachePolicy = null;
          object.signature = "";
          object.fullQueryCacheHit = false;
          object.persistedQueryHit = false;
          object.persistedQueryRegister = false;
          object.registeredOperation = false;
          object.forbiddenOperation = false;
          object.queryPlan = null;
          object.unexecutedOperationBody = "";
          object.unexecutedOperationName = "";
          object.fieldExecutionWeight = 0;
          object.isIncomplete = false;
        }
        if (message.endTime != null && message.hasOwnProperty("endTime"))
          object.endTime = $root.google.protobuf.Timestamp.toObject(message.endTime, options);
        if (message.startTime != null && message.hasOwnProperty("startTime"))
          object.startTime = $root.google.protobuf.Timestamp.toObject(message.startTime, options);
        if (message.details != null && message.hasOwnProperty("details"))
          object.details = $root.Trace.Details.toObject(message.details, options);
        if (message.clientName != null && message.hasOwnProperty("clientName"))
          object.clientName = message.clientName;
        if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
          object.clientVersion = message.clientVersion;
        if (message.http != null && message.hasOwnProperty("http"))
          object.http = $root.Trace.HTTP.toObject(message.http, options);
        if (message.durationNs != null && message.hasOwnProperty("durationNs"))
          if (typeof message.durationNs === "number")
            object.durationNs = options.longs === String ? String(message.durationNs) : message.durationNs;
          else
            object.durationNs = options.longs === String ? $util.Long.prototype.toString.call(message.durationNs) : options.longs === Number ? new $util.LongBits(message.durationNs.low >>> 0, message.durationNs.high >>> 0).toNumber(true) : message.durationNs;
        if (message.root != null && message.hasOwnProperty("root"))
          object.root = $root.Trace.Node.toObject(message.root, options);
        if (message.cachePolicy != null && message.hasOwnProperty("cachePolicy"))
          object.cachePolicy = $root.Trace.CachePolicy.toObject(message.cachePolicy, options);
        if (message.signature != null && message.hasOwnProperty("signature"))
          object.signature = message.signature;
        if (message.fullQueryCacheHit != null && message.hasOwnProperty("fullQueryCacheHit"))
          object.fullQueryCacheHit = message.fullQueryCacheHit;
        if (message.persistedQueryHit != null && message.hasOwnProperty("persistedQueryHit"))
          object.persistedQueryHit = message.persistedQueryHit;
        if (message.persistedQueryRegister != null && message.hasOwnProperty("persistedQueryRegister"))
          object.persistedQueryRegister = message.persistedQueryRegister;
        if (message.registeredOperation != null && message.hasOwnProperty("registeredOperation"))
          object.registeredOperation = message.registeredOperation;
        if (message.forbiddenOperation != null && message.hasOwnProperty("forbiddenOperation"))
          object.forbiddenOperation = message.forbiddenOperation;
        if (message.queryPlan != null && message.hasOwnProperty("queryPlan"))
          object.queryPlan = $root.Trace.QueryPlanNode.toObject(message.queryPlan, options);
        if (message.unexecutedOperationBody != null && message.hasOwnProperty("unexecutedOperationBody"))
          object.unexecutedOperationBody = message.unexecutedOperationBody;
        if (message.unexecutedOperationName != null && message.hasOwnProperty("unexecutedOperationName"))
          object.unexecutedOperationName = message.unexecutedOperationName;
        if (message.fieldExecutionWeight != null && message.hasOwnProperty("fieldExecutionWeight"))
          object.fieldExecutionWeight = options.json && !isFinite(message.fieldExecutionWeight) ? String(message.fieldExecutionWeight) : message.fieldExecutionWeight;
        if (message.isIncomplete != null && message.hasOwnProperty("isIncomplete"))
          object.isIncomplete = message.isIncomplete;
        return object;
      };
      Trace.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      Trace.CachePolicy = function() {
        function CachePolicy(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        CachePolicy.prototype.scope = 0;
        CachePolicy.prototype.maxAgeNs = 0;
        CachePolicy.create = function create(properties) {
          return new CachePolicy(properties);
        };
        CachePolicy.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.scope != null && Object.hasOwnProperty.call(message, "scope"))
            writer.uint32(
              /* id 1, wireType 0 =*/
              8
            ).int32(message.scope);
          if (message.maxAgeNs != null && Object.hasOwnProperty.call(message, "maxAgeNs"))
            writer.uint32(
              /* id 2, wireType 0 =*/
              16
            ).int64(message.maxAgeNs);
          return writer;
        };
        CachePolicy.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        CachePolicy.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.CachePolicy();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.scope = reader.int32();
                break;
              case 2:
                message.maxAgeNs = reader.int64();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        CachePolicy.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        CachePolicy.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.scope != null && message.hasOwnProperty("scope"))
            switch (message.scope) {
              default:
                return "scope: enum value expected";
              case 0:
              case 1:
              case 2:
                break;
            }
          if (message.maxAgeNs != null && message.hasOwnProperty("maxAgeNs")) {
            if (!$util.isInteger(message.maxAgeNs) && !(message.maxAgeNs && $util.isInteger(message.maxAgeNs.low) && $util.isInteger(message.maxAgeNs.high)))
              return "maxAgeNs: integer|Long expected";
          }
          return null;
        };
        CachePolicy.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.defaults) {
            object.scope = options.enums === String ? "UNKNOWN" : 0;
            object.maxAgeNs = 0;
          }
          if (message.scope != null && message.hasOwnProperty("scope"))
            object.scope = options.enums === String ? $root.Trace.CachePolicy.Scope[message.scope] : message.scope;
          if (message.maxAgeNs != null && message.hasOwnProperty("maxAgeNs"))
            if (typeof message.maxAgeNs === "number")
              object.maxAgeNs = options.longs === String ? String(message.maxAgeNs) : message.maxAgeNs;
            else
              object.maxAgeNs = options.longs === String ? $util.Long.prototype.toString.call(message.maxAgeNs) : options.longs === Number ? new $util.LongBits(message.maxAgeNs.low >>> 0, message.maxAgeNs.high >>> 0).toNumber() : message.maxAgeNs;
          return object;
        };
        CachePolicy.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        CachePolicy.Scope = function() {
          var valuesById = {}, values = Object.create(valuesById);
          values[valuesById[0] = "UNKNOWN"] = 0;
          values[valuesById[1] = "PUBLIC"] = 1;
          values[valuesById[2] = "PRIVATE"] = 2;
          return values;
        }();
        return CachePolicy;
      }();
      Trace.Details = function() {
        function Details(properties) {
          this.variablesJson = {};
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        Details.prototype.variablesJson = $util.emptyObject;
        Details.prototype.operationName = "";
        Details.create = function create(properties) {
          return new Details(properties);
        };
        Details.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.operationName != null && Object.hasOwnProperty.call(message, "operationName"))
            writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).string(message.operationName);
          if (message.variablesJson != null && Object.hasOwnProperty.call(message, "variablesJson"))
            for (var keys = Object.keys(message.variablesJson), i = 0; i < keys.length; ++i)
              writer.uint32(
                /* id 4, wireType 2 =*/
                34
              ).fork().uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(keys[i]).uint32(
                /* id 2, wireType 2 =*/
                18
              ).string(message.variablesJson[keys[i]]).ldelim();
          return writer;
        };
        Details.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        Details.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.Details(), key;
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 4:
                reader.skip().pos++;
                if (message.variablesJson === $util.emptyObject)
                  message.variablesJson = {};
                key = reader.string();
                reader.pos++;
                message.variablesJson[key] = reader.string();
                break;
              case 3:
                message.operationName = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        Details.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        Details.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.variablesJson != null && message.hasOwnProperty("variablesJson")) {
            if (!$util.isObject(message.variablesJson))
              return "variablesJson: object expected";
            var key = Object.keys(message.variablesJson);
            for (var i = 0; i < key.length; ++i)
              if (!$util.isString(message.variablesJson[key[i]]))
                return "variablesJson: string{k:string} expected";
          }
          if (message.operationName != null && message.hasOwnProperty("operationName")) {
            if (!$util.isString(message.operationName))
              return "operationName: string expected";
          }
          return null;
        };
        Details.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.objects || options.defaults)
            object.variablesJson = {};
          if (options.defaults)
            object.operationName = "";
          if (message.operationName != null && message.hasOwnProperty("operationName"))
            object.operationName = message.operationName;
          var keys2;
          if (message.variablesJson && (keys2 = Object.keys(message.variablesJson)).length) {
            object.variablesJson = {};
            for (var j = 0; j < keys2.length; ++j)
              object.variablesJson[keys2[j]] = message.variablesJson[keys2[j]];
          }
          return object;
        };
        Details.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return Details;
      }();
      Trace.Error = function() {
        function Error2(properties) {
          this.location = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        Error2.prototype.message = "";
        Error2.prototype.location = $util.emptyArray;
        Error2.prototype.timeNs = 0;
        Error2.prototype.json = "";
        Error2.create = function create(properties) {
          return new Error2(properties);
        };
        Error2.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.message != null && Object.hasOwnProperty.call(message, "message"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(message.message);
          if (message.location != null && message.location.length)
            for (var i = 0; i < message.location.length; ++i)
              $root.Trace.Location.encode(message.location[i], writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).fork()).ldelim();
          if (message.timeNs != null && Object.hasOwnProperty.call(message, "timeNs"))
            writer.uint32(
              /* id 3, wireType 0 =*/
              24
            ).uint64(message.timeNs);
          if (message.json != null && Object.hasOwnProperty.call(message, "json"))
            writer.uint32(
              /* id 4, wireType 2 =*/
              34
            ).string(message.json);
          return writer;
        };
        Error2.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        Error2.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.Error();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.message = reader.string();
                break;
              case 2:
                if (!(message.location && message.location.length))
                  message.location = [];
                message.location.push($root.Trace.Location.decode(reader, reader.uint32()));
                break;
              case 3:
                message.timeNs = reader.uint64();
                break;
              case 4:
                message.json = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        Error2.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        Error2.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.message != null && message.hasOwnProperty("message")) {
            if (!$util.isString(message.message))
              return "message: string expected";
          }
          if (message.location != null && message.hasOwnProperty("location")) {
            if (!Array.isArray(message.location))
              return "location: array expected";
            for (var i = 0; i < message.location.length; ++i) {
              var error = $root.Trace.Location.verify(message.location[i]);
              if (error)
                return "location." + error;
            }
          }
          if (message.timeNs != null && message.hasOwnProperty("timeNs")) {
            if (!$util.isInteger(message.timeNs) && !(message.timeNs && $util.isInteger(message.timeNs.low) && $util.isInteger(message.timeNs.high)))
              return "timeNs: integer|Long expected";
          }
          if (message.json != null && message.hasOwnProperty("json")) {
            if (!$util.isString(message.json))
              return "json: string expected";
          }
          return null;
        };
        Error2.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults)
            object.location = [];
          if (options.defaults) {
            object.message = "";
            object.timeNs = 0;
            object.json = "";
          }
          if (message.message != null && message.hasOwnProperty("message"))
            object.message = message.message;
          if (message.location && message.location.length) {
            object.location = [];
            for (var j = 0; j < message.location.length; ++j)
              object.location[j] = $root.Trace.Location.toObject(message.location[j], options);
          }
          if (message.timeNs != null && message.hasOwnProperty("timeNs"))
            if (typeof message.timeNs === "number")
              object.timeNs = options.longs === String ? String(message.timeNs) : message.timeNs;
            else
              object.timeNs = options.longs === String ? $util.Long.prototype.toString.call(message.timeNs) : options.longs === Number ? new $util.LongBits(message.timeNs.low >>> 0, message.timeNs.high >>> 0).toNumber(true) : message.timeNs;
          if (message.json != null && message.hasOwnProperty("json"))
            object.json = message.json;
          return object;
        };
        Error2.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return Error2;
      }();
      Trace.HTTP = function() {
        function HTTP(properties) {
          this.requestHeaders = {};
          this.responseHeaders = {};
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        HTTP.prototype.method = 0;
        HTTP.prototype.requestHeaders = $util.emptyObject;
        HTTP.prototype.responseHeaders = $util.emptyObject;
        HTTP.prototype.statusCode = 0;
        HTTP.create = function create(properties) {
          return new HTTP(properties);
        };
        HTTP.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.method != null && Object.hasOwnProperty.call(message, "method"))
            writer.uint32(
              /* id 1, wireType 0 =*/
              8
            ).int32(message.method);
          if (message.requestHeaders != null && Object.hasOwnProperty.call(message, "requestHeaders"))
            for (var keys = Object.keys(message.requestHeaders), i = 0; i < keys.length; ++i) {
              writer.uint32(
                /* id 4, wireType 2 =*/
                34
              ).fork().uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(keys[i]);
              $root.Trace.HTTP.Values.encode(message.requestHeaders[keys[i]], writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).fork()).ldelim().ldelim();
            }
          if (message.responseHeaders != null && Object.hasOwnProperty.call(message, "responseHeaders"))
            for (var keys = Object.keys(message.responseHeaders), i = 0; i < keys.length; ++i) {
              writer.uint32(
                /* id 5, wireType 2 =*/
                42
              ).fork().uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(keys[i]);
              $root.Trace.HTTP.Values.encode(message.responseHeaders[keys[i]], writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).fork()).ldelim().ldelim();
            }
          if (message.statusCode != null && Object.hasOwnProperty.call(message, "statusCode"))
            writer.uint32(
              /* id 6, wireType 0 =*/
              48
            ).uint32(message.statusCode);
          return writer;
        };
        HTTP.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        HTTP.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.HTTP(), key;
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.method = reader.int32();
                break;
              case 4:
                reader.skip().pos++;
                if (message.requestHeaders === $util.emptyObject)
                  message.requestHeaders = {};
                key = reader.string();
                reader.pos++;
                message.requestHeaders[key] = $root.Trace.HTTP.Values.decode(reader, reader.uint32());
                break;
              case 5:
                reader.skip().pos++;
                if (message.responseHeaders === $util.emptyObject)
                  message.responseHeaders = {};
                key = reader.string();
                reader.pos++;
                message.responseHeaders[key] = $root.Trace.HTTP.Values.decode(reader, reader.uint32());
                break;
              case 6:
                message.statusCode = reader.uint32();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        HTTP.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        HTTP.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.method != null && message.hasOwnProperty("method"))
            switch (message.method) {
              default:
                return "method: enum value expected";
              case 0:
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
              case 6:
              case 7:
              case 8:
              case 9:
                break;
            }
          if (message.requestHeaders != null && message.hasOwnProperty("requestHeaders")) {
            if (!$util.isObject(message.requestHeaders))
              return "requestHeaders: object expected";
            var key = Object.keys(message.requestHeaders);
            for (var i = 0; i < key.length; ++i) {
              var error = $root.Trace.HTTP.Values.verify(message.requestHeaders[key[i]]);
              if (error)
                return "requestHeaders." + error;
            }
          }
          if (message.responseHeaders != null && message.hasOwnProperty("responseHeaders")) {
            if (!$util.isObject(message.responseHeaders))
              return "responseHeaders: object expected";
            var key = Object.keys(message.responseHeaders);
            for (var i = 0; i < key.length; ++i) {
              var error = $root.Trace.HTTP.Values.verify(message.responseHeaders[key[i]]);
              if (error)
                return "responseHeaders." + error;
            }
          }
          if (message.statusCode != null && message.hasOwnProperty("statusCode")) {
            if (!$util.isInteger(message.statusCode))
              return "statusCode: integer expected";
          }
          return null;
        };
        HTTP.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.objects || options.defaults) {
            object.requestHeaders = {};
            object.responseHeaders = {};
          }
          if (options.defaults) {
            object.method = options.enums === String ? "UNKNOWN" : 0;
            object.statusCode = 0;
          }
          if (message.method != null && message.hasOwnProperty("method"))
            object.method = options.enums === String ? $root.Trace.HTTP.Method[message.method] : message.method;
          var keys2;
          if (message.requestHeaders && (keys2 = Object.keys(message.requestHeaders)).length) {
            object.requestHeaders = {};
            for (var j = 0; j < keys2.length; ++j)
              object.requestHeaders[keys2[j]] = $root.Trace.HTTP.Values.toObject(message.requestHeaders[keys2[j]], options);
          }
          if (message.responseHeaders && (keys2 = Object.keys(message.responseHeaders)).length) {
            object.responseHeaders = {};
            for (var j = 0; j < keys2.length; ++j)
              object.responseHeaders[keys2[j]] = $root.Trace.HTTP.Values.toObject(message.responseHeaders[keys2[j]], options);
          }
          if (message.statusCode != null && message.hasOwnProperty("statusCode"))
            object.statusCode = message.statusCode;
          return object;
        };
        HTTP.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        HTTP.Values = function() {
          function Values(properties) {
            this.value = [];
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          Values.prototype.value = $util.emptyArray;
          Values.create = function create(properties) {
            return new Values(properties);
          };
          Values.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.value != null && message.value.length)
              for (var i = 0; i < message.value.length; ++i)
                writer.uint32(
                  /* id 1, wireType 2 =*/
                  10
                ).string(message.value[i]);
            return writer;
          };
          Values.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          Values.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.HTTP.Values();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  if (!(message.value && message.value.length))
                    message.value = [];
                  message.value.push(reader.string());
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          Values.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          Values.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.value != null && message.hasOwnProperty("value")) {
              if (!Array.isArray(message.value))
                return "value: array expected";
              for (var i = 0; i < message.value.length; ++i)
                if (!$util.isString(message.value[i]))
                  return "value: string[] expected";
            }
            return null;
          };
          Values.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.arrays || options.defaults)
              object.value = [];
            if (message.value && message.value.length) {
              object.value = [];
              for (var j = 0; j < message.value.length; ++j)
                object.value[j] = message.value[j];
            }
            return object;
          };
          Values.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return Values;
        }();
        HTTP.Method = function() {
          var valuesById = {}, values = Object.create(valuesById);
          values[valuesById[0] = "UNKNOWN"] = 0;
          values[valuesById[1] = "OPTIONS"] = 1;
          values[valuesById[2] = "GET"] = 2;
          values[valuesById[3] = "HEAD"] = 3;
          values[valuesById[4] = "POST"] = 4;
          values[valuesById[5] = "PUT"] = 5;
          values[valuesById[6] = "DELETE"] = 6;
          values[valuesById[7] = "TRACE"] = 7;
          values[valuesById[8] = "CONNECT"] = 8;
          values[valuesById[9] = "PATCH"] = 9;
          return values;
        }();
        return HTTP;
      }();
      Trace.Location = function() {
        function Location2(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        Location2.prototype.line = 0;
        Location2.prototype.column = 0;
        Location2.create = function create(properties) {
          return new Location2(properties);
        };
        Location2.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.line != null && Object.hasOwnProperty.call(message, "line"))
            writer.uint32(
              /* id 1, wireType 0 =*/
              8
            ).uint32(message.line);
          if (message.column != null && Object.hasOwnProperty.call(message, "column"))
            writer.uint32(
              /* id 2, wireType 0 =*/
              16
            ).uint32(message.column);
          return writer;
        };
        Location2.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        Location2.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.Location();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.line = reader.uint32();
                break;
              case 2:
                message.column = reader.uint32();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        Location2.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        Location2.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.line != null && message.hasOwnProperty("line")) {
            if (!$util.isInteger(message.line))
              return "line: integer expected";
          }
          if (message.column != null && message.hasOwnProperty("column")) {
            if (!$util.isInteger(message.column))
              return "column: integer expected";
          }
          return null;
        };
        Location2.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.defaults) {
            object.line = 0;
            object.column = 0;
          }
          if (message.line != null && message.hasOwnProperty("line"))
            object.line = message.line;
          if (message.column != null && message.hasOwnProperty("column"))
            object.column = message.column;
          return object;
        };
        Location2.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return Location2;
      }();
      Trace.Node = function() {
        function Node(properties) {
          this.error = [];
          this.child = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        Node.prototype.responseName = "";
        Node.prototype.index = 0;
        Node.prototype.originalFieldName = "";
        Node.prototype.type = "";
        Node.prototype.parentType = "";
        Node.prototype.cachePolicy = null;
        Node.prototype.startTime = 0;
        Node.prototype.endTime = 0;
        Node.prototype.error = $util.emptyArray;
        Node.prototype.child = $util.emptyArray;
        var $oneOfFields;
        Object.defineProperty(Node.prototype, "id", {
          get: $util.oneOfGetter($oneOfFields = ["responseName", "index"]),
          set: $util.oneOfSetter($oneOfFields)
        });
        Node.create = function create(properties) {
          return new Node(properties);
        };
        Node.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.responseName != null && Object.hasOwnProperty.call(message, "responseName"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(message.responseName);
          if (message.index != null && Object.hasOwnProperty.call(message, "index"))
            writer.uint32(
              /* id 2, wireType 0 =*/
              16
            ).uint32(message.index);
          if (message.type != null && Object.hasOwnProperty.call(message, "type"))
            writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).string(message.type);
          if (message.cachePolicy != null && Object.hasOwnProperty.call(message, "cachePolicy"))
            $root.Trace.CachePolicy.encode(message.cachePolicy, writer.uint32(
              /* id 5, wireType 2 =*/
              42
            ).fork()).ldelim();
          if (message.startTime != null && Object.hasOwnProperty.call(message, "startTime"))
            writer.uint32(
              /* id 8, wireType 0 =*/
              64
            ).uint64(message.startTime);
          if (message.endTime != null && Object.hasOwnProperty.call(message, "endTime"))
            writer.uint32(
              /* id 9, wireType 0 =*/
              72
            ).uint64(message.endTime);
          if (message.error != null && message.error.length)
            for (var i = 0; i < message.error.length; ++i)
              $root.Trace.Error.encode(message.error[i], writer.uint32(
                /* id 11, wireType 2 =*/
                90
              ).fork()).ldelim();
          if (message.child != null && message.child.length)
            for (var i = 0; i < message.child.length; ++i)
              $root.Trace.Node.encode(message.child[i], writer.uint32(
                /* id 12, wireType 2 =*/
                98
              ).fork()).ldelim();
          if (message.parentType != null && Object.hasOwnProperty.call(message, "parentType"))
            writer.uint32(
              /* id 13, wireType 2 =*/
              106
            ).string(message.parentType);
          if (message.originalFieldName != null && Object.hasOwnProperty.call(message, "originalFieldName"))
            writer.uint32(
              /* id 14, wireType 2 =*/
              114
            ).string(message.originalFieldName);
          return writer;
        };
        Node.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        Node.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.Node();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.responseName = reader.string();
                break;
              case 2:
                message.index = reader.uint32();
                break;
              case 14:
                message.originalFieldName = reader.string();
                break;
              case 3:
                message.type = reader.string();
                break;
              case 13:
                message.parentType = reader.string();
                break;
              case 5:
                message.cachePolicy = $root.Trace.CachePolicy.decode(reader, reader.uint32());
                break;
              case 8:
                message.startTime = reader.uint64();
                break;
              case 9:
                message.endTime = reader.uint64();
                break;
              case 11:
                if (!(message.error && message.error.length))
                  message.error = [];
                message.error.push($root.Trace.Error.decode(reader, reader.uint32()));
                break;
              case 12:
                if (!(message.child && message.child.length))
                  message.child = [];
                message.child.push($root.Trace.Node.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        Node.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        Node.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          var properties = {};
          if (message.responseName != null && message.hasOwnProperty("responseName")) {
            properties.id = 1;
            if (!$util.isString(message.responseName))
              return "responseName: string expected";
          }
          if (message.index != null && message.hasOwnProperty("index")) {
            if (properties.id === 1)
              return "id: multiple values";
            properties.id = 1;
            if (!$util.isInteger(message.index))
              return "index: integer expected";
          }
          if (message.originalFieldName != null && message.hasOwnProperty("originalFieldName")) {
            if (!$util.isString(message.originalFieldName))
              return "originalFieldName: string expected";
          }
          if (message.type != null && message.hasOwnProperty("type")) {
            if (!$util.isString(message.type))
              return "type: string expected";
          }
          if (message.parentType != null && message.hasOwnProperty("parentType")) {
            if (!$util.isString(message.parentType))
              return "parentType: string expected";
          }
          if (message.cachePolicy != null && message.hasOwnProperty("cachePolicy")) {
            var error = $root.Trace.CachePolicy.verify(message.cachePolicy);
            if (error)
              return "cachePolicy." + error;
          }
          if (message.startTime != null && message.hasOwnProperty("startTime")) {
            if (!$util.isInteger(message.startTime) && !(message.startTime && $util.isInteger(message.startTime.low) && $util.isInteger(message.startTime.high)))
              return "startTime: integer|Long expected";
          }
          if (message.endTime != null && message.hasOwnProperty("endTime")) {
            if (!$util.isInteger(message.endTime) && !(message.endTime && $util.isInteger(message.endTime.low) && $util.isInteger(message.endTime.high)))
              return "endTime: integer|Long expected";
          }
          if (message.error != null && message.hasOwnProperty("error")) {
            if (!Array.isArray(message.error))
              return "error: array expected";
            for (var i = 0; i < message.error.length; ++i) {
              var error = $root.Trace.Error.verify(message.error[i]);
              if (error)
                return "error." + error;
            }
          }
          if (message.child != null && message.hasOwnProperty("child")) {
            if (!Array.isArray(message.child))
              return "child: array expected";
            for (var i = 0; i < message.child.length; ++i) {
              var error = $root.Trace.Node.verify(message.child[i]);
              if (error)
                return "child." + error;
            }
          }
          return null;
        };
        Node.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults) {
            object.error = [];
            object.child = [];
          }
          if (options.defaults) {
            object.type = "";
            object.cachePolicy = null;
            object.startTime = 0;
            object.endTime = 0;
            object.parentType = "";
            object.originalFieldName = "";
          }
          if (message.responseName != null && message.hasOwnProperty("responseName")) {
            object.responseName = message.responseName;
            if (options.oneofs)
              object.id = "responseName";
          }
          if (message.index != null && message.hasOwnProperty("index")) {
            object.index = message.index;
            if (options.oneofs)
              object.id = "index";
          }
          if (message.type != null && message.hasOwnProperty("type"))
            object.type = message.type;
          if (message.cachePolicy != null && message.hasOwnProperty("cachePolicy"))
            object.cachePolicy = $root.Trace.CachePolicy.toObject(message.cachePolicy, options);
          if (message.startTime != null && message.hasOwnProperty("startTime"))
            if (typeof message.startTime === "number")
              object.startTime = options.longs === String ? String(message.startTime) : message.startTime;
            else
              object.startTime = options.longs === String ? $util.Long.prototype.toString.call(message.startTime) : options.longs === Number ? new $util.LongBits(message.startTime.low >>> 0, message.startTime.high >>> 0).toNumber(true) : message.startTime;
          if (message.endTime != null && message.hasOwnProperty("endTime"))
            if (typeof message.endTime === "number")
              object.endTime = options.longs === String ? String(message.endTime) : message.endTime;
            else
              object.endTime = options.longs === String ? $util.Long.prototype.toString.call(message.endTime) : options.longs === Number ? new $util.LongBits(message.endTime.low >>> 0, message.endTime.high >>> 0).toNumber(true) : message.endTime;
          if (message.error && message.error.length) {
            object.error = [];
            for (var j = 0; j < message.error.length; ++j)
              object.error[j] = $root.Trace.Error.toObject(message.error[j], options);
          }
          if (message.child && message.child.length) {
            object.child = [];
            for (var j = 0; j < message.child.length; ++j)
              object.child[j] = $root.Trace.Node.toObject(message.child[j], options);
          }
          if (message.parentType != null && message.hasOwnProperty("parentType"))
            object.parentType = message.parentType;
          if (message.originalFieldName != null && message.hasOwnProperty("originalFieldName"))
            object.originalFieldName = message.originalFieldName;
          return object;
        };
        Node.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return Node;
      }();
      Trace.QueryPlanNode = function() {
        function QueryPlanNode(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        QueryPlanNode.prototype.sequence = null;
        QueryPlanNode.prototype.parallel = null;
        QueryPlanNode.prototype.fetch = null;
        QueryPlanNode.prototype.flatten = null;
        QueryPlanNode.prototype.defer = null;
        QueryPlanNode.prototype.condition = null;
        var $oneOfFields;
        Object.defineProperty(QueryPlanNode.prototype, "node", {
          get: $util.oneOfGetter($oneOfFields = ["sequence", "parallel", "fetch", "flatten", "defer", "condition"]),
          set: $util.oneOfSetter($oneOfFields)
        });
        QueryPlanNode.create = function create(properties) {
          return new QueryPlanNode(properties);
        };
        QueryPlanNode.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.sequence != null && Object.hasOwnProperty.call(message, "sequence"))
            $root.Trace.QueryPlanNode.SequenceNode.encode(message.sequence, writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).fork()).ldelim();
          if (message.parallel != null && Object.hasOwnProperty.call(message, "parallel"))
            $root.Trace.QueryPlanNode.ParallelNode.encode(message.parallel, writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim();
          if (message.fetch != null && Object.hasOwnProperty.call(message, "fetch"))
            $root.Trace.QueryPlanNode.FetchNode.encode(message.fetch, writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).fork()).ldelim();
          if (message.flatten != null && Object.hasOwnProperty.call(message, "flatten"))
            $root.Trace.QueryPlanNode.FlattenNode.encode(message.flatten, writer.uint32(
              /* id 4, wireType 2 =*/
              34
            ).fork()).ldelim();
          if (message.defer != null && Object.hasOwnProperty.call(message, "defer"))
            $root.Trace.QueryPlanNode.DeferNode.encode(message.defer, writer.uint32(
              /* id 5, wireType 2 =*/
              42
            ).fork()).ldelim();
          if (message.condition != null && Object.hasOwnProperty.call(message, "condition"))
            $root.Trace.QueryPlanNode.ConditionNode.encode(message.condition, writer.uint32(
              /* id 6, wireType 2 =*/
              50
            ).fork()).ldelim();
          return writer;
        };
        QueryPlanNode.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        QueryPlanNode.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.sequence = $root.Trace.QueryPlanNode.SequenceNode.decode(reader, reader.uint32());
                break;
              case 2:
                message.parallel = $root.Trace.QueryPlanNode.ParallelNode.decode(reader, reader.uint32());
                break;
              case 3:
                message.fetch = $root.Trace.QueryPlanNode.FetchNode.decode(reader, reader.uint32());
                break;
              case 4:
                message.flatten = $root.Trace.QueryPlanNode.FlattenNode.decode(reader, reader.uint32());
                break;
              case 5:
                message.defer = $root.Trace.QueryPlanNode.DeferNode.decode(reader, reader.uint32());
                break;
              case 6:
                message.condition = $root.Trace.QueryPlanNode.ConditionNode.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        QueryPlanNode.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        QueryPlanNode.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          var properties = {};
          if (message.sequence != null && message.hasOwnProperty("sequence")) {
            properties.node = 1;
            {
              var error = $root.Trace.QueryPlanNode.SequenceNode.verify(message.sequence);
              if (error)
                return "sequence." + error;
            }
          }
          if (message.parallel != null && message.hasOwnProperty("parallel")) {
            if (properties.node === 1)
              return "node: multiple values";
            properties.node = 1;
            {
              var error = $root.Trace.QueryPlanNode.ParallelNode.verify(message.parallel);
              if (error)
                return "parallel." + error;
            }
          }
          if (message.fetch != null && message.hasOwnProperty("fetch")) {
            if (properties.node === 1)
              return "node: multiple values";
            properties.node = 1;
            {
              var error = $root.Trace.QueryPlanNode.FetchNode.verify(message.fetch);
              if (error)
                return "fetch." + error;
            }
          }
          if (message.flatten != null && message.hasOwnProperty("flatten")) {
            if (properties.node === 1)
              return "node: multiple values";
            properties.node = 1;
            {
              var error = $root.Trace.QueryPlanNode.FlattenNode.verify(message.flatten);
              if (error)
                return "flatten." + error;
            }
          }
          if (message.defer != null && message.hasOwnProperty("defer")) {
            if (properties.node === 1)
              return "node: multiple values";
            properties.node = 1;
            {
              var error = $root.Trace.QueryPlanNode.DeferNode.verify(message.defer);
              if (error)
                return "defer." + error;
            }
          }
          if (message.condition != null && message.hasOwnProperty("condition")) {
            if (properties.node === 1)
              return "node: multiple values";
            properties.node = 1;
            {
              var error = $root.Trace.QueryPlanNode.ConditionNode.verify(message.condition);
              if (error)
                return "condition." + error;
            }
          }
          return null;
        };
        QueryPlanNode.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (message.sequence != null && message.hasOwnProperty("sequence")) {
            object.sequence = $root.Trace.QueryPlanNode.SequenceNode.toObject(message.sequence, options);
            if (options.oneofs)
              object.node = "sequence";
          }
          if (message.parallel != null && message.hasOwnProperty("parallel")) {
            object.parallel = $root.Trace.QueryPlanNode.ParallelNode.toObject(message.parallel, options);
            if (options.oneofs)
              object.node = "parallel";
          }
          if (message.fetch != null && message.hasOwnProperty("fetch")) {
            object.fetch = $root.Trace.QueryPlanNode.FetchNode.toObject(message.fetch, options);
            if (options.oneofs)
              object.node = "fetch";
          }
          if (message.flatten != null && message.hasOwnProperty("flatten")) {
            object.flatten = $root.Trace.QueryPlanNode.FlattenNode.toObject(message.flatten, options);
            if (options.oneofs)
              object.node = "flatten";
          }
          if (message.defer != null && message.hasOwnProperty("defer")) {
            object.defer = $root.Trace.QueryPlanNode.DeferNode.toObject(message.defer, options);
            if (options.oneofs)
              object.node = "defer";
          }
          if (message.condition != null && message.hasOwnProperty("condition")) {
            object.condition = $root.Trace.QueryPlanNode.ConditionNode.toObject(message.condition, options);
            if (options.oneofs)
              object.node = "condition";
          }
          return object;
        };
        QueryPlanNode.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        QueryPlanNode.SequenceNode = function() {
          function SequenceNode(properties) {
            this.nodes = [];
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          SequenceNode.prototype.nodes = $util.emptyArray;
          SequenceNode.create = function create(properties) {
            return new SequenceNode(properties);
          };
          SequenceNode.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.nodes != null && message.nodes.length)
              for (var i = 0; i < message.nodes.length; ++i)
                $root.Trace.QueryPlanNode.encode(message.nodes[i], writer.uint32(
                  /* id 1, wireType 2 =*/
                  10
                ).fork()).ldelim();
            return writer;
          };
          SequenceNode.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          SequenceNode.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.SequenceNode();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  if (!(message.nodes && message.nodes.length))
                    message.nodes = [];
                  message.nodes.push($root.Trace.QueryPlanNode.decode(reader, reader.uint32()));
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          SequenceNode.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          SequenceNode.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.nodes != null && message.hasOwnProperty("nodes")) {
              if (!Array.isArray(message.nodes))
                return "nodes: array expected";
              for (var i = 0; i < message.nodes.length; ++i) {
                var error = $root.Trace.QueryPlanNode.verify(message.nodes[i]);
                if (error)
                  return "nodes." + error;
              }
            }
            return null;
          };
          SequenceNode.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.arrays || options.defaults)
              object.nodes = [];
            if (message.nodes && message.nodes.length) {
              object.nodes = [];
              for (var j = 0; j < message.nodes.length; ++j)
                object.nodes[j] = $root.Trace.QueryPlanNode.toObject(message.nodes[j], options);
            }
            return object;
          };
          SequenceNode.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return SequenceNode;
        }();
        QueryPlanNode.ParallelNode = function() {
          function ParallelNode(properties) {
            this.nodes = [];
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          ParallelNode.prototype.nodes = $util.emptyArray;
          ParallelNode.create = function create(properties) {
            return new ParallelNode(properties);
          };
          ParallelNode.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.nodes != null && message.nodes.length)
              for (var i = 0; i < message.nodes.length; ++i)
                $root.Trace.QueryPlanNode.encode(message.nodes[i], writer.uint32(
                  /* id 1, wireType 2 =*/
                  10
                ).fork()).ldelim();
            return writer;
          };
          ParallelNode.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          ParallelNode.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.ParallelNode();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  if (!(message.nodes && message.nodes.length))
                    message.nodes = [];
                  message.nodes.push($root.Trace.QueryPlanNode.decode(reader, reader.uint32()));
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          ParallelNode.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          ParallelNode.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.nodes != null && message.hasOwnProperty("nodes")) {
              if (!Array.isArray(message.nodes))
                return "nodes: array expected";
              for (var i = 0; i < message.nodes.length; ++i) {
                var error = $root.Trace.QueryPlanNode.verify(message.nodes[i]);
                if (error)
                  return "nodes." + error;
              }
            }
            return null;
          };
          ParallelNode.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.arrays || options.defaults)
              object.nodes = [];
            if (message.nodes && message.nodes.length) {
              object.nodes = [];
              for (var j = 0; j < message.nodes.length; ++j)
                object.nodes[j] = $root.Trace.QueryPlanNode.toObject(message.nodes[j], options);
            }
            return object;
          };
          ParallelNode.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return ParallelNode;
        }();
        QueryPlanNode.FetchNode = function() {
          function FetchNode(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          FetchNode.prototype.serviceName = "";
          FetchNode.prototype.traceParsingFailed = false;
          FetchNode.prototype.trace = null;
          FetchNode.prototype.sentTimeOffset = 0;
          FetchNode.prototype.sentTime = null;
          FetchNode.prototype.receivedTime = null;
          FetchNode.create = function create(properties) {
            return new FetchNode(properties);
          };
          FetchNode.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.serviceName != null && Object.hasOwnProperty.call(message, "serviceName"))
              writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(message.serviceName);
            if (message.traceParsingFailed != null && Object.hasOwnProperty.call(message, "traceParsingFailed"))
              writer.uint32(
                /* id 2, wireType 0 =*/
                16
              ).bool(message.traceParsingFailed);
            if (message.trace != null && Object.hasOwnProperty.call(message, "trace"))
              $root.Trace.encode(message.trace, writer.uint32(
                /* id 3, wireType 2 =*/
                26
              ).fork()).ldelim();
            if (message.sentTimeOffset != null && Object.hasOwnProperty.call(message, "sentTimeOffset"))
              writer.uint32(
                /* id 4, wireType 0 =*/
                32
              ).uint64(message.sentTimeOffset);
            if (message.sentTime != null && Object.hasOwnProperty.call(message, "sentTime"))
              $root.google.protobuf.Timestamp.encode(message.sentTime, writer.uint32(
                /* id 5, wireType 2 =*/
                42
              ).fork()).ldelim();
            if (message.receivedTime != null && Object.hasOwnProperty.call(message, "receivedTime"))
              $root.google.protobuf.Timestamp.encode(message.receivedTime, writer.uint32(
                /* id 6, wireType 2 =*/
                50
              ).fork()).ldelim();
            return writer;
          };
          FetchNode.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          FetchNode.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.FetchNode();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.serviceName = reader.string();
                  break;
                case 2:
                  message.traceParsingFailed = reader.bool();
                  break;
                case 3:
                  message.trace = $root.Trace.decode(reader, reader.uint32());
                  break;
                case 4:
                  message.sentTimeOffset = reader.uint64();
                  break;
                case 5:
                  message.sentTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                  break;
                case 6:
                  message.receivedTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          FetchNode.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          FetchNode.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.serviceName != null && message.hasOwnProperty("serviceName")) {
              if (!$util.isString(message.serviceName))
                return "serviceName: string expected";
            }
            if (message.traceParsingFailed != null && message.hasOwnProperty("traceParsingFailed")) {
              if (typeof message.traceParsingFailed !== "boolean")
                return "traceParsingFailed: boolean expected";
            }
            if (message.trace != null && message.hasOwnProperty("trace")) {
              var error = $root.Trace.verify(message.trace);
              if (error)
                return "trace." + error;
            }
            if (message.sentTimeOffset != null && message.hasOwnProperty("sentTimeOffset")) {
              if (!$util.isInteger(message.sentTimeOffset) && !(message.sentTimeOffset && $util.isInteger(message.sentTimeOffset.low) && $util.isInteger(message.sentTimeOffset.high)))
                return "sentTimeOffset: integer|Long expected";
            }
            if (message.sentTime != null && message.hasOwnProperty("sentTime")) {
              var error = $root.google.protobuf.Timestamp.verify(message.sentTime);
              if (error)
                return "sentTime." + error;
            }
            if (message.receivedTime != null && message.hasOwnProperty("receivedTime")) {
              var error = $root.google.protobuf.Timestamp.verify(message.receivedTime);
              if (error)
                return "receivedTime." + error;
            }
            return null;
          };
          FetchNode.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults) {
              object.serviceName = "";
              object.traceParsingFailed = false;
              object.trace = null;
              object.sentTimeOffset = 0;
              object.sentTime = null;
              object.receivedTime = null;
            }
            if (message.serviceName != null && message.hasOwnProperty("serviceName"))
              object.serviceName = message.serviceName;
            if (message.traceParsingFailed != null && message.hasOwnProperty("traceParsingFailed"))
              object.traceParsingFailed = message.traceParsingFailed;
            if (message.trace != null && message.hasOwnProperty("trace"))
              object.trace = $root.Trace.toObject(message.trace, options);
            if (message.sentTimeOffset != null && message.hasOwnProperty("sentTimeOffset"))
              if (typeof message.sentTimeOffset === "number")
                object.sentTimeOffset = options.longs === String ? String(message.sentTimeOffset) : message.sentTimeOffset;
              else
                object.sentTimeOffset = options.longs === String ? $util.Long.prototype.toString.call(message.sentTimeOffset) : options.longs === Number ? new $util.LongBits(message.sentTimeOffset.low >>> 0, message.sentTimeOffset.high >>> 0).toNumber(true) : message.sentTimeOffset;
            if (message.sentTime != null && message.hasOwnProperty("sentTime"))
              object.sentTime = $root.google.protobuf.Timestamp.toObject(message.sentTime, options);
            if (message.receivedTime != null && message.hasOwnProperty("receivedTime"))
              object.receivedTime = $root.google.protobuf.Timestamp.toObject(message.receivedTime, options);
            return object;
          };
          FetchNode.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return FetchNode;
        }();
        QueryPlanNode.FlattenNode = function() {
          function FlattenNode(properties) {
            this.responsePath = [];
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          FlattenNode.prototype.responsePath = $util.emptyArray;
          FlattenNode.prototype.node = null;
          FlattenNode.create = function create(properties) {
            return new FlattenNode(properties);
          };
          FlattenNode.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.responsePath != null && message.responsePath.length)
              for (var i = 0; i < message.responsePath.length; ++i)
                $root.Trace.QueryPlanNode.ResponsePathElement.encode(message.responsePath[i], writer.uint32(
                  /* id 1, wireType 2 =*/
                  10
                ).fork()).ldelim();
            if (message.node != null && Object.hasOwnProperty.call(message, "node"))
              $root.Trace.QueryPlanNode.encode(message.node, writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).fork()).ldelim();
            return writer;
          };
          FlattenNode.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          FlattenNode.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.FlattenNode();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  if (!(message.responsePath && message.responsePath.length))
                    message.responsePath = [];
                  message.responsePath.push($root.Trace.QueryPlanNode.ResponsePathElement.decode(reader, reader.uint32()));
                  break;
                case 2:
                  message.node = $root.Trace.QueryPlanNode.decode(reader, reader.uint32());
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          FlattenNode.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          FlattenNode.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.responsePath != null && message.hasOwnProperty("responsePath")) {
              if (!Array.isArray(message.responsePath))
                return "responsePath: array expected";
              for (var i = 0; i < message.responsePath.length; ++i) {
                var error = $root.Trace.QueryPlanNode.ResponsePathElement.verify(message.responsePath[i]);
                if (error)
                  return "responsePath." + error;
              }
            }
            if (message.node != null && message.hasOwnProperty("node")) {
              var error = $root.Trace.QueryPlanNode.verify(message.node);
              if (error)
                return "node." + error;
            }
            return null;
          };
          FlattenNode.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.arrays || options.defaults)
              object.responsePath = [];
            if (options.defaults)
              object.node = null;
            if (message.responsePath && message.responsePath.length) {
              object.responsePath = [];
              for (var j = 0; j < message.responsePath.length; ++j)
                object.responsePath[j] = $root.Trace.QueryPlanNode.ResponsePathElement.toObject(message.responsePath[j], options);
            }
            if (message.node != null && message.hasOwnProperty("node"))
              object.node = $root.Trace.QueryPlanNode.toObject(message.node, options);
            return object;
          };
          FlattenNode.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return FlattenNode;
        }();
        QueryPlanNode.DeferNode = function() {
          function DeferNode(properties) {
            this.deferred = [];
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          DeferNode.prototype.primary = null;
          DeferNode.prototype.deferred = $util.emptyArray;
          DeferNode.create = function create(properties) {
            return new DeferNode(properties);
          };
          DeferNode.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.primary != null && Object.hasOwnProperty.call(message, "primary"))
              $root.Trace.QueryPlanNode.DeferNodePrimary.encode(message.primary, writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).fork()).ldelim();
            if (message.deferred != null && message.deferred.length)
              for (var i = 0; i < message.deferred.length; ++i)
                $root.Trace.QueryPlanNode.DeferredNode.encode(message.deferred[i], writer.uint32(
                  /* id 2, wireType 2 =*/
                  18
                ).fork()).ldelim();
            return writer;
          };
          DeferNode.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          DeferNode.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.DeferNode();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.primary = $root.Trace.QueryPlanNode.DeferNodePrimary.decode(reader, reader.uint32());
                  break;
                case 2:
                  if (!(message.deferred && message.deferred.length))
                    message.deferred = [];
                  message.deferred.push($root.Trace.QueryPlanNode.DeferredNode.decode(reader, reader.uint32()));
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          DeferNode.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          DeferNode.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.primary != null && message.hasOwnProperty("primary")) {
              var error = $root.Trace.QueryPlanNode.DeferNodePrimary.verify(message.primary);
              if (error)
                return "primary." + error;
            }
            if (message.deferred != null && message.hasOwnProperty("deferred")) {
              if (!Array.isArray(message.deferred))
                return "deferred: array expected";
              for (var i = 0; i < message.deferred.length; ++i) {
                var error = $root.Trace.QueryPlanNode.DeferredNode.verify(message.deferred[i]);
                if (error)
                  return "deferred." + error;
              }
            }
            return null;
          };
          DeferNode.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.arrays || options.defaults)
              object.deferred = [];
            if (options.defaults)
              object.primary = null;
            if (message.primary != null && message.hasOwnProperty("primary"))
              object.primary = $root.Trace.QueryPlanNode.DeferNodePrimary.toObject(message.primary, options);
            if (message.deferred && message.deferred.length) {
              object.deferred = [];
              for (var j = 0; j < message.deferred.length; ++j)
                object.deferred[j] = $root.Trace.QueryPlanNode.DeferredNode.toObject(message.deferred[j], options);
            }
            return object;
          };
          DeferNode.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return DeferNode;
        }();
        QueryPlanNode.ConditionNode = function() {
          function ConditionNode(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          ConditionNode.prototype.condition = "";
          ConditionNode.prototype.ifClause = null;
          ConditionNode.prototype.elseClause = null;
          ConditionNode.create = function create(properties) {
            return new ConditionNode(properties);
          };
          ConditionNode.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.condition != null && Object.hasOwnProperty.call(message, "condition"))
              writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(message.condition);
            if (message.ifClause != null && Object.hasOwnProperty.call(message, "ifClause"))
              $root.Trace.QueryPlanNode.encode(message.ifClause, writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).fork()).ldelim();
            if (message.elseClause != null && Object.hasOwnProperty.call(message, "elseClause"))
              $root.Trace.QueryPlanNode.encode(message.elseClause, writer.uint32(
                /* id 3, wireType 2 =*/
                26
              ).fork()).ldelim();
            return writer;
          };
          ConditionNode.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          ConditionNode.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.ConditionNode();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.condition = reader.string();
                  break;
                case 2:
                  message.ifClause = $root.Trace.QueryPlanNode.decode(reader, reader.uint32());
                  break;
                case 3:
                  message.elseClause = $root.Trace.QueryPlanNode.decode(reader, reader.uint32());
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          ConditionNode.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          ConditionNode.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.condition != null && message.hasOwnProperty("condition")) {
              if (!$util.isString(message.condition))
                return "condition: string expected";
            }
            if (message.ifClause != null && message.hasOwnProperty("ifClause")) {
              var error = $root.Trace.QueryPlanNode.verify(message.ifClause);
              if (error)
                return "ifClause." + error;
            }
            if (message.elseClause != null && message.hasOwnProperty("elseClause")) {
              var error = $root.Trace.QueryPlanNode.verify(message.elseClause);
              if (error)
                return "elseClause." + error;
            }
            return null;
          };
          ConditionNode.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults) {
              object.condition = "";
              object.ifClause = null;
              object.elseClause = null;
            }
            if (message.condition != null && message.hasOwnProperty("condition"))
              object.condition = message.condition;
            if (message.ifClause != null && message.hasOwnProperty("ifClause"))
              object.ifClause = $root.Trace.QueryPlanNode.toObject(message.ifClause, options);
            if (message.elseClause != null && message.hasOwnProperty("elseClause"))
              object.elseClause = $root.Trace.QueryPlanNode.toObject(message.elseClause, options);
            return object;
          };
          ConditionNode.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return ConditionNode;
        }();
        QueryPlanNode.DeferNodePrimary = function() {
          function DeferNodePrimary(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          DeferNodePrimary.prototype.node = null;
          DeferNodePrimary.create = function create(properties) {
            return new DeferNodePrimary(properties);
          };
          DeferNodePrimary.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.node != null && Object.hasOwnProperty.call(message, "node"))
              $root.Trace.QueryPlanNode.encode(message.node, writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).fork()).ldelim();
            return writer;
          };
          DeferNodePrimary.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          DeferNodePrimary.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.DeferNodePrimary();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.node = $root.Trace.QueryPlanNode.decode(reader, reader.uint32());
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          DeferNodePrimary.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          DeferNodePrimary.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.node != null && message.hasOwnProperty("node")) {
              var error = $root.Trace.QueryPlanNode.verify(message.node);
              if (error)
                return "node." + error;
            }
            return null;
          };
          DeferNodePrimary.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults)
              object.node = null;
            if (message.node != null && message.hasOwnProperty("node"))
              object.node = $root.Trace.QueryPlanNode.toObject(message.node, options);
            return object;
          };
          DeferNodePrimary.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return DeferNodePrimary;
        }();
        QueryPlanNode.DeferredNode = function() {
          function DeferredNode(properties) {
            this.depends = [];
            this.path = [];
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          DeferredNode.prototype.depends = $util.emptyArray;
          DeferredNode.prototype.label = "";
          DeferredNode.prototype.path = $util.emptyArray;
          DeferredNode.prototype.node = null;
          DeferredNode.create = function create(properties) {
            return new DeferredNode(properties);
          };
          DeferredNode.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.depends != null && message.depends.length)
              for (var i = 0; i < message.depends.length; ++i)
                $root.Trace.QueryPlanNode.DeferredNodeDepends.encode(message.depends[i], writer.uint32(
                  /* id 1, wireType 2 =*/
                  10
                ).fork()).ldelim();
            if (message.label != null && Object.hasOwnProperty.call(message, "label"))
              writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).string(message.label);
            if (message.path != null && message.path.length)
              for (var i = 0; i < message.path.length; ++i)
                $root.Trace.QueryPlanNode.ResponsePathElement.encode(message.path[i], writer.uint32(
                  /* id 3, wireType 2 =*/
                  26
                ).fork()).ldelim();
            if (message.node != null && Object.hasOwnProperty.call(message, "node"))
              $root.Trace.QueryPlanNode.encode(message.node, writer.uint32(
                /* id 4, wireType 2 =*/
                34
              ).fork()).ldelim();
            return writer;
          };
          DeferredNode.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          DeferredNode.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.DeferredNode();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  if (!(message.depends && message.depends.length))
                    message.depends = [];
                  message.depends.push($root.Trace.QueryPlanNode.DeferredNodeDepends.decode(reader, reader.uint32()));
                  break;
                case 2:
                  message.label = reader.string();
                  break;
                case 3:
                  if (!(message.path && message.path.length))
                    message.path = [];
                  message.path.push($root.Trace.QueryPlanNode.ResponsePathElement.decode(reader, reader.uint32()));
                  break;
                case 4:
                  message.node = $root.Trace.QueryPlanNode.decode(reader, reader.uint32());
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          DeferredNode.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          DeferredNode.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.depends != null && message.hasOwnProperty("depends")) {
              if (!Array.isArray(message.depends))
                return "depends: array expected";
              for (var i = 0; i < message.depends.length; ++i) {
                var error = $root.Trace.QueryPlanNode.DeferredNodeDepends.verify(message.depends[i]);
                if (error)
                  return "depends." + error;
              }
            }
            if (message.label != null && message.hasOwnProperty("label")) {
              if (!$util.isString(message.label))
                return "label: string expected";
            }
            if (message.path != null && message.hasOwnProperty("path")) {
              if (!Array.isArray(message.path))
                return "path: array expected";
              for (var i = 0; i < message.path.length; ++i) {
                var error = $root.Trace.QueryPlanNode.ResponsePathElement.verify(message.path[i]);
                if (error)
                  return "path." + error;
              }
            }
            if (message.node != null && message.hasOwnProperty("node")) {
              var error = $root.Trace.QueryPlanNode.verify(message.node);
              if (error)
                return "node." + error;
            }
            return null;
          };
          DeferredNode.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.arrays || options.defaults) {
              object.depends = [];
              object.path = [];
            }
            if (options.defaults) {
              object.label = "";
              object.node = null;
            }
            if (message.depends && message.depends.length) {
              object.depends = [];
              for (var j = 0; j < message.depends.length; ++j)
                object.depends[j] = $root.Trace.QueryPlanNode.DeferredNodeDepends.toObject(message.depends[j], options);
            }
            if (message.label != null && message.hasOwnProperty("label"))
              object.label = message.label;
            if (message.path && message.path.length) {
              object.path = [];
              for (var j = 0; j < message.path.length; ++j)
                object.path[j] = $root.Trace.QueryPlanNode.ResponsePathElement.toObject(message.path[j], options);
            }
            if (message.node != null && message.hasOwnProperty("node"))
              object.node = $root.Trace.QueryPlanNode.toObject(message.node, options);
            return object;
          };
          DeferredNode.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return DeferredNode;
        }();
        QueryPlanNode.DeferredNodeDepends = function() {
          function DeferredNodeDepends(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          DeferredNodeDepends.prototype.id = "";
          DeferredNodeDepends.prototype.deferLabel = "";
          DeferredNodeDepends.create = function create(properties) {
            return new DeferredNodeDepends(properties);
          };
          DeferredNodeDepends.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
              writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(message.id);
            if (message.deferLabel != null && Object.hasOwnProperty.call(message, "deferLabel"))
              writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).string(message.deferLabel);
            return writer;
          };
          DeferredNodeDepends.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          DeferredNodeDepends.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.DeferredNodeDepends();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.id = reader.string();
                  break;
                case 2:
                  message.deferLabel = reader.string();
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          DeferredNodeDepends.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          DeferredNodeDepends.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.id != null && message.hasOwnProperty("id")) {
              if (!$util.isString(message.id))
                return "id: string expected";
            }
            if (message.deferLabel != null && message.hasOwnProperty("deferLabel")) {
              if (!$util.isString(message.deferLabel))
                return "deferLabel: string expected";
            }
            return null;
          };
          DeferredNodeDepends.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults) {
              object.id = "";
              object.deferLabel = "";
            }
            if (message.id != null && message.hasOwnProperty("id"))
              object.id = message.id;
            if (message.deferLabel != null && message.hasOwnProperty("deferLabel"))
              object.deferLabel = message.deferLabel;
            return object;
          };
          DeferredNodeDepends.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return DeferredNodeDepends;
        }();
        QueryPlanNode.ResponsePathElement = function() {
          function ResponsePathElement(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          ResponsePathElement.prototype.fieldName = "";
          ResponsePathElement.prototype.index = 0;
          var $oneOfFields2;
          Object.defineProperty(ResponsePathElement.prototype, "id", {
            get: $util.oneOfGetter($oneOfFields2 = ["fieldName", "index"]),
            set: $util.oneOfSetter($oneOfFields2)
          });
          ResponsePathElement.create = function create(properties) {
            return new ResponsePathElement(properties);
          };
          ResponsePathElement.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.fieldName != null && Object.hasOwnProperty.call(message, "fieldName"))
              writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(message.fieldName);
            if (message.index != null && Object.hasOwnProperty.call(message, "index"))
              writer.uint32(
                /* id 2, wireType 0 =*/
                16
              ).uint32(message.index);
            return writer;
          };
          ResponsePathElement.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          ResponsePathElement.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.ResponsePathElement();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.fieldName = reader.string();
                  break;
                case 2:
                  message.index = reader.uint32();
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          ResponsePathElement.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          ResponsePathElement.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            var properties = {};
            if (message.fieldName != null && message.hasOwnProperty("fieldName")) {
              properties.id = 1;
              if (!$util.isString(message.fieldName))
                return "fieldName: string expected";
            }
            if (message.index != null && message.hasOwnProperty("index")) {
              if (properties.id === 1)
                return "id: multiple values";
              properties.id = 1;
              if (!$util.isInteger(message.index))
                return "index: integer expected";
            }
            return null;
          };
          ResponsePathElement.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (message.fieldName != null && message.hasOwnProperty("fieldName")) {
              object.fieldName = message.fieldName;
              if (options.oneofs)
                object.id = "fieldName";
            }
            if (message.index != null && message.hasOwnProperty("index")) {
              object.index = message.index;
              if (options.oneofs)
                object.id = "index";
            }
            return object;
          };
          ResponsePathElement.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return ResponsePathElement;
        }();
        return QueryPlanNode;
      }();
      return Trace;
    }();
    $root.ReportHeader = function() {
      function ReportHeader(properties) {
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      ReportHeader.prototype.graphRef = "";
      ReportHeader.prototype.hostname = "";
      ReportHeader.prototype.agentVersion = "";
      ReportHeader.prototype.serviceVersion = "";
      ReportHeader.prototype.runtimeVersion = "";
      ReportHeader.prototype.uname = "";
      ReportHeader.prototype.executableSchemaId = "";
      ReportHeader.create = function create(properties) {
        return new ReportHeader(properties);
      };
      ReportHeader.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.hostname != null && Object.hasOwnProperty.call(message, "hostname"))
          writer.uint32(
            /* id 5, wireType 2 =*/
            42
          ).string(message.hostname);
        if (message.agentVersion != null && Object.hasOwnProperty.call(message, "agentVersion"))
          writer.uint32(
            /* id 6, wireType 2 =*/
            50
          ).string(message.agentVersion);
        if (message.serviceVersion != null && Object.hasOwnProperty.call(message, "serviceVersion"))
          writer.uint32(
            /* id 7, wireType 2 =*/
            58
          ).string(message.serviceVersion);
        if (message.runtimeVersion != null && Object.hasOwnProperty.call(message, "runtimeVersion"))
          writer.uint32(
            /* id 8, wireType 2 =*/
            66
          ).string(message.runtimeVersion);
        if (message.uname != null && Object.hasOwnProperty.call(message, "uname"))
          writer.uint32(
            /* id 9, wireType 2 =*/
            74
          ).string(message.uname);
        if (message.executableSchemaId != null && Object.hasOwnProperty.call(message, "executableSchemaId"))
          writer.uint32(
            /* id 11, wireType 2 =*/
            90
          ).string(message.executableSchemaId);
        if (message.graphRef != null && Object.hasOwnProperty.call(message, "graphRef"))
          writer.uint32(
            /* id 12, wireType 2 =*/
            98
          ).string(message.graphRef);
        return writer;
      };
      ReportHeader.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };
      ReportHeader.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ReportHeader();
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 12:
              message.graphRef = reader.string();
              break;
            case 5:
              message.hostname = reader.string();
              break;
            case 6:
              message.agentVersion = reader.string();
              break;
            case 7:
              message.serviceVersion = reader.string();
              break;
            case 8:
              message.runtimeVersion = reader.string();
              break;
            case 9:
              message.uname = reader.string();
              break;
            case 11:
              message.executableSchemaId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };
      ReportHeader.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      ReportHeader.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.graphRef != null && message.hasOwnProperty("graphRef")) {
          if (!$util.isString(message.graphRef))
            return "graphRef: string expected";
        }
        if (message.hostname != null && message.hasOwnProperty("hostname")) {
          if (!$util.isString(message.hostname))
            return "hostname: string expected";
        }
        if (message.agentVersion != null && message.hasOwnProperty("agentVersion")) {
          if (!$util.isString(message.agentVersion))
            return "agentVersion: string expected";
        }
        if (message.serviceVersion != null && message.hasOwnProperty("serviceVersion")) {
          if (!$util.isString(message.serviceVersion))
            return "serviceVersion: string expected";
        }
        if (message.runtimeVersion != null && message.hasOwnProperty("runtimeVersion")) {
          if (!$util.isString(message.runtimeVersion))
            return "runtimeVersion: string expected";
        }
        if (message.uname != null && message.hasOwnProperty("uname")) {
          if (!$util.isString(message.uname))
            return "uname: string expected";
        }
        if (message.executableSchemaId != null && message.hasOwnProperty("executableSchemaId")) {
          if (!$util.isString(message.executableSchemaId))
            return "executableSchemaId: string expected";
        }
        return null;
      };
      ReportHeader.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.defaults) {
          object.hostname = "";
          object.agentVersion = "";
          object.serviceVersion = "";
          object.runtimeVersion = "";
          object.uname = "";
          object.executableSchemaId = "";
          object.graphRef = "";
        }
        if (message.hostname != null && message.hasOwnProperty("hostname"))
          object.hostname = message.hostname;
        if (message.agentVersion != null && message.hasOwnProperty("agentVersion"))
          object.agentVersion = message.agentVersion;
        if (message.serviceVersion != null && message.hasOwnProperty("serviceVersion"))
          object.serviceVersion = message.serviceVersion;
        if (message.runtimeVersion != null && message.hasOwnProperty("runtimeVersion"))
          object.runtimeVersion = message.runtimeVersion;
        if (message.uname != null && message.hasOwnProperty("uname"))
          object.uname = message.uname;
        if (message.executableSchemaId != null && message.hasOwnProperty("executableSchemaId"))
          object.executableSchemaId = message.executableSchemaId;
        if (message.graphRef != null && message.hasOwnProperty("graphRef"))
          object.graphRef = message.graphRef;
        return object;
      };
      ReportHeader.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      return ReportHeader;
    }();
    $root.PathErrorStats = function() {
      function PathErrorStats(properties) {
        this.children = {};
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      PathErrorStats.prototype.children = $util.emptyObject;
      PathErrorStats.prototype.errorsCount = 0;
      PathErrorStats.prototype.requestsWithErrorsCount = 0;
      PathErrorStats.create = function create(properties) {
        return new PathErrorStats(properties);
      };
      PathErrorStats.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.children != null && Object.hasOwnProperty.call(message, "children"))
          for (var keys = Object.keys(message.children), i = 0; i < keys.length; ++i) {
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).fork().uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(keys[i]);
            $root.PathErrorStats.encode(message.children[keys[i]], writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim().ldelim();
          }
        if (message.errorsCount != null && Object.hasOwnProperty.call(message, "errorsCount"))
          writer.uint32(
            /* id 4, wireType 0 =*/
            32
          ).uint64(message.errorsCount);
        if (message.requestsWithErrorsCount != null && Object.hasOwnProperty.call(message, "requestsWithErrorsCount"))
          writer.uint32(
            /* id 5, wireType 0 =*/
            40
          ).uint64(message.requestsWithErrorsCount);
        return writer;
      };
      PathErrorStats.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };
      PathErrorStats.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.PathErrorStats(), key;
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              reader.skip().pos++;
              if (message.children === $util.emptyObject)
                message.children = {};
              key = reader.string();
              reader.pos++;
              message.children[key] = $root.PathErrorStats.decode(reader, reader.uint32());
              break;
            case 4:
              message.errorsCount = reader.uint64();
              break;
            case 5:
              message.requestsWithErrorsCount = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };
      PathErrorStats.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      PathErrorStats.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.children != null && message.hasOwnProperty("children")) {
          if (!$util.isObject(message.children))
            return "children: object expected";
          var key = Object.keys(message.children);
          for (var i = 0; i < key.length; ++i) {
            var error = $root.PathErrorStats.verify(message.children[key[i]]);
            if (error)
              return "children." + error;
          }
        }
        if (message.errorsCount != null && message.hasOwnProperty("errorsCount")) {
          if (!$util.isInteger(message.errorsCount) && !(message.errorsCount && $util.isInteger(message.errorsCount.low) && $util.isInteger(message.errorsCount.high)))
            return "errorsCount: integer|Long expected";
        }
        if (message.requestsWithErrorsCount != null && message.hasOwnProperty("requestsWithErrorsCount")) {
          if (!$util.isInteger(message.requestsWithErrorsCount) && !(message.requestsWithErrorsCount && $util.isInteger(message.requestsWithErrorsCount.low) && $util.isInteger(message.requestsWithErrorsCount.high)))
            return "requestsWithErrorsCount: integer|Long expected";
        }
        return null;
      };
      PathErrorStats.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.objects || options.defaults)
          object.children = {};
        if (options.defaults) {
          object.errorsCount = 0;
          object.requestsWithErrorsCount = 0;
        }
        var keys2;
        if (message.children && (keys2 = Object.keys(message.children)).length) {
          object.children = {};
          for (var j = 0; j < keys2.length; ++j)
            object.children[keys2[j]] = $root.PathErrorStats.toObject(message.children[keys2[j]], options);
        }
        if (message.errorsCount != null && message.hasOwnProperty("errorsCount"))
          if (typeof message.errorsCount === "number")
            object.errorsCount = options.longs === String ? String(message.errorsCount) : message.errorsCount;
          else
            object.errorsCount = options.longs === String ? $util.Long.prototype.toString.call(message.errorsCount) : options.longs === Number ? new $util.LongBits(message.errorsCount.low >>> 0, message.errorsCount.high >>> 0).toNumber(true) : message.errorsCount;
        if (message.requestsWithErrorsCount != null && message.hasOwnProperty("requestsWithErrorsCount"))
          if (typeof message.requestsWithErrorsCount === "number")
            object.requestsWithErrorsCount = options.longs === String ? String(message.requestsWithErrorsCount) : message.requestsWithErrorsCount;
          else
            object.requestsWithErrorsCount = options.longs === String ? $util.Long.prototype.toString.call(message.requestsWithErrorsCount) : options.longs === Number ? new $util.LongBits(message.requestsWithErrorsCount.low >>> 0, message.requestsWithErrorsCount.high >>> 0).toNumber(true) : message.requestsWithErrorsCount;
        return object;
      };
      PathErrorStats.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      return PathErrorStats;
    }();
    $root.QueryLatencyStats = function() {
      function QueryLatencyStats(properties) {
        this.latencyCount = [];
        this.cacheLatencyCount = [];
        this.publicCacheTtlCount = [];
        this.privateCacheTtlCount = [];
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      QueryLatencyStats.prototype.latencyCount = $util.emptyArray;
      QueryLatencyStats.prototype.requestCount = 0;
      QueryLatencyStats.prototype.cacheHits = 0;
      QueryLatencyStats.prototype.persistedQueryHits = 0;
      QueryLatencyStats.prototype.persistedQueryMisses = 0;
      QueryLatencyStats.prototype.cacheLatencyCount = $util.emptyArray;
      QueryLatencyStats.prototype.rootErrorStats = null;
      QueryLatencyStats.prototype.requestsWithErrorsCount = 0;
      QueryLatencyStats.prototype.publicCacheTtlCount = $util.emptyArray;
      QueryLatencyStats.prototype.privateCacheTtlCount = $util.emptyArray;
      QueryLatencyStats.prototype.registeredOperationCount = 0;
      QueryLatencyStats.prototype.forbiddenOperationCount = 0;
      QueryLatencyStats.prototype.requestsWithoutFieldInstrumentation = 0;
      QueryLatencyStats.create = function create(properties) {
        return new QueryLatencyStats(properties);
      };
      QueryLatencyStats.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.requestCount != null && Object.hasOwnProperty.call(message, "requestCount"))
          writer.uint32(
            /* id 2, wireType 0 =*/
            16
          ).uint64(message.requestCount);
        if (message.cacheHits != null && Object.hasOwnProperty.call(message, "cacheHits"))
          writer.uint32(
            /* id 3, wireType 0 =*/
            24
          ).uint64(message.cacheHits);
        if (message.persistedQueryHits != null && Object.hasOwnProperty.call(message, "persistedQueryHits"))
          writer.uint32(
            /* id 4, wireType 0 =*/
            32
          ).uint64(message.persistedQueryHits);
        if (message.persistedQueryMisses != null && Object.hasOwnProperty.call(message, "persistedQueryMisses"))
          writer.uint32(
            /* id 5, wireType 0 =*/
            40
          ).uint64(message.persistedQueryMisses);
        if (message.rootErrorStats != null && Object.hasOwnProperty.call(message, "rootErrorStats"))
          $root.PathErrorStats.encode(message.rootErrorStats, writer.uint32(
            /* id 7, wireType 2 =*/
            58
          ).fork()).ldelim();
        if (message.requestsWithErrorsCount != null && Object.hasOwnProperty.call(message, "requestsWithErrorsCount"))
          writer.uint32(
            /* id 8, wireType 0 =*/
            64
          ).uint64(message.requestsWithErrorsCount);
        if (message.registeredOperationCount != null && Object.hasOwnProperty.call(message, "registeredOperationCount"))
          writer.uint32(
            /* id 11, wireType 0 =*/
            88
          ).uint64(message.registeredOperationCount);
        if (message.forbiddenOperationCount != null && Object.hasOwnProperty.call(message, "forbiddenOperationCount"))
          writer.uint32(
            /* id 12, wireType 0 =*/
            96
          ).uint64(message.forbiddenOperationCount);
        var array13;
        if (message.latencyCount != null && message.latencyCount.toArray)
          array13 = message.latencyCount.toArray();
        else
          array13 = message.latencyCount;
        if (array13 != null && array13.length) {
          writer.uint32(
            /* id 13, wireType 2 =*/
            106
          ).fork();
          for (var i = 0; i < array13.length; ++i)
            writer.sint64(array13[i]);
          writer.ldelim();
        }
        var array14;
        if (message.cacheLatencyCount != null && message.cacheLatencyCount.toArray)
          array14 = message.cacheLatencyCount.toArray();
        else
          array14 = message.cacheLatencyCount;
        if (array14 != null && array14.length) {
          writer.uint32(
            /* id 14, wireType 2 =*/
            114
          ).fork();
          for (var i = 0; i < array14.length; ++i)
            writer.sint64(array14[i]);
          writer.ldelim();
        }
        var array15;
        if (message.publicCacheTtlCount != null && message.publicCacheTtlCount.toArray)
          array15 = message.publicCacheTtlCount.toArray();
        else
          array15 = message.publicCacheTtlCount;
        if (array15 != null && array15.length) {
          writer.uint32(
            /* id 15, wireType 2 =*/
            122
          ).fork();
          for (var i = 0; i < array15.length; ++i)
            writer.sint64(array15[i]);
          writer.ldelim();
        }
        var array16;
        if (message.privateCacheTtlCount != null && message.privateCacheTtlCount.toArray)
          array16 = message.privateCacheTtlCount.toArray();
        else
          array16 = message.privateCacheTtlCount;
        if (array16 != null && array16.length) {
          writer.uint32(
            /* id 16, wireType 2 =*/
            130
          ).fork();
          for (var i = 0; i < array16.length; ++i)
            writer.sint64(array16[i]);
          writer.ldelim();
        }
        if (message.requestsWithoutFieldInstrumentation != null && Object.hasOwnProperty.call(message, "requestsWithoutFieldInstrumentation"))
          writer.uint32(
            /* id 17, wireType 0 =*/
            136
          ).uint64(message.requestsWithoutFieldInstrumentation);
        return writer;
      };
      QueryLatencyStats.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };
      QueryLatencyStats.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.QueryLatencyStats();
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 13:
              if (!(message.latencyCount && message.latencyCount.length))
                message.latencyCount = [];
              if ((tag & 7) === 2) {
                var end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2)
                  message.latencyCount.push(reader.sint64());
              } else
                message.latencyCount.push(reader.sint64());
              break;
            case 2:
              message.requestCount = reader.uint64();
              break;
            case 3:
              message.cacheHits = reader.uint64();
              break;
            case 4:
              message.persistedQueryHits = reader.uint64();
              break;
            case 5:
              message.persistedQueryMisses = reader.uint64();
              break;
            case 14:
              if (!(message.cacheLatencyCount && message.cacheLatencyCount.length))
                message.cacheLatencyCount = [];
              if ((tag & 7) === 2) {
                var end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2)
                  message.cacheLatencyCount.push(reader.sint64());
              } else
                message.cacheLatencyCount.push(reader.sint64());
              break;
            case 7:
              message.rootErrorStats = $root.PathErrorStats.decode(reader, reader.uint32());
              break;
            case 8:
              message.requestsWithErrorsCount = reader.uint64();
              break;
            case 15:
              if (!(message.publicCacheTtlCount && message.publicCacheTtlCount.length))
                message.publicCacheTtlCount = [];
              if ((tag & 7) === 2) {
                var end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2)
                  message.publicCacheTtlCount.push(reader.sint64());
              } else
                message.publicCacheTtlCount.push(reader.sint64());
              break;
            case 16:
              if (!(message.privateCacheTtlCount && message.privateCacheTtlCount.length))
                message.privateCacheTtlCount = [];
              if ((tag & 7) === 2) {
                var end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2)
                  message.privateCacheTtlCount.push(reader.sint64());
              } else
                message.privateCacheTtlCount.push(reader.sint64());
              break;
            case 11:
              message.registeredOperationCount = reader.uint64();
              break;
            case 12:
              message.forbiddenOperationCount = reader.uint64();
              break;
            case 17:
              message.requestsWithoutFieldInstrumentation = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };
      QueryLatencyStats.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      QueryLatencyStats.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.latencyCount != null && message.hasOwnProperty("latencyCount")) {
          var array13;
          if (message.latencyCount != null && message.latencyCount.toArray)
            array13 = message.latencyCount.toArray();
          else
            array13 = message.latencyCount;
          if (!Array.isArray(array13))
            return "latencyCount: array expected";
          for (var i = 0; i < array13.length; ++i)
            if (!$util.isInteger(array13[i]) && !(array13[i] && $util.isInteger(array13[i].low) && $util.isInteger(array13[i].high)))
              return "latencyCount: integer|Long[] expected";
        }
        if (message.requestCount != null && message.hasOwnProperty("requestCount")) {
          if (!$util.isInteger(message.requestCount) && !(message.requestCount && $util.isInteger(message.requestCount.low) && $util.isInteger(message.requestCount.high)))
            return "requestCount: integer|Long expected";
        }
        if (message.cacheHits != null && message.hasOwnProperty("cacheHits")) {
          if (!$util.isInteger(message.cacheHits) && !(message.cacheHits && $util.isInteger(message.cacheHits.low) && $util.isInteger(message.cacheHits.high)))
            return "cacheHits: integer|Long expected";
        }
        if (message.persistedQueryHits != null && message.hasOwnProperty("persistedQueryHits")) {
          if (!$util.isInteger(message.persistedQueryHits) && !(message.persistedQueryHits && $util.isInteger(message.persistedQueryHits.low) && $util.isInteger(message.persistedQueryHits.high)))
            return "persistedQueryHits: integer|Long expected";
        }
        if (message.persistedQueryMisses != null && message.hasOwnProperty("persistedQueryMisses")) {
          if (!$util.isInteger(message.persistedQueryMisses) && !(message.persistedQueryMisses && $util.isInteger(message.persistedQueryMisses.low) && $util.isInteger(message.persistedQueryMisses.high)))
            return "persistedQueryMisses: integer|Long expected";
        }
        if (message.cacheLatencyCount != null && message.hasOwnProperty("cacheLatencyCount")) {
          var array14;
          if (message.cacheLatencyCount != null && message.cacheLatencyCount.toArray)
            array14 = message.cacheLatencyCount.toArray();
          else
            array14 = message.cacheLatencyCount;
          if (!Array.isArray(array14))
            return "cacheLatencyCount: array expected";
          for (var i = 0; i < array14.length; ++i)
            if (!$util.isInteger(array14[i]) && !(array14[i] && $util.isInteger(array14[i].low) && $util.isInteger(array14[i].high)))
              return "cacheLatencyCount: integer|Long[] expected";
        }
        if (message.rootErrorStats != null && message.hasOwnProperty("rootErrorStats")) {
          var error = $root.PathErrorStats.verify(message.rootErrorStats);
          if (error)
            return "rootErrorStats." + error;
        }
        if (message.requestsWithErrorsCount != null && message.hasOwnProperty("requestsWithErrorsCount")) {
          if (!$util.isInteger(message.requestsWithErrorsCount) && !(message.requestsWithErrorsCount && $util.isInteger(message.requestsWithErrorsCount.low) && $util.isInteger(message.requestsWithErrorsCount.high)))
            return "requestsWithErrorsCount: integer|Long expected";
        }
        if (message.publicCacheTtlCount != null && message.hasOwnProperty("publicCacheTtlCount")) {
          var array15;
          if (message.publicCacheTtlCount != null && message.publicCacheTtlCount.toArray)
            array15 = message.publicCacheTtlCount.toArray();
          else
            array15 = message.publicCacheTtlCount;
          if (!Array.isArray(array15))
            return "publicCacheTtlCount: array expected";
          for (var i = 0; i < array15.length; ++i)
            if (!$util.isInteger(array15[i]) && !(array15[i] && $util.isInteger(array15[i].low) && $util.isInteger(array15[i].high)))
              return "publicCacheTtlCount: integer|Long[] expected";
        }
        if (message.privateCacheTtlCount != null && message.hasOwnProperty("privateCacheTtlCount")) {
          var array16;
          if (message.privateCacheTtlCount != null && message.privateCacheTtlCount.toArray)
            array16 = message.privateCacheTtlCount.toArray();
          else
            array16 = message.privateCacheTtlCount;
          if (!Array.isArray(array16))
            return "privateCacheTtlCount: array expected";
          for (var i = 0; i < array16.length; ++i)
            if (!$util.isInteger(array16[i]) && !(array16[i] && $util.isInteger(array16[i].low) && $util.isInteger(array16[i].high)))
              return "privateCacheTtlCount: integer|Long[] expected";
        }
        if (message.registeredOperationCount != null && message.hasOwnProperty("registeredOperationCount")) {
          if (!$util.isInteger(message.registeredOperationCount) && !(message.registeredOperationCount && $util.isInteger(message.registeredOperationCount.low) && $util.isInteger(message.registeredOperationCount.high)))
            return "registeredOperationCount: integer|Long expected";
        }
        if (message.forbiddenOperationCount != null && message.hasOwnProperty("forbiddenOperationCount")) {
          if (!$util.isInteger(message.forbiddenOperationCount) && !(message.forbiddenOperationCount && $util.isInteger(message.forbiddenOperationCount.low) && $util.isInteger(message.forbiddenOperationCount.high)))
            return "forbiddenOperationCount: integer|Long expected";
        }
        if (message.requestsWithoutFieldInstrumentation != null && message.hasOwnProperty("requestsWithoutFieldInstrumentation")) {
          if (!$util.isInteger(message.requestsWithoutFieldInstrumentation) && !(message.requestsWithoutFieldInstrumentation && $util.isInteger(message.requestsWithoutFieldInstrumentation.low) && $util.isInteger(message.requestsWithoutFieldInstrumentation.high)))
            return "requestsWithoutFieldInstrumentation: integer|Long expected";
        }
        return null;
      };
      QueryLatencyStats.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.arrays || options.defaults) {
          object.latencyCount = [];
          object.cacheLatencyCount = [];
          object.publicCacheTtlCount = [];
          object.privateCacheTtlCount = [];
        }
        if (options.defaults) {
          object.requestCount = 0;
          object.cacheHits = 0;
          object.persistedQueryHits = 0;
          object.persistedQueryMisses = 0;
          object.rootErrorStats = null;
          object.requestsWithErrorsCount = 0;
          object.registeredOperationCount = 0;
          object.forbiddenOperationCount = 0;
          object.requestsWithoutFieldInstrumentation = 0;
        }
        if (message.requestCount != null && message.hasOwnProperty("requestCount"))
          if (typeof message.requestCount === "number")
            object.requestCount = options.longs === String ? String(message.requestCount) : message.requestCount;
          else
            object.requestCount = options.longs === String ? $util.Long.prototype.toString.call(message.requestCount) : options.longs === Number ? new $util.LongBits(message.requestCount.low >>> 0, message.requestCount.high >>> 0).toNumber(true) : message.requestCount;
        if (message.cacheHits != null && message.hasOwnProperty("cacheHits"))
          if (typeof message.cacheHits === "number")
            object.cacheHits = options.longs === String ? String(message.cacheHits) : message.cacheHits;
          else
            object.cacheHits = options.longs === String ? $util.Long.prototype.toString.call(message.cacheHits) : options.longs === Number ? new $util.LongBits(message.cacheHits.low >>> 0, message.cacheHits.high >>> 0).toNumber(true) : message.cacheHits;
        if (message.persistedQueryHits != null && message.hasOwnProperty("persistedQueryHits"))
          if (typeof message.persistedQueryHits === "number")
            object.persistedQueryHits = options.longs === String ? String(message.persistedQueryHits) : message.persistedQueryHits;
          else
            object.persistedQueryHits = options.longs === String ? $util.Long.prototype.toString.call(message.persistedQueryHits) : options.longs === Number ? new $util.LongBits(message.persistedQueryHits.low >>> 0, message.persistedQueryHits.high >>> 0).toNumber(true) : message.persistedQueryHits;
        if (message.persistedQueryMisses != null && message.hasOwnProperty("persistedQueryMisses"))
          if (typeof message.persistedQueryMisses === "number")
            object.persistedQueryMisses = options.longs === String ? String(message.persistedQueryMisses) : message.persistedQueryMisses;
          else
            object.persistedQueryMisses = options.longs === String ? $util.Long.prototype.toString.call(message.persistedQueryMisses) : options.longs === Number ? new $util.LongBits(message.persistedQueryMisses.low >>> 0, message.persistedQueryMisses.high >>> 0).toNumber(true) : message.persistedQueryMisses;
        if (message.rootErrorStats != null && message.hasOwnProperty("rootErrorStats"))
          object.rootErrorStats = $root.PathErrorStats.toObject(message.rootErrorStats, options);
        if (message.requestsWithErrorsCount != null && message.hasOwnProperty("requestsWithErrorsCount"))
          if (typeof message.requestsWithErrorsCount === "number")
            object.requestsWithErrorsCount = options.longs === String ? String(message.requestsWithErrorsCount) : message.requestsWithErrorsCount;
          else
            object.requestsWithErrorsCount = options.longs === String ? $util.Long.prototype.toString.call(message.requestsWithErrorsCount) : options.longs === Number ? new $util.LongBits(message.requestsWithErrorsCount.low >>> 0, message.requestsWithErrorsCount.high >>> 0).toNumber(true) : message.requestsWithErrorsCount;
        if (message.registeredOperationCount != null && message.hasOwnProperty("registeredOperationCount"))
          if (typeof message.registeredOperationCount === "number")
            object.registeredOperationCount = options.longs === String ? String(message.registeredOperationCount) : message.registeredOperationCount;
          else
            object.registeredOperationCount = options.longs === String ? $util.Long.prototype.toString.call(message.registeredOperationCount) : options.longs === Number ? new $util.LongBits(message.registeredOperationCount.low >>> 0, message.registeredOperationCount.high >>> 0).toNumber(true) : message.registeredOperationCount;
        if (message.forbiddenOperationCount != null && message.hasOwnProperty("forbiddenOperationCount"))
          if (typeof message.forbiddenOperationCount === "number")
            object.forbiddenOperationCount = options.longs === String ? String(message.forbiddenOperationCount) : message.forbiddenOperationCount;
          else
            object.forbiddenOperationCount = options.longs === String ? $util.Long.prototype.toString.call(message.forbiddenOperationCount) : options.longs === Number ? new $util.LongBits(message.forbiddenOperationCount.low >>> 0, message.forbiddenOperationCount.high >>> 0).toNumber(true) : message.forbiddenOperationCount;
        if (message.latencyCount && message.latencyCount.length) {
          object.latencyCount = [];
          for (var j = 0; j < message.latencyCount.length; ++j)
            if (typeof message.latencyCount[j] === "number")
              object.latencyCount[j] = options.longs === String ? String(message.latencyCount[j]) : message.latencyCount[j];
            else
              object.latencyCount[j] = options.longs === String ? $util.Long.prototype.toString.call(message.latencyCount[j]) : options.longs === Number ? new $util.LongBits(message.latencyCount[j].low >>> 0, message.latencyCount[j].high >>> 0).toNumber() : message.latencyCount[j];
        }
        if (message.cacheLatencyCount && message.cacheLatencyCount.length) {
          object.cacheLatencyCount = [];
          for (var j = 0; j < message.cacheLatencyCount.length; ++j)
            if (typeof message.cacheLatencyCount[j] === "number")
              object.cacheLatencyCount[j] = options.longs === String ? String(message.cacheLatencyCount[j]) : message.cacheLatencyCount[j];
            else
              object.cacheLatencyCount[j] = options.longs === String ? $util.Long.prototype.toString.call(message.cacheLatencyCount[j]) : options.longs === Number ? new $util.LongBits(message.cacheLatencyCount[j].low >>> 0, message.cacheLatencyCount[j].high >>> 0).toNumber() : message.cacheLatencyCount[j];
        }
        if (message.publicCacheTtlCount && message.publicCacheTtlCount.length) {
          object.publicCacheTtlCount = [];
          for (var j = 0; j < message.publicCacheTtlCount.length; ++j)
            if (typeof message.publicCacheTtlCount[j] === "number")
              object.publicCacheTtlCount[j] = options.longs === String ? String(message.publicCacheTtlCount[j]) : message.publicCacheTtlCount[j];
            else
              object.publicCacheTtlCount[j] = options.longs === String ? $util.Long.prototype.toString.call(message.publicCacheTtlCount[j]) : options.longs === Number ? new $util.LongBits(message.publicCacheTtlCount[j].low >>> 0, message.publicCacheTtlCount[j].high >>> 0).toNumber() : message.publicCacheTtlCount[j];
        }
        if (message.privateCacheTtlCount && message.privateCacheTtlCount.length) {
          object.privateCacheTtlCount = [];
          for (var j = 0; j < message.privateCacheTtlCount.length; ++j)
            if (typeof message.privateCacheTtlCount[j] === "number")
              object.privateCacheTtlCount[j] = options.longs === String ? String(message.privateCacheTtlCount[j]) : message.privateCacheTtlCount[j];
            else
              object.privateCacheTtlCount[j] = options.longs === String ? $util.Long.prototype.toString.call(message.privateCacheTtlCount[j]) : options.longs === Number ? new $util.LongBits(message.privateCacheTtlCount[j].low >>> 0, message.privateCacheTtlCount[j].high >>> 0).toNumber() : message.privateCacheTtlCount[j];
        }
        if (message.requestsWithoutFieldInstrumentation != null && message.hasOwnProperty("requestsWithoutFieldInstrumentation"))
          if (typeof message.requestsWithoutFieldInstrumentation === "number")
            object.requestsWithoutFieldInstrumentation = options.longs === String ? String(message.requestsWithoutFieldInstrumentation) : message.requestsWithoutFieldInstrumentation;
          else
            object.requestsWithoutFieldInstrumentation = options.longs === String ? $util.Long.prototype.toString.call(message.requestsWithoutFieldInstrumentation) : options.longs === Number ? new $util.LongBits(message.requestsWithoutFieldInstrumentation.low >>> 0, message.requestsWithoutFieldInstrumentation.high >>> 0).toNumber(true) : message.requestsWithoutFieldInstrumentation;
        return object;
      };
      QueryLatencyStats.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      return QueryLatencyStats;
    }();
    $root.StatsContext = function() {
      function StatsContext(properties) {
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      StatsContext.prototype.clientName = "";
      StatsContext.prototype.clientVersion = "";
      StatsContext.create = function create(properties) {
        return new StatsContext(properties);
      };
      StatsContext.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.clientName != null && Object.hasOwnProperty.call(message, "clientName"))
          writer.uint32(
            /* id 2, wireType 2 =*/
            18
          ).string(message.clientName);
        if (message.clientVersion != null && Object.hasOwnProperty.call(message, "clientVersion"))
          writer.uint32(
            /* id 3, wireType 2 =*/
            26
          ).string(message.clientVersion);
        return writer;
      };
      StatsContext.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };
      StatsContext.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.StatsContext();
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 2:
              message.clientName = reader.string();
              break;
            case 3:
              message.clientVersion = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };
      StatsContext.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      StatsContext.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.clientName != null && message.hasOwnProperty("clientName")) {
          if (!$util.isString(message.clientName))
            return "clientName: string expected";
        }
        if (message.clientVersion != null && message.hasOwnProperty("clientVersion")) {
          if (!$util.isString(message.clientVersion))
            return "clientVersion: string expected";
        }
        return null;
      };
      StatsContext.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.defaults) {
          object.clientName = "";
          object.clientVersion = "";
        }
        if (message.clientName != null && message.hasOwnProperty("clientName"))
          object.clientName = message.clientName;
        if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
          object.clientVersion = message.clientVersion;
        return object;
      };
      StatsContext.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      return StatsContext;
    }();
    $root.ContextualizedQueryLatencyStats = function() {
      function ContextualizedQueryLatencyStats(properties) {
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      ContextualizedQueryLatencyStats.prototype.queryLatencyStats = null;
      ContextualizedQueryLatencyStats.prototype.context = null;
      ContextualizedQueryLatencyStats.create = function create(properties) {
        return new ContextualizedQueryLatencyStats(properties);
      };
      ContextualizedQueryLatencyStats.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.queryLatencyStats != null && Object.hasOwnProperty.call(message, "queryLatencyStats"))
          $root.QueryLatencyStats.encode(message.queryLatencyStats, writer.uint32(
            /* id 1, wireType 2 =*/
            10
          ).fork()).ldelim();
        if (message.context != null && Object.hasOwnProperty.call(message, "context"))
          $root.StatsContext.encode(message.context, writer.uint32(
            /* id 2, wireType 2 =*/
            18
          ).fork()).ldelim();
        return writer;
      };
      ContextualizedQueryLatencyStats.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };
      ContextualizedQueryLatencyStats.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ContextualizedQueryLatencyStats();
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.queryLatencyStats = $root.QueryLatencyStats.decode(reader, reader.uint32());
              break;
            case 2:
              message.context = $root.StatsContext.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };
      ContextualizedQueryLatencyStats.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      ContextualizedQueryLatencyStats.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.queryLatencyStats != null && message.hasOwnProperty("queryLatencyStats")) {
          var error = $root.QueryLatencyStats.verify(message.queryLatencyStats);
          if (error)
            return "queryLatencyStats." + error;
        }
        if (message.context != null && message.hasOwnProperty("context")) {
          var error = $root.StatsContext.verify(message.context);
          if (error)
            return "context." + error;
        }
        return null;
      };
      ContextualizedQueryLatencyStats.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.defaults) {
          object.queryLatencyStats = null;
          object.context = null;
        }
        if (message.queryLatencyStats != null && message.hasOwnProperty("queryLatencyStats"))
          object.queryLatencyStats = $root.QueryLatencyStats.toObject(message.queryLatencyStats, options);
        if (message.context != null && message.hasOwnProperty("context"))
          object.context = $root.StatsContext.toObject(message.context, options);
        return object;
      };
      ContextualizedQueryLatencyStats.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      return ContextualizedQueryLatencyStats;
    }();
    $root.ContextualizedTypeStats = function() {
      function ContextualizedTypeStats(properties) {
        this.perTypeStat = {};
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      ContextualizedTypeStats.prototype.context = null;
      ContextualizedTypeStats.prototype.perTypeStat = $util.emptyObject;
      ContextualizedTypeStats.create = function create(properties) {
        return new ContextualizedTypeStats(properties);
      };
      ContextualizedTypeStats.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.context != null && Object.hasOwnProperty.call(message, "context"))
          $root.StatsContext.encode(message.context, writer.uint32(
            /* id 1, wireType 2 =*/
            10
          ).fork()).ldelim();
        if (message.perTypeStat != null && Object.hasOwnProperty.call(message, "perTypeStat"))
          for (var keys = Object.keys(message.perTypeStat), i = 0; i < keys.length; ++i) {
            writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork().uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(keys[i]);
            $root.TypeStat.encode(message.perTypeStat[keys[i]], writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim().ldelim();
          }
        return writer;
      };
      ContextualizedTypeStats.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };
      ContextualizedTypeStats.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ContextualizedTypeStats(), key;
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.context = $root.StatsContext.decode(reader, reader.uint32());
              break;
            case 2:
              reader.skip().pos++;
              if (message.perTypeStat === $util.emptyObject)
                message.perTypeStat = {};
              key = reader.string();
              reader.pos++;
              message.perTypeStat[key] = $root.TypeStat.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };
      ContextualizedTypeStats.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      ContextualizedTypeStats.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.context != null && message.hasOwnProperty("context")) {
          var error = $root.StatsContext.verify(message.context);
          if (error)
            return "context." + error;
        }
        if (message.perTypeStat != null && message.hasOwnProperty("perTypeStat")) {
          if (!$util.isObject(message.perTypeStat))
            return "perTypeStat: object expected";
          var key = Object.keys(message.perTypeStat);
          for (var i = 0; i < key.length; ++i) {
            var error = $root.TypeStat.verify(message.perTypeStat[key[i]]);
            if (error)
              return "perTypeStat." + error;
          }
        }
        return null;
      };
      ContextualizedTypeStats.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.objects || options.defaults)
          object.perTypeStat = {};
        if (options.defaults)
          object.context = null;
        if (message.context != null && message.hasOwnProperty("context"))
          object.context = $root.StatsContext.toObject(message.context, options);
        var keys2;
        if (message.perTypeStat && (keys2 = Object.keys(message.perTypeStat)).length) {
          object.perTypeStat = {};
          for (var j = 0; j < keys2.length; ++j)
            object.perTypeStat[keys2[j]] = $root.TypeStat.toObject(message.perTypeStat[keys2[j]], options);
        }
        return object;
      };
      ContextualizedTypeStats.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      return ContextualizedTypeStats;
    }();
    $root.FieldStat = function() {
      function FieldStat(properties) {
        this.latencyCount = [];
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      FieldStat.prototype.returnType = "";
      FieldStat.prototype.errorsCount = 0;
      FieldStat.prototype.observedExecutionCount = 0;
      FieldStat.prototype.estimatedExecutionCount = 0;
      FieldStat.prototype.requestsWithErrorsCount = 0;
      FieldStat.prototype.latencyCount = $util.emptyArray;
      FieldStat.create = function create(properties) {
        return new FieldStat(properties);
      };
      FieldStat.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.returnType != null && Object.hasOwnProperty.call(message, "returnType"))
          writer.uint32(
            /* id 3, wireType 2 =*/
            26
          ).string(message.returnType);
        if (message.errorsCount != null && Object.hasOwnProperty.call(message, "errorsCount"))
          writer.uint32(
            /* id 4, wireType 0 =*/
            32
          ).uint64(message.errorsCount);
        if (message.observedExecutionCount != null && Object.hasOwnProperty.call(message, "observedExecutionCount"))
          writer.uint32(
            /* id 5, wireType 0 =*/
            40
          ).uint64(message.observedExecutionCount);
        if (message.requestsWithErrorsCount != null && Object.hasOwnProperty.call(message, "requestsWithErrorsCount"))
          writer.uint32(
            /* id 6, wireType 0 =*/
            48
          ).uint64(message.requestsWithErrorsCount);
        var array9;
        if (message.latencyCount != null && message.latencyCount.toArray)
          array9 = message.latencyCount.toArray();
        else
          array9 = message.latencyCount;
        if (array9 != null && array9.length) {
          writer.uint32(
            /* id 9, wireType 2 =*/
            74
          ).fork();
          for (var i = 0; i < array9.length; ++i)
            writer.sint64(array9[i]);
          writer.ldelim();
        }
        if (message.estimatedExecutionCount != null && Object.hasOwnProperty.call(message, "estimatedExecutionCount"))
          writer.uint32(
            /* id 10, wireType 0 =*/
            80
          ).uint64(message.estimatedExecutionCount);
        return writer;
      };
      FieldStat.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };
      FieldStat.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.FieldStat();
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 3:
              message.returnType = reader.string();
              break;
            case 4:
              message.errorsCount = reader.uint64();
              break;
            case 5:
              message.observedExecutionCount = reader.uint64();
              break;
            case 10:
              message.estimatedExecutionCount = reader.uint64();
              break;
            case 6:
              message.requestsWithErrorsCount = reader.uint64();
              break;
            case 9:
              if (!(message.latencyCount && message.latencyCount.length))
                message.latencyCount = [];
              if ((tag & 7) === 2) {
                var end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2)
                  message.latencyCount.push(reader.sint64());
              } else
                message.latencyCount.push(reader.sint64());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };
      FieldStat.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      FieldStat.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.returnType != null && message.hasOwnProperty("returnType")) {
          if (!$util.isString(message.returnType))
            return "returnType: string expected";
        }
        if (message.errorsCount != null && message.hasOwnProperty("errorsCount")) {
          if (!$util.isInteger(message.errorsCount) && !(message.errorsCount && $util.isInteger(message.errorsCount.low) && $util.isInteger(message.errorsCount.high)))
            return "errorsCount: integer|Long expected";
        }
        if (message.observedExecutionCount != null && message.hasOwnProperty("observedExecutionCount")) {
          if (!$util.isInteger(message.observedExecutionCount) && !(message.observedExecutionCount && $util.isInteger(message.observedExecutionCount.low) && $util.isInteger(message.observedExecutionCount.high)))
            return "observedExecutionCount: integer|Long expected";
        }
        if (message.estimatedExecutionCount != null && message.hasOwnProperty("estimatedExecutionCount")) {
          if (!$util.isInteger(message.estimatedExecutionCount) && !(message.estimatedExecutionCount && $util.isInteger(message.estimatedExecutionCount.low) && $util.isInteger(message.estimatedExecutionCount.high)))
            return "estimatedExecutionCount: integer|Long expected";
        }
        if (message.requestsWithErrorsCount != null && message.hasOwnProperty("requestsWithErrorsCount")) {
          if (!$util.isInteger(message.requestsWithErrorsCount) && !(message.requestsWithErrorsCount && $util.isInteger(message.requestsWithErrorsCount.low) && $util.isInteger(message.requestsWithErrorsCount.high)))
            return "requestsWithErrorsCount: integer|Long expected";
        }
        if (message.latencyCount != null && message.hasOwnProperty("latencyCount")) {
          var array9;
          if (message.latencyCount != null && message.latencyCount.toArray)
            array9 = message.latencyCount.toArray();
          else
            array9 = message.latencyCount;
          if (!Array.isArray(array9))
            return "latencyCount: array expected";
          for (var i = 0; i < array9.length; ++i)
            if (!$util.isInteger(array9[i]) && !(array9[i] && $util.isInteger(array9[i].low) && $util.isInteger(array9[i].high)))
              return "latencyCount: integer|Long[] expected";
        }
        return null;
      };
      FieldStat.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.arrays || options.defaults)
          object.latencyCount = [];
        if (options.defaults) {
          object.returnType = "";
          object.errorsCount = 0;
          object.observedExecutionCount = 0;
          object.requestsWithErrorsCount = 0;
          object.estimatedExecutionCount = 0;
        }
        if (message.returnType != null && message.hasOwnProperty("returnType"))
          object.returnType = message.returnType;
        if (message.errorsCount != null && message.hasOwnProperty("errorsCount"))
          if (typeof message.errorsCount === "number")
            object.errorsCount = options.longs === String ? String(message.errorsCount) : message.errorsCount;
          else
            object.errorsCount = options.longs === String ? $util.Long.prototype.toString.call(message.errorsCount) : options.longs === Number ? new $util.LongBits(message.errorsCount.low >>> 0, message.errorsCount.high >>> 0).toNumber(true) : message.errorsCount;
        if (message.observedExecutionCount != null && message.hasOwnProperty("observedExecutionCount"))
          if (typeof message.observedExecutionCount === "number")
            object.observedExecutionCount = options.longs === String ? String(message.observedExecutionCount) : message.observedExecutionCount;
          else
            object.observedExecutionCount = options.longs === String ? $util.Long.prototype.toString.call(message.observedExecutionCount) : options.longs === Number ? new $util.LongBits(message.observedExecutionCount.low >>> 0, message.observedExecutionCount.high >>> 0).toNumber(true) : message.observedExecutionCount;
        if (message.requestsWithErrorsCount != null && message.hasOwnProperty("requestsWithErrorsCount"))
          if (typeof message.requestsWithErrorsCount === "number")
            object.requestsWithErrorsCount = options.longs === String ? String(message.requestsWithErrorsCount) : message.requestsWithErrorsCount;
          else
            object.requestsWithErrorsCount = options.longs === String ? $util.Long.prototype.toString.call(message.requestsWithErrorsCount) : options.longs === Number ? new $util.LongBits(message.requestsWithErrorsCount.low >>> 0, message.requestsWithErrorsCount.high >>> 0).toNumber(true) : message.requestsWithErrorsCount;
        if (message.latencyCount && message.latencyCount.length) {
          object.latencyCount = [];
          for (var j = 0; j < message.latencyCount.length; ++j)
            if (typeof message.latencyCount[j] === "number")
              object.latencyCount[j] = options.longs === String ? String(message.latencyCount[j]) : message.latencyCount[j];
            else
              object.latencyCount[j] = options.longs === String ? $util.Long.prototype.toString.call(message.latencyCount[j]) : options.longs === Number ? new $util.LongBits(message.latencyCount[j].low >>> 0, message.latencyCount[j].high >>> 0).toNumber() : message.latencyCount[j];
        }
        if (message.estimatedExecutionCount != null && message.hasOwnProperty("estimatedExecutionCount"))
          if (typeof message.estimatedExecutionCount === "number")
            object.estimatedExecutionCount = options.longs === String ? String(message.estimatedExecutionCount) : message.estimatedExecutionCount;
          else
            object.estimatedExecutionCount = options.longs === String ? $util.Long.prototype.toString.call(message.estimatedExecutionCount) : options.longs === Number ? new $util.LongBits(message.estimatedExecutionCount.low >>> 0, message.estimatedExecutionCount.high >>> 0).toNumber(true) : message.estimatedExecutionCount;
        return object;
      };
      FieldStat.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      return FieldStat;
    }();
    $root.TypeStat = function() {
      function TypeStat(properties) {
        this.perFieldStat = {};
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      TypeStat.prototype.perFieldStat = $util.emptyObject;
      TypeStat.create = function create(properties) {
        return new TypeStat(properties);
      };
      TypeStat.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.perFieldStat != null && Object.hasOwnProperty.call(message, "perFieldStat"))
          for (var keys = Object.keys(message.perFieldStat), i = 0; i < keys.length; ++i) {
            writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).fork().uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(keys[i]);
            $root.FieldStat.encode(message.perFieldStat[keys[i]], writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim().ldelim();
          }
        return writer;
      };
      TypeStat.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };
      TypeStat.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.TypeStat(), key;
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 3:
              reader.skip().pos++;
              if (message.perFieldStat === $util.emptyObject)
                message.perFieldStat = {};
              key = reader.string();
              reader.pos++;
              message.perFieldStat[key] = $root.FieldStat.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };
      TypeStat.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      TypeStat.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.perFieldStat != null && message.hasOwnProperty("perFieldStat")) {
          if (!$util.isObject(message.perFieldStat))
            return "perFieldStat: object expected";
          var key = Object.keys(message.perFieldStat);
          for (var i = 0; i < key.length; ++i) {
            var error = $root.FieldStat.verify(message.perFieldStat[key[i]]);
            if (error)
              return "perFieldStat." + error;
          }
        }
        return null;
      };
      TypeStat.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.objects || options.defaults)
          object.perFieldStat = {};
        var keys2;
        if (message.perFieldStat && (keys2 = Object.keys(message.perFieldStat)).length) {
          object.perFieldStat = {};
          for (var j = 0; j < keys2.length; ++j)
            object.perFieldStat[keys2[j]] = $root.FieldStat.toObject(message.perFieldStat[keys2[j]], options);
        }
        return object;
      };
      TypeStat.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      return TypeStat;
    }();
    $root.ReferencedFieldsForType = function() {
      function ReferencedFieldsForType(properties) {
        this.fieldNames = [];
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      ReferencedFieldsForType.prototype.fieldNames = $util.emptyArray;
      ReferencedFieldsForType.prototype.isInterface = false;
      ReferencedFieldsForType.create = function create(properties) {
        return new ReferencedFieldsForType(properties);
      };
      ReferencedFieldsForType.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.fieldNames != null && message.fieldNames.length)
          for (var i = 0; i < message.fieldNames.length; ++i)
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(message.fieldNames[i]);
        if (message.isInterface != null && Object.hasOwnProperty.call(message, "isInterface"))
          writer.uint32(
            /* id 2, wireType 0 =*/
            16
          ).bool(message.isInterface);
        return writer;
      };
      ReferencedFieldsForType.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };
      ReferencedFieldsForType.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ReferencedFieldsForType();
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.fieldNames && message.fieldNames.length))
                message.fieldNames = [];
              message.fieldNames.push(reader.string());
              break;
            case 2:
              message.isInterface = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };
      ReferencedFieldsForType.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      ReferencedFieldsForType.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.fieldNames != null && message.hasOwnProperty("fieldNames")) {
          if (!Array.isArray(message.fieldNames))
            return "fieldNames: array expected";
          for (var i = 0; i < message.fieldNames.length; ++i)
            if (!$util.isString(message.fieldNames[i]))
              return "fieldNames: string[] expected";
        }
        if (message.isInterface != null && message.hasOwnProperty("isInterface")) {
          if (typeof message.isInterface !== "boolean")
            return "isInterface: boolean expected";
        }
        return null;
      };
      ReferencedFieldsForType.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.arrays || options.defaults)
          object.fieldNames = [];
        if (options.defaults)
          object.isInterface = false;
        if (message.fieldNames && message.fieldNames.length) {
          object.fieldNames = [];
          for (var j = 0; j < message.fieldNames.length; ++j)
            object.fieldNames[j] = message.fieldNames[j];
        }
        if (message.isInterface != null && message.hasOwnProperty("isInterface"))
          object.isInterface = message.isInterface;
        return object;
      };
      ReferencedFieldsForType.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      return ReferencedFieldsForType;
    }();
    $root.Report = function() {
      function Report(properties) {
        this.tracesPerQuery = {};
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      Report.prototype.header = null;
      Report.prototype.tracesPerQuery = $util.emptyObject;
      Report.prototype.endTime = null;
      Report.prototype.operationCount = 0;
      Report.prototype.tracesPreAggregated = false;
      Report.create = function create(properties) {
        return new Report(properties);
      };
      Report.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.header != null && Object.hasOwnProperty.call(message, "header"))
          $root.ReportHeader.encode(message.header, writer.uint32(
            /* id 1, wireType 2 =*/
            10
          ).fork()).ldelim();
        if (message.endTime != null && Object.hasOwnProperty.call(message, "endTime"))
          $root.google.protobuf.Timestamp.encode(message.endTime, writer.uint32(
            /* id 2, wireType 2 =*/
            18
          ).fork()).ldelim();
        if (message.tracesPerQuery != null && Object.hasOwnProperty.call(message, "tracesPerQuery"))
          for (var keys = Object.keys(message.tracesPerQuery), i = 0; i < keys.length; ++i) {
            writer.uint32(
              /* id 5, wireType 2 =*/
              42
            ).fork().uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(keys[i]);
            $root.TracesAndStats.encode(message.tracesPerQuery[keys[i]], writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim().ldelim();
          }
        if (message.operationCount != null && Object.hasOwnProperty.call(message, "operationCount"))
          writer.uint32(
            /* id 6, wireType 0 =*/
            48
          ).uint64(message.operationCount);
        if (message.tracesPreAggregated != null && Object.hasOwnProperty.call(message, "tracesPreAggregated"))
          writer.uint32(
            /* id 7, wireType 0 =*/
            56
          ).bool(message.tracesPreAggregated);
        return writer;
      };
      Report.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };
      Report.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Report(), key;
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.header = $root.ReportHeader.decode(reader, reader.uint32());
              break;
            case 5:
              reader.skip().pos++;
              if (message.tracesPerQuery === $util.emptyObject)
                message.tracesPerQuery = {};
              key = reader.string();
              reader.pos++;
              message.tracesPerQuery[key] = $root.TracesAndStats.decode(reader, reader.uint32());
              break;
            case 2:
              message.endTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
              break;
            case 6:
              message.operationCount = reader.uint64();
              break;
            case 7:
              message.tracesPreAggregated = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };
      Report.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      Report.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.header != null && message.hasOwnProperty("header")) {
          var error = $root.ReportHeader.verify(message.header);
          if (error)
            return "header." + error;
        }
        if (message.tracesPerQuery != null && message.hasOwnProperty("tracesPerQuery")) {
          if (!$util.isObject(message.tracesPerQuery))
            return "tracesPerQuery: object expected";
          var key = Object.keys(message.tracesPerQuery);
          for (var i = 0; i < key.length; ++i) {
            var error = $root.TracesAndStats.verify(message.tracesPerQuery[key[i]]);
            if (error)
              return "tracesPerQuery." + error;
          }
        }
        if (message.endTime != null && message.hasOwnProperty("endTime")) {
          var error = $root.google.protobuf.Timestamp.verify(message.endTime);
          if (error)
            return "endTime." + error;
        }
        if (message.operationCount != null && message.hasOwnProperty("operationCount")) {
          if (!$util.isInteger(message.operationCount) && !(message.operationCount && $util.isInteger(message.operationCount.low) && $util.isInteger(message.operationCount.high)))
            return "operationCount: integer|Long expected";
        }
        if (message.tracesPreAggregated != null && message.hasOwnProperty("tracesPreAggregated")) {
          if (typeof message.tracesPreAggregated !== "boolean")
            return "tracesPreAggregated: boolean expected";
        }
        return null;
      };
      Report.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.objects || options.defaults)
          object.tracesPerQuery = {};
        if (options.defaults) {
          object.header = null;
          object.endTime = null;
          object.operationCount = 0;
          object.tracesPreAggregated = false;
        }
        if (message.header != null && message.hasOwnProperty("header"))
          object.header = $root.ReportHeader.toObject(message.header, options);
        if (message.endTime != null && message.hasOwnProperty("endTime"))
          object.endTime = $root.google.protobuf.Timestamp.toObject(message.endTime, options);
        var keys2;
        if (message.tracesPerQuery && (keys2 = Object.keys(message.tracesPerQuery)).length) {
          object.tracesPerQuery = {};
          for (var j = 0; j < keys2.length; ++j)
            object.tracesPerQuery[keys2[j]] = $root.TracesAndStats.toObject(message.tracesPerQuery[keys2[j]], options);
        }
        if (message.operationCount != null && message.hasOwnProperty("operationCount"))
          if (typeof message.operationCount === "number")
            object.operationCount = options.longs === String ? String(message.operationCount) : message.operationCount;
          else
            object.operationCount = options.longs === String ? $util.Long.prototype.toString.call(message.operationCount) : options.longs === Number ? new $util.LongBits(message.operationCount.low >>> 0, message.operationCount.high >>> 0).toNumber(true) : message.operationCount;
        if (message.tracesPreAggregated != null && message.hasOwnProperty("tracesPreAggregated"))
          object.tracesPreAggregated = message.tracesPreAggregated;
        return object;
      };
      Report.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      return Report;
    }();
    $root.ContextualizedStats = function() {
      function ContextualizedStats(properties) {
        this.perTypeStat = {};
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      ContextualizedStats.prototype.context = null;
      ContextualizedStats.prototype.queryLatencyStats = null;
      ContextualizedStats.prototype.perTypeStat = $util.emptyObject;
      ContextualizedStats.create = function create(properties) {
        return new ContextualizedStats(properties);
      };
      ContextualizedStats.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.context != null && Object.hasOwnProperty.call(message, "context"))
          $root.StatsContext.encode(message.context, writer.uint32(
            /* id 1, wireType 2 =*/
            10
          ).fork()).ldelim();
        if (message.queryLatencyStats != null && Object.hasOwnProperty.call(message, "queryLatencyStats"))
          $root.QueryLatencyStats.encode(message.queryLatencyStats, writer.uint32(
            /* id 2, wireType 2 =*/
            18
          ).fork()).ldelim();
        if (message.perTypeStat != null && Object.hasOwnProperty.call(message, "perTypeStat"))
          for (var keys = Object.keys(message.perTypeStat), i = 0; i < keys.length; ++i) {
            writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).fork().uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(keys[i]);
            $root.TypeStat.encode(message.perTypeStat[keys[i]], writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim().ldelim();
          }
        return writer;
      };
      ContextualizedStats.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };
      ContextualizedStats.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ContextualizedStats(), key;
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.context = $root.StatsContext.decode(reader, reader.uint32());
              break;
            case 2:
              message.queryLatencyStats = $root.QueryLatencyStats.decode(reader, reader.uint32());
              break;
            case 3:
              reader.skip().pos++;
              if (message.perTypeStat === $util.emptyObject)
                message.perTypeStat = {};
              key = reader.string();
              reader.pos++;
              message.perTypeStat[key] = $root.TypeStat.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };
      ContextualizedStats.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      ContextualizedStats.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.context != null && message.hasOwnProperty("context")) {
          var error = $root.StatsContext.verify(message.context);
          if (error)
            return "context." + error;
        }
        if (message.queryLatencyStats != null && message.hasOwnProperty("queryLatencyStats")) {
          var error = $root.QueryLatencyStats.verify(message.queryLatencyStats);
          if (error)
            return "queryLatencyStats." + error;
        }
        if (message.perTypeStat != null && message.hasOwnProperty("perTypeStat")) {
          if (!$util.isObject(message.perTypeStat))
            return "perTypeStat: object expected";
          var key = Object.keys(message.perTypeStat);
          for (var i = 0; i < key.length; ++i) {
            var error = $root.TypeStat.verify(message.perTypeStat[key[i]]);
            if (error)
              return "perTypeStat." + error;
          }
        }
        return null;
      };
      ContextualizedStats.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.objects || options.defaults)
          object.perTypeStat = {};
        if (options.defaults) {
          object.context = null;
          object.queryLatencyStats = null;
        }
        if (message.context != null && message.hasOwnProperty("context"))
          object.context = $root.StatsContext.toObject(message.context, options);
        if (message.queryLatencyStats != null && message.hasOwnProperty("queryLatencyStats"))
          object.queryLatencyStats = $root.QueryLatencyStats.toObject(message.queryLatencyStats, options);
        var keys2;
        if (message.perTypeStat && (keys2 = Object.keys(message.perTypeStat)).length) {
          object.perTypeStat = {};
          for (var j = 0; j < keys2.length; ++j)
            object.perTypeStat[keys2[j]] = $root.TypeStat.toObject(message.perTypeStat[keys2[j]], options);
        }
        return object;
      };
      ContextualizedStats.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      return ContextualizedStats;
    }();
    $root.TracesAndStats = function() {
      function TracesAndStats(properties) {
        this.trace = [];
        this.statsWithContext = [];
        this.referencedFieldsByType = {};
        this.internalTracesContributingToStats = [];
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      TracesAndStats.prototype.trace = $util.emptyArray;
      TracesAndStats.prototype.statsWithContext = $util.emptyArray;
      TracesAndStats.prototype.referencedFieldsByType = $util.emptyObject;
      TracesAndStats.prototype.internalTracesContributingToStats = $util.emptyArray;
      TracesAndStats.create = function create(properties) {
        return new TracesAndStats(properties);
      };
      TracesAndStats.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.trace != null && message.trace.length)
          for (var i = 0; i < message.trace.length; ++i)
            if (message.trace[i] instanceof Uint8Array) {
              writer.uint32(
                /* id 1, wireType 2 =*/
                10
              );
              writer.bytes(message.trace[i]);
            } else
              $root.Trace.encode(message.trace[i], writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).fork()).ldelim();
        var array2;
        if (message.statsWithContext != null && message.statsWithContext.toArray)
          array2 = message.statsWithContext.toArray();
        else
          array2 = message.statsWithContext;
        if (array2 != null && array2.length)
          for (var i = 0; i < array2.length; ++i)
            $root.ContextualizedStats.encode(array2[i], writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim();
        if (message.internalTracesContributingToStats != null && message.internalTracesContributingToStats.length)
          for (var i = 0; i < message.internalTracesContributingToStats.length; ++i)
            if (message.internalTracesContributingToStats[i] instanceof Uint8Array) {
              writer.uint32(
                /* id 3, wireType 2 =*/
                26
              );
              writer.bytes(message.internalTracesContributingToStats[i]);
            } else
              $root.Trace.encode(message.internalTracesContributingToStats[i], writer.uint32(
                /* id 3, wireType 2 =*/
                26
              ).fork()).ldelim();
        if (message.referencedFieldsByType != null && Object.hasOwnProperty.call(message, "referencedFieldsByType"))
          for (var keys = Object.keys(message.referencedFieldsByType), i = 0; i < keys.length; ++i) {
            writer.uint32(
              /* id 4, wireType 2 =*/
              34
            ).fork().uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(keys[i]);
            $root.ReferencedFieldsForType.encode(message.referencedFieldsByType[keys[i]], writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim().ldelim();
          }
        return writer;
      };
      TracesAndStats.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };
      TracesAndStats.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.TracesAndStats(), key;
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.trace && message.trace.length))
                message.trace = [];
              message.trace.push($root.Trace.decode(reader, reader.uint32()));
              break;
            case 2:
              if (!(message.statsWithContext && message.statsWithContext.length))
                message.statsWithContext = [];
              message.statsWithContext.push($root.ContextualizedStats.decode(reader, reader.uint32()));
              break;
            case 4:
              reader.skip().pos++;
              if (message.referencedFieldsByType === $util.emptyObject)
                message.referencedFieldsByType = {};
              key = reader.string();
              reader.pos++;
              message.referencedFieldsByType[key] = $root.ReferencedFieldsForType.decode(reader, reader.uint32());
              break;
            case 3:
              if (!(message.internalTracesContributingToStats && message.internalTracesContributingToStats.length))
                message.internalTracesContributingToStats = [];
              message.internalTracesContributingToStats.push($root.Trace.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };
      TracesAndStats.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      TracesAndStats.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.trace != null && message.hasOwnProperty("trace")) {
          if (!Array.isArray(message.trace))
            return "trace: array expected";
          for (var i = 0; i < message.trace.length; ++i)
            if (!(message.trace[i] instanceof Uint8Array)) {
              var error = $root.Trace.verify(message.trace[i]);
              if (error)
                return "trace." + error;
            }
        }
        if (message.statsWithContext != null && message.hasOwnProperty("statsWithContext")) {
          var array2;
          if (message.statsWithContext != null && message.statsWithContext.toArray)
            array2 = message.statsWithContext.toArray();
          else
            array2 = message.statsWithContext;
          if (!Array.isArray(array2))
            return "statsWithContext: array expected";
          for (var i = 0; i < array2.length; ++i) {
            var error = $root.ContextualizedStats.verify(array2[i]);
            if (error)
              return "statsWithContext." + error;
          }
        }
        if (message.referencedFieldsByType != null && message.hasOwnProperty("referencedFieldsByType")) {
          if (!$util.isObject(message.referencedFieldsByType))
            return "referencedFieldsByType: object expected";
          var key = Object.keys(message.referencedFieldsByType);
          for (var i = 0; i < key.length; ++i) {
            var error = $root.ReferencedFieldsForType.verify(message.referencedFieldsByType[key[i]]);
            if (error)
              return "referencedFieldsByType." + error;
          }
        }
        if (message.internalTracesContributingToStats != null && message.hasOwnProperty("internalTracesContributingToStats")) {
          if (!Array.isArray(message.internalTracesContributingToStats))
            return "internalTracesContributingToStats: array expected";
          for (var i = 0; i < message.internalTracesContributingToStats.length; ++i)
            if (!(message.internalTracesContributingToStats[i] instanceof Uint8Array)) {
              var error = $root.Trace.verify(message.internalTracesContributingToStats[i]);
              if (error)
                return "internalTracesContributingToStats." + error;
            }
        }
        return null;
      };
      TracesAndStats.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.arrays || options.defaults) {
          object.trace = [];
          object.statsWithContext = [];
          object.internalTracesContributingToStats = [];
        }
        if (options.objects || options.defaults)
          object.referencedFieldsByType = {};
        if (message.trace && message.trace.length) {
          object.trace = [];
          for (var j = 0; j < message.trace.length; ++j)
            object.trace[j] = $root.Trace.toObject(message.trace[j], options);
        }
        if (message.statsWithContext && message.statsWithContext.length) {
          object.statsWithContext = [];
          for (var j = 0; j < message.statsWithContext.length; ++j)
            object.statsWithContext[j] = $root.ContextualizedStats.toObject(message.statsWithContext[j], options);
        }
        if (message.internalTracesContributingToStats && message.internalTracesContributingToStats.length) {
          object.internalTracesContributingToStats = [];
          for (var j = 0; j < message.internalTracesContributingToStats.length; ++j)
            object.internalTracesContributingToStats[j] = $root.Trace.toObject(message.internalTracesContributingToStats[j], options);
        }
        var keys2;
        if (message.referencedFieldsByType && (keys2 = Object.keys(message.referencedFieldsByType)).length) {
          object.referencedFieldsByType = {};
          for (var j = 0; j < keys2.length; ++j)
            object.referencedFieldsByType[keys2[j]] = $root.ReferencedFieldsForType.toObject(message.referencedFieldsByType[keys2[j]], options);
        }
        return object;
      };
      TracesAndStats.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      return TracesAndStats;
    }();
    $root.google = function() {
      var google = {};
      google.protobuf = function() {
        var protobuf = {};
        protobuf.Timestamp = function() {
          function Timestamp(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          Timestamp.prototype.seconds = 0;
          Timestamp.prototype.nanos = 0;
          Timestamp.create = function create(properties) {
            return new Timestamp(properties);
          };
          Timestamp.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.seconds != null && Object.hasOwnProperty.call(message, "seconds"))
              writer.uint32(
                /* id 1, wireType 0 =*/
                8
              ).int64(message.seconds);
            if (message.nanos != null && Object.hasOwnProperty.call(message, "nanos"))
              writer.uint32(
                /* id 2, wireType 0 =*/
                16
              ).int32(message.nanos);
            return writer;
          };
          Timestamp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          Timestamp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.google.protobuf.Timestamp();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.seconds = reader.int64();
                  break;
                case 2:
                  message.nanos = reader.int32();
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          Timestamp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          Timestamp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.seconds != null && message.hasOwnProperty("seconds")) {
              if (!$util.isInteger(message.seconds) && !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high)))
                return "seconds: integer|Long expected";
            }
            if (message.nanos != null && message.hasOwnProperty("nanos")) {
              if (!$util.isInteger(message.nanos))
                return "nanos: integer expected";
            }
            return null;
          };
          Timestamp.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults) {
              object.seconds = 0;
              object.nanos = 0;
            }
            if (message.seconds != null && message.hasOwnProperty("seconds"))
              if (typeof message.seconds === "number")
                object.seconds = options.longs === String ? String(message.seconds) : message.seconds;
              else
                object.seconds = options.longs === String ? $util.Long.prototype.toString.call(message.seconds) : options.longs === Number ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber() : message.seconds;
            if (message.nanos != null && message.hasOwnProperty("nanos"))
              object.nanos = message.nanos;
            return object;
          };
          Timestamp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return Timestamp;
        }();
        return protobuf;
      }();
      return google;
    }();
    module2.exports = $root;
  }
});

// ../../../node_modules/apollo-reporting-protobuf/generated/index.js
var require_generated = __commonJS({
  "../../../node_modules/apollo-reporting-protobuf/generated/index.js"(exports2, module2) {
    var protobuf = require_protobuf();
    var protobufJS = require_minimal2();
    protobufJS.util.Long = void 0;
    protobufJS.configure();
    module2.exports = protobuf;
  }
});

// ../../../node_modules/node-abort-controller/browser.js
var require_browser = __commonJS({
  "../../../node_modules/node-abort-controller/browser.js"(exports2, module2) {
    "use strict";
    var _global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : (
      /* otherwise */
      void 0
    );
    if (!_global) {
      throw new Error(
        `Unable to find global scope. Are you sure this is running in the browser?`
      );
    }
    if (!_global.AbortController) {
      throw new Error(
        `Could not find "AbortController" in the global scope. You need to polyfill it first`
      );
    }
    module2.exports.AbortController = _global.AbortController;
  }
});

// ../../../node_modules/yallist/iterator.js
var require_iterator = __commonJS({
  "../../../node_modules/yallist/iterator.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Yallist) {
      Yallist.prototype[Symbol.iterator] = function* () {
        for (let walker = this.head; walker; walker = walker.next) {
          yield walker.value;
        }
      };
    };
  }
});

// ../../../node_modules/yallist/yallist.js
var require_yallist = __commonJS({
  "../../../node_modules/yallist/yallist.js"(exports2, module2) {
    "use strict";
    module2.exports = Yallist;
    Yallist.Node = Node;
    Yallist.create = Yallist;
    function Yallist(list) {
      var self2 = this;
      if (!(self2 instanceof Yallist)) {
        self2 = new Yallist();
      }
      self2.tail = null;
      self2.head = null;
      self2.length = 0;
      if (list && typeof list.forEach === "function") {
        list.forEach(function(item) {
          self2.push(item);
        });
      } else if (arguments.length > 0) {
        for (var i = 0, l = arguments.length; i < l; i++) {
          self2.push(arguments[i]);
        }
      }
      return self2;
    }
    Yallist.prototype.removeNode = function(node) {
      if (node.list !== this) {
        throw new Error("removing node which does not belong to this list");
      }
      var next = node.next;
      var prev = node.prev;
      if (next) {
        next.prev = prev;
      }
      if (prev) {
        prev.next = next;
      }
      if (node === this.head) {
        this.head = next;
      }
      if (node === this.tail) {
        this.tail = prev;
      }
      node.list.length--;
      node.next = null;
      node.prev = null;
      node.list = null;
      return next;
    };
    Yallist.prototype.unshiftNode = function(node) {
      if (node === this.head) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var head = this.head;
      node.list = this;
      node.next = head;
      if (head) {
        head.prev = node;
      }
      this.head = node;
      if (!this.tail) {
        this.tail = node;
      }
      this.length++;
    };
    Yallist.prototype.pushNode = function(node) {
      if (node === this.tail) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var tail = this.tail;
      node.list = this;
      node.prev = tail;
      if (tail) {
        tail.next = node;
      }
      this.tail = node;
      if (!this.head) {
        this.head = node;
      }
      this.length++;
    };
    Yallist.prototype.push = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        push(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.unshift = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        unshift(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.pop = function() {
      if (!this.tail) {
        return void 0;
      }
      var res = this.tail.value;
      this.tail = this.tail.prev;
      if (this.tail) {
        this.tail.next = null;
      } else {
        this.head = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.shift = function() {
      if (!this.head) {
        return void 0;
      }
      var res = this.head.value;
      this.head = this.head.next;
      if (this.head) {
        this.head.prev = null;
      } else {
        this.tail = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.head, i = 0; walker !== null; i++) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.next;
      }
    };
    Yallist.prototype.forEachReverse = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.prev;
      }
    };
    Yallist.prototype.get = function(n) {
      for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
        walker = walker.next;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.getReverse = function(n) {
      for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
        walker = walker.prev;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.map = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.head; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.next;
      }
      return res;
    };
    Yallist.prototype.mapReverse = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.tail; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.prev;
      }
      return res;
    };
    Yallist.prototype.reduce = function(fn, initial) {
      var acc;
      var walker = this.head;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.head) {
        walker = this.head.next;
        acc = this.head.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = 0; walker !== null; i++) {
        acc = fn(acc, walker.value, i);
        walker = walker.next;
      }
      return acc;
    };
    Yallist.prototype.reduceReverse = function(fn, initial) {
      var acc;
      var walker = this.tail;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.tail) {
        walker = this.tail.prev;
        acc = this.tail.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = this.length - 1; walker !== null; i--) {
        acc = fn(acc, walker.value, i);
        walker = walker.prev;
      }
      return acc;
    };
    Yallist.prototype.toArray = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.head; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.next;
      }
      return arr;
    };
    Yallist.prototype.toArrayReverse = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.tail; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.prev;
      }
      return arr;
    };
    Yallist.prototype.slice = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
        walker = walker.next;
      }
      for (; walker !== null && i < to; i++, walker = walker.next) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.sliceReverse = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
        walker = walker.prev;
      }
      for (; walker !== null && i > from; i--, walker = walker.prev) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
      if (start > this.length) {
        start = this.length - 1;
      }
      if (start < 0) {
        start = this.length + start;
      }
      for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
        walker = walker.next;
      }
      var ret = [];
      for (var i = 0; walker && i < deleteCount; i++) {
        ret.push(walker.value);
        walker = this.removeNode(walker);
      }
      if (walker === null) {
        walker = this.tail;
      }
      if (walker !== this.head && walker !== this.tail) {
        walker = walker.prev;
      }
      for (var i = 0; i < nodes.length; i++) {
        walker = insert(this, walker, nodes[i]);
      }
      return ret;
    };
    Yallist.prototype.reverse = function() {
      var head = this.head;
      var tail = this.tail;
      for (var walker = head; walker !== null; walker = walker.prev) {
        var p = walker.prev;
        walker.prev = walker.next;
        walker.next = p;
      }
      this.head = tail;
      this.tail = head;
      return this;
    };
    function insert(self2, node, value) {
      var inserted = node === self2.head ? new Node(value, null, node, self2) : new Node(value, node, node.next, self2);
      if (inserted.next === null) {
        self2.tail = inserted;
      }
      if (inserted.prev === null) {
        self2.head = inserted;
      }
      self2.length++;
      return inserted;
    }
    function push(self2, item) {
      self2.tail = new Node(item, self2.tail, null, self2);
      if (!self2.head) {
        self2.head = self2.tail;
      }
      self2.length++;
    }
    function unshift(self2, item) {
      self2.head = new Node(item, null, self2.head, self2);
      if (!self2.tail) {
        self2.tail = self2.head;
      }
      self2.length++;
    }
    function Node(value, prev, next, list) {
      if (!(this instanceof Node)) {
        return new Node(value, prev, next, list);
      }
      this.list = list;
      this.value = value;
      if (prev) {
        prev.next = this;
        this.prev = prev;
      } else {
        this.prev = null;
      }
      if (next) {
        next.prev = this;
        this.next = next;
      } else {
        this.next = null;
      }
    }
    try {
      require_iterator()(Yallist);
    } catch (er) {
    }
  }
});

// ../../../node_modules/lru-cache/index.js
var require_lru_cache2 = __commonJS({
  "../../../node_modules/lru-cache/index.js"(exports2, module2) {
    "use strict";
    var Yallist = require_yallist();
    var MAX = Symbol("max");
    var LENGTH = Symbol("length");
    var LENGTH_CALCULATOR = Symbol("lengthCalculator");
    var ALLOW_STALE = Symbol("allowStale");
    var MAX_AGE = Symbol("maxAge");
    var DISPOSE = Symbol("dispose");
    var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
    var LRU_LIST = Symbol("lruList");
    var CACHE = Symbol("cache");
    var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
    var naiveLength = () => 1;
    var LRUCache = class {
      constructor(options) {
        if (typeof options === "number")
          options = { max: options };
        if (!options)
          options = {};
        if (options.max && (typeof options.max !== "number" || options.max < 0))
          throw new TypeError("max must be a non-negative number");
        const max = this[MAX] = options.max || Infinity;
        const lc = options.length || naiveLength;
        this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
        this[ALLOW_STALE] = options.stale || false;
        if (options.maxAge && typeof options.maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        this[MAX_AGE] = options.maxAge || 0;
        this[DISPOSE] = options.dispose;
        this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
        this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
        this.reset();
      }
      // resize the cache when the max changes.
      set max(mL) {
        if (typeof mL !== "number" || mL < 0)
          throw new TypeError("max must be a non-negative number");
        this[MAX] = mL || Infinity;
        trim(this);
      }
      get max() {
        return this[MAX];
      }
      set allowStale(allowStale) {
        this[ALLOW_STALE] = !!allowStale;
      }
      get allowStale() {
        return this[ALLOW_STALE];
      }
      set maxAge(mA) {
        if (typeof mA !== "number")
          throw new TypeError("maxAge must be a non-negative number");
        this[MAX_AGE] = mA;
        trim(this);
      }
      get maxAge() {
        return this[MAX_AGE];
      }
      // resize the cache when the lengthCalculator changes.
      set lengthCalculator(lC) {
        if (typeof lC !== "function")
          lC = naiveLength;
        if (lC !== this[LENGTH_CALCULATOR]) {
          this[LENGTH_CALCULATOR] = lC;
          this[LENGTH] = 0;
          this[LRU_LIST].forEach((hit) => {
            hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
            this[LENGTH] += hit.length;
          });
        }
        trim(this);
      }
      get lengthCalculator() {
        return this[LENGTH_CALCULATOR];
      }
      get length() {
        return this[LENGTH];
      }
      get itemCount() {
        return this[LRU_LIST].length;
      }
      rforEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].tail; walker !== null; ) {
          const prev = walker.prev;
          forEachStep(this, fn, walker, thisp);
          walker = prev;
        }
      }
      forEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].head; walker !== null; ) {
          const next = walker.next;
          forEachStep(this, fn, walker, thisp);
          walker = next;
        }
      }
      keys() {
        return this[LRU_LIST].toArray().map((k) => k.key);
      }
      values() {
        return this[LRU_LIST].toArray().map((k) => k.value);
      }
      reset() {
        if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
          this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
        }
        this[CACHE] = /* @__PURE__ */ new Map();
        this[LRU_LIST] = new Yallist();
        this[LENGTH] = 0;
      }
      dump() {
        return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
          k: hit.key,
          v: hit.value,
          e: hit.now + (hit.maxAge || 0)
        }).toArray().filter((h) => h);
      }
      dumpLru() {
        return this[LRU_LIST];
      }
      set(key, value, maxAge) {
        maxAge = maxAge || this[MAX_AGE];
        if (maxAge && typeof maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        const now = maxAge ? Date.now() : 0;
        const len = this[LENGTH_CALCULATOR](value, key);
        if (this[CACHE].has(key)) {
          if (len > this[MAX]) {
            del(this, this[CACHE].get(key));
            return false;
          }
          const node = this[CACHE].get(key);
          const item = node.value;
          if (this[DISPOSE]) {
            if (!this[NO_DISPOSE_ON_SET])
              this[DISPOSE](key, item.value);
          }
          item.now = now;
          item.maxAge = maxAge;
          item.value = value;
          this[LENGTH] += len - item.length;
          item.length = len;
          this.get(key);
          trim(this);
          return true;
        }
        const hit = new Entry(key, value, len, now, maxAge);
        if (hit.length > this[MAX]) {
          if (this[DISPOSE])
            this[DISPOSE](key, value);
          return false;
        }
        this[LENGTH] += hit.length;
        this[LRU_LIST].unshift(hit);
        this[CACHE].set(key, this[LRU_LIST].head);
        trim(this);
        return true;
      }
      has(key) {
        if (!this[CACHE].has(key))
          return false;
        const hit = this[CACHE].get(key).value;
        return !isStale(this, hit);
      }
      get(key) {
        return get(this, key, true);
      }
      peek(key) {
        return get(this, key, false);
      }
      pop() {
        const node = this[LRU_LIST].tail;
        if (!node)
          return null;
        del(this, node);
        return node.value;
      }
      del(key) {
        del(this, this[CACHE].get(key));
      }
      load(arr) {
        this.reset();
        const now = Date.now();
        for (let l = arr.length - 1; l >= 0; l--) {
          const hit = arr[l];
          const expiresAt = hit.e || 0;
          if (expiresAt === 0)
            this.set(hit.k, hit.v);
          else {
            const maxAge = expiresAt - now;
            if (maxAge > 0) {
              this.set(hit.k, hit.v, maxAge);
            }
          }
        }
      }
      prune() {
        this[CACHE].forEach((value, key) => get(this, key, false));
      }
    };
    var get = (self2, key, doUse) => {
      const node = self2[CACHE].get(key);
      if (node) {
        const hit = node.value;
        if (isStale(self2, hit)) {
          del(self2, node);
          if (!self2[ALLOW_STALE])
            return void 0;
        } else {
          if (doUse) {
            if (self2[UPDATE_AGE_ON_GET])
              node.value.now = Date.now();
            self2[LRU_LIST].unshiftNode(node);
          }
        }
        return hit.value;
      }
    };
    var isStale = (self2, hit) => {
      if (!hit || !hit.maxAge && !self2[MAX_AGE])
        return false;
      const diff2 = Date.now() - hit.now;
      return hit.maxAge ? diff2 > hit.maxAge : self2[MAX_AGE] && diff2 > self2[MAX_AGE];
    };
    var trim = (self2) => {
      if (self2[LENGTH] > self2[MAX]) {
        for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
          const prev = walker.prev;
          del(self2, walker);
          walker = prev;
        }
      }
    };
    var del = (self2, node) => {
      if (node) {
        const hit = node.value;
        if (self2[DISPOSE])
          self2[DISPOSE](hit.key, hit.value);
        self2[LENGTH] -= hit.length;
        self2[CACHE].delete(hit.key);
        self2[LRU_LIST].removeNode(node);
      }
    };
    var Entry = class {
      constructor(key, value, length, now, maxAge) {
        this.key = key;
        this.value = value;
        this.length = length;
        this.now = now;
        this.maxAge = maxAge || 0;
      }
    };
    var forEachStep = (self2, fn, node, thisp) => {
      let hit = node.value;
      if (isStale(self2, hit)) {
        del(self2, node);
        if (!self2[ALLOW_STALE])
          hit = void 0;
      }
      if (hit)
        fn.call(thisp, hit.value, hit.key, self2);
    };
    module2.exports = LRUCache;
  }
});

// ../../../node_modules/apollo-server-core/dist/plugin/usageReporting/operationDerivedDataCache.js
var require_operationDerivedDataCache = __commonJS({
  "../../../node_modules/apollo-server-core/dist/plugin/usageReporting/operationDerivedDataCache.js"(exports2) {
    "use strict";
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.operationDerivedDataCacheKey = exports2.createOperationDerivedDataCache = void 0;
    var lru_cache_1 = __importDefault2(require_lru_cache2());
    function createOperationDerivedDataCache({ logger }) {
      let lastWarn;
      let lastDisposals = 0;
      return new lru_cache_1.default({
        length(obj) {
          return Buffer.byteLength(JSON.stringify(obj), "utf8");
        },
        max: Math.pow(2, 20) * 10,
        dispose() {
          lastDisposals++;
          if (!lastWarn || (/* @__PURE__ */ new Date()).getTime() - lastWarn.getTime() > 6e4) {
            lastWarn = /* @__PURE__ */ new Date();
            logger.warn([
              "This server is processing a high number of unique operations.  ",
              `A total of ${lastDisposals} records have been `,
              "ejected from the ApolloServerPluginUsageReporting signature cache in the past ",
              "interval.  If you see this warning frequently, please open an ",
              "issue on the Apollo Server repository."
            ].join(""));
            lastDisposals = 0;
          }
        }
      });
    }
    exports2.createOperationDerivedDataCache = createOperationDerivedDataCache;
    function operationDerivedDataCacheKey(queryHash, operationName) {
      return `${queryHash}${operationName && ":" + operationName}`;
    }
    exports2.operationDerivedDataCacheKey = operationDerivedDataCacheKey;
  }
});

// ../../../node_modules/@apollo/protobufjs/src/util/longbits.js
var require_longbits2 = __commonJS({
  "../../../node_modules/@apollo/protobufjs/src/util/longbits.js"(exports2, module2) {
    "use strict";
    module2.exports = LongBits;
    var util = require_minimal3();
    function LongBits(lo, hi) {
      this.lo = lo >>> 0;
      this.hi = hi >>> 0;
    }
    var zero = LongBits.zero = new LongBits(0, 0);
    zero.toNumber = function() {
      return 0;
    };
    zero.zzEncode = zero.zzDecode = function() {
      return this;
    };
    zero.length = function() {
      return 1;
    };
    var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
    LongBits.fromNumber = function fromNumber(value) {
      if (value === 0)
        return zero;
      var sign = value < 0;
      if (sign)
        value = -value;
      var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
      if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
          lo = 0;
          if (++hi > 4294967295)
            hi = 0;
        }
      }
      return new LongBits(lo, hi);
    };
    LongBits.from = function from(value) {
      if (typeof value === "number")
        return LongBits.fromNumber(value);
      if (util.isString(value)) {
        if (util.Long)
          value = util.Long.fromString(value);
        else
          return LongBits.fromNumber(parseInt(value, 10));
      }
      return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
    };
    LongBits.prototype.toNumber = function toNumber(unsigned) {
      if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
        if (!lo)
          hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
    };
    LongBits.prototype.toLong = function toLong(unsigned) {
      return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
    };
    var charCodeAt = String.prototype.charCodeAt;
    LongBits.fromHash = function fromHash(hash) {
      if (hash === zeroHash)
        return zero;
      return new LongBits(
        (charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0,
        (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0
      );
    };
    LongBits.prototype.toHash = function toHash() {
      return String.fromCharCode(
        this.lo & 255,
        this.lo >>> 8 & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24,
        this.hi & 255,
        this.hi >>> 8 & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
      );
    };
    LongBits.prototype.zzEncode = function zzEncode() {
      var mask = this.hi >> 31;
      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
      this.lo = (this.lo << 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.zzDecode = function zzDecode() {
      var mask = -(this.lo & 1);
      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
      this.hi = (this.hi >>> 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.length = function length() {
      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    };
  }
});

// ../../../node_modules/@apollo/protobufjs/src/util/minimal.js
var require_minimal3 = __commonJS({
  "../../../node_modules/@apollo/protobufjs/src/util/minimal.js"(exports2) {
    "use strict";
    var util = exports2;
    util.asPromise = require_aspromise();
    util.base64 = require_base64();
    util.EventEmitter = require_eventemitter();
    util.float = require_float();
    util.inquire = require_inquire();
    util.utf8 = require_utf8();
    util.pool = require_pool();
    util.LongBits = require_longbits2();
    util.global = typeof window !== "undefined" && window || typeof global !== "undefined" && global || typeof self !== "undefined" && self || exports2;
    util.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    );
    util.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    );
    util.isNode = Boolean(util.global.process && util.global.process.versions && util.global.process.versions.node);
    util.isInteger = Number.isInteger || /* istanbul ignore next */
    function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    };
    util.isString = function isString(value) {
      return typeof value === "string" || value instanceof String;
    };
    util.isObject = function isObject(value) {
      return value && typeof value === "object";
    };
    util.isset = /**
     * Checks if a property on a message is considered to be present.
     * @param {Object} obj Plain object or message instance
     * @param {string} prop Property name
     * @returns {boolean} `true` if considered to be present, otherwise `false`
     */
    util.isSet = function isSet(obj, prop) {
      var value = obj[prop];
      if (value != null && obj.hasOwnProperty(prop))
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
      return false;
    };
    util.Buffer = function() {
      try {
        var Buffer2 = util.inquire("buffer").Buffer;
        return Buffer2.prototype.utf8Write ? Buffer2 : (
          /* istanbul ignore next */
          null
        );
      } catch (e) {
        return null;
      }
    }();
    util._Buffer_from = null;
    util._Buffer_allocUnsafe = null;
    util.newBuffer = function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    };
    util.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util.Long = typeof process === "undefined" || process.env.ENABLE_LONG ? (
      /* istanbul ignore next */
      util.global.dcodeIO && /* istanbul ignore next */
      util.global.dcodeIO.Long || /* istanbul ignore next */
      util.global.Long || util.inquire("long")
    ) : void 0;
    util.key2Re = /^true|false|0|1$/;
    util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util.longToHash = function longToHash(value) {
      return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
    };
    util.longFromHash = function longFromHash(hash, unsigned) {
      var bits = util.LongBits.fromHash(hash);
      if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
      return bits.toNumber(Boolean(unsigned));
    };
    function merge(dst, src, ifNotSet) {
      for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === void 0 || !ifNotSet)
          dst[keys[i]] = src[keys[i]];
      return dst;
    }
    util.merge = merge;
    util.lcFirst = function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    };
    function newError(name) {
      function CustomError(message, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message, properties);
        Object.defineProperty(this, "message", { get: function() {
          return message;
        } });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge(this, properties);
      }
      (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;
      Object.defineProperty(CustomError.prototype, "name", { get: function() {
        return name;
      } });
      CustomError.prototype.toString = function toString() {
        return this.name + ": " + this.message;
      };
      return CustomError;
    }
    util.newError = newError;
    util.ProtocolError = newError("ProtocolError");
    util.oneOfGetter = function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;
      return function() {
        for (var keys = Object.keys(this), i2 = keys.length - 1; i2 > -1; --i2)
          if (fieldMap[keys[i2]] === 1 && this[keys[i2]] !== void 0 && this[keys[i2]] !== null)
            return keys[i2];
      };
    };
    util.oneOfSetter = function setOneOf(fieldNames) {
      return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
          if (fieldNames[i] !== name)
            delete this[fieldNames[i]];
      };
    };
    util.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util._configure = function() {
      var Buffer2 = util.Buffer;
      if (!Buffer2) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
      }
      util._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || /* istanbul ignore next */
      function Buffer_from(value, encoding) {
        return new Buffer2(value, encoding);
      };
      util._Buffer_allocUnsafe = Buffer2.allocUnsafe || /* istanbul ignore next */
      function Buffer_allocUnsafe(size) {
        return new Buffer2(size);
      };
    };
  }
});

// ../../../node_modules/@apollo/protobufjs/src/writer.js
var require_writer2 = __commonJS({
  "../../../node_modules/@apollo/protobufjs/src/writer.js"(exports2, module2) {
    "use strict";
    module2.exports = Writer;
    var util = require_minimal3();
    var BufferWriter;
    var LongBits = util.LongBits;
    var base64 = util.base64;
    var utf8 = util.utf8;
    function Op(fn, len, val) {
      this.fn = fn;
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    function noop() {
    }
    function State(writer) {
      this.head = writer.head;
      this.tail = writer.tail;
      this.len = writer.len;
      this.next = writer.states;
    }
    function Writer() {
      this.len = 0;
      this.head = new Op(noop, 0, 0);
      this.tail = this.head;
      this.states = null;
    }
    Writer.create = util.Buffer ? function create_buffer_setup() {
      return (Writer.create = function create_buffer() {
        return new BufferWriter();
      })();
    } : function create_array() {
      return new Writer();
    };
    Writer.alloc = function alloc(size) {
      return new util.Array(size);
    };
    if (util.Array !== Array)
      Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);
    Writer.prototype._push = function push(fn, len, val) {
      this.tail = this.tail.next = new Op(fn, len, val);
      this.len += len;
      return this;
    };
    function writeByte(val, buf, pos) {
      buf[pos] = val & 255;
    }
    function writeVarint32(val, buf, pos) {
      while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
      }
      buf[pos] = val;
    }
    function VarintOp(len, val) {
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    VarintOp.prototype = Object.create(Op.prototype);
    VarintOp.prototype.fn = writeVarint32;
    Writer.prototype.uint32 = function write_uint32(value) {
      this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,
        value
      )).len;
      return this;
    };
    Writer.prototype.int32 = function write_int32(value) {
      return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
    };
    Writer.prototype.sint32 = function write_sint32(value) {
      return this.uint32((value << 1 ^ value >> 31) >>> 0);
    };
    function writeVarint64(val, buf, pos) {
      while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
      }
      while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
      }
      buf[pos++] = val.lo;
    }
    Writer.prototype.uint64 = function write_uint64(value) {
      var bits = LongBits.from(value);
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.int64 = Writer.prototype.uint64;
    Writer.prototype.sint64 = function write_sint64(value) {
      var bits = LongBits.from(value).zzEncode();
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.bool = function write_bool(value) {
      return this._push(writeByte, 1, value ? 1 : 0);
    };
    function writeFixed32(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    Writer.prototype.fixed32 = function write_fixed32(value) {
      return this._push(writeFixed32, 4, value >>> 0);
    };
    Writer.prototype.sfixed32 = Writer.prototype.fixed32;
    Writer.prototype.fixed64 = function write_fixed64(value) {
      var bits = LongBits.from(value);
      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
    };
    Writer.prototype.sfixed64 = Writer.prototype.fixed64;
    Writer.prototype.float = function write_float(value) {
      return this._push(util.float.writeFloatLE, 4, value);
    };
    Writer.prototype.double = function write_double(value) {
      return this._push(util.float.writeDoubleLE, 8, value);
    };
    var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
      buf.set(val, pos);
    } : function writeBytes_for(val, buf, pos) {
      for (var i = 0; i < val.length; ++i)
        buf[pos + i] = val[i];
    };
    Writer.prototype.bytes = function write_bytes(value) {
      var len = value.length >>> 0;
      if (!len)
        return this._push(writeByte, 1, 0);
      if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
      }
      return this.uint32(len)._push(writeBytes, len, value);
    };
    Writer.prototype.string = function write_string(value) {
      var len = utf8.length(value);
      return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
    };
    Writer.prototype.fork = function fork() {
      this.states = new State(this);
      this.head = this.tail = new Op(noop, 0, 0);
      this.len = 0;
      return this;
    };
    Writer.prototype.reset = function reset() {
      if (this.states) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
      } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len = 0;
      }
      return this;
    };
    Writer.prototype.ldelim = function ldelim() {
      var head = this.head, tail = this.tail, len = this.len;
      this.reset().uint32(len);
      if (len) {
        this.tail.next = head.next;
        this.tail = tail;
        this.len += len;
      }
      return this;
    };
    Writer.prototype.finish = function finish() {
      var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
      while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
      }
      return buf;
    };
    Writer._configure = function(BufferWriter_) {
      BufferWriter = BufferWriter_;
    };
  }
});

// ../../../node_modules/@apollo/protobufjs/src/writer_buffer.js
var require_writer_buffer2 = __commonJS({
  "../../../node_modules/@apollo/protobufjs/src/writer_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferWriter;
    var Writer = require_writer2();
    (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
    var util = require_minimal3();
    var Buffer2 = util.Buffer;
    function BufferWriter() {
      Writer.call(this);
    }
    BufferWriter.alloc = function alloc_buffer(size) {
      return (BufferWriter.alloc = util._Buffer_allocUnsafe)(size);
    };
    var writeBytesBuffer = Buffer2 && Buffer2.prototype instanceof Uint8Array && Buffer2.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
      buf.set(val, pos);
    } : function writeBytesBuffer_copy(val, buf, pos) {
      if (val.copy)
        val.copy(buf, pos, 0, val.length);
      else
        for (var i = 0; i < val.length; )
          buf[pos++] = val[i++];
    };
    BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
      if (util.isString(value))
        value = util._Buffer_from(value, "base64");
      var len = value.length >>> 0;
      this.uint32(len);
      if (len)
        this._push(writeBytesBuffer, len, value);
      return this;
    };
    function writeStringBuffer(val, buf, pos) {
      if (val.length < 40)
        util.utf8.write(val, buf, pos);
      else
        buf.utf8Write(val, pos);
    }
    BufferWriter.prototype.string = function write_string_buffer(value) {
      var len = Buffer2.byteLength(value);
      this.uint32(len);
      if (len)
        this._push(writeStringBuffer, len, value);
      return this;
    };
  }
});

// ../../../node_modules/@apollo/protobufjs/src/reader.js
var require_reader2 = __commonJS({
  "../../../node_modules/@apollo/protobufjs/src/reader.js"(exports2, module2) {
    "use strict";
    module2.exports = Reader;
    var util = require_minimal3();
    var BufferReader;
    var LongBits = util.LongBits;
    var utf8 = util.utf8;
    function indexOutOfRange(reader, writeLength) {
      return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
    }
    function Reader(buffer) {
      this.buf = buffer;
      this.pos = 0;
      this.len = buffer.length;
    }
    var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer) {
      if (buffer instanceof Uint8Array || Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    } : function create_array2(buffer) {
      if (Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    };
    Reader.create = util.Buffer ? function create_buffer_setup(buffer) {
      return (Reader.create = function create_buffer(buffer2) {
        return util.Buffer.isBuffer(buffer2) ? new BufferReader(buffer2) : create_array(buffer2);
      })(buffer);
    } : create_array;
    Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */
    util.Array.prototype.slice;
    Reader.prototype.uint32 = /* @__PURE__ */ function read_uint32_setup() {
      var value = 4294967295;
      return function read_uint32() {
        value = (this.buf[this.pos] & 127) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        if ((this.pos += 5) > this.len) {
          this.pos = this.len;
          throw indexOutOfRange(this, 10);
        }
        return value;
      };
    }();
    Reader.prototype.int32 = function read_int32() {
      return this.uint32() | 0;
    };
    Reader.prototype.sint32 = function read_sint32() {
      var value = this.uint32();
      return value >>> 1 ^ -(value & 1) | 0;
    };
    function readLongVarint() {
      var bits = new LongBits(0, 0);
      var i = 0;
      if (this.len - this.pos > 4) {
        for (; i < 4; ++i) {
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
        i = 0;
      } else {
        for (; i < 3; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
      }
      if (this.len - this.pos > 4) {
        for (; i < 5; ++i) {
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      } else {
        for (; i < 5; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      }
      throw Error("invalid varint encoding");
    }
    Reader.prototype.bool = function read_bool() {
      return this.uint32() !== 0;
    };
    function readFixed32_end(buf, end) {
      return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
    }
    Reader.prototype.fixed32 = function read_fixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4);
    };
    Reader.prototype.sfixed32 = function read_sfixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4) | 0;
    };
    function readFixed64() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);
      return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
    }
    Reader.prototype.float = function read_float() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readFloatLE(this.buf, this.pos);
      this.pos += 4;
      return value;
    };
    Reader.prototype.double = function read_double() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readDoubleLE(this.buf, this.pos);
      this.pos += 8;
      return value;
    };
    Reader.prototype.bytes = function read_bytes() {
      var length = this.uint32(), start = this.pos, end = this.pos + length;
      if (end > this.len)
        throw indexOutOfRange(this, length);
      this.pos += length;
      if (Array.isArray(this.buf))
        return this.buf.slice(start, end);
      return start === end ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end);
    };
    Reader.prototype.string = function read_string() {
      var bytes = this.bytes();
      return utf8.read(bytes, 0, bytes.length);
    };
    Reader.prototype.skip = function skip(length) {
      if (typeof length === "number") {
        if (this.pos + length > this.len)
          throw indexOutOfRange(this, length);
        this.pos += length;
      } else {
        do {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
      }
      return this;
    };
    Reader.prototype.skipType = function(wireType) {
      switch (wireType) {
        case 0:
          this.skip();
          break;
        case 1:
          this.skip(8);
          break;
        case 2:
          this.skip(this.uint32());
          break;
        case 3:
          while ((wireType = this.uint32() & 7) !== 4) {
            this.skipType(wireType);
          }
          break;
        case 5:
          this.skip(4);
          break;
        default:
          throw Error("invalid wire type " + wireType + " at offset " + this.pos);
      }
      return this;
    };
    Reader._configure = function(BufferReader_) {
      BufferReader = BufferReader_;
      var fn = util.Long ? "toLong" : (
        /* istanbul ignore next */
        "toNumber"
      );
      util.merge(Reader.prototype, {
        int64: function read_int64() {
          return readLongVarint.call(this)[fn](false);
        },
        uint64: function read_uint64() {
          return readLongVarint.call(this)[fn](true);
        },
        sint64: function read_sint64() {
          return readLongVarint.call(this).zzDecode()[fn](false);
        },
        fixed64: function read_fixed64() {
          return readFixed64.call(this)[fn](true);
        },
        sfixed64: function read_sfixed64() {
          return readFixed64.call(this)[fn](false);
        }
      });
    };
  }
});

// ../../../node_modules/@apollo/protobufjs/src/reader_buffer.js
var require_reader_buffer2 = __commonJS({
  "../../../node_modules/@apollo/protobufjs/src/reader_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferReader;
    var Reader = require_reader2();
    (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
    var util = require_minimal3();
    function BufferReader(buffer) {
      Reader.call(this, buffer);
    }
    if (util.Buffer)
      BufferReader.prototype._slice = util.Buffer.prototype.slice;
    BufferReader.prototype.string = function read_string_buffer() {
      var len = this.uint32();
      return this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len));
    };
  }
});

// ../../../node_modules/@apollo/protobufjs/src/rpc/service.js
var require_service2 = __commonJS({
  "../../../node_modules/@apollo/protobufjs/src/rpc/service.js"(exports2, module2) {
    "use strict";
    module2.exports = Service;
    var util = require_minimal3();
    (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
    function Service(rpcImpl, requestDelimited, responseDelimited) {
      if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");
      util.EventEmitter.call(this);
      this.rpcImpl = rpcImpl;
      this.requestDelimited = Boolean(requestDelimited);
      this.responseDelimited = Boolean(responseDelimited);
    }
    Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
      if (!request)
        throw TypeError("request must be specified");
      var self2 = this;
      if (!callback)
        return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
      if (!self2.rpcImpl) {
        setTimeout(function() {
          callback(Error("already ended"));
        }, 0);
        return void 0;
      }
      try {
        return self2.rpcImpl(
          method,
          requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
          function rpcCallback(err, response) {
            if (err) {
              self2.emit("error", err, method);
              return callback(err);
            }
            if (response === null) {
              self2.end(
                /* endedByRPC */
                true
              );
              return void 0;
            }
            if (!(response instanceof responseCtor)) {
              try {
                response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
              } catch (err2) {
                self2.emit("error", err2, method);
                return callback(err2);
              }
            }
            self2.emit("data", response, method);
            return callback(null, response);
          }
        );
      } catch (err) {
        self2.emit("error", err, method);
        setTimeout(function() {
          callback(err);
        }, 0);
        return void 0;
      }
    };
    Service.prototype.end = function end(endedByRPC) {
      if (this.rpcImpl) {
        if (!endedByRPC)
          this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
      }
      return this;
    };
  }
});

// ../../../node_modules/@apollo/protobufjs/src/rpc.js
var require_rpc2 = __commonJS({
  "../../../node_modules/@apollo/protobufjs/src/rpc.js"(exports2) {
    "use strict";
    var rpc = exports2;
    rpc.Service = require_service2();
  }
});

// ../../../node_modules/@apollo/protobufjs/src/roots.js
var require_roots2 = __commonJS({
  "../../../node_modules/@apollo/protobufjs/src/roots.js"(exports2, module2) {
    "use strict";
    module2.exports = {};
  }
});

// ../../../node_modules/@apollo/protobufjs/src/index-minimal.js
var require_index_minimal2 = __commonJS({
  "../../../node_modules/@apollo/protobufjs/src/index-minimal.js"(exports2) {
    "use strict";
    var protobuf = exports2;
    protobuf.build = "minimal";
    protobuf.Writer = require_writer2();
    protobuf.BufferWriter = require_writer_buffer2();
    protobuf.Reader = require_reader2();
    protobuf.BufferReader = require_reader_buffer2();
    protobuf.util = require_minimal3();
    protobuf.rpc = require_rpc2();
    protobuf.roots = require_roots2();
    protobuf.configure = configure;
    function configure() {
      protobuf.Reader._configure(protobuf.BufferReader);
      protobuf.util._configure();
    }
    protobuf.Writer._configure(protobuf.BufferWriter);
    configure();
  }
});

// ../../../node_modules/@apollo/protobufjs/minimal.js
var require_minimal4 = __commonJS({
  "../../../node_modules/@apollo/protobufjs/minimal.js"(exports2, module2) {
    "use strict";
    module2.exports = require_index_minimal2();
  }
});

// ../../../node_modules/@apollo/usage-reporting-protobuf/generated/cjs/protobuf.js
var require_protobuf2 = __commonJS({
  "../../../node_modules/@apollo/usage-reporting-protobuf/generated/cjs/protobuf.js"(exports2, module2) {
    "use strict";
    var $protobuf = require_minimal4();
    var $Reader = $protobuf.Reader;
    var $Writer = $protobuf.Writer;
    var $util = $protobuf.util;
    var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
    $root.Trace = function() {
      function Trace(properties) {
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      Trace.prototype.startTime = null;
      Trace.prototype.endTime = null;
      Trace.prototype.durationNs = 0;
      Trace.prototype.root = null;
      Trace.prototype.isIncomplete = false;
      Trace.prototype.signature = "";
      Trace.prototype.unexecutedOperationBody = "";
      Trace.prototype.unexecutedOperationName = "";
      Trace.prototype.details = null;
      Trace.prototype.clientName = "";
      Trace.prototype.clientVersion = "";
      Trace.prototype.http = null;
      Trace.prototype.cachePolicy = null;
      Trace.prototype.queryPlan = null;
      Trace.prototype.fullQueryCacheHit = false;
      Trace.prototype.persistedQueryHit = false;
      Trace.prototype.persistedQueryRegister = false;
      Trace.prototype.registeredOperation = false;
      Trace.prototype.forbiddenOperation = false;
      Trace.prototype.fieldExecutionWeight = 0;
      Trace.create = function create(properties) {
        return new Trace(properties);
      };
      Trace.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.endTime != null && Object.hasOwnProperty.call(message, "endTime"))
          $root.google.protobuf.Timestamp.encode(message.endTime, writer.uint32(
            /* id 3, wireType 2 =*/
            26
          ).fork()).ldelim();
        if (message.startTime != null && Object.hasOwnProperty.call(message, "startTime"))
          $root.google.protobuf.Timestamp.encode(message.startTime, writer.uint32(
            /* id 4, wireType 2 =*/
            34
          ).fork()).ldelim();
        if (message.details != null && Object.hasOwnProperty.call(message, "details"))
          $root.Trace.Details.encode(message.details, writer.uint32(
            /* id 6, wireType 2 =*/
            50
          ).fork()).ldelim();
        if (message.clientName != null && Object.hasOwnProperty.call(message, "clientName"))
          writer.uint32(
            /* id 7, wireType 2 =*/
            58
          ).string(message.clientName);
        if (message.clientVersion != null && Object.hasOwnProperty.call(message, "clientVersion"))
          writer.uint32(
            /* id 8, wireType 2 =*/
            66
          ).string(message.clientVersion);
        if (message.http != null && Object.hasOwnProperty.call(message, "http"))
          $root.Trace.HTTP.encode(message.http, writer.uint32(
            /* id 10, wireType 2 =*/
            82
          ).fork()).ldelim();
        if (message.durationNs != null && Object.hasOwnProperty.call(message, "durationNs"))
          writer.uint32(
            /* id 11, wireType 0 =*/
            88
          ).uint64(message.durationNs);
        if (message.root != null && Object.hasOwnProperty.call(message, "root"))
          $root.Trace.Node.encode(message.root, writer.uint32(
            /* id 14, wireType 2 =*/
            114
          ).fork()).ldelim();
        if (message.cachePolicy != null && Object.hasOwnProperty.call(message, "cachePolicy"))
          $root.Trace.CachePolicy.encode(message.cachePolicy, writer.uint32(
            /* id 18, wireType 2 =*/
            146
          ).fork()).ldelim();
        if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
          writer.uint32(
            /* id 19, wireType 2 =*/
            154
          ).string(message.signature);
        if (message.fullQueryCacheHit != null && Object.hasOwnProperty.call(message, "fullQueryCacheHit"))
          writer.uint32(
            /* id 20, wireType 0 =*/
            160
          ).bool(message.fullQueryCacheHit);
        if (message.persistedQueryHit != null && Object.hasOwnProperty.call(message, "persistedQueryHit"))
          writer.uint32(
            /* id 21, wireType 0 =*/
            168
          ).bool(message.persistedQueryHit);
        if (message.persistedQueryRegister != null && Object.hasOwnProperty.call(message, "persistedQueryRegister"))
          writer.uint32(
            /* id 22, wireType 0 =*/
            176
          ).bool(message.persistedQueryRegister);
        if (message.registeredOperation != null && Object.hasOwnProperty.call(message, "registeredOperation"))
          writer.uint32(
            /* id 24, wireType 0 =*/
            192
          ).bool(message.registeredOperation);
        if (message.forbiddenOperation != null && Object.hasOwnProperty.call(message, "forbiddenOperation"))
          writer.uint32(
            /* id 25, wireType 0 =*/
            200
          ).bool(message.forbiddenOperation);
        if (message.queryPlan != null && Object.hasOwnProperty.call(message, "queryPlan"))
          $root.Trace.QueryPlanNode.encode(message.queryPlan, writer.uint32(
            /* id 26, wireType 2 =*/
            210
          ).fork()).ldelim();
        if (message.unexecutedOperationBody != null && Object.hasOwnProperty.call(message, "unexecutedOperationBody"))
          writer.uint32(
            /* id 27, wireType 2 =*/
            218
          ).string(message.unexecutedOperationBody);
        if (message.unexecutedOperationName != null && Object.hasOwnProperty.call(message, "unexecutedOperationName"))
          writer.uint32(
            /* id 28, wireType 2 =*/
            226
          ).string(message.unexecutedOperationName);
        if (message.fieldExecutionWeight != null && Object.hasOwnProperty.call(message, "fieldExecutionWeight"))
          writer.uint32(
            /* id 31, wireType 1 =*/
            249
          ).double(message.fieldExecutionWeight);
        if (message.isIncomplete != null && Object.hasOwnProperty.call(message, "isIncomplete"))
          writer.uint32(
            /* id 33, wireType 0 =*/
            264
          ).bool(message.isIncomplete);
        return writer;
      };
      Trace.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };
      Trace.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace();
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 4:
              message.startTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
              break;
            case 3:
              message.endTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
              break;
            case 11:
              message.durationNs = reader.uint64();
              break;
            case 14:
              message.root = $root.Trace.Node.decode(reader, reader.uint32());
              break;
            case 33:
              message.isIncomplete = reader.bool();
              break;
            case 19:
              message.signature = reader.string();
              break;
            case 27:
              message.unexecutedOperationBody = reader.string();
              break;
            case 28:
              message.unexecutedOperationName = reader.string();
              break;
            case 6:
              message.details = $root.Trace.Details.decode(reader, reader.uint32());
              break;
            case 7:
              message.clientName = reader.string();
              break;
            case 8:
              message.clientVersion = reader.string();
              break;
            case 10:
              message.http = $root.Trace.HTTP.decode(reader, reader.uint32());
              break;
            case 18:
              message.cachePolicy = $root.Trace.CachePolicy.decode(reader, reader.uint32());
              break;
            case 26:
              message.queryPlan = $root.Trace.QueryPlanNode.decode(reader, reader.uint32());
              break;
            case 20:
              message.fullQueryCacheHit = reader.bool();
              break;
            case 21:
              message.persistedQueryHit = reader.bool();
              break;
            case 22:
              message.persistedQueryRegister = reader.bool();
              break;
            case 24:
              message.registeredOperation = reader.bool();
              break;
            case 25:
              message.forbiddenOperation = reader.bool();
              break;
            case 31:
              message.fieldExecutionWeight = reader.double();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };
      Trace.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      Trace.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.startTime != null && message.hasOwnProperty("startTime")) {
          var error = $root.google.protobuf.Timestamp.verify(message.startTime);
          if (error)
            return "startTime." + error;
        }
        if (message.endTime != null && message.hasOwnProperty("endTime")) {
          var error = $root.google.protobuf.Timestamp.verify(message.endTime);
          if (error)
            return "endTime." + error;
        }
        if (message.durationNs != null && message.hasOwnProperty("durationNs")) {
          if (!$util.isInteger(message.durationNs) && !(message.durationNs && $util.isInteger(message.durationNs.low) && $util.isInteger(message.durationNs.high)))
            return "durationNs: integer|Long expected";
        }
        if (message.root != null && message.hasOwnProperty("root")) {
          var error = $root.Trace.Node.verify(message.root);
          if (error)
            return "root." + error;
        }
        if (message.isIncomplete != null && message.hasOwnProperty("isIncomplete")) {
          if (typeof message.isIncomplete !== "boolean")
            return "isIncomplete: boolean expected";
        }
        if (message.signature != null && message.hasOwnProperty("signature")) {
          if (!$util.isString(message.signature))
            return "signature: string expected";
        }
        if (message.unexecutedOperationBody != null && message.hasOwnProperty("unexecutedOperationBody")) {
          if (!$util.isString(message.unexecutedOperationBody))
            return "unexecutedOperationBody: string expected";
        }
        if (message.unexecutedOperationName != null && message.hasOwnProperty("unexecutedOperationName")) {
          if (!$util.isString(message.unexecutedOperationName))
            return "unexecutedOperationName: string expected";
        }
        if (message.details != null && message.hasOwnProperty("details")) {
          var error = $root.Trace.Details.verify(message.details);
          if (error)
            return "details." + error;
        }
        if (message.clientName != null && message.hasOwnProperty("clientName")) {
          if (!$util.isString(message.clientName))
            return "clientName: string expected";
        }
        if (message.clientVersion != null && message.hasOwnProperty("clientVersion")) {
          if (!$util.isString(message.clientVersion))
            return "clientVersion: string expected";
        }
        if (message.http != null && message.hasOwnProperty("http")) {
          var error = $root.Trace.HTTP.verify(message.http);
          if (error)
            return "http." + error;
        }
        if (message.cachePolicy != null && message.hasOwnProperty("cachePolicy")) {
          var error = $root.Trace.CachePolicy.verify(message.cachePolicy);
          if (error)
            return "cachePolicy." + error;
        }
        if (message.queryPlan != null && message.hasOwnProperty("queryPlan")) {
          var error = $root.Trace.QueryPlanNode.verify(message.queryPlan);
          if (error)
            return "queryPlan." + error;
        }
        if (message.fullQueryCacheHit != null && message.hasOwnProperty("fullQueryCacheHit")) {
          if (typeof message.fullQueryCacheHit !== "boolean")
            return "fullQueryCacheHit: boolean expected";
        }
        if (message.persistedQueryHit != null && message.hasOwnProperty("persistedQueryHit")) {
          if (typeof message.persistedQueryHit !== "boolean")
            return "persistedQueryHit: boolean expected";
        }
        if (message.persistedQueryRegister != null && message.hasOwnProperty("persistedQueryRegister")) {
          if (typeof message.persistedQueryRegister !== "boolean")
            return "persistedQueryRegister: boolean expected";
        }
        if (message.registeredOperation != null && message.hasOwnProperty("registeredOperation")) {
          if (typeof message.registeredOperation !== "boolean")
            return "registeredOperation: boolean expected";
        }
        if (message.forbiddenOperation != null && message.hasOwnProperty("forbiddenOperation")) {
          if (typeof message.forbiddenOperation !== "boolean")
            return "forbiddenOperation: boolean expected";
        }
        if (message.fieldExecutionWeight != null && message.hasOwnProperty("fieldExecutionWeight")) {
          if (typeof message.fieldExecutionWeight !== "number")
            return "fieldExecutionWeight: number expected";
        }
        return null;
      };
      Trace.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.defaults) {
          object.endTime = null;
          object.startTime = null;
          object.details = null;
          object.clientName = "";
          object.clientVersion = "";
          object.http = null;
          object.durationNs = 0;
          object.root = null;
          object.cachePolicy = null;
          object.signature = "";
          object.fullQueryCacheHit = false;
          object.persistedQueryHit = false;
          object.persistedQueryRegister = false;
          object.registeredOperation = false;
          object.forbiddenOperation = false;
          object.queryPlan = null;
          object.unexecutedOperationBody = "";
          object.unexecutedOperationName = "";
          object.fieldExecutionWeight = 0;
          object.isIncomplete = false;
        }
        if (message.endTime != null && message.hasOwnProperty("endTime"))
          object.endTime = $root.google.protobuf.Timestamp.toObject(message.endTime, options);
        if (message.startTime != null && message.hasOwnProperty("startTime"))
          object.startTime = $root.google.protobuf.Timestamp.toObject(message.startTime, options);
        if (message.details != null && message.hasOwnProperty("details"))
          object.details = $root.Trace.Details.toObject(message.details, options);
        if (message.clientName != null && message.hasOwnProperty("clientName"))
          object.clientName = message.clientName;
        if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
          object.clientVersion = message.clientVersion;
        if (message.http != null && message.hasOwnProperty("http"))
          object.http = $root.Trace.HTTP.toObject(message.http, options);
        if (message.durationNs != null && message.hasOwnProperty("durationNs"))
          if (typeof message.durationNs === "number")
            object.durationNs = options.longs === String ? String(message.durationNs) : message.durationNs;
          else
            object.durationNs = options.longs === String ? $util.Long.prototype.toString.call(message.durationNs) : options.longs === Number ? new $util.LongBits(message.durationNs.low >>> 0, message.durationNs.high >>> 0).toNumber(true) : message.durationNs;
        if (message.root != null && message.hasOwnProperty("root"))
          object.root = $root.Trace.Node.toObject(message.root, options);
        if (message.cachePolicy != null && message.hasOwnProperty("cachePolicy"))
          object.cachePolicy = $root.Trace.CachePolicy.toObject(message.cachePolicy, options);
        if (message.signature != null && message.hasOwnProperty("signature"))
          object.signature = message.signature;
        if (message.fullQueryCacheHit != null && message.hasOwnProperty("fullQueryCacheHit"))
          object.fullQueryCacheHit = message.fullQueryCacheHit;
        if (message.persistedQueryHit != null && message.hasOwnProperty("persistedQueryHit"))
          object.persistedQueryHit = message.persistedQueryHit;
        if (message.persistedQueryRegister != null && message.hasOwnProperty("persistedQueryRegister"))
          object.persistedQueryRegister = message.persistedQueryRegister;
        if (message.registeredOperation != null && message.hasOwnProperty("registeredOperation"))
          object.registeredOperation = message.registeredOperation;
        if (message.forbiddenOperation != null && message.hasOwnProperty("forbiddenOperation"))
          object.forbiddenOperation = message.forbiddenOperation;
        if (message.queryPlan != null && message.hasOwnProperty("queryPlan"))
          object.queryPlan = $root.Trace.QueryPlanNode.toObject(message.queryPlan, options);
        if (message.unexecutedOperationBody != null && message.hasOwnProperty("unexecutedOperationBody"))
          object.unexecutedOperationBody = message.unexecutedOperationBody;
        if (message.unexecutedOperationName != null && message.hasOwnProperty("unexecutedOperationName"))
          object.unexecutedOperationName = message.unexecutedOperationName;
        if (message.fieldExecutionWeight != null && message.hasOwnProperty("fieldExecutionWeight"))
          object.fieldExecutionWeight = options.json && !isFinite(message.fieldExecutionWeight) ? String(message.fieldExecutionWeight) : message.fieldExecutionWeight;
        if (message.isIncomplete != null && message.hasOwnProperty("isIncomplete"))
          object.isIncomplete = message.isIncomplete;
        return object;
      };
      Trace.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      Trace.CachePolicy = function() {
        function CachePolicy(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        CachePolicy.prototype.scope = 0;
        CachePolicy.prototype.maxAgeNs = 0;
        CachePolicy.create = function create(properties) {
          return new CachePolicy(properties);
        };
        CachePolicy.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.scope != null && Object.hasOwnProperty.call(message, "scope"))
            writer.uint32(
              /* id 1, wireType 0 =*/
              8
            ).int32(message.scope);
          if (message.maxAgeNs != null && Object.hasOwnProperty.call(message, "maxAgeNs"))
            writer.uint32(
              /* id 2, wireType 0 =*/
              16
            ).int64(message.maxAgeNs);
          return writer;
        };
        CachePolicy.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        CachePolicy.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.CachePolicy();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.scope = reader.int32();
                break;
              case 2:
                message.maxAgeNs = reader.int64();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        CachePolicy.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        CachePolicy.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.scope != null && message.hasOwnProperty("scope"))
            switch (message.scope) {
              default:
                return "scope: enum value expected";
              case 0:
              case 1:
              case 2:
                break;
            }
          if (message.maxAgeNs != null && message.hasOwnProperty("maxAgeNs")) {
            if (!$util.isInteger(message.maxAgeNs) && !(message.maxAgeNs && $util.isInteger(message.maxAgeNs.low) && $util.isInteger(message.maxAgeNs.high)))
              return "maxAgeNs: integer|Long expected";
          }
          return null;
        };
        CachePolicy.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.defaults) {
            object.scope = options.enums === String ? "UNKNOWN" : 0;
            object.maxAgeNs = 0;
          }
          if (message.scope != null && message.hasOwnProperty("scope"))
            object.scope = options.enums === String ? $root.Trace.CachePolicy.Scope[message.scope] : message.scope;
          if (message.maxAgeNs != null && message.hasOwnProperty("maxAgeNs"))
            if (typeof message.maxAgeNs === "number")
              object.maxAgeNs = options.longs === String ? String(message.maxAgeNs) : message.maxAgeNs;
            else
              object.maxAgeNs = options.longs === String ? $util.Long.prototype.toString.call(message.maxAgeNs) : options.longs === Number ? new $util.LongBits(message.maxAgeNs.low >>> 0, message.maxAgeNs.high >>> 0).toNumber() : message.maxAgeNs;
          return object;
        };
        CachePolicy.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        CachePolicy.Scope = function() {
          var valuesById = {}, values = Object.create(valuesById);
          values[valuesById[0] = "UNKNOWN"] = 0;
          values[valuesById[1] = "PUBLIC"] = 1;
          values[valuesById[2] = "PRIVATE"] = 2;
          return values;
        }();
        return CachePolicy;
      }();
      Trace.Details = function() {
        function Details(properties) {
          this.variablesJson = {};
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        Details.prototype.variablesJson = $util.emptyObject;
        Details.prototype.operationName = "";
        Details.create = function create(properties) {
          return new Details(properties);
        };
        Details.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.operationName != null && Object.hasOwnProperty.call(message, "operationName"))
            writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).string(message.operationName);
          if (message.variablesJson != null && Object.hasOwnProperty.call(message, "variablesJson"))
            for (var keys = Object.keys(message.variablesJson), i = 0; i < keys.length; ++i)
              writer.uint32(
                /* id 4, wireType 2 =*/
                34
              ).fork().uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(keys[i]).uint32(
                /* id 2, wireType 2 =*/
                18
              ).string(message.variablesJson[keys[i]]).ldelim();
          return writer;
        };
        Details.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        Details.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.Details(), key;
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 4:
                reader.skip().pos++;
                if (message.variablesJson === $util.emptyObject)
                  message.variablesJson = {};
                key = reader.string();
                reader.pos++;
                message.variablesJson[key] = reader.string();
                break;
              case 3:
                message.operationName = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        Details.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        Details.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.variablesJson != null && message.hasOwnProperty("variablesJson")) {
            if (!$util.isObject(message.variablesJson))
              return "variablesJson: object expected";
            var key = Object.keys(message.variablesJson);
            for (var i = 0; i < key.length; ++i)
              if (!$util.isString(message.variablesJson[key[i]]))
                return "variablesJson: string{k:string} expected";
          }
          if (message.operationName != null && message.hasOwnProperty("operationName")) {
            if (!$util.isString(message.operationName))
              return "operationName: string expected";
          }
          return null;
        };
        Details.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.objects || options.defaults)
            object.variablesJson = {};
          if (options.defaults)
            object.operationName = "";
          if (message.operationName != null && message.hasOwnProperty("operationName"))
            object.operationName = message.operationName;
          var keys2;
          if (message.variablesJson && (keys2 = Object.keys(message.variablesJson)).length) {
            object.variablesJson = {};
            for (var j = 0; j < keys2.length; ++j)
              object.variablesJson[keys2[j]] = message.variablesJson[keys2[j]];
          }
          return object;
        };
        Details.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return Details;
      }();
      Trace.Error = function() {
        function Error2(properties) {
          this.location = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        Error2.prototype.message = "";
        Error2.prototype.location = $util.emptyArray;
        Error2.prototype.timeNs = 0;
        Error2.prototype.json = "";
        Error2.create = function create(properties) {
          return new Error2(properties);
        };
        Error2.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.message != null && Object.hasOwnProperty.call(message, "message"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(message.message);
          if (message.location != null && message.location.length)
            for (var i = 0; i < message.location.length; ++i)
              $root.Trace.Location.encode(message.location[i], writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).fork()).ldelim();
          if (message.timeNs != null && Object.hasOwnProperty.call(message, "timeNs"))
            writer.uint32(
              /* id 3, wireType 0 =*/
              24
            ).uint64(message.timeNs);
          if (message.json != null && Object.hasOwnProperty.call(message, "json"))
            writer.uint32(
              /* id 4, wireType 2 =*/
              34
            ).string(message.json);
          return writer;
        };
        Error2.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        Error2.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.Error();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.message = reader.string();
                break;
              case 2:
                if (!(message.location && message.location.length))
                  message.location = [];
                message.location.push($root.Trace.Location.decode(reader, reader.uint32()));
                break;
              case 3:
                message.timeNs = reader.uint64();
                break;
              case 4:
                message.json = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        Error2.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        Error2.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.message != null && message.hasOwnProperty("message")) {
            if (!$util.isString(message.message))
              return "message: string expected";
          }
          if (message.location != null && message.hasOwnProperty("location")) {
            if (!Array.isArray(message.location))
              return "location: array expected";
            for (var i = 0; i < message.location.length; ++i) {
              var error = $root.Trace.Location.verify(message.location[i]);
              if (error)
                return "location." + error;
            }
          }
          if (message.timeNs != null && message.hasOwnProperty("timeNs")) {
            if (!$util.isInteger(message.timeNs) && !(message.timeNs && $util.isInteger(message.timeNs.low) && $util.isInteger(message.timeNs.high)))
              return "timeNs: integer|Long expected";
          }
          if (message.json != null && message.hasOwnProperty("json")) {
            if (!$util.isString(message.json))
              return "json: string expected";
          }
          return null;
        };
        Error2.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults)
            object.location = [];
          if (options.defaults) {
            object.message = "";
            object.timeNs = 0;
            object.json = "";
          }
          if (message.message != null && message.hasOwnProperty("message"))
            object.message = message.message;
          if (message.location && message.location.length) {
            object.location = [];
            for (var j = 0; j < message.location.length; ++j)
              object.location[j] = $root.Trace.Location.toObject(message.location[j], options);
          }
          if (message.timeNs != null && message.hasOwnProperty("timeNs"))
            if (typeof message.timeNs === "number")
              object.timeNs = options.longs === String ? String(message.timeNs) : message.timeNs;
            else
              object.timeNs = options.longs === String ? $util.Long.prototype.toString.call(message.timeNs) : options.longs === Number ? new $util.LongBits(message.timeNs.low >>> 0, message.timeNs.high >>> 0).toNumber(true) : message.timeNs;
          if (message.json != null && message.hasOwnProperty("json"))
            object.json = message.json;
          return object;
        };
        Error2.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return Error2;
      }();
      Trace.HTTP = function() {
        function HTTP(properties) {
          this.requestHeaders = {};
          this.responseHeaders = {};
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        HTTP.prototype.method = 0;
        HTTP.prototype.requestHeaders = $util.emptyObject;
        HTTP.prototype.responseHeaders = $util.emptyObject;
        HTTP.prototype.statusCode = 0;
        HTTP.create = function create(properties) {
          return new HTTP(properties);
        };
        HTTP.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.method != null && Object.hasOwnProperty.call(message, "method"))
            writer.uint32(
              /* id 1, wireType 0 =*/
              8
            ).int32(message.method);
          if (message.requestHeaders != null && Object.hasOwnProperty.call(message, "requestHeaders"))
            for (var keys = Object.keys(message.requestHeaders), i = 0; i < keys.length; ++i) {
              writer.uint32(
                /* id 4, wireType 2 =*/
                34
              ).fork().uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(keys[i]);
              $root.Trace.HTTP.Values.encode(message.requestHeaders[keys[i]], writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).fork()).ldelim().ldelim();
            }
          if (message.responseHeaders != null && Object.hasOwnProperty.call(message, "responseHeaders"))
            for (var keys = Object.keys(message.responseHeaders), i = 0; i < keys.length; ++i) {
              writer.uint32(
                /* id 5, wireType 2 =*/
                42
              ).fork().uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(keys[i]);
              $root.Trace.HTTP.Values.encode(message.responseHeaders[keys[i]], writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).fork()).ldelim().ldelim();
            }
          if (message.statusCode != null && Object.hasOwnProperty.call(message, "statusCode"))
            writer.uint32(
              /* id 6, wireType 0 =*/
              48
            ).uint32(message.statusCode);
          return writer;
        };
        HTTP.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        HTTP.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.HTTP(), key;
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.method = reader.int32();
                break;
              case 4:
                reader.skip().pos++;
                if (message.requestHeaders === $util.emptyObject)
                  message.requestHeaders = {};
                key = reader.string();
                reader.pos++;
                message.requestHeaders[key] = $root.Trace.HTTP.Values.decode(reader, reader.uint32());
                break;
              case 5:
                reader.skip().pos++;
                if (message.responseHeaders === $util.emptyObject)
                  message.responseHeaders = {};
                key = reader.string();
                reader.pos++;
                message.responseHeaders[key] = $root.Trace.HTTP.Values.decode(reader, reader.uint32());
                break;
              case 6:
                message.statusCode = reader.uint32();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        HTTP.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        HTTP.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.method != null && message.hasOwnProperty("method"))
            switch (message.method) {
              default:
                return "method: enum value expected";
              case 0:
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
              case 6:
              case 7:
              case 8:
              case 9:
                break;
            }
          if (message.requestHeaders != null && message.hasOwnProperty("requestHeaders")) {
            if (!$util.isObject(message.requestHeaders))
              return "requestHeaders: object expected";
            var key = Object.keys(message.requestHeaders);
            for (var i = 0; i < key.length; ++i) {
              var error = $root.Trace.HTTP.Values.verify(message.requestHeaders[key[i]]);
              if (error)
                return "requestHeaders." + error;
            }
          }
          if (message.responseHeaders != null && message.hasOwnProperty("responseHeaders")) {
            if (!$util.isObject(message.responseHeaders))
              return "responseHeaders: object expected";
            var key = Object.keys(message.responseHeaders);
            for (var i = 0; i < key.length; ++i) {
              var error = $root.Trace.HTTP.Values.verify(message.responseHeaders[key[i]]);
              if (error)
                return "responseHeaders." + error;
            }
          }
          if (message.statusCode != null && message.hasOwnProperty("statusCode")) {
            if (!$util.isInteger(message.statusCode))
              return "statusCode: integer expected";
          }
          return null;
        };
        HTTP.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.objects || options.defaults) {
            object.requestHeaders = {};
            object.responseHeaders = {};
          }
          if (options.defaults) {
            object.method = options.enums === String ? "UNKNOWN" : 0;
            object.statusCode = 0;
          }
          if (message.method != null && message.hasOwnProperty("method"))
            object.method = options.enums === String ? $root.Trace.HTTP.Method[message.method] : message.method;
          var keys2;
          if (message.requestHeaders && (keys2 = Object.keys(message.requestHeaders)).length) {
            object.requestHeaders = {};
            for (var j = 0; j < keys2.length; ++j)
              object.requestHeaders[keys2[j]] = $root.Trace.HTTP.Values.toObject(message.requestHeaders[keys2[j]], options);
          }
          if (message.responseHeaders && (keys2 = Object.keys(message.responseHeaders)).length) {
            object.responseHeaders = {};
            for (var j = 0; j < keys2.length; ++j)
              object.responseHeaders[keys2[j]] = $root.Trace.HTTP.Values.toObject(message.responseHeaders[keys2[j]], options);
          }
          if (message.statusCode != null && message.hasOwnProperty("statusCode"))
            object.statusCode = message.statusCode;
          return object;
        };
        HTTP.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        HTTP.Values = function() {
          function Values(properties) {
            this.value = [];
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          Values.prototype.value = $util.emptyArray;
          Values.create = function create(properties) {
            return new Values(properties);
          };
          Values.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.value != null && message.value.length)
              for (var i = 0; i < message.value.length; ++i)
                writer.uint32(
                  /* id 1, wireType 2 =*/
                  10
                ).string(message.value[i]);
            return writer;
          };
          Values.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          Values.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.HTTP.Values();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  if (!(message.value && message.value.length))
                    message.value = [];
                  message.value.push(reader.string());
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          Values.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          Values.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.value != null && message.hasOwnProperty("value")) {
              if (!Array.isArray(message.value))
                return "value: array expected";
              for (var i = 0; i < message.value.length; ++i)
                if (!$util.isString(message.value[i]))
                  return "value: string[] expected";
            }
            return null;
          };
          Values.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.arrays || options.defaults)
              object.value = [];
            if (message.value && message.value.length) {
              object.value = [];
              for (var j = 0; j < message.value.length; ++j)
                object.value[j] = message.value[j];
            }
            return object;
          };
          Values.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return Values;
        }();
        HTTP.Method = function() {
          var valuesById = {}, values = Object.create(valuesById);
          values[valuesById[0] = "UNKNOWN"] = 0;
          values[valuesById[1] = "OPTIONS"] = 1;
          values[valuesById[2] = "GET"] = 2;
          values[valuesById[3] = "HEAD"] = 3;
          values[valuesById[4] = "POST"] = 4;
          values[valuesById[5] = "PUT"] = 5;
          values[valuesById[6] = "DELETE"] = 6;
          values[valuesById[7] = "TRACE"] = 7;
          values[valuesById[8] = "CONNECT"] = 8;
          values[valuesById[9] = "PATCH"] = 9;
          return values;
        }();
        return HTTP;
      }();
      Trace.Location = function() {
        function Location2(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        Location2.prototype.line = 0;
        Location2.prototype.column = 0;
        Location2.create = function create(properties) {
          return new Location2(properties);
        };
        Location2.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.line != null && Object.hasOwnProperty.call(message, "line"))
            writer.uint32(
              /* id 1, wireType 0 =*/
              8
            ).uint32(message.line);
          if (message.column != null && Object.hasOwnProperty.call(message, "column"))
            writer.uint32(
              /* id 2, wireType 0 =*/
              16
            ).uint32(message.column);
          return writer;
        };
        Location2.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        Location2.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.Location();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.line = reader.uint32();
                break;
              case 2:
                message.column = reader.uint32();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        Location2.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        Location2.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.line != null && message.hasOwnProperty("line")) {
            if (!$util.isInteger(message.line))
              return "line: integer expected";
          }
          if (message.column != null && message.hasOwnProperty("column")) {
            if (!$util.isInteger(message.column))
              return "column: integer expected";
          }
          return null;
        };
        Location2.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.defaults) {
            object.line = 0;
            object.column = 0;
          }
          if (message.line != null && message.hasOwnProperty("line"))
            object.line = message.line;
          if (message.column != null && message.hasOwnProperty("column"))
            object.column = message.column;
          return object;
        };
        Location2.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return Location2;
      }();
      Trace.Node = function() {
        function Node(properties) {
          this.error = [];
          this.child = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        Node.prototype.responseName = "";
        Node.prototype.index = 0;
        Node.prototype.originalFieldName = "";
        Node.prototype.type = "";
        Node.prototype.parentType = "";
        Node.prototype.cachePolicy = null;
        Node.prototype.startTime = 0;
        Node.prototype.endTime = 0;
        Node.prototype.error = $util.emptyArray;
        Node.prototype.child = $util.emptyArray;
        var $oneOfFields;
        Object.defineProperty(Node.prototype, "id", {
          get: $util.oneOfGetter($oneOfFields = ["responseName", "index"]),
          set: $util.oneOfSetter($oneOfFields)
        });
        Node.create = function create(properties) {
          return new Node(properties);
        };
        Node.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.responseName != null && Object.hasOwnProperty.call(message, "responseName"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(message.responseName);
          if (message.index != null && Object.hasOwnProperty.call(message, "index"))
            writer.uint32(
              /* id 2, wireType 0 =*/
              16
            ).uint32(message.index);
          if (message.type != null && Object.hasOwnProperty.call(message, "type"))
            writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).string(message.type);
          if (message.cachePolicy != null && Object.hasOwnProperty.call(message, "cachePolicy"))
            $root.Trace.CachePolicy.encode(message.cachePolicy, writer.uint32(
              /* id 5, wireType 2 =*/
              42
            ).fork()).ldelim();
          if (message.startTime != null && Object.hasOwnProperty.call(message, "startTime"))
            writer.uint32(
              /* id 8, wireType 0 =*/
              64
            ).uint64(message.startTime);
          if (message.endTime != null && Object.hasOwnProperty.call(message, "endTime"))
            writer.uint32(
              /* id 9, wireType 0 =*/
              72
            ).uint64(message.endTime);
          if (message.error != null && message.error.length)
            for (var i = 0; i < message.error.length; ++i)
              $root.Trace.Error.encode(message.error[i], writer.uint32(
                /* id 11, wireType 2 =*/
                90
              ).fork()).ldelim();
          if (message.child != null && message.child.length)
            for (var i = 0; i < message.child.length; ++i)
              $root.Trace.Node.encode(message.child[i], writer.uint32(
                /* id 12, wireType 2 =*/
                98
              ).fork()).ldelim();
          if (message.parentType != null && Object.hasOwnProperty.call(message, "parentType"))
            writer.uint32(
              /* id 13, wireType 2 =*/
              106
            ).string(message.parentType);
          if (message.originalFieldName != null && Object.hasOwnProperty.call(message, "originalFieldName"))
            writer.uint32(
              /* id 14, wireType 2 =*/
              114
            ).string(message.originalFieldName);
          return writer;
        };
        Node.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        Node.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.Node();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.responseName = reader.string();
                break;
              case 2:
                message.index = reader.uint32();
                break;
              case 14:
                message.originalFieldName = reader.string();
                break;
              case 3:
                message.type = reader.string();
                break;
              case 13:
                message.parentType = reader.string();
                break;
              case 5:
                message.cachePolicy = $root.Trace.CachePolicy.decode(reader, reader.uint32());
                break;
              case 8:
                message.startTime = reader.uint64();
                break;
              case 9:
                message.endTime = reader.uint64();
                break;
              case 11:
                if (!(message.error && message.error.length))
                  message.error = [];
                message.error.push($root.Trace.Error.decode(reader, reader.uint32()));
                break;
              case 12:
                if (!(message.child && message.child.length))
                  message.child = [];
                message.child.push($root.Trace.Node.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        Node.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        Node.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          var properties = {};
          if (message.responseName != null && message.hasOwnProperty("responseName")) {
            properties.id = 1;
            if (!$util.isString(message.responseName))
              return "responseName: string expected";
          }
          if (message.index != null && message.hasOwnProperty("index")) {
            if (properties.id === 1)
              return "id: multiple values";
            properties.id = 1;
            if (!$util.isInteger(message.index))
              return "index: integer expected";
          }
          if (message.originalFieldName != null && message.hasOwnProperty("originalFieldName")) {
            if (!$util.isString(message.originalFieldName))
              return "originalFieldName: string expected";
          }
          if (message.type != null && message.hasOwnProperty("type")) {
            if (!$util.isString(message.type))
              return "type: string expected";
          }
          if (message.parentType != null && message.hasOwnProperty("parentType")) {
            if (!$util.isString(message.parentType))
              return "parentType: string expected";
          }
          if (message.cachePolicy != null && message.hasOwnProperty("cachePolicy")) {
            var error = $root.Trace.CachePolicy.verify(message.cachePolicy);
            if (error)
              return "cachePolicy." + error;
          }
          if (message.startTime != null && message.hasOwnProperty("startTime")) {
            if (!$util.isInteger(message.startTime) && !(message.startTime && $util.isInteger(message.startTime.low) && $util.isInteger(message.startTime.high)))
              return "startTime: integer|Long expected";
          }
          if (message.endTime != null && message.hasOwnProperty("endTime")) {
            if (!$util.isInteger(message.endTime) && !(message.endTime && $util.isInteger(message.endTime.low) && $util.isInteger(message.endTime.high)))
              return "endTime: integer|Long expected";
          }
          if (message.error != null && message.hasOwnProperty("error")) {
            if (!Array.isArray(message.error))
              return "error: array expected";
            for (var i = 0; i < message.error.length; ++i) {
              var error = $root.Trace.Error.verify(message.error[i]);
              if (error)
                return "error." + error;
            }
          }
          if (message.child != null && message.hasOwnProperty("child")) {
            if (!Array.isArray(message.child))
              return "child: array expected";
            for (var i = 0; i < message.child.length; ++i) {
              var error = $root.Trace.Node.verify(message.child[i]);
              if (error)
                return "child." + error;
            }
          }
          return null;
        };
        Node.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults) {
            object.error = [];
            object.child = [];
          }
          if (options.defaults) {
            object.type = "";
            object.cachePolicy = null;
            object.startTime = 0;
            object.endTime = 0;
            object.parentType = "";
            object.originalFieldName = "";
          }
          if (message.responseName != null && message.hasOwnProperty("responseName")) {
            object.responseName = message.responseName;
            if (options.oneofs)
              object.id = "responseName";
          }
          if (message.index != null && message.hasOwnProperty("index")) {
            object.index = message.index;
            if (options.oneofs)
              object.id = "index";
          }
          if (message.type != null && message.hasOwnProperty("type"))
            object.type = message.type;
          if (message.cachePolicy != null && message.hasOwnProperty("cachePolicy"))
            object.cachePolicy = $root.Trace.CachePolicy.toObject(message.cachePolicy, options);
          if (message.startTime != null && message.hasOwnProperty("startTime"))
            if (typeof message.startTime === "number")
              object.startTime = options.longs === String ? String(message.startTime) : message.startTime;
            else
              object.startTime = options.longs === String ? $util.Long.prototype.toString.call(message.startTime) : options.longs === Number ? new $util.LongBits(message.startTime.low >>> 0, message.startTime.high >>> 0).toNumber(true) : message.startTime;
          if (message.endTime != null && message.hasOwnProperty("endTime"))
            if (typeof message.endTime === "number")
              object.endTime = options.longs === String ? String(message.endTime) : message.endTime;
            else
              object.endTime = options.longs === String ? $util.Long.prototype.toString.call(message.endTime) : options.longs === Number ? new $util.LongBits(message.endTime.low >>> 0, message.endTime.high >>> 0).toNumber(true) : message.endTime;
          if (message.error && message.error.length) {
            object.error = [];
            for (var j = 0; j < message.error.length; ++j)
              object.error[j] = $root.Trace.Error.toObject(message.error[j], options);
          }
          if (message.child && message.child.length) {
            object.child = [];
            for (var j = 0; j < message.child.length; ++j)
              object.child[j] = $root.Trace.Node.toObject(message.child[j], options);
          }
          if (message.parentType != null && message.hasOwnProperty("parentType"))
            object.parentType = message.parentType;
          if (message.originalFieldName != null && message.hasOwnProperty("originalFieldName"))
            object.originalFieldName = message.originalFieldName;
          return object;
        };
        Node.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return Node;
      }();
      Trace.QueryPlanNode = function() {
        function QueryPlanNode(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        QueryPlanNode.prototype.sequence = null;
        QueryPlanNode.prototype.parallel = null;
        QueryPlanNode.prototype.fetch = null;
        QueryPlanNode.prototype.flatten = null;
        QueryPlanNode.prototype.defer = null;
        QueryPlanNode.prototype.condition = null;
        var $oneOfFields;
        Object.defineProperty(QueryPlanNode.prototype, "node", {
          get: $util.oneOfGetter($oneOfFields = ["sequence", "parallel", "fetch", "flatten", "defer", "condition"]),
          set: $util.oneOfSetter($oneOfFields)
        });
        QueryPlanNode.create = function create(properties) {
          return new QueryPlanNode(properties);
        };
        QueryPlanNode.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.sequence != null && Object.hasOwnProperty.call(message, "sequence"))
            $root.Trace.QueryPlanNode.SequenceNode.encode(message.sequence, writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).fork()).ldelim();
          if (message.parallel != null && Object.hasOwnProperty.call(message, "parallel"))
            $root.Trace.QueryPlanNode.ParallelNode.encode(message.parallel, writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim();
          if (message.fetch != null && Object.hasOwnProperty.call(message, "fetch"))
            $root.Trace.QueryPlanNode.FetchNode.encode(message.fetch, writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).fork()).ldelim();
          if (message.flatten != null && Object.hasOwnProperty.call(message, "flatten"))
            $root.Trace.QueryPlanNode.FlattenNode.encode(message.flatten, writer.uint32(
              /* id 4, wireType 2 =*/
              34
            ).fork()).ldelim();
          if (message.defer != null && Object.hasOwnProperty.call(message, "defer"))
            $root.Trace.QueryPlanNode.DeferNode.encode(message.defer, writer.uint32(
              /* id 5, wireType 2 =*/
              42
            ).fork()).ldelim();
          if (message.condition != null && Object.hasOwnProperty.call(message, "condition"))
            $root.Trace.QueryPlanNode.ConditionNode.encode(message.condition, writer.uint32(
              /* id 6, wireType 2 =*/
              50
            ).fork()).ldelim();
          return writer;
        };
        QueryPlanNode.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        QueryPlanNode.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.sequence = $root.Trace.QueryPlanNode.SequenceNode.decode(reader, reader.uint32());
                break;
              case 2:
                message.parallel = $root.Trace.QueryPlanNode.ParallelNode.decode(reader, reader.uint32());
                break;
              case 3:
                message.fetch = $root.Trace.QueryPlanNode.FetchNode.decode(reader, reader.uint32());
                break;
              case 4:
                message.flatten = $root.Trace.QueryPlanNode.FlattenNode.decode(reader, reader.uint32());
                break;
              case 5:
                message.defer = $root.Trace.QueryPlanNode.DeferNode.decode(reader, reader.uint32());
                break;
              case 6:
                message.condition = $root.Trace.QueryPlanNode.ConditionNode.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        QueryPlanNode.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        QueryPlanNode.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          var properties = {};
          if (message.sequence != null && message.hasOwnProperty("sequence")) {
            properties.node = 1;
            {
              var error = $root.Trace.QueryPlanNode.SequenceNode.verify(message.sequence);
              if (error)
                return "sequence." + error;
            }
          }
          if (message.parallel != null && message.hasOwnProperty("parallel")) {
            if (properties.node === 1)
              return "node: multiple values";
            properties.node = 1;
            {
              var error = $root.Trace.QueryPlanNode.ParallelNode.verify(message.parallel);
              if (error)
                return "parallel." + error;
            }
          }
          if (message.fetch != null && message.hasOwnProperty("fetch")) {
            if (properties.node === 1)
              return "node: multiple values";
            properties.node = 1;
            {
              var error = $root.Trace.QueryPlanNode.FetchNode.verify(message.fetch);
              if (error)
                return "fetch." + error;
            }
          }
          if (message.flatten != null && message.hasOwnProperty("flatten")) {
            if (properties.node === 1)
              return "node: multiple values";
            properties.node = 1;
            {
              var error = $root.Trace.QueryPlanNode.FlattenNode.verify(message.flatten);
              if (error)
                return "flatten." + error;
            }
          }
          if (message.defer != null && message.hasOwnProperty("defer")) {
            if (properties.node === 1)
              return "node: multiple values";
            properties.node = 1;
            {
              var error = $root.Trace.QueryPlanNode.DeferNode.verify(message.defer);
              if (error)
                return "defer." + error;
            }
          }
          if (message.condition != null && message.hasOwnProperty("condition")) {
            if (properties.node === 1)
              return "node: multiple values";
            properties.node = 1;
            {
              var error = $root.Trace.QueryPlanNode.ConditionNode.verify(message.condition);
              if (error)
                return "condition." + error;
            }
          }
          return null;
        };
        QueryPlanNode.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (message.sequence != null && message.hasOwnProperty("sequence")) {
            object.sequence = $root.Trace.QueryPlanNode.SequenceNode.toObject(message.sequence, options);
            if (options.oneofs)
              object.node = "sequence";
          }
          if (message.parallel != null && message.hasOwnProperty("parallel")) {
            object.parallel = $root.Trace.QueryPlanNode.ParallelNode.toObject(message.parallel, options);
            if (options.oneofs)
              object.node = "parallel";
          }
          if (message.fetch != null && message.hasOwnProperty("fetch")) {
            object.fetch = $root.Trace.QueryPlanNode.FetchNode.toObject(message.fetch, options);
            if (options.oneofs)
              object.node = "fetch";
          }
          if (message.flatten != null && message.hasOwnProperty("flatten")) {
            object.flatten = $root.Trace.QueryPlanNode.FlattenNode.toObject(message.flatten, options);
            if (options.oneofs)
              object.node = "flatten";
          }
          if (message.defer != null && message.hasOwnProperty("defer")) {
            object.defer = $root.Trace.QueryPlanNode.DeferNode.toObject(message.defer, options);
            if (options.oneofs)
              object.node = "defer";
          }
          if (message.condition != null && message.hasOwnProperty("condition")) {
            object.condition = $root.Trace.QueryPlanNode.ConditionNode.toObject(message.condition, options);
            if (options.oneofs)
              object.node = "condition";
          }
          return object;
        };
        QueryPlanNode.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        QueryPlanNode.SequenceNode = function() {
          function SequenceNode(properties) {
            this.nodes = [];
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          SequenceNode.prototype.nodes = $util.emptyArray;
          SequenceNode.create = function create(properties) {
            return new SequenceNode(properties);
          };
          SequenceNode.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.nodes != null && message.nodes.length)
              for (var i = 0; i < message.nodes.length; ++i)
                $root.Trace.QueryPlanNode.encode(message.nodes[i], writer.uint32(
                  /* id 1, wireType 2 =*/
                  10
                ).fork()).ldelim();
            return writer;
          };
          SequenceNode.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          SequenceNode.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.SequenceNode();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  if (!(message.nodes && message.nodes.length))
                    message.nodes = [];
                  message.nodes.push($root.Trace.QueryPlanNode.decode(reader, reader.uint32()));
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          SequenceNode.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          SequenceNode.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.nodes != null && message.hasOwnProperty("nodes")) {
              if (!Array.isArray(message.nodes))
                return "nodes: array expected";
              for (var i = 0; i < message.nodes.length; ++i) {
                var error = $root.Trace.QueryPlanNode.verify(message.nodes[i]);
                if (error)
                  return "nodes." + error;
              }
            }
            return null;
          };
          SequenceNode.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.arrays || options.defaults)
              object.nodes = [];
            if (message.nodes && message.nodes.length) {
              object.nodes = [];
              for (var j = 0; j < message.nodes.length; ++j)
                object.nodes[j] = $root.Trace.QueryPlanNode.toObject(message.nodes[j], options);
            }
            return object;
          };
          SequenceNode.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return SequenceNode;
        }();
        QueryPlanNode.ParallelNode = function() {
          function ParallelNode(properties) {
            this.nodes = [];
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          ParallelNode.prototype.nodes = $util.emptyArray;
          ParallelNode.create = function create(properties) {
            return new ParallelNode(properties);
          };
          ParallelNode.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.nodes != null && message.nodes.length)
              for (var i = 0; i < message.nodes.length; ++i)
                $root.Trace.QueryPlanNode.encode(message.nodes[i], writer.uint32(
                  /* id 1, wireType 2 =*/
                  10
                ).fork()).ldelim();
            return writer;
          };
          ParallelNode.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          ParallelNode.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.ParallelNode();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  if (!(message.nodes && message.nodes.length))
                    message.nodes = [];
                  message.nodes.push($root.Trace.QueryPlanNode.decode(reader, reader.uint32()));
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          ParallelNode.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          ParallelNode.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.nodes != null && message.hasOwnProperty("nodes")) {
              if (!Array.isArray(message.nodes))
                return "nodes: array expected";
              for (var i = 0; i < message.nodes.length; ++i) {
                var error = $root.Trace.QueryPlanNode.verify(message.nodes[i]);
                if (error)
                  return "nodes." + error;
              }
            }
            return null;
          };
          ParallelNode.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.arrays || options.defaults)
              object.nodes = [];
            if (message.nodes && message.nodes.length) {
              object.nodes = [];
              for (var j = 0; j < message.nodes.length; ++j)
                object.nodes[j] = $root.Trace.QueryPlanNode.toObject(message.nodes[j], options);
            }
            return object;
          };
          ParallelNode.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return ParallelNode;
        }();
        QueryPlanNode.FetchNode = function() {
          function FetchNode(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          FetchNode.prototype.serviceName = "";
          FetchNode.prototype.traceParsingFailed = false;
          FetchNode.prototype.trace = null;
          FetchNode.prototype.sentTimeOffset = 0;
          FetchNode.prototype.sentTime = null;
          FetchNode.prototype.receivedTime = null;
          FetchNode.create = function create(properties) {
            return new FetchNode(properties);
          };
          FetchNode.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.serviceName != null && Object.hasOwnProperty.call(message, "serviceName"))
              writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(message.serviceName);
            if (message.traceParsingFailed != null && Object.hasOwnProperty.call(message, "traceParsingFailed"))
              writer.uint32(
                /* id 2, wireType 0 =*/
                16
              ).bool(message.traceParsingFailed);
            if (message.trace != null && Object.hasOwnProperty.call(message, "trace"))
              $root.Trace.encode(message.trace, writer.uint32(
                /* id 3, wireType 2 =*/
                26
              ).fork()).ldelim();
            if (message.sentTimeOffset != null && Object.hasOwnProperty.call(message, "sentTimeOffset"))
              writer.uint32(
                /* id 4, wireType 0 =*/
                32
              ).uint64(message.sentTimeOffset);
            if (message.sentTime != null && Object.hasOwnProperty.call(message, "sentTime"))
              $root.google.protobuf.Timestamp.encode(message.sentTime, writer.uint32(
                /* id 5, wireType 2 =*/
                42
              ).fork()).ldelim();
            if (message.receivedTime != null && Object.hasOwnProperty.call(message, "receivedTime"))
              $root.google.protobuf.Timestamp.encode(message.receivedTime, writer.uint32(
                /* id 6, wireType 2 =*/
                50
              ).fork()).ldelim();
            return writer;
          };
          FetchNode.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          FetchNode.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.FetchNode();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.serviceName = reader.string();
                  break;
                case 2:
                  message.traceParsingFailed = reader.bool();
                  break;
                case 3:
                  message.trace = $root.Trace.decode(reader, reader.uint32());
                  break;
                case 4:
                  message.sentTimeOffset = reader.uint64();
                  break;
                case 5:
                  message.sentTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                  break;
                case 6:
                  message.receivedTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          FetchNode.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          FetchNode.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.serviceName != null && message.hasOwnProperty("serviceName")) {
              if (!$util.isString(message.serviceName))
                return "serviceName: string expected";
            }
            if (message.traceParsingFailed != null && message.hasOwnProperty("traceParsingFailed")) {
              if (typeof message.traceParsingFailed !== "boolean")
                return "traceParsingFailed: boolean expected";
            }
            if (message.trace != null && message.hasOwnProperty("trace")) {
              var error = $root.Trace.verify(message.trace);
              if (error)
                return "trace." + error;
            }
            if (message.sentTimeOffset != null && message.hasOwnProperty("sentTimeOffset")) {
              if (!$util.isInteger(message.sentTimeOffset) && !(message.sentTimeOffset && $util.isInteger(message.sentTimeOffset.low) && $util.isInteger(message.sentTimeOffset.high)))
                return "sentTimeOffset: integer|Long expected";
            }
            if (message.sentTime != null && message.hasOwnProperty("sentTime")) {
              var error = $root.google.protobuf.Timestamp.verify(message.sentTime);
              if (error)
                return "sentTime." + error;
            }
            if (message.receivedTime != null && message.hasOwnProperty("receivedTime")) {
              var error = $root.google.protobuf.Timestamp.verify(message.receivedTime);
              if (error)
                return "receivedTime." + error;
            }
            return null;
          };
          FetchNode.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults) {
              object.serviceName = "";
              object.traceParsingFailed = false;
              object.trace = null;
              object.sentTimeOffset = 0;
              object.sentTime = null;
              object.receivedTime = null;
            }
            if (message.serviceName != null && message.hasOwnProperty("serviceName"))
              object.serviceName = message.serviceName;
            if (message.traceParsingFailed != null && message.hasOwnProperty("traceParsingFailed"))
              object.traceParsingFailed = message.traceParsingFailed;
            if (message.trace != null && message.hasOwnProperty("trace"))
              object.trace = $root.Trace.toObject(message.trace, options);
            if (message.sentTimeOffset != null && message.hasOwnProperty("sentTimeOffset"))
              if (typeof message.sentTimeOffset === "number")
                object.sentTimeOffset = options.longs === String ? String(message.sentTimeOffset) : message.sentTimeOffset;
              else
                object.sentTimeOffset = options.longs === String ? $util.Long.prototype.toString.call(message.sentTimeOffset) : options.longs === Number ? new $util.LongBits(message.sentTimeOffset.low >>> 0, message.sentTimeOffset.high >>> 0).toNumber(true) : message.sentTimeOffset;
            if (message.sentTime != null && message.hasOwnProperty("sentTime"))
              object.sentTime = $root.google.protobuf.Timestamp.toObject(message.sentTime, options);
            if (message.receivedTime != null && message.hasOwnProperty("receivedTime"))
              object.receivedTime = $root.google.protobuf.Timestamp.toObject(message.receivedTime, options);
            return object;
          };
          FetchNode.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return FetchNode;
        }();
        QueryPlanNode.FlattenNode = function() {
          function FlattenNode(properties) {
            this.responsePath = [];
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          FlattenNode.prototype.responsePath = $util.emptyArray;
          FlattenNode.prototype.node = null;
          FlattenNode.create = function create(properties) {
            return new FlattenNode(properties);
          };
          FlattenNode.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.responsePath != null && message.responsePath.length)
              for (var i = 0; i < message.responsePath.length; ++i)
                $root.Trace.QueryPlanNode.ResponsePathElement.encode(message.responsePath[i], writer.uint32(
                  /* id 1, wireType 2 =*/
                  10
                ).fork()).ldelim();
            if (message.node != null && Object.hasOwnProperty.call(message, "node"))
              $root.Trace.QueryPlanNode.encode(message.node, writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).fork()).ldelim();
            return writer;
          };
          FlattenNode.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          FlattenNode.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.FlattenNode();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  if (!(message.responsePath && message.responsePath.length))
                    message.responsePath = [];
                  message.responsePath.push($root.Trace.QueryPlanNode.ResponsePathElement.decode(reader, reader.uint32()));
                  break;
                case 2:
                  message.node = $root.Trace.QueryPlanNode.decode(reader, reader.uint32());
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          FlattenNode.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          FlattenNode.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.responsePath != null && message.hasOwnProperty("responsePath")) {
              if (!Array.isArray(message.responsePath))
                return "responsePath: array expected";
              for (var i = 0; i < message.responsePath.length; ++i) {
                var error = $root.Trace.QueryPlanNode.ResponsePathElement.verify(message.responsePath[i]);
                if (error)
                  return "responsePath." + error;
              }
            }
            if (message.node != null && message.hasOwnProperty("node")) {
              var error = $root.Trace.QueryPlanNode.verify(message.node);
              if (error)
                return "node." + error;
            }
            return null;
          };
          FlattenNode.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.arrays || options.defaults)
              object.responsePath = [];
            if (options.defaults)
              object.node = null;
            if (message.responsePath && message.responsePath.length) {
              object.responsePath = [];
              for (var j = 0; j < message.responsePath.length; ++j)
                object.responsePath[j] = $root.Trace.QueryPlanNode.ResponsePathElement.toObject(message.responsePath[j], options);
            }
            if (message.node != null && message.hasOwnProperty("node"))
              object.node = $root.Trace.QueryPlanNode.toObject(message.node, options);
            return object;
          };
          FlattenNode.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return FlattenNode;
        }();
        QueryPlanNode.DeferNode = function() {
          function DeferNode(properties) {
            this.deferred = [];
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          DeferNode.prototype.primary = null;
          DeferNode.prototype.deferred = $util.emptyArray;
          DeferNode.create = function create(properties) {
            return new DeferNode(properties);
          };
          DeferNode.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.primary != null && Object.hasOwnProperty.call(message, "primary"))
              $root.Trace.QueryPlanNode.DeferNodePrimary.encode(message.primary, writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).fork()).ldelim();
            if (message.deferred != null && message.deferred.length)
              for (var i = 0; i < message.deferred.length; ++i)
                $root.Trace.QueryPlanNode.DeferredNode.encode(message.deferred[i], writer.uint32(
                  /* id 2, wireType 2 =*/
                  18
                ).fork()).ldelim();
            return writer;
          };
          DeferNode.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          DeferNode.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.DeferNode();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.primary = $root.Trace.QueryPlanNode.DeferNodePrimary.decode(reader, reader.uint32());
                  break;
                case 2:
                  if (!(message.deferred && message.deferred.length))
                    message.deferred = [];
                  message.deferred.push($root.Trace.QueryPlanNode.DeferredNode.decode(reader, reader.uint32()));
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          DeferNode.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          DeferNode.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.primary != null && message.hasOwnProperty("primary")) {
              var error = $root.Trace.QueryPlanNode.DeferNodePrimary.verify(message.primary);
              if (error)
                return "primary." + error;
            }
            if (message.deferred != null && message.hasOwnProperty("deferred")) {
              if (!Array.isArray(message.deferred))
                return "deferred: array expected";
              for (var i = 0; i < message.deferred.length; ++i) {
                var error = $root.Trace.QueryPlanNode.DeferredNode.verify(message.deferred[i]);
                if (error)
                  return "deferred." + error;
              }
            }
            return null;
          };
          DeferNode.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.arrays || options.defaults)
              object.deferred = [];
            if (options.defaults)
              object.primary = null;
            if (message.primary != null && message.hasOwnProperty("primary"))
              object.primary = $root.Trace.QueryPlanNode.DeferNodePrimary.toObject(message.primary, options);
            if (message.deferred && message.deferred.length) {
              object.deferred = [];
              for (var j = 0; j < message.deferred.length; ++j)
                object.deferred[j] = $root.Trace.QueryPlanNode.DeferredNode.toObject(message.deferred[j], options);
            }
            return object;
          };
          DeferNode.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return DeferNode;
        }();
        QueryPlanNode.ConditionNode = function() {
          function ConditionNode(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          ConditionNode.prototype.condition = "";
          ConditionNode.prototype.ifClause = null;
          ConditionNode.prototype.elseClause = null;
          ConditionNode.create = function create(properties) {
            return new ConditionNode(properties);
          };
          ConditionNode.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.condition != null && Object.hasOwnProperty.call(message, "condition"))
              writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(message.condition);
            if (message.ifClause != null && Object.hasOwnProperty.call(message, "ifClause"))
              $root.Trace.QueryPlanNode.encode(message.ifClause, writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).fork()).ldelim();
            if (message.elseClause != null && Object.hasOwnProperty.call(message, "elseClause"))
              $root.Trace.QueryPlanNode.encode(message.elseClause, writer.uint32(
                /* id 3, wireType 2 =*/
                26
              ).fork()).ldelim();
            return writer;
          };
          ConditionNode.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          ConditionNode.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.ConditionNode();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.condition = reader.string();
                  break;
                case 2:
                  message.ifClause = $root.Trace.QueryPlanNode.decode(reader, reader.uint32());
                  break;
                case 3:
                  message.elseClause = $root.Trace.QueryPlanNode.decode(reader, reader.uint32());
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          ConditionNode.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          ConditionNode.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.condition != null && message.hasOwnProperty("condition")) {
              if (!$util.isString(message.condition))
                return "condition: string expected";
            }
            if (message.ifClause != null && message.hasOwnProperty("ifClause")) {
              var error = $root.Trace.QueryPlanNode.verify(message.ifClause);
              if (error)
                return "ifClause." + error;
            }
            if (message.elseClause != null && message.hasOwnProperty("elseClause")) {
              var error = $root.Trace.QueryPlanNode.verify(message.elseClause);
              if (error)
                return "elseClause." + error;
            }
            return null;
          };
          ConditionNode.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults) {
              object.condition = "";
              object.ifClause = null;
              object.elseClause = null;
            }
            if (message.condition != null && message.hasOwnProperty("condition"))
              object.condition = message.condition;
            if (message.ifClause != null && message.hasOwnProperty("ifClause"))
              object.ifClause = $root.Trace.QueryPlanNode.toObject(message.ifClause, options);
            if (message.elseClause != null && message.hasOwnProperty("elseClause"))
              object.elseClause = $root.Trace.QueryPlanNode.toObject(message.elseClause, options);
            return object;
          };
          ConditionNode.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return ConditionNode;
        }();
        QueryPlanNode.DeferNodePrimary = function() {
          function DeferNodePrimary(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          DeferNodePrimary.prototype.node = null;
          DeferNodePrimary.create = function create(properties) {
            return new DeferNodePrimary(properties);
          };
          DeferNodePrimary.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.node != null && Object.hasOwnProperty.call(message, "node"))
              $root.Trace.QueryPlanNode.encode(message.node, writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).fork()).ldelim();
            return writer;
          };
          DeferNodePrimary.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          DeferNodePrimary.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.DeferNodePrimary();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.node = $root.Trace.QueryPlanNode.decode(reader, reader.uint32());
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          DeferNodePrimary.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          DeferNodePrimary.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.node != null && message.hasOwnProperty("node")) {
              var error = $root.Trace.QueryPlanNode.verify(message.node);
              if (error)
                return "node." + error;
            }
            return null;
          };
          DeferNodePrimary.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults)
              object.node = null;
            if (message.node != null && message.hasOwnProperty("node"))
              object.node = $root.Trace.QueryPlanNode.toObject(message.node, options);
            return object;
          };
          DeferNodePrimary.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return DeferNodePrimary;
        }();
        QueryPlanNode.DeferredNode = function() {
          function DeferredNode(properties) {
            this.depends = [];
            this.path = [];
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          DeferredNode.prototype.depends = $util.emptyArray;
          DeferredNode.prototype.label = "";
          DeferredNode.prototype.path = $util.emptyArray;
          DeferredNode.prototype.node = null;
          DeferredNode.create = function create(properties) {
            return new DeferredNode(properties);
          };
          DeferredNode.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.depends != null && message.depends.length)
              for (var i = 0; i < message.depends.length; ++i)
                $root.Trace.QueryPlanNode.DeferredNodeDepends.encode(message.depends[i], writer.uint32(
                  /* id 1, wireType 2 =*/
                  10
                ).fork()).ldelim();
            if (message.label != null && Object.hasOwnProperty.call(message, "label"))
              writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).string(message.label);
            if (message.path != null && message.path.length)
              for (var i = 0; i < message.path.length; ++i)
                $root.Trace.QueryPlanNode.ResponsePathElement.encode(message.path[i], writer.uint32(
                  /* id 3, wireType 2 =*/
                  26
                ).fork()).ldelim();
            if (message.node != null && Object.hasOwnProperty.call(message, "node"))
              $root.Trace.QueryPlanNode.encode(message.node, writer.uint32(
                /* id 4, wireType 2 =*/
                34
              ).fork()).ldelim();
            return writer;
          };
          DeferredNode.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          DeferredNode.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.DeferredNode();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  if (!(message.depends && message.depends.length))
                    message.depends = [];
                  message.depends.push($root.Trace.QueryPlanNode.DeferredNodeDepends.decode(reader, reader.uint32()));
                  break;
                case 2:
                  message.label = reader.string();
                  break;
                case 3:
                  if (!(message.path && message.path.length))
                    message.path = [];
                  message.path.push($root.Trace.QueryPlanNode.ResponsePathElement.decode(reader, reader.uint32()));
                  break;
                case 4:
                  message.node = $root.Trace.QueryPlanNode.decode(reader, reader.uint32());
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          DeferredNode.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          DeferredNode.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.depends != null && message.hasOwnProperty("depends")) {
              if (!Array.isArray(message.depends))
                return "depends: array expected";
              for (var i = 0; i < message.depends.length; ++i) {
                var error = $root.Trace.QueryPlanNode.DeferredNodeDepends.verify(message.depends[i]);
                if (error)
                  return "depends." + error;
              }
            }
            if (message.label != null && message.hasOwnProperty("label")) {
              if (!$util.isString(message.label))
                return "label: string expected";
            }
            if (message.path != null && message.hasOwnProperty("path")) {
              if (!Array.isArray(message.path))
                return "path: array expected";
              for (var i = 0; i < message.path.length; ++i) {
                var error = $root.Trace.QueryPlanNode.ResponsePathElement.verify(message.path[i]);
                if (error)
                  return "path." + error;
              }
            }
            if (message.node != null && message.hasOwnProperty("node")) {
              var error = $root.Trace.QueryPlanNode.verify(message.node);
              if (error)
                return "node." + error;
            }
            return null;
          };
          DeferredNode.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.arrays || options.defaults) {
              object.depends = [];
              object.path = [];
            }
            if (options.defaults) {
              object.label = "";
              object.node = null;
            }
            if (message.depends && message.depends.length) {
              object.depends = [];
              for (var j = 0; j < message.depends.length; ++j)
                object.depends[j] = $root.Trace.QueryPlanNode.DeferredNodeDepends.toObject(message.depends[j], options);
            }
            if (message.label != null && message.hasOwnProperty("label"))
              object.label = message.label;
            if (message.path && message.path.length) {
              object.path = [];
              for (var j = 0; j < message.path.length; ++j)
                object.path[j] = $root.Trace.QueryPlanNode.ResponsePathElement.toObject(message.path[j], options);
            }
            if (message.node != null && message.hasOwnProperty("node"))
              object.node = $root.Trace.QueryPlanNode.toObject(message.node, options);
            return object;
          };
          DeferredNode.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return DeferredNode;
        }();
        QueryPlanNode.DeferredNodeDepends = function() {
          function DeferredNodeDepends(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          DeferredNodeDepends.prototype.id = "";
          DeferredNodeDepends.prototype.deferLabel = "";
          DeferredNodeDepends.create = function create(properties) {
            return new DeferredNodeDepends(properties);
          };
          DeferredNodeDepends.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
              writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(message.id);
            if (message.deferLabel != null && Object.hasOwnProperty.call(message, "deferLabel"))
              writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).string(message.deferLabel);
            return writer;
          };
          DeferredNodeDepends.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          DeferredNodeDepends.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.DeferredNodeDepends();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.id = reader.string();
                  break;
                case 2:
                  message.deferLabel = reader.string();
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          DeferredNodeDepends.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          DeferredNodeDepends.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.id != null && message.hasOwnProperty("id")) {
              if (!$util.isString(message.id))
                return "id: string expected";
            }
            if (message.deferLabel != null && message.hasOwnProperty("deferLabel")) {
              if (!$util.isString(message.deferLabel))
                return "deferLabel: string expected";
            }
            return null;
          };
          DeferredNodeDepends.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults) {
              object.id = "";
              object.deferLabel = "";
            }
            if (message.id != null && message.hasOwnProperty("id"))
              object.id = message.id;
            if (message.deferLabel != null && message.hasOwnProperty("deferLabel"))
              object.deferLabel = message.deferLabel;
            return object;
          };
          DeferredNodeDepends.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return DeferredNodeDepends;
        }();
        QueryPlanNode.ResponsePathElement = function() {
          function ResponsePathElement(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          ResponsePathElement.prototype.fieldName = "";
          ResponsePathElement.prototype.index = 0;
          var $oneOfFields2;
          Object.defineProperty(ResponsePathElement.prototype, "id", {
            get: $util.oneOfGetter($oneOfFields2 = ["fieldName", "index"]),
            set: $util.oneOfSetter($oneOfFields2)
          });
          ResponsePathElement.create = function create(properties) {
            return new ResponsePathElement(properties);
          };
          ResponsePathElement.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.fieldName != null && Object.hasOwnProperty.call(message, "fieldName"))
              writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(message.fieldName);
            if (message.index != null && Object.hasOwnProperty.call(message, "index"))
              writer.uint32(
                /* id 2, wireType 0 =*/
                16
              ).uint32(message.index);
            return writer;
          };
          ResponsePathElement.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          ResponsePathElement.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.ResponsePathElement();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.fieldName = reader.string();
                  break;
                case 2:
                  message.index = reader.uint32();
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          ResponsePathElement.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          ResponsePathElement.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            var properties = {};
            if (message.fieldName != null && message.hasOwnProperty("fieldName")) {
              properties.id = 1;
              if (!$util.isString(message.fieldName))
                return "fieldName: string expected";
            }
            if (message.index != null && message.hasOwnProperty("index")) {
              if (properties.id === 1)
                return "id: multiple values";
              properties.id = 1;
              if (!$util.isInteger(message.index))
                return "index: integer expected";
            }
            return null;
          };
          ResponsePathElement.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (message.fieldName != null && message.hasOwnProperty("fieldName")) {
              object.fieldName = message.fieldName;
              if (options.oneofs)
                object.id = "fieldName";
            }
            if (message.index != null && message.hasOwnProperty("index")) {
              object.index = message.index;
              if (options.oneofs)
                object.id = "index";
            }
            return object;
          };
          ResponsePathElement.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return ResponsePathElement;
        }();
        return QueryPlanNode;
      }();
      return Trace;
    }();
    $root.ReportHeader = function() {
      function ReportHeader(properties) {
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      ReportHeader.prototype.graphRef = "";
      ReportHeader.prototype.hostname = "";
      ReportHeader.prototype.agentVersion = "";
      ReportHeader.prototype.serviceVersion = "";
      ReportHeader.prototype.runtimeVersion = "";
      ReportHeader.prototype.uname = "";
      ReportHeader.prototype.executableSchemaId = "";
      ReportHeader.create = function create(properties) {
        return new ReportHeader(properties);
      };
      ReportHeader.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.hostname != null && Object.hasOwnProperty.call(message, "hostname"))
          writer.uint32(
            /* id 5, wireType 2 =*/
            42
          ).string(message.hostname);
        if (message.agentVersion != null && Object.hasOwnProperty.call(message, "agentVersion"))
          writer.uint32(
            /* id 6, wireType 2 =*/
            50
          ).string(message.agentVersion);
        if (message.serviceVersion != null && Object.hasOwnProperty.call(message, "serviceVersion"))
          writer.uint32(
            /* id 7, wireType 2 =*/
            58
          ).string(message.serviceVersion);
        if (message.runtimeVersion != null && Object.hasOwnProperty.call(message, "runtimeVersion"))
          writer.uint32(
            /* id 8, wireType 2 =*/
            66
          ).string(message.runtimeVersion);
        if (message.uname != null && Object.hasOwnProperty.call(message, "uname"))
          writer.uint32(
            /* id 9, wireType 2 =*/
            74
          ).string(message.uname);
        if (message.executableSchemaId != null && Object.hasOwnProperty.call(message, "executableSchemaId"))
          writer.uint32(
            /* id 11, wireType 2 =*/
            90
          ).string(message.executableSchemaId);
        if (message.graphRef != null && Object.hasOwnProperty.call(message, "graphRef"))
          writer.uint32(
            /* id 12, wireType 2 =*/
            98
          ).string(message.graphRef);
        return writer;
      };
      ReportHeader.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };
      ReportHeader.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ReportHeader();
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 12:
              message.graphRef = reader.string();
              break;
            case 5:
              message.hostname = reader.string();
              break;
            case 6:
              message.agentVersion = reader.string();
              break;
            case 7:
              message.serviceVersion = reader.string();
              break;
            case 8:
              message.runtimeVersion = reader.string();
              break;
            case 9:
              message.uname = reader.string();
              break;
            case 11:
              message.executableSchemaId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };
      ReportHeader.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      ReportHeader.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.graphRef != null && message.hasOwnProperty("graphRef")) {
          if (!$util.isString(message.graphRef))
            return "graphRef: string expected";
        }
        if (message.hostname != null && message.hasOwnProperty("hostname")) {
          if (!$util.isString(message.hostname))
            return "hostname: string expected";
        }
        if (message.agentVersion != null && message.hasOwnProperty("agentVersion")) {
          if (!$util.isString(message.agentVersion))
            return "agentVersion: string expected";
        }
        if (message.serviceVersion != null && message.hasOwnProperty("serviceVersion")) {
          if (!$util.isString(message.serviceVersion))
            return "serviceVersion: string expected";
        }
        if (message.runtimeVersion != null && message.hasOwnProperty("runtimeVersion")) {
          if (!$util.isString(message.runtimeVersion))
            return "runtimeVersion: string expected";
        }
        if (message.uname != null && message.hasOwnProperty("uname")) {
          if (!$util.isString(message.uname))
            return "uname: string expected";
        }
        if (message.executableSchemaId != null && message.hasOwnProperty("executableSchemaId")) {
          if (!$util.isString(message.executableSchemaId))
            return "executableSchemaId: string expected";
        }
        return null;
      };
      ReportHeader.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.defaults) {
          object.hostname = "";
          object.agentVersion = "";
          object.serviceVersion = "";
          object.runtimeVersion = "";
          object.uname = "";
          object.executableSchemaId = "";
          object.graphRef = "";
        }
        if (message.hostname != null && message.hasOwnProperty("hostname"))
          object.hostname = message.hostname;
        if (message.agentVersion != null && message.hasOwnProperty("agentVersion"))
          object.agentVersion = message.agentVersion;
        if (message.serviceVersion != null && message.hasOwnProperty("serviceVersion"))
          object.serviceVersion = message.serviceVersion;
        if (message.runtimeVersion != null && message.hasOwnProperty("runtimeVersion"))
          object.runtimeVersion = message.runtimeVersion;
        if (message.uname != null && message.hasOwnProperty("uname"))
          object.uname = message.uname;
        if (message.executableSchemaId != null && message.hasOwnProperty("executableSchemaId"))
          object.executableSchemaId = message.executableSchemaId;
        if (message.graphRef != null && message.hasOwnProperty("graphRef"))
          object.graphRef = message.graphRef;
        return object;
      };
      ReportHeader.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      return ReportHeader;
    }();
    $root.PathErrorStats = function() {
      function PathErrorStats(properties) {
        this.children = {};
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      PathErrorStats.prototype.children = $util.emptyObject;
      PathErrorStats.prototype.errorsCount = 0;
      PathErrorStats.prototype.requestsWithErrorsCount = 0;
      PathErrorStats.create = function create(properties) {
        return new PathErrorStats(properties);
      };
      PathErrorStats.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.children != null && Object.hasOwnProperty.call(message, "children"))
          for (var keys = Object.keys(message.children), i = 0; i < keys.length; ++i) {
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).fork().uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(keys[i]);
            $root.PathErrorStats.encode(message.children[keys[i]], writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim().ldelim();
          }
        if (message.errorsCount != null && Object.hasOwnProperty.call(message, "errorsCount"))
          writer.uint32(
            /* id 4, wireType 0 =*/
            32
          ).uint64(message.errorsCount);
        if (message.requestsWithErrorsCount != null && Object.hasOwnProperty.call(message, "requestsWithErrorsCount"))
          writer.uint32(
            /* id 5, wireType 0 =*/
            40
          ).uint64(message.requestsWithErrorsCount);
        return writer;
      };
      PathErrorStats.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };
      PathErrorStats.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.PathErrorStats(), key;
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              reader.skip().pos++;
              if (message.children === $util.emptyObject)
                message.children = {};
              key = reader.string();
              reader.pos++;
              message.children[key] = $root.PathErrorStats.decode(reader, reader.uint32());
              break;
            case 4:
              message.errorsCount = reader.uint64();
              break;
            case 5:
              message.requestsWithErrorsCount = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };
      PathErrorStats.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      PathErrorStats.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.children != null && message.hasOwnProperty("children")) {
          if (!$util.isObject(message.children))
            return "children: object expected";
          var key = Object.keys(message.children);
          for (var i = 0; i < key.length; ++i) {
            var error = $root.PathErrorStats.verify(message.children[key[i]]);
            if (error)
              return "children." + error;
          }
        }
        if (message.errorsCount != null && message.hasOwnProperty("errorsCount")) {
          if (!$util.isInteger(message.errorsCount) && !(message.errorsCount && $util.isInteger(message.errorsCount.low) && $util.isInteger(message.errorsCount.high)))
            return "errorsCount: integer|Long expected";
        }
        if (message.requestsWithErrorsCount != null && message.hasOwnProperty("requestsWithErrorsCount")) {
          if (!$util.isInteger(message.requestsWithErrorsCount) && !(message.requestsWithErrorsCount && $util.isInteger(message.requestsWithErrorsCount.low) && $util.isInteger(message.requestsWithErrorsCount.high)))
            return "requestsWithErrorsCount: integer|Long expected";
        }
        return null;
      };
      PathErrorStats.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.objects || options.defaults)
          object.children = {};
        if (options.defaults) {
          object.errorsCount = 0;
          object.requestsWithErrorsCount = 0;
        }
        var keys2;
        if (message.children && (keys2 = Object.keys(message.children)).length) {
          object.children = {};
          for (var j = 0; j < keys2.length; ++j)
            object.children[keys2[j]] = $root.PathErrorStats.toObject(message.children[keys2[j]], options);
        }
        if (message.errorsCount != null && message.hasOwnProperty("errorsCount"))
          if (typeof message.errorsCount === "number")
            object.errorsCount = options.longs === String ? String(message.errorsCount) : message.errorsCount;
          else
            object.errorsCount = options.longs === String ? $util.Long.prototype.toString.call(message.errorsCount) : options.longs === Number ? new $util.LongBits(message.errorsCount.low >>> 0, message.errorsCount.high >>> 0).toNumber(true) : message.errorsCount;
        if (message.requestsWithErrorsCount != null && message.hasOwnProperty("requestsWithErrorsCount"))
          if (typeof message.requestsWithErrorsCount === "number")
            object.requestsWithErrorsCount = options.longs === String ? String(message.requestsWithErrorsCount) : message.requestsWithErrorsCount;
          else
            object.requestsWithErrorsCount = options.longs === String ? $util.Long.prototype.toString.call(message.requestsWithErrorsCount) : options.longs === Number ? new $util.LongBits(message.requestsWithErrorsCount.low >>> 0, message.requestsWithErrorsCount.high >>> 0).toNumber(true) : message.requestsWithErrorsCount;
        return object;
      };
      PathErrorStats.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      return PathErrorStats;
    }();
    $root.QueryLatencyStats = function() {
      function QueryLatencyStats(properties) {
        this.latencyCount = [];
        this.cacheLatencyCount = [];
        this.publicCacheTtlCount = [];
        this.privateCacheTtlCount = [];
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      QueryLatencyStats.prototype.latencyCount = $util.emptyArray;
      QueryLatencyStats.prototype.requestCount = 0;
      QueryLatencyStats.prototype.cacheHits = 0;
      QueryLatencyStats.prototype.persistedQueryHits = 0;
      QueryLatencyStats.prototype.persistedQueryMisses = 0;
      QueryLatencyStats.prototype.cacheLatencyCount = $util.emptyArray;
      QueryLatencyStats.prototype.rootErrorStats = null;
      QueryLatencyStats.prototype.requestsWithErrorsCount = 0;
      QueryLatencyStats.prototype.publicCacheTtlCount = $util.emptyArray;
      QueryLatencyStats.prototype.privateCacheTtlCount = $util.emptyArray;
      QueryLatencyStats.prototype.registeredOperationCount = 0;
      QueryLatencyStats.prototype.forbiddenOperationCount = 0;
      QueryLatencyStats.prototype.requestsWithoutFieldInstrumentation = 0;
      QueryLatencyStats.create = function create(properties) {
        return new QueryLatencyStats(properties);
      };
      QueryLatencyStats.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.requestCount != null && Object.hasOwnProperty.call(message, "requestCount"))
          writer.uint32(
            /* id 2, wireType 0 =*/
            16
          ).uint64(message.requestCount);
        if (message.cacheHits != null && Object.hasOwnProperty.call(message, "cacheHits"))
          writer.uint32(
            /* id 3, wireType 0 =*/
            24
          ).uint64(message.cacheHits);
        if (message.persistedQueryHits != null && Object.hasOwnProperty.call(message, "persistedQueryHits"))
          writer.uint32(
            /* id 4, wireType 0 =*/
            32
          ).uint64(message.persistedQueryHits);
        if (message.persistedQueryMisses != null && Object.hasOwnProperty.call(message, "persistedQueryMisses"))
          writer.uint32(
            /* id 5, wireType 0 =*/
            40
          ).uint64(message.persistedQueryMisses);
        if (message.rootErrorStats != null && Object.hasOwnProperty.call(message, "rootErrorStats"))
          $root.PathErrorStats.encode(message.rootErrorStats, writer.uint32(
            /* id 7, wireType 2 =*/
            58
          ).fork()).ldelim();
        if (message.requestsWithErrorsCount != null && Object.hasOwnProperty.call(message, "requestsWithErrorsCount"))
          writer.uint32(
            /* id 8, wireType 0 =*/
            64
          ).uint64(message.requestsWithErrorsCount);
        if (message.registeredOperationCount != null && Object.hasOwnProperty.call(message, "registeredOperationCount"))
          writer.uint32(
            /* id 11, wireType 0 =*/
            88
          ).uint64(message.registeredOperationCount);
        if (message.forbiddenOperationCount != null && Object.hasOwnProperty.call(message, "forbiddenOperationCount"))
          writer.uint32(
            /* id 12, wireType 0 =*/
            96
          ).uint64(message.forbiddenOperationCount);
        var array13;
        if (message.latencyCount != null && message.latencyCount.toArray)
          array13 = message.latencyCount.toArray();
        else
          array13 = message.latencyCount;
        if (array13 != null && array13.length) {
          writer.uint32(
            /* id 13, wireType 2 =*/
            106
          ).fork();
          for (var i = 0; i < array13.length; ++i)
            writer.sint64(array13[i]);
          writer.ldelim();
        }
        var array14;
        if (message.cacheLatencyCount != null && message.cacheLatencyCount.toArray)
          array14 = message.cacheLatencyCount.toArray();
        else
          array14 = message.cacheLatencyCount;
        if (array14 != null && array14.length) {
          writer.uint32(
            /* id 14, wireType 2 =*/
            114
          ).fork();
          for (var i = 0; i < array14.length; ++i)
            writer.sint64(array14[i]);
          writer.ldelim();
        }
        var array15;
        if (message.publicCacheTtlCount != null && message.publicCacheTtlCount.toArray)
          array15 = message.publicCacheTtlCount.toArray();
        else
          array15 = message.publicCacheTtlCount;
        if (array15 != null && array15.length) {
          writer.uint32(
            /* id 15, wireType 2 =*/
            122
          ).fork();
          for (var i = 0; i < array15.length; ++i)
            writer.sint64(array15[i]);
          writer.ldelim();
        }
        var array16;
        if (message.privateCacheTtlCount != null && message.privateCacheTtlCount.toArray)
          array16 = message.privateCacheTtlCount.toArray();
        else
          array16 = message.privateCacheTtlCount;
        if (array16 != null && array16.length) {
          writer.uint32(
            /* id 16, wireType 2 =*/
            130
          ).fork();
          for (var i = 0; i < array16.length; ++i)
            writer.sint64(array16[i]);
          writer.ldelim();
        }
        if (message.requestsWithoutFieldInstrumentation != null && Object.hasOwnProperty.call(message, "requestsWithoutFieldInstrumentation"))
          writer.uint32(
            /* id 17, wireType 0 =*/
            136
          ).uint64(message.requestsWithoutFieldInstrumentation);
        return writer;
      };
      QueryLatencyStats.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };
      QueryLatencyStats.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.QueryLatencyStats();
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 13:
              if (!(message.latencyCount && message.latencyCount.length))
                message.latencyCount = [];
              if ((tag & 7) === 2) {
                var end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2)
                  message.latencyCount.push(reader.sint64());
              } else
                message.latencyCount.push(reader.sint64());
              break;
            case 2:
              message.requestCount = reader.uint64();
              break;
            case 3:
              message.cacheHits = reader.uint64();
              break;
            case 4:
              message.persistedQueryHits = reader.uint64();
              break;
            case 5:
              message.persistedQueryMisses = reader.uint64();
              break;
            case 14:
              if (!(message.cacheLatencyCount && message.cacheLatencyCount.length))
                message.cacheLatencyCount = [];
              if ((tag & 7) === 2) {
                var end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2)
                  message.cacheLatencyCount.push(reader.sint64());
              } else
                message.cacheLatencyCount.push(reader.sint64());
              break;
            case 7:
              message.rootErrorStats = $root.PathErrorStats.decode(reader, reader.uint32());
              break;
            case 8:
              message.requestsWithErrorsCount = reader.uint64();
              break;
            case 15:
              if (!(message.publicCacheTtlCount && message.publicCacheTtlCount.length))
                message.publicCacheTtlCount = [];
              if ((tag & 7) === 2) {
                var end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2)
                  message.publicCacheTtlCount.push(reader.sint64());
              } else
                message.publicCacheTtlCount.push(reader.sint64());
              break;
            case 16:
              if (!(message.privateCacheTtlCount && message.privateCacheTtlCount.length))
                message.privateCacheTtlCount = [];
              if ((tag & 7) === 2) {
                var end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2)
                  message.privateCacheTtlCount.push(reader.sint64());
              } else
                message.privateCacheTtlCount.push(reader.sint64());
              break;
            case 11:
              message.registeredOperationCount = reader.uint64();
              break;
            case 12:
              message.forbiddenOperationCount = reader.uint64();
              break;
            case 17:
              message.requestsWithoutFieldInstrumentation = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };
      QueryLatencyStats.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      QueryLatencyStats.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.latencyCount != null && message.hasOwnProperty("latencyCount")) {
          var array13;
          if (message.latencyCount != null && message.latencyCount.toArray)
            array13 = message.latencyCount.toArray();
          else
            array13 = message.latencyCount;
          if (!Array.isArray(array13))
            return "latencyCount: array expected";
          for (var i = 0; i < array13.length; ++i)
            if (!$util.isInteger(array13[i]) && !(array13[i] && $util.isInteger(array13[i].low) && $util.isInteger(array13[i].high)))
              return "latencyCount: integer|Long[] expected";
        }
        if (message.requestCount != null && message.hasOwnProperty("requestCount")) {
          if (!$util.isInteger(message.requestCount) && !(message.requestCount && $util.isInteger(message.requestCount.low) && $util.isInteger(message.requestCount.high)))
            return "requestCount: integer|Long expected";
        }
        if (message.cacheHits != null && message.hasOwnProperty("cacheHits")) {
          if (!$util.isInteger(message.cacheHits) && !(message.cacheHits && $util.isInteger(message.cacheHits.low) && $util.isInteger(message.cacheHits.high)))
            return "cacheHits: integer|Long expected";
        }
        if (message.persistedQueryHits != null && message.hasOwnProperty("persistedQueryHits")) {
          if (!$util.isInteger(message.persistedQueryHits) && !(message.persistedQueryHits && $util.isInteger(message.persistedQueryHits.low) && $util.isInteger(message.persistedQueryHits.high)))
            return "persistedQueryHits: integer|Long expected";
        }
        if (message.persistedQueryMisses != null && message.hasOwnProperty("persistedQueryMisses")) {
          if (!$util.isInteger(message.persistedQueryMisses) && !(message.persistedQueryMisses && $util.isInteger(message.persistedQueryMisses.low) && $util.isInteger(message.persistedQueryMisses.high)))
            return "persistedQueryMisses: integer|Long expected";
        }
        if (message.cacheLatencyCount != null && message.hasOwnProperty("cacheLatencyCount")) {
          var array14;
          if (message.cacheLatencyCount != null && message.cacheLatencyCount.toArray)
            array14 = message.cacheLatencyCount.toArray();
          else
            array14 = message.cacheLatencyCount;
          if (!Array.isArray(array14))
            return "cacheLatencyCount: array expected";
          for (var i = 0; i < array14.length; ++i)
            if (!$util.isInteger(array14[i]) && !(array14[i] && $util.isInteger(array14[i].low) && $util.isInteger(array14[i].high)))
              return "cacheLatencyCount: integer|Long[] expected";
        }
        if (message.rootErrorStats != null && message.hasOwnProperty("rootErrorStats")) {
          var error = $root.PathErrorStats.verify(message.rootErrorStats);
          if (error)
            return "rootErrorStats." + error;
        }
        if (message.requestsWithErrorsCount != null && message.hasOwnProperty("requestsWithErrorsCount")) {
          if (!$util.isInteger(message.requestsWithErrorsCount) && !(message.requestsWithErrorsCount && $util.isInteger(message.requestsWithErrorsCount.low) && $util.isInteger(message.requestsWithErrorsCount.high)))
            return "requestsWithErrorsCount: integer|Long expected";
        }
        if (message.publicCacheTtlCount != null && message.hasOwnProperty("publicCacheTtlCount")) {
          var array15;
          if (message.publicCacheTtlCount != null && message.publicCacheTtlCount.toArray)
            array15 = message.publicCacheTtlCount.toArray();
          else
            array15 = message.publicCacheTtlCount;
          if (!Array.isArray(array15))
            return "publicCacheTtlCount: array expected";
          for (var i = 0; i < array15.length; ++i)
            if (!$util.isInteger(array15[i]) && !(array15[i] && $util.isInteger(array15[i].low) && $util.isInteger(array15[i].high)))
              return "publicCacheTtlCount: integer|Long[] expected";
        }
        if (message.privateCacheTtlCount != null && message.hasOwnProperty("privateCacheTtlCount")) {
          var array16;
          if (message.privateCacheTtlCount != null && message.privateCacheTtlCount.toArray)
            array16 = message.privateCacheTtlCount.toArray();
          else
            array16 = message.privateCacheTtlCount;
          if (!Array.isArray(array16))
            return "privateCacheTtlCount: array expected";
          for (var i = 0; i < array16.length; ++i)
            if (!$util.isInteger(array16[i]) && !(array16[i] && $util.isInteger(array16[i].low) && $util.isInteger(array16[i].high)))
              return "privateCacheTtlCount: integer|Long[] expected";
        }
        if (message.registeredOperationCount != null && message.hasOwnProperty("registeredOperationCount")) {
          if (!$util.isInteger(message.registeredOperationCount) && !(message.registeredOperationCount && $util.isInteger(message.registeredOperationCount.low) && $util.isInteger(message.registeredOperationCount.high)))
            return "registeredOperationCount: integer|Long expected";
        }
        if (message.forbiddenOperationCount != null && message.hasOwnProperty("forbiddenOperationCount")) {
          if (!$util.isInteger(message.forbiddenOperationCount) && !(message.forbiddenOperationCount && $util.isInteger(message.forbiddenOperationCount.low) && $util.isInteger(message.forbiddenOperationCount.high)))
            return "forbiddenOperationCount: integer|Long expected";
        }
        if (message.requestsWithoutFieldInstrumentation != null && message.hasOwnProperty("requestsWithoutFieldInstrumentation")) {
          if (!$util.isInteger(message.requestsWithoutFieldInstrumentation) && !(message.requestsWithoutFieldInstrumentation && $util.isInteger(message.requestsWithoutFieldInstrumentation.low) && $util.isInteger(message.requestsWithoutFieldInstrumentation.high)))
            return "requestsWithoutFieldInstrumentation: integer|Long expected";
        }
        return null;
      };
      QueryLatencyStats.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.arrays || options.defaults) {
          object.latencyCount = [];
          object.cacheLatencyCount = [];
          object.publicCacheTtlCount = [];
          object.privateCacheTtlCount = [];
        }
        if (options.defaults) {
          object.requestCount = 0;
          object.cacheHits = 0;
          object.persistedQueryHits = 0;
          object.persistedQueryMisses = 0;
          object.rootErrorStats = null;
          object.requestsWithErrorsCount = 0;
          object.registeredOperationCount = 0;
          object.forbiddenOperationCount = 0;
          object.requestsWithoutFieldInstrumentation = 0;
        }
        if (message.requestCount != null && message.hasOwnProperty("requestCount"))
          if (typeof message.requestCount === "number")
            object.requestCount = options.longs === String ? String(message.requestCount) : message.requestCount;
          else
            object.requestCount = options.longs === String ? $util.Long.prototype.toString.call(message.requestCount) : options.longs === Number ? new $util.LongBits(message.requestCount.low >>> 0, message.requestCount.high >>> 0).toNumber(true) : message.requestCount;
        if (message.cacheHits != null && message.hasOwnProperty("cacheHits"))
          if (typeof message.cacheHits === "number")
            object.cacheHits = options.longs === String ? String(message.cacheHits) : message.cacheHits;
          else
            object.cacheHits = options.longs === String ? $util.Long.prototype.toString.call(message.cacheHits) : options.longs === Number ? new $util.LongBits(message.cacheHits.low >>> 0, message.cacheHits.high >>> 0).toNumber(true) : message.cacheHits;
        if (message.persistedQueryHits != null && message.hasOwnProperty("persistedQueryHits"))
          if (typeof message.persistedQueryHits === "number")
            object.persistedQueryHits = options.longs === String ? String(message.persistedQueryHits) : message.persistedQueryHits;
          else
            object.persistedQueryHits = options.longs === String ? $util.Long.prototype.toString.call(message.persistedQueryHits) : options.longs === Number ? new $util.LongBits(message.persistedQueryHits.low >>> 0, message.persistedQueryHits.high >>> 0).toNumber(true) : message.persistedQueryHits;
        if (message.persistedQueryMisses != null && message.hasOwnProperty("persistedQueryMisses"))
          if (typeof message.persistedQueryMisses === "number")
            object.persistedQueryMisses = options.longs === String ? String(message.persistedQueryMisses) : message.persistedQueryMisses;
          else
            object.persistedQueryMisses = options.longs === String ? $util.Long.prototype.toString.call(message.persistedQueryMisses) : options.longs === Number ? new $util.LongBits(message.persistedQueryMisses.low >>> 0, message.persistedQueryMisses.high >>> 0).toNumber(true) : message.persistedQueryMisses;
        if (message.rootErrorStats != null && message.hasOwnProperty("rootErrorStats"))
          object.rootErrorStats = $root.PathErrorStats.toObject(message.rootErrorStats, options);
        if (message.requestsWithErrorsCount != null && message.hasOwnProperty("requestsWithErrorsCount"))
          if (typeof message.requestsWithErrorsCount === "number")
            object.requestsWithErrorsCount = options.longs === String ? String(message.requestsWithErrorsCount) : message.requestsWithErrorsCount;
          else
            object.requestsWithErrorsCount = options.longs === String ? $util.Long.prototype.toString.call(message.requestsWithErrorsCount) : options.longs === Number ? new $util.LongBits(message.requestsWithErrorsCount.low >>> 0, message.requestsWithErrorsCount.high >>> 0).toNumber(true) : message.requestsWithErrorsCount;
        if (message.registeredOperationCount != null && message.hasOwnProperty("registeredOperationCount"))
          if (typeof message.registeredOperationCount === "number")
            object.registeredOperationCount = options.longs === String ? String(message.registeredOperationCount) : message.registeredOperationCount;
          else
            object.registeredOperationCount = options.longs === String ? $util.Long.prototype.toString.call(message.registeredOperationCount) : options.longs === Number ? new $util.LongBits(message.registeredOperationCount.low >>> 0, message.registeredOperationCount.high >>> 0).toNumber(true) : message.registeredOperationCount;
        if (message.forbiddenOperationCount != null && message.hasOwnProperty("forbiddenOperationCount"))
          if (typeof message.forbiddenOperationCount === "number")
            object.forbiddenOperationCount = options.longs === String ? String(message.forbiddenOperationCount) : message.forbiddenOperationCount;
          else
            object.forbiddenOperationCount = options.longs === String ? $util.Long.prototype.toString.call(message.forbiddenOperationCount) : options.longs === Number ? new $util.LongBits(message.forbiddenOperationCount.low >>> 0, message.forbiddenOperationCount.high >>> 0).toNumber(true) : message.forbiddenOperationCount;
        if (message.latencyCount && message.latencyCount.length) {
          object.latencyCount = [];
          for (var j = 0; j < message.latencyCount.length; ++j)
            if (typeof message.latencyCount[j] === "number")
              object.latencyCount[j] = options.longs === String ? String(message.latencyCount[j]) : message.latencyCount[j];
            else
              object.latencyCount[j] = options.longs === String ? $util.Long.prototype.toString.call(message.latencyCount[j]) : options.longs === Number ? new $util.LongBits(message.latencyCount[j].low >>> 0, message.latencyCount[j].high >>> 0).toNumber() : message.latencyCount[j];
        }
        if (message.cacheLatencyCount && message.cacheLatencyCount.length) {
          object.cacheLatencyCount = [];
          for (var j = 0; j < message.cacheLatencyCount.length; ++j)
            if (typeof message.cacheLatencyCount[j] === "number")
              object.cacheLatencyCount[j] = options.longs === String ? String(message.cacheLatencyCount[j]) : message.cacheLatencyCount[j];
            else
              object.cacheLatencyCount[j] = options.longs === String ? $util.Long.prototype.toString.call(message.cacheLatencyCount[j]) : options.longs === Number ? new $util.LongBits(message.cacheLatencyCount[j].low >>> 0, message.cacheLatencyCount[j].high >>> 0).toNumber() : message.cacheLatencyCount[j];
        }
        if (message.publicCacheTtlCount && message.publicCacheTtlCount.length) {
          object.publicCacheTtlCount = [];
          for (var j = 0; j < message.publicCacheTtlCount.length; ++j)
            if (typeof message.publicCacheTtlCount[j] === "number")
              object.publicCacheTtlCount[j] = options.longs === String ? String(message.publicCacheTtlCount[j]) : message.publicCacheTtlCount[j];
            else
              object.publicCacheTtlCount[j] = options.longs === String ? $util.Long.prototype.toString.call(message.publicCacheTtlCount[j]) : options.longs === Number ? new $util.LongBits(message.publicCacheTtlCount[j].low >>> 0, message.publicCacheTtlCount[j].high >>> 0).toNumber() : message.publicCacheTtlCount[j];
        }
        if (message.privateCacheTtlCount && message.privateCacheTtlCount.length) {
          object.privateCacheTtlCount = [];
          for (var j = 0; j < message.privateCacheTtlCount.length; ++j)
            if (typeof message.privateCacheTtlCount[j] === "number")
              object.privateCacheTtlCount[j] = options.longs === String ? String(message.privateCacheTtlCount[j]) : message.privateCacheTtlCount[j];
            else
              object.privateCacheTtlCount[j] = options.longs === String ? $util.Long.prototype.toString.call(message.privateCacheTtlCount[j]) : options.longs === Number ? new $util.LongBits(message.privateCacheTtlCount[j].low >>> 0, message.privateCacheTtlCount[j].high >>> 0).toNumber() : message.privateCacheTtlCount[j];
        }
        if (message.requestsWithoutFieldInstrumentation != null && message.hasOwnProperty("requestsWithoutFieldInstrumentation"))
          if (typeof message.requestsWithoutFieldInstrumentation === "number")
            object.requestsWithoutFieldInstrumentation = options.longs === String ? String(message.requestsWithoutFieldInstrumentation) : message.requestsWithoutFieldInstrumentation;
          else
            object.requestsWithoutFieldInstrumentation = options.longs === String ? $util.Long.prototype.toString.call(message.requestsWithoutFieldInstrumentation) : options.longs === Number ? new $util.LongBits(message.requestsWithoutFieldInstrumentation.low >>> 0, message.requestsWithoutFieldInstrumentation.high >>> 0).toNumber(true) : message.requestsWithoutFieldInstrumentation;
        return object;
      };
      QueryLatencyStats.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      return QueryLatencyStats;
    }();
    $root.StatsContext = function() {
      function StatsContext(properties) {
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      StatsContext.prototype.clientName = "";
      StatsContext.prototype.clientVersion = "";
      StatsContext.create = function create(properties) {
        return new StatsContext(properties);
      };
      StatsContext.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.clientName != null && Object.hasOwnProperty.call(message, "clientName"))
          writer.uint32(
            /* id 2, wireType 2 =*/
            18
          ).string(message.clientName);
        if (message.clientVersion != null && Object.hasOwnProperty.call(message, "clientVersion"))
          writer.uint32(
            /* id 3, wireType 2 =*/
            26
          ).string(message.clientVersion);
        return writer;
      };
      StatsContext.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };
      StatsContext.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.StatsContext();
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 2:
              message.clientName = reader.string();
              break;
            case 3:
              message.clientVersion = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };
      StatsContext.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      StatsContext.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.clientName != null && message.hasOwnProperty("clientName")) {
          if (!$util.isString(message.clientName))
            return "clientName: string expected";
        }
        if (message.clientVersion != null && message.hasOwnProperty("clientVersion")) {
          if (!$util.isString(message.clientVersion))
            return "clientVersion: string expected";
        }
        return null;
      };
      StatsContext.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.defaults) {
          object.clientName = "";
          object.clientVersion = "";
        }
        if (message.clientName != null && message.hasOwnProperty("clientName"))
          object.clientName = message.clientName;
        if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
          object.clientVersion = message.clientVersion;
        return object;
      };
      StatsContext.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      return StatsContext;
    }();
    $root.ContextualizedQueryLatencyStats = function() {
      function ContextualizedQueryLatencyStats(properties) {
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      ContextualizedQueryLatencyStats.prototype.queryLatencyStats = null;
      ContextualizedQueryLatencyStats.prototype.context = null;
      ContextualizedQueryLatencyStats.create = function create(properties) {
        return new ContextualizedQueryLatencyStats(properties);
      };
      ContextualizedQueryLatencyStats.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.queryLatencyStats != null && Object.hasOwnProperty.call(message, "queryLatencyStats"))
          $root.QueryLatencyStats.encode(message.queryLatencyStats, writer.uint32(
            /* id 1, wireType 2 =*/
            10
          ).fork()).ldelim();
        if (message.context != null && Object.hasOwnProperty.call(message, "context"))
          $root.StatsContext.encode(message.context, writer.uint32(
            /* id 2, wireType 2 =*/
            18
          ).fork()).ldelim();
        return writer;
      };
      ContextualizedQueryLatencyStats.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };
      ContextualizedQueryLatencyStats.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ContextualizedQueryLatencyStats();
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.queryLatencyStats = $root.QueryLatencyStats.decode(reader, reader.uint32());
              break;
            case 2:
              message.context = $root.StatsContext.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };
      ContextualizedQueryLatencyStats.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      ContextualizedQueryLatencyStats.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.queryLatencyStats != null && message.hasOwnProperty("queryLatencyStats")) {
          var error = $root.QueryLatencyStats.verify(message.queryLatencyStats);
          if (error)
            return "queryLatencyStats." + error;
        }
        if (message.context != null && message.hasOwnProperty("context")) {
          var error = $root.StatsContext.verify(message.context);
          if (error)
            return "context." + error;
        }
        return null;
      };
      ContextualizedQueryLatencyStats.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.defaults) {
          object.queryLatencyStats = null;
          object.context = null;
        }
        if (message.queryLatencyStats != null && message.hasOwnProperty("queryLatencyStats"))
          object.queryLatencyStats = $root.QueryLatencyStats.toObject(message.queryLatencyStats, options);
        if (message.context != null && message.hasOwnProperty("context"))
          object.context = $root.StatsContext.toObject(message.context, options);
        return object;
      };
      ContextualizedQueryLatencyStats.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      return ContextualizedQueryLatencyStats;
    }();
    $root.ContextualizedTypeStats = function() {
      function ContextualizedTypeStats(properties) {
        this.perTypeStat = {};
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      ContextualizedTypeStats.prototype.context = null;
      ContextualizedTypeStats.prototype.perTypeStat = $util.emptyObject;
      ContextualizedTypeStats.create = function create(properties) {
        return new ContextualizedTypeStats(properties);
      };
      ContextualizedTypeStats.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.context != null && Object.hasOwnProperty.call(message, "context"))
          $root.StatsContext.encode(message.context, writer.uint32(
            /* id 1, wireType 2 =*/
            10
          ).fork()).ldelim();
        if (message.perTypeStat != null && Object.hasOwnProperty.call(message, "perTypeStat"))
          for (var keys = Object.keys(message.perTypeStat), i = 0; i < keys.length; ++i) {
            writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork().uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(keys[i]);
            $root.TypeStat.encode(message.perTypeStat[keys[i]], writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim().ldelim();
          }
        return writer;
      };
      ContextualizedTypeStats.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };
      ContextualizedTypeStats.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ContextualizedTypeStats(), key;
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.context = $root.StatsContext.decode(reader, reader.uint32());
              break;
            case 2:
              reader.skip().pos++;
              if (message.perTypeStat === $util.emptyObject)
                message.perTypeStat = {};
              key = reader.string();
              reader.pos++;
              message.perTypeStat[key] = $root.TypeStat.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };
      ContextualizedTypeStats.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      ContextualizedTypeStats.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.context != null && message.hasOwnProperty("context")) {
          var error = $root.StatsContext.verify(message.context);
          if (error)
            return "context." + error;
        }
        if (message.perTypeStat != null && message.hasOwnProperty("perTypeStat")) {
          if (!$util.isObject(message.perTypeStat))
            return "perTypeStat: object expected";
          var key = Object.keys(message.perTypeStat);
          for (var i = 0; i < key.length; ++i) {
            var error = $root.TypeStat.verify(message.perTypeStat[key[i]]);
            if (error)
              return "perTypeStat." + error;
          }
        }
        return null;
      };
      ContextualizedTypeStats.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.objects || options.defaults)
          object.perTypeStat = {};
        if (options.defaults)
          object.context = null;
        if (message.context != null && message.hasOwnProperty("context"))
          object.context = $root.StatsContext.toObject(message.context, options);
        var keys2;
        if (message.perTypeStat && (keys2 = Object.keys(message.perTypeStat)).length) {
          object.perTypeStat = {};
          for (var j = 0; j < keys2.length; ++j)
            object.perTypeStat[keys2[j]] = $root.TypeStat.toObject(message.perTypeStat[keys2[j]], options);
        }
        return object;
      };
      ContextualizedTypeStats.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      return ContextualizedTypeStats;
    }();
    $root.FieldStat = function() {
      function FieldStat(properties) {
        this.latencyCount = [];
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      FieldStat.prototype.returnType = "";
      FieldStat.prototype.errorsCount = 0;
      FieldStat.prototype.observedExecutionCount = 0;
      FieldStat.prototype.estimatedExecutionCount = 0;
      FieldStat.prototype.requestsWithErrorsCount = 0;
      FieldStat.prototype.latencyCount = $util.emptyArray;
      FieldStat.create = function create(properties) {
        return new FieldStat(properties);
      };
      FieldStat.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.returnType != null && Object.hasOwnProperty.call(message, "returnType"))
          writer.uint32(
            /* id 3, wireType 2 =*/
            26
          ).string(message.returnType);
        if (message.errorsCount != null && Object.hasOwnProperty.call(message, "errorsCount"))
          writer.uint32(
            /* id 4, wireType 0 =*/
            32
          ).uint64(message.errorsCount);
        if (message.observedExecutionCount != null && Object.hasOwnProperty.call(message, "observedExecutionCount"))
          writer.uint32(
            /* id 5, wireType 0 =*/
            40
          ).uint64(message.observedExecutionCount);
        if (message.requestsWithErrorsCount != null && Object.hasOwnProperty.call(message, "requestsWithErrorsCount"))
          writer.uint32(
            /* id 6, wireType 0 =*/
            48
          ).uint64(message.requestsWithErrorsCount);
        var array9;
        if (message.latencyCount != null && message.latencyCount.toArray)
          array9 = message.latencyCount.toArray();
        else
          array9 = message.latencyCount;
        if (array9 != null && array9.length) {
          writer.uint32(
            /* id 9, wireType 2 =*/
            74
          ).fork();
          for (var i = 0; i < array9.length; ++i)
            writer.sint64(array9[i]);
          writer.ldelim();
        }
        if (message.estimatedExecutionCount != null && Object.hasOwnProperty.call(message, "estimatedExecutionCount"))
          writer.uint32(
            /* id 10, wireType 0 =*/
            80
          ).uint64(message.estimatedExecutionCount);
        return writer;
      };
      FieldStat.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };
      FieldStat.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.FieldStat();
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 3:
              message.returnType = reader.string();
              break;
            case 4:
              message.errorsCount = reader.uint64();
              break;
            case 5:
              message.observedExecutionCount = reader.uint64();
              break;
            case 10:
              message.estimatedExecutionCount = reader.uint64();
              break;
            case 6:
              message.requestsWithErrorsCount = reader.uint64();
              break;
            case 9:
              if (!(message.latencyCount && message.latencyCount.length))
                message.latencyCount = [];
              if ((tag & 7) === 2) {
                var end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2)
                  message.latencyCount.push(reader.sint64());
              } else
                message.latencyCount.push(reader.sint64());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };
      FieldStat.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      FieldStat.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.returnType != null && message.hasOwnProperty("returnType")) {
          if (!$util.isString(message.returnType))
            return "returnType: string expected";
        }
        if (message.errorsCount != null && message.hasOwnProperty("errorsCount")) {
          if (!$util.isInteger(message.errorsCount) && !(message.errorsCount && $util.isInteger(message.errorsCount.low) && $util.isInteger(message.errorsCount.high)))
            return "errorsCount: integer|Long expected";
        }
        if (message.observedExecutionCount != null && message.hasOwnProperty("observedExecutionCount")) {
          if (!$util.isInteger(message.observedExecutionCount) && !(message.observedExecutionCount && $util.isInteger(message.observedExecutionCount.low) && $util.isInteger(message.observedExecutionCount.high)))
            return "observedExecutionCount: integer|Long expected";
        }
        if (message.estimatedExecutionCount != null && message.hasOwnProperty("estimatedExecutionCount")) {
          if (!$util.isInteger(message.estimatedExecutionCount) && !(message.estimatedExecutionCount && $util.isInteger(message.estimatedExecutionCount.low) && $util.isInteger(message.estimatedExecutionCount.high)))
            return "estimatedExecutionCount: integer|Long expected";
        }
        if (message.requestsWithErrorsCount != null && message.hasOwnProperty("requestsWithErrorsCount")) {
          if (!$util.isInteger(message.requestsWithErrorsCount) && !(message.requestsWithErrorsCount && $util.isInteger(message.requestsWithErrorsCount.low) && $util.isInteger(message.requestsWithErrorsCount.high)))
            return "requestsWithErrorsCount: integer|Long expected";
        }
        if (message.latencyCount != null && message.hasOwnProperty("latencyCount")) {
          var array9;
          if (message.latencyCount != null && message.latencyCount.toArray)
            array9 = message.latencyCount.toArray();
          else
            array9 = message.latencyCount;
          if (!Array.isArray(array9))
            return "latencyCount: array expected";
          for (var i = 0; i < array9.length; ++i)
            if (!$util.isInteger(array9[i]) && !(array9[i] && $util.isInteger(array9[i].low) && $util.isInteger(array9[i].high)))
              return "latencyCount: integer|Long[] expected";
        }
        return null;
      };
      FieldStat.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.arrays || options.defaults)
          object.latencyCount = [];
        if (options.defaults) {
          object.returnType = "";
          object.errorsCount = 0;
          object.observedExecutionCount = 0;
          object.requestsWithErrorsCount = 0;
          object.estimatedExecutionCount = 0;
        }
        if (message.returnType != null && message.hasOwnProperty("returnType"))
          object.returnType = message.returnType;
        if (message.errorsCount != null && message.hasOwnProperty("errorsCount"))
          if (typeof message.errorsCount === "number")
            object.errorsCount = options.longs === String ? String(message.errorsCount) : message.errorsCount;
          else
            object.errorsCount = options.longs === String ? $util.Long.prototype.toString.call(message.errorsCount) : options.longs === Number ? new $util.LongBits(message.errorsCount.low >>> 0, message.errorsCount.high >>> 0).toNumber(true) : message.errorsCount;
        if (message.observedExecutionCount != null && message.hasOwnProperty("observedExecutionCount"))
          if (typeof message.observedExecutionCount === "number")
            object.observedExecutionCount = options.longs === String ? String(message.observedExecutionCount) : message.observedExecutionCount;
          else
            object.observedExecutionCount = options.longs === String ? $util.Long.prototype.toString.call(message.observedExecutionCount) : options.longs === Number ? new $util.LongBits(message.observedExecutionCount.low >>> 0, message.observedExecutionCount.high >>> 0).toNumber(true) : message.observedExecutionCount;
        if (message.requestsWithErrorsCount != null && message.hasOwnProperty("requestsWithErrorsCount"))
          if (typeof message.requestsWithErrorsCount === "number")
            object.requestsWithErrorsCount = options.longs === String ? String(message.requestsWithErrorsCount) : message.requestsWithErrorsCount;
          else
            object.requestsWithErrorsCount = options.longs === String ? $util.Long.prototype.toString.call(message.requestsWithErrorsCount) : options.longs === Number ? new $util.LongBits(message.requestsWithErrorsCount.low >>> 0, message.requestsWithErrorsCount.high >>> 0).toNumber(true) : message.requestsWithErrorsCount;
        if (message.latencyCount && message.latencyCount.length) {
          object.latencyCount = [];
          for (var j = 0; j < message.latencyCount.length; ++j)
            if (typeof message.latencyCount[j] === "number")
              object.latencyCount[j] = options.longs === String ? String(message.latencyCount[j]) : message.latencyCount[j];
            else
              object.latencyCount[j] = options.longs === String ? $util.Long.prototype.toString.call(message.latencyCount[j]) : options.longs === Number ? new $util.LongBits(message.latencyCount[j].low >>> 0, message.latencyCount[j].high >>> 0).toNumber() : message.latencyCount[j];
        }
        if (message.estimatedExecutionCount != null && message.hasOwnProperty("estimatedExecutionCount"))
          if (typeof message.estimatedExecutionCount === "number")
            object.estimatedExecutionCount = options.longs === String ? String(message.estimatedExecutionCount) : message.estimatedExecutionCount;
          else
            object.estimatedExecutionCount = options.longs === String ? $util.Long.prototype.toString.call(message.estimatedExecutionCount) : options.longs === Number ? new $util.LongBits(message.estimatedExecutionCount.low >>> 0, message.estimatedExecutionCount.high >>> 0).toNumber(true) : message.estimatedExecutionCount;
        return object;
      };
      FieldStat.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      return FieldStat;
    }();
    $root.TypeStat = function() {
      function TypeStat(properties) {
        this.perFieldStat = {};
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      TypeStat.prototype.perFieldStat = $util.emptyObject;
      TypeStat.create = function create(properties) {
        return new TypeStat(properties);
      };
      TypeStat.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.perFieldStat != null && Object.hasOwnProperty.call(message, "perFieldStat"))
          for (var keys = Object.keys(message.perFieldStat), i = 0; i < keys.length; ++i) {
            writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).fork().uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(keys[i]);
            $root.FieldStat.encode(message.perFieldStat[keys[i]], writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim().ldelim();
          }
        return writer;
      };
      TypeStat.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };
      TypeStat.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.TypeStat(), key;
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 3:
              reader.skip().pos++;
              if (message.perFieldStat === $util.emptyObject)
                message.perFieldStat = {};
              key = reader.string();
              reader.pos++;
              message.perFieldStat[key] = $root.FieldStat.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };
      TypeStat.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      TypeStat.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.perFieldStat != null && message.hasOwnProperty("perFieldStat")) {
          if (!$util.isObject(message.perFieldStat))
            return "perFieldStat: object expected";
          var key = Object.keys(message.perFieldStat);
          for (var i = 0; i < key.length; ++i) {
            var error = $root.FieldStat.verify(message.perFieldStat[key[i]]);
            if (error)
              return "perFieldStat." + error;
          }
        }
        return null;
      };
      TypeStat.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.objects || options.defaults)
          object.perFieldStat = {};
        var keys2;
        if (message.perFieldStat && (keys2 = Object.keys(message.perFieldStat)).length) {
          object.perFieldStat = {};
          for (var j = 0; j < keys2.length; ++j)
            object.perFieldStat[keys2[j]] = $root.FieldStat.toObject(message.perFieldStat[keys2[j]], options);
        }
        return object;
      };
      TypeStat.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      return TypeStat;
    }();
    $root.ReferencedFieldsForType = function() {
      function ReferencedFieldsForType(properties) {
        this.fieldNames = [];
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      ReferencedFieldsForType.prototype.fieldNames = $util.emptyArray;
      ReferencedFieldsForType.prototype.isInterface = false;
      ReferencedFieldsForType.create = function create(properties) {
        return new ReferencedFieldsForType(properties);
      };
      ReferencedFieldsForType.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.fieldNames != null && message.fieldNames.length)
          for (var i = 0; i < message.fieldNames.length; ++i)
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(message.fieldNames[i]);
        if (message.isInterface != null && Object.hasOwnProperty.call(message, "isInterface"))
          writer.uint32(
            /* id 2, wireType 0 =*/
            16
          ).bool(message.isInterface);
        return writer;
      };
      ReferencedFieldsForType.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };
      ReferencedFieldsForType.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ReferencedFieldsForType();
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.fieldNames && message.fieldNames.length))
                message.fieldNames = [];
              message.fieldNames.push(reader.string());
              break;
            case 2:
              message.isInterface = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };
      ReferencedFieldsForType.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      ReferencedFieldsForType.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.fieldNames != null && message.hasOwnProperty("fieldNames")) {
          if (!Array.isArray(message.fieldNames))
            return "fieldNames: array expected";
          for (var i = 0; i < message.fieldNames.length; ++i)
            if (!$util.isString(message.fieldNames[i]))
              return "fieldNames: string[] expected";
        }
        if (message.isInterface != null && message.hasOwnProperty("isInterface")) {
          if (typeof message.isInterface !== "boolean")
            return "isInterface: boolean expected";
        }
        return null;
      };
      ReferencedFieldsForType.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.arrays || options.defaults)
          object.fieldNames = [];
        if (options.defaults)
          object.isInterface = false;
        if (message.fieldNames && message.fieldNames.length) {
          object.fieldNames = [];
          for (var j = 0; j < message.fieldNames.length; ++j)
            object.fieldNames[j] = message.fieldNames[j];
        }
        if (message.isInterface != null && message.hasOwnProperty("isInterface"))
          object.isInterface = message.isInterface;
        return object;
      };
      ReferencedFieldsForType.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      return ReferencedFieldsForType;
    }();
    $root.Report = function() {
      function Report(properties) {
        this.tracesPerQuery = {};
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      Report.prototype.header = null;
      Report.prototype.tracesPerQuery = $util.emptyObject;
      Report.prototype.endTime = null;
      Report.prototype.operationCount = 0;
      Report.prototype.tracesPreAggregated = false;
      Report.create = function create(properties) {
        return new Report(properties);
      };
      Report.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.header != null && Object.hasOwnProperty.call(message, "header"))
          $root.ReportHeader.encode(message.header, writer.uint32(
            /* id 1, wireType 2 =*/
            10
          ).fork()).ldelim();
        if (message.endTime != null && Object.hasOwnProperty.call(message, "endTime"))
          $root.google.protobuf.Timestamp.encode(message.endTime, writer.uint32(
            /* id 2, wireType 2 =*/
            18
          ).fork()).ldelim();
        if (message.tracesPerQuery != null && Object.hasOwnProperty.call(message, "tracesPerQuery"))
          for (var keys = Object.keys(message.tracesPerQuery), i = 0; i < keys.length; ++i) {
            writer.uint32(
              /* id 5, wireType 2 =*/
              42
            ).fork().uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(keys[i]);
            $root.TracesAndStats.encode(message.tracesPerQuery[keys[i]], writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim().ldelim();
          }
        if (message.operationCount != null && Object.hasOwnProperty.call(message, "operationCount"))
          writer.uint32(
            /* id 6, wireType 0 =*/
            48
          ).uint64(message.operationCount);
        if (message.tracesPreAggregated != null && Object.hasOwnProperty.call(message, "tracesPreAggregated"))
          writer.uint32(
            /* id 7, wireType 0 =*/
            56
          ).bool(message.tracesPreAggregated);
        return writer;
      };
      Report.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };
      Report.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Report(), key;
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.header = $root.ReportHeader.decode(reader, reader.uint32());
              break;
            case 5:
              reader.skip().pos++;
              if (message.tracesPerQuery === $util.emptyObject)
                message.tracesPerQuery = {};
              key = reader.string();
              reader.pos++;
              message.tracesPerQuery[key] = $root.TracesAndStats.decode(reader, reader.uint32());
              break;
            case 2:
              message.endTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
              break;
            case 6:
              message.operationCount = reader.uint64();
              break;
            case 7:
              message.tracesPreAggregated = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };
      Report.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      Report.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.header != null && message.hasOwnProperty("header")) {
          var error = $root.ReportHeader.verify(message.header);
          if (error)
            return "header." + error;
        }
        if (message.tracesPerQuery != null && message.hasOwnProperty("tracesPerQuery")) {
          if (!$util.isObject(message.tracesPerQuery))
            return "tracesPerQuery: object expected";
          var key = Object.keys(message.tracesPerQuery);
          for (var i = 0; i < key.length; ++i) {
            var error = $root.TracesAndStats.verify(message.tracesPerQuery[key[i]]);
            if (error)
              return "tracesPerQuery." + error;
          }
        }
        if (message.endTime != null && message.hasOwnProperty("endTime")) {
          var error = $root.google.protobuf.Timestamp.verify(message.endTime);
          if (error)
            return "endTime." + error;
        }
        if (message.operationCount != null && message.hasOwnProperty("operationCount")) {
          if (!$util.isInteger(message.operationCount) && !(message.operationCount && $util.isInteger(message.operationCount.low) && $util.isInteger(message.operationCount.high)))
            return "operationCount: integer|Long expected";
        }
        if (message.tracesPreAggregated != null && message.hasOwnProperty("tracesPreAggregated")) {
          if (typeof message.tracesPreAggregated !== "boolean")
            return "tracesPreAggregated: boolean expected";
        }
        return null;
      };
      Report.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.objects || options.defaults)
          object.tracesPerQuery = {};
        if (options.defaults) {
          object.header = null;
          object.endTime = null;
          object.operationCount = 0;
          object.tracesPreAggregated = false;
        }
        if (message.header != null && message.hasOwnProperty("header"))
          object.header = $root.ReportHeader.toObject(message.header, options);
        if (message.endTime != null && message.hasOwnProperty("endTime"))
          object.endTime = $root.google.protobuf.Timestamp.toObject(message.endTime, options);
        var keys2;
        if (message.tracesPerQuery && (keys2 = Object.keys(message.tracesPerQuery)).length) {
          object.tracesPerQuery = {};
          for (var j = 0; j < keys2.length; ++j)
            object.tracesPerQuery[keys2[j]] = $root.TracesAndStats.toObject(message.tracesPerQuery[keys2[j]], options);
        }
        if (message.operationCount != null && message.hasOwnProperty("operationCount"))
          if (typeof message.operationCount === "number")
            object.operationCount = options.longs === String ? String(message.operationCount) : message.operationCount;
          else
            object.operationCount = options.longs === String ? $util.Long.prototype.toString.call(message.operationCount) : options.longs === Number ? new $util.LongBits(message.operationCount.low >>> 0, message.operationCount.high >>> 0).toNumber(true) : message.operationCount;
        if (message.tracesPreAggregated != null && message.hasOwnProperty("tracesPreAggregated"))
          object.tracesPreAggregated = message.tracesPreAggregated;
        return object;
      };
      Report.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      return Report;
    }();
    $root.ContextualizedStats = function() {
      function ContextualizedStats(properties) {
        this.perTypeStat = {};
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      ContextualizedStats.prototype.context = null;
      ContextualizedStats.prototype.queryLatencyStats = null;
      ContextualizedStats.prototype.perTypeStat = $util.emptyObject;
      ContextualizedStats.create = function create(properties) {
        return new ContextualizedStats(properties);
      };
      ContextualizedStats.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.context != null && Object.hasOwnProperty.call(message, "context"))
          $root.StatsContext.encode(message.context, writer.uint32(
            /* id 1, wireType 2 =*/
            10
          ).fork()).ldelim();
        if (message.queryLatencyStats != null && Object.hasOwnProperty.call(message, "queryLatencyStats"))
          $root.QueryLatencyStats.encode(message.queryLatencyStats, writer.uint32(
            /* id 2, wireType 2 =*/
            18
          ).fork()).ldelim();
        if (message.perTypeStat != null && Object.hasOwnProperty.call(message, "perTypeStat"))
          for (var keys = Object.keys(message.perTypeStat), i = 0; i < keys.length; ++i) {
            writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).fork().uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(keys[i]);
            $root.TypeStat.encode(message.perTypeStat[keys[i]], writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim().ldelim();
          }
        return writer;
      };
      ContextualizedStats.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };
      ContextualizedStats.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ContextualizedStats(), key;
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.context = $root.StatsContext.decode(reader, reader.uint32());
              break;
            case 2:
              message.queryLatencyStats = $root.QueryLatencyStats.decode(reader, reader.uint32());
              break;
            case 3:
              reader.skip().pos++;
              if (message.perTypeStat === $util.emptyObject)
                message.perTypeStat = {};
              key = reader.string();
              reader.pos++;
              message.perTypeStat[key] = $root.TypeStat.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };
      ContextualizedStats.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      ContextualizedStats.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.context != null && message.hasOwnProperty("context")) {
          var error = $root.StatsContext.verify(message.context);
          if (error)
            return "context." + error;
        }
        if (message.queryLatencyStats != null && message.hasOwnProperty("queryLatencyStats")) {
          var error = $root.QueryLatencyStats.verify(message.queryLatencyStats);
          if (error)
            return "queryLatencyStats." + error;
        }
        if (message.perTypeStat != null && message.hasOwnProperty("perTypeStat")) {
          if (!$util.isObject(message.perTypeStat))
            return "perTypeStat: object expected";
          var key = Object.keys(message.perTypeStat);
          for (var i = 0; i < key.length; ++i) {
            var error = $root.TypeStat.verify(message.perTypeStat[key[i]]);
            if (error)
              return "perTypeStat." + error;
          }
        }
        return null;
      };
      ContextualizedStats.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.objects || options.defaults)
          object.perTypeStat = {};
        if (options.defaults) {
          object.context = null;
          object.queryLatencyStats = null;
        }
        if (message.context != null && message.hasOwnProperty("context"))
          object.context = $root.StatsContext.toObject(message.context, options);
        if (message.queryLatencyStats != null && message.hasOwnProperty("queryLatencyStats"))
          object.queryLatencyStats = $root.QueryLatencyStats.toObject(message.queryLatencyStats, options);
        var keys2;
        if (message.perTypeStat && (keys2 = Object.keys(message.perTypeStat)).length) {
          object.perTypeStat = {};
          for (var j = 0; j < keys2.length; ++j)
            object.perTypeStat[keys2[j]] = $root.TypeStat.toObject(message.perTypeStat[keys2[j]], options);
        }
        return object;
      };
      ContextualizedStats.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      return ContextualizedStats;
    }();
    $root.TracesAndStats = function() {
      function TracesAndStats(properties) {
        this.trace = [];
        this.statsWithContext = [];
        this.referencedFieldsByType = {};
        this.internalTracesContributingToStats = [];
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      TracesAndStats.prototype.trace = $util.emptyArray;
      TracesAndStats.prototype.statsWithContext = $util.emptyArray;
      TracesAndStats.prototype.referencedFieldsByType = $util.emptyObject;
      TracesAndStats.prototype.internalTracesContributingToStats = $util.emptyArray;
      TracesAndStats.create = function create(properties) {
        return new TracesAndStats(properties);
      };
      TracesAndStats.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.trace != null && message.trace.length)
          for (var i = 0; i < message.trace.length; ++i)
            if (message.trace[i] instanceof Uint8Array) {
              writer.uint32(
                /* id 1, wireType 2 =*/
                10
              );
              writer.bytes(message.trace[i]);
            } else
              $root.Trace.encode(message.trace[i], writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).fork()).ldelim();
        var array2;
        if (message.statsWithContext != null && message.statsWithContext.toArray)
          array2 = message.statsWithContext.toArray();
        else
          array2 = message.statsWithContext;
        if (array2 != null && array2.length)
          for (var i = 0; i < array2.length; ++i)
            $root.ContextualizedStats.encode(array2[i], writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim();
        if (message.internalTracesContributingToStats != null && message.internalTracesContributingToStats.length)
          for (var i = 0; i < message.internalTracesContributingToStats.length; ++i)
            if (message.internalTracesContributingToStats[i] instanceof Uint8Array) {
              writer.uint32(
                /* id 3, wireType 2 =*/
                26
              );
              writer.bytes(message.internalTracesContributingToStats[i]);
            } else
              $root.Trace.encode(message.internalTracesContributingToStats[i], writer.uint32(
                /* id 3, wireType 2 =*/
                26
              ).fork()).ldelim();
        if (message.referencedFieldsByType != null && Object.hasOwnProperty.call(message, "referencedFieldsByType"))
          for (var keys = Object.keys(message.referencedFieldsByType), i = 0; i < keys.length; ++i) {
            writer.uint32(
              /* id 4, wireType 2 =*/
              34
            ).fork().uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(keys[i]);
            $root.ReferencedFieldsForType.encode(message.referencedFieldsByType[keys[i]], writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim().ldelim();
          }
        return writer;
      };
      TracesAndStats.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };
      TracesAndStats.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.TracesAndStats(), key;
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.trace && message.trace.length))
                message.trace = [];
              message.trace.push($root.Trace.decode(reader, reader.uint32()));
              break;
            case 2:
              if (!(message.statsWithContext && message.statsWithContext.length))
                message.statsWithContext = [];
              message.statsWithContext.push($root.ContextualizedStats.decode(reader, reader.uint32()));
              break;
            case 4:
              reader.skip().pos++;
              if (message.referencedFieldsByType === $util.emptyObject)
                message.referencedFieldsByType = {};
              key = reader.string();
              reader.pos++;
              message.referencedFieldsByType[key] = $root.ReferencedFieldsForType.decode(reader, reader.uint32());
              break;
            case 3:
              if (!(message.internalTracesContributingToStats && message.internalTracesContributingToStats.length))
                message.internalTracesContributingToStats = [];
              message.internalTracesContributingToStats.push($root.Trace.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };
      TracesAndStats.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      TracesAndStats.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.trace != null && message.hasOwnProperty("trace")) {
          if (!Array.isArray(message.trace))
            return "trace: array expected";
          for (var i = 0; i < message.trace.length; ++i)
            if (!(message.trace[i] instanceof Uint8Array)) {
              var error = $root.Trace.verify(message.trace[i]);
              if (error)
                return "trace." + error;
            }
        }
        if (message.statsWithContext != null && message.hasOwnProperty("statsWithContext")) {
          var array2;
          if (message.statsWithContext != null && message.statsWithContext.toArray)
            array2 = message.statsWithContext.toArray();
          else
            array2 = message.statsWithContext;
          if (!Array.isArray(array2))
            return "statsWithContext: array expected";
          for (var i = 0; i < array2.length; ++i) {
            var error = $root.ContextualizedStats.verify(array2[i]);
            if (error)
              return "statsWithContext." + error;
          }
        }
        if (message.referencedFieldsByType != null && message.hasOwnProperty("referencedFieldsByType")) {
          if (!$util.isObject(message.referencedFieldsByType))
            return "referencedFieldsByType: object expected";
          var key = Object.keys(message.referencedFieldsByType);
          for (var i = 0; i < key.length; ++i) {
            var error = $root.ReferencedFieldsForType.verify(message.referencedFieldsByType[key[i]]);
            if (error)
              return "referencedFieldsByType." + error;
          }
        }
        if (message.internalTracesContributingToStats != null && message.hasOwnProperty("internalTracesContributingToStats")) {
          if (!Array.isArray(message.internalTracesContributingToStats))
            return "internalTracesContributingToStats: array expected";
          for (var i = 0; i < message.internalTracesContributingToStats.length; ++i)
            if (!(message.internalTracesContributingToStats[i] instanceof Uint8Array)) {
              var error = $root.Trace.verify(message.internalTracesContributingToStats[i]);
              if (error)
                return "internalTracesContributingToStats." + error;
            }
        }
        return null;
      };
      TracesAndStats.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.arrays || options.defaults) {
          object.trace = [];
          object.statsWithContext = [];
          object.internalTracesContributingToStats = [];
        }
        if (options.objects || options.defaults)
          object.referencedFieldsByType = {};
        if (message.trace && message.trace.length) {
          object.trace = [];
          for (var j = 0; j < message.trace.length; ++j)
            object.trace[j] = $root.Trace.toObject(message.trace[j], options);
        }
        if (message.statsWithContext && message.statsWithContext.length) {
          object.statsWithContext = [];
          for (var j = 0; j < message.statsWithContext.length; ++j)
            object.statsWithContext[j] = $root.ContextualizedStats.toObject(message.statsWithContext[j], options);
        }
        if (message.internalTracesContributingToStats && message.internalTracesContributingToStats.length) {
          object.internalTracesContributingToStats = [];
          for (var j = 0; j < message.internalTracesContributingToStats.length; ++j)
            object.internalTracesContributingToStats[j] = $root.Trace.toObject(message.internalTracesContributingToStats[j], options);
        }
        var keys2;
        if (message.referencedFieldsByType && (keys2 = Object.keys(message.referencedFieldsByType)).length) {
          object.referencedFieldsByType = {};
          for (var j = 0; j < keys2.length; ++j)
            object.referencedFieldsByType[keys2[j]] = $root.ReferencedFieldsForType.toObject(message.referencedFieldsByType[keys2[j]], options);
        }
        return object;
      };
      TracesAndStats.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      return TracesAndStats;
    }();
    $root.google = function() {
      var google = {};
      google.protobuf = function() {
        var protobuf = {};
        protobuf.Timestamp = function() {
          function Timestamp(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          Timestamp.prototype.seconds = 0;
          Timestamp.prototype.nanos = 0;
          Timestamp.create = function create(properties) {
            return new Timestamp(properties);
          };
          Timestamp.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.seconds != null && Object.hasOwnProperty.call(message, "seconds"))
              writer.uint32(
                /* id 1, wireType 0 =*/
                8
              ).int64(message.seconds);
            if (message.nanos != null && Object.hasOwnProperty.call(message, "nanos"))
              writer.uint32(
                /* id 2, wireType 0 =*/
                16
              ).int32(message.nanos);
            return writer;
          };
          Timestamp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          Timestamp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.google.protobuf.Timestamp();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.seconds = reader.int64();
                  break;
                case 2:
                  message.nanos = reader.int32();
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          Timestamp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          Timestamp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.seconds != null && message.hasOwnProperty("seconds")) {
              if (!$util.isInteger(message.seconds) && !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high)))
                return "seconds: integer|Long expected";
            }
            if (message.nanos != null && message.hasOwnProperty("nanos")) {
              if (!$util.isInteger(message.nanos))
                return "nanos: integer expected";
            }
            return null;
          };
          Timestamp.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults) {
              object.seconds = 0;
              object.nanos = 0;
            }
            if (message.seconds != null && message.hasOwnProperty("seconds"))
              if (typeof message.seconds === "number")
                object.seconds = options.longs === String ? String(message.seconds) : message.seconds;
              else
                object.seconds = options.longs === String ? $util.Long.prototype.toString.call(message.seconds) : options.longs === Number ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber() : message.seconds;
            if (message.nanos != null && message.hasOwnProperty("nanos"))
              object.nanos = message.nanos;
            return object;
          };
          Timestamp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return Timestamp;
        }();
        return protobuf;
      }();
      return google;
    }();
    module2.exports = $root;
  }
});

// ../../../node_modules/@apollo/utils.usagereporting/dist/calculateReferencedFieldsByType.js
var require_calculateReferencedFieldsByType = __commonJS({
  "../../../node_modules/@apollo/utils.usagereporting/dist/calculateReferencedFieldsByType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.calculateReferencedFieldsByType = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var usage_reporting_protobuf_1 = require_protobuf2();
    function calculateReferencedFieldsByType({ document: document2, schema, resolvedOperationName }) {
      const documentSeparatedByOperation = (0, graphql_1.separateOperations)(document2);
      const filteredDocument = documentSeparatedByOperation[resolvedOperationName !== null && resolvedOperationName !== void 0 ? resolvedOperationName : ""];
      if (!filteredDocument) {
        throw Error(`shouldn't happen: operation '${resolvedOperationName !== null && resolvedOperationName !== void 0 ? resolvedOperationName : ""}' not found`);
      }
      const typeInfo = new graphql_1.TypeInfo(schema);
      const interfaces = /* @__PURE__ */ new Set();
      const referencedFieldSetByType = /* @__PURE__ */ Object.create(null);
      (0, graphql_1.visit)(filteredDocument, (0, graphql_1.visitWithTypeInfo)(typeInfo, {
        Field(field) {
          const fieldName = field.name.value;
          const parentType = typeInfo.getParentType();
          if (!parentType) {
            throw Error(`shouldn't happen: missing parent type for field ${fieldName}`);
          }
          const parentTypeName = parentType.name;
          if (!referencedFieldSetByType[parentTypeName]) {
            referencedFieldSetByType[parentTypeName] = /* @__PURE__ */ new Set();
            if ((0, graphql_1.isInterfaceType)(parentType)) {
              interfaces.add(parentTypeName);
            }
          }
          referencedFieldSetByType[parentTypeName].add(fieldName);
        }
      }));
      const referencedFieldsByType = /* @__PURE__ */ Object.create(null);
      for (const [typeName, fieldNames] of Object.entries(referencedFieldSetByType)) {
        referencedFieldsByType[typeName] = new usage_reporting_protobuf_1.ReferencedFieldsForType({
          fieldNames: [...fieldNames],
          isInterface: interfaces.has(typeName)
        });
      }
      return referencedFieldsByType;
    }
    exports2.calculateReferencedFieldsByType = calculateReferencedFieldsByType;
  }
});

// ../../../node_modules/@apollo/utils.dropunuseddefinitions/dist/index.js
var require_dist4 = __commonJS({
  "../../../node_modules/@apollo/utils.dropunuseddefinitions/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.dropUnusedDefinitions = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function dropUnusedDefinitions(ast, operationName) {
      const separated = (0, graphql_1.separateOperations)(ast)[operationName];
      if (!separated) {
        return ast;
      }
      return separated;
    }
    exports2.dropUnusedDefinitions = dropUnusedDefinitions;
  }
});

// ../../../node_modules/@apollo/utils.stripsensitiveliterals/dist/index.js
var require_dist5 = __commonJS({
  "../../../node_modules/@apollo/utils.stripsensitiveliterals/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.stripSensitiveLiterals = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function stripSensitiveLiterals(ast, options = {
      hideListAndObjectLiterals: false
    }) {
      const listAndObjectVisitorIfEnabled = options.hideListAndObjectLiterals ? {
        ListValue(node) {
          return { ...node, values: [] };
        },
        ObjectValue(node) {
          return { ...node, fields: [] };
        }
      } : {};
      return (0, graphql_1.visit)(ast, {
        IntValue(node) {
          return { ...node, value: "0" };
        },
        FloatValue(node) {
          return { ...node, value: "0" };
        },
        StringValue(node) {
          return { ...node, value: "", block: false };
        },
        ...listAndObjectVisitorIfEnabled
      });
    }
    exports2.stripSensitiveLiterals = stripSensitiveLiterals;
  }
});

// ../../../node_modules/@apollo/utils.printwithreducedwhitespace/dist/index.js
var require_dist6 = __commonJS({
  "../../../node_modules/@apollo/utils.printwithreducedwhitespace/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.printWithReducedWhitespace = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function printWithReducedWhitespace(ast) {
      const sanitizedAST = (0, graphql_1.visit)(ast, {
        StringValue(node) {
          return {
            ...node,
            value: Buffer.from(node.value, "utf8").toString("hex"),
            block: false
          };
        }
      });
      const withWhitespace = (0, graphql_1.print)(sanitizedAST);
      const minimizedButStillHex = withWhitespace.replace(/\s+/g, " ").replace(/([^_a-zA-Z0-9]) /g, (_, c) => c).replace(/ ([^_a-zA-Z0-9])/g, (_, c) => c);
      return minimizedButStillHex.replace(/"([a-f0-9]+)"/g, (_, hex) => JSON.stringify(Buffer.from(hex, "hex").toString("utf8")));
    }
    exports2.printWithReducedWhitespace = printWithReducedWhitespace;
  }
});

// ../../../node_modules/@apollo/utils.removealiases/dist/index.js
var require_dist7 = __commonJS({
  "../../../node_modules/@apollo/utils.removealiases/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.removeAliases = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function removeAliases(ast) {
      return (0, graphql_1.visit)(ast, {
        Field(node) {
          const { alias, ...rest } = node;
          return rest;
        }
      });
    }
    exports2.removeAliases = removeAliases;
  }
});

// ../../../node_modules/lodash.sortby/index.js
var require_lodash = __commonJS({
  "../../../node_modules/lodash.sortby/index.js"(exports2, module2) {
    var LARGE_ARRAY_SIZE = 200;
    var FUNC_ERROR_TEXT = "Expected a function";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var UNORDERED_COMPARE_FLAG = 1;
    var PARTIAL_COMPARE_FLAG = 2;
    var INFINITY = 1 / 0;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp = /^\w*$/;
    var reLeadingDot = /^\./;
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reEscapeChar = /\\(\\)?/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        return freeProcess && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function arrayMap(array, iteratee) {
      var index = -1, length = array ? array.length : 0, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function arraySome(array, predicate) {
      var index = -1, length = array ? array.length : 0;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    function baseProperty(key) {
      return function(object) {
        return object == null ? void 0 : object[key];
      };
    }
    function baseSortBy(array, comparer) {
      var length = array.length;
      array.sort(comparer);
      while (length--) {
        array[length] = array[length].value;
      }
      return array;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Symbol2 = root.Symbol;
    var Uint8Array2 = root.Uint8Array;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
    var nativeKeys = overArg(Object.keys, Object);
    var nativeMax = Math.max;
    var DataView2 = getNative(root, "DataView");
    var Map2 = getNative(root, "Map");
    var Promise2 = getNative(root, "Promise");
    var Set2 = getNative(root, "Set");
    var WeakMap2 = getNative(root, "WeakMap");
    var nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView2);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap2);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty2.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty2.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values) {
      var index = -1, length = values ? values.length : 0;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function Stack(entries) {
      this.__data__ = new ListCache(entries);
    }
    function stackClear() {
      this.__data__ = new ListCache();
    }
    function stackDelete(key) {
      return this.__data__["delete"](key);
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var cache = this.__data__;
      if (cache instanceof ListCache) {
        var pairs = cache.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          return this;
        }
        cache = this.__data__ = new MapCache(pairs);
      }
      cache.set(key, value);
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    var baseEach = createBaseEach(baseForOwn);
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1, length = array.length;
      predicate || (predicate = isFlattenable);
      result || (result = []);
      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }
    var baseFor = createBaseFor();
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }
    function baseGet(object, path) {
      path = isKey(path, object) ? [path] : castPath(path);
      var index = 0, length = path.length;
      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return index && index == length ? object : void 0;
    }
    function baseGetTag(value) {
      return objectToString.call(value);
    }
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }
    function baseIsEqual(value, other, customizer, bitmask, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObject(value) && !isObjectLike2(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
    }
    function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = arrayTag, othTag = arrayTag;
      if (!objIsArr) {
        objTag = getTag(object);
        objTag = objTag == argsTag ? objectTag : objTag;
      }
      if (!othIsArr) {
        othTag = getTag(other);
        othTag = othTag == argsTag ? objectTag : othTag;
      }
      var objIsObj = objTag == objectTag && !isHostObject(object), othIsObj = othTag == objectTag && !isHostObject(other), isSameTag = objTag == othTag;
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, equalFunc, customizer, bitmask, stack) : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
      }
      if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
    }
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length, length = index, noCustomizer = !customizer;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0], objValue = object[key], srcValue = data[1];
        if (noCustomizer && data[2]) {
          if (objValue === void 0 && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack();
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === void 0 ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack) : result)) {
            return false;
          }
        }
      }
      return true;
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike2(value) && isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
    }
    function baseIteratee(value) {
      if (typeof value == "function") {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == "object") {
        return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
      }
      return property(value);
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty2.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function baseMap(collection, iteratee) {
      var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
      baseEach(collection, function(value, key, collection2) {
        result[++index] = iteratee(value, key, collection2);
      });
      return result;
    }
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get(object, path);
        return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, void 0, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
      };
    }
    function baseOrderBy(collection, iteratees, orders) {
      var index = -1;
      iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(baseIteratee));
      var result = baseMap(collection, function(value, key, collection2) {
        var criteria = arrayMap(iteratees, function(iteratee) {
          return iteratee(value);
        });
        return { "criteria": criteria, "index": ++index, "value": value };
      });
      return baseSortBy(result, function(object, other) {
        return compareMultiple(object, other, orders);
      });
    }
    function basePropertyDeep(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }
    function baseRest(func, start) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = array;
        return apply(func, this, otherArgs);
      };
    }
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function castPath(value) {
      return isArray(value) ? value : stringToPath(value);
    }
    function compareAscending(value, other) {
      if (value !== other) {
        var valIsDefined = value !== void 0, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
        var othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
        if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
          return 1;
        }
        if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
          return -1;
        }
      }
      return 0;
    }
    function compareMultiple(object, other, orders) {
      var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
      while (++index < length) {
        var result = compareAscending(objCriteria[index], othCriteria[index]);
        if (result) {
          if (index >= ordersLength) {
            return result;
          }
          var order = orders[index];
          return result * (order == "desc" ? -1 : 1);
        }
      }
      return object.index - other.index;
    }
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
        while (fromRight ? index-- : ++index < length) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var stacked = stack.get(array);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var index = -1, result = true, seen = bitmask & UNORDERED_COMPARE_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!seen.has(othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, customizer, bitmask, stack))) {
              return seen.add(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= UNORDERED_COMPARE_FLAG;
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
          stack["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG, objProps = keys(object), objLength = objProps.length, othProps = keys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
          return false;
        }
      }
      var stacked = stack.get(object);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      stack["delete"](other);
      return result;
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getMatchData(object) {
      var result = keys(object), length = result.length;
      while (length--) {
        var key = result[length], value = object[key];
        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    var getTag = baseGetTag;
    if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = function(value) {
        var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function hasPath(object, path, hasFunc) {
      path = isKey(path, object) ? [path] : castPath(path);
      var result, index = -1, length = path.length;
      while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result) {
        return result;
      }
      var length = object ? object.length : 0;
      return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
    }
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
        return eq(object[index], value);
      }
      return false;
    }
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
      };
    }
    var stringToPath = memoize(function(string) {
      string = toString(string);
      var result = [];
      if (reLeadingDot.test(string)) {
        result.push("");
      }
      string.replace(rePropName, function(match, number, quote, string2) {
        result.push(quote ? string2.replace(reEscapeChar, "$1") : number || match);
      });
      return result;
    });
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    var sortBy2 = baseRest(function(collection, iteratees) {
      if (collection == null) {
        return [];
      }
      var length = iteratees.length;
      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
        iteratees = [];
      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
        iteratees = [iteratees[0]];
      }
      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
    });
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result);
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty2.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike2(value) && isArrayLike(value);
    }
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike2(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike2(value) && objectToString.call(value) == symbolTag;
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    function get(object, path, defaultValue) {
      var result = object == null ? void 0 : baseGet(object, path);
      return result === void 0 ? defaultValue : result;
    }
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function identity(value) {
      return value;
    }
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }
    module2.exports = sortBy2;
  }
});

// ../../../node_modules/@apollo/utils.sortast/dist/index.js
var require_dist8 = __commonJS({
  "../../../node_modules/@apollo/utils.sortast/dist/index.js"(exports2) {
    "use strict";
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sortAST = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var lodash_sortby_1 = __importDefault2(require_lodash());
    function sortAST(ast) {
      return (0, graphql_1.visit)(ast, {
        Document(node) {
          return {
            ...node,
            definitions: (0, lodash_sortby_1.default)(node.definitions, "kind", "name.value")
          };
        },
        OperationDefinition(node) {
          return sortVariableDefinitions(node);
        },
        SelectionSet(node) {
          return {
            ...node,
            selections: (0, lodash_sortby_1.default)(node.selections, "kind", "name.value")
          };
        },
        Field(node) {
          return sortArguments(node);
        },
        FragmentSpread(node) {
          return sortDirectives(node);
        },
        InlineFragment(node) {
          return sortDirectives(node);
        },
        FragmentDefinition(node) {
          return sortDirectives(sortVariableDefinitions(node));
        },
        Directive(node) {
          return sortArguments(node);
        }
      });
    }
    exports2.sortAST = sortAST;
    function sortDirectives(node) {
      return "directives" in node ? { ...node, directives: (0, lodash_sortby_1.default)(node.directives, "name.value") } : node;
    }
    function sortArguments(node) {
      return "arguments" in node ? { ...node, arguments: (0, lodash_sortby_1.default)(node.arguments, "name.value") } : node;
    }
    function sortVariableDefinitions(node) {
      return "variableDefinitions" in node ? {
        ...node,
        variableDefinitions: (0, lodash_sortby_1.default)(node.variableDefinitions, "variable.name.value")
      } : node;
    }
  }
});

// ../../../node_modules/@apollo/utils.usagereporting/dist/signature.js
var require_signature = __commonJS({
  "../../../node_modules/@apollo/utils.usagereporting/dist/signature.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.usageReportingSignature = void 0;
    var utils_dropunuseddefinitions_1 = require_dist4();
    var utils_stripsensitiveliterals_1 = require_dist5();
    var utils_printwithreducedwhitespace_1 = require_dist6();
    var utils_removealiases_1 = require_dist7();
    var utils_sortast_1 = require_dist8();
    function usageReportingSignature(ast, operationName) {
      return (0, utils_printwithreducedwhitespace_1.printWithReducedWhitespace)((0, utils_sortast_1.sortAST)((0, utils_removealiases_1.removeAliases)((0, utils_stripsensitiveliterals_1.stripSensitiveLiterals)((0, utils_dropunuseddefinitions_1.dropUnusedDefinitions)(ast, operationName), {
        hideListAndObjectLiterals: true
      }))));
    }
    exports2.usageReportingSignature = usageReportingSignature;
  }
});

// ../../../node_modules/@apollo/utils.usagereporting/dist/index.js
var require_dist9 = __commonJS({
  "../../../node_modules/@apollo/utils.usagereporting/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.usageReportingSignature = exports2.calculateReferencedFieldsByType = void 0;
    var calculateReferencedFieldsByType_1 = require_calculateReferencedFieldsByType();
    Object.defineProperty(exports2, "calculateReferencedFieldsByType", { enumerable: true, get: function() {
      return calculateReferencedFieldsByType_1.calculateReferencedFieldsByType;
    } });
    var signature_1 = require_signature();
    Object.defineProperty(exports2, "usageReportingSignature", { enumerable: true, get: function() {
      return signature_1.usageReportingSignature;
    } });
  }
});

// ../../../node_modules/apollo-server-core/dist/plugin/traceTreeBuilder.js
var require_traceTreeBuilder = __commonJS({
  "../../../node_modules/apollo-server-core/dist/plugin/traceTreeBuilder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.dateToProtoTimestamp = exports2.TraceTreeBuilder = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var apollo_reporting_protobuf_1 = require_generated();
    function internalError(message) {
      return new Error(`[internal apollo-server error] ${message}`);
    }
    var TraceTreeBuilder = class {
      constructor(options) {
        this.rootNode = new apollo_reporting_protobuf_1.Trace.Node();
        this.logger = console;
        this.trace = new apollo_reporting_protobuf_1.Trace({
          root: this.rootNode,
          fieldExecutionWeight: 1
        });
        this.stopped = false;
        this.nodes = /* @__PURE__ */ new Map([
          [responsePathAsString(), this.rootNode]
        ]);
        this.rewriteError = options.rewriteError;
        if (options.logger)
          this.logger = options.logger;
      }
      startTiming() {
        if (this.startHrTime) {
          throw internalError("startTiming called twice!");
        }
        if (this.stopped) {
          throw internalError("startTiming called after stopTiming!");
        }
        this.trace.startTime = dateToProtoTimestamp(/* @__PURE__ */ new Date());
        this.startHrTime = process.hrtime();
      }
      stopTiming() {
        if (!this.startHrTime) {
          throw internalError("stopTiming called before startTiming!");
        }
        if (this.stopped) {
          throw internalError("stopTiming called twice!");
        }
        this.trace.durationNs = durationHrTimeToNanos(process.hrtime(this.startHrTime));
        this.trace.endTime = dateToProtoTimestamp(/* @__PURE__ */ new Date());
        this.stopped = true;
      }
      willResolveField(info) {
        if (!this.startHrTime) {
          throw internalError("willResolveField called before startTiming!");
        }
        if (this.stopped) {
          return () => {
          };
        }
        const path = info.path;
        const node = this.newNode(path);
        node.type = info.returnType.toString();
        node.parentType = info.parentType.toString();
        node.startTime = durationHrTimeToNanos(process.hrtime(this.startHrTime));
        if (typeof path.key === "string" && path.key !== info.fieldName) {
          node.originalFieldName = info.fieldName;
        }
        return () => {
          node.endTime = durationHrTimeToNanos(process.hrtime(this.startHrTime));
        };
      }
      didEncounterErrors(errors) {
        errors.forEach((err) => {
          var _a;
          if ((_a = err.extensions) === null || _a === void 0 ? void 0 : _a.serviceName) {
            return;
          }
          const errorForReporting = this.rewriteAndNormalizeError(err);
          if (errorForReporting === null) {
            return;
          }
          this.addProtobufError(errorForReporting.path, errorToProtobufError(errorForReporting));
        });
      }
      addProtobufError(path, error) {
        if (!this.startHrTime) {
          throw internalError("addProtobufError called before startTiming!");
        }
        if (this.stopped) {
          throw internalError("addProtobufError called after stopTiming!");
        }
        let node = this.rootNode;
        if (Array.isArray(path)) {
          const specificNode = this.nodes.get(path.join("."));
          if (specificNode) {
            node = specificNode;
          } else {
            this.logger.warn(`Could not find node with path ${path.join(".")}; defaulting to put errors on root node.`);
          }
        }
        node.error.push(error);
      }
      newNode(path) {
        const node = new apollo_reporting_protobuf_1.Trace.Node();
        const id = path.key;
        if (typeof id === "number") {
          node.index = id;
        } else {
          node.responseName = id;
        }
        this.nodes.set(responsePathAsString(path), node);
        const parentNode = this.ensureParentNode(path);
        parentNode.child.push(node);
        return node;
      }
      ensureParentNode(path) {
        const parentPath = responsePathAsString(path.prev);
        const parentNode = this.nodes.get(parentPath);
        if (parentNode) {
          return parentNode;
        }
        return this.newNode(path.prev);
      }
      rewriteAndNormalizeError(err) {
        if (this.rewriteError) {
          const clonedError = Object.assign(Object.create(Object.getPrototypeOf(err)), err);
          const rewrittenError = this.rewriteError(clonedError);
          if (rewrittenError === null) {
            return null;
          }
          if (!(rewrittenError instanceof graphql_1.GraphQLError)) {
            return err;
          }
          return new graphql_1.GraphQLError(rewrittenError.message, err.nodes, err.source, err.positions, err.path, err.originalError, rewrittenError.extensions || err.extensions);
        }
        return err;
      }
    };
    exports2.TraceTreeBuilder = TraceTreeBuilder;
    function durationHrTimeToNanos(hrtime) {
      return hrtime[0] * 1e9 + hrtime[1];
    }
    function responsePathAsString(p) {
      if (p === void 0) {
        return "";
      }
      let res = String(p.key);
      while ((p = p.prev) !== void 0) {
        res = `${p.key}.${res}`;
      }
      return res;
    }
    function errorToProtobufError(error) {
      return new apollo_reporting_protobuf_1.Trace.Error({
        message: error.message,
        location: (error.locations || []).map(({ line, column }) => new apollo_reporting_protobuf_1.Trace.Location({ line, column })),
        json: JSON.stringify(error)
      });
    }
    function dateToProtoTimestamp(date) {
      const totalMillis = +date;
      const millis = totalMillis % 1e3;
      return new apollo_reporting_protobuf_1.google.protobuf.Timestamp({
        seconds: (totalMillis - millis) / 1e3,
        nanos: millis * 1e6
      });
    }
    exports2.dateToProtoTimestamp = dateToProtoTimestamp;
  }
});

// ../../../node_modules/apollo-server-core/dist/plugin/usageReporting/traceDetails.js
var require_traceDetails = __commonJS({
  "../../../node_modules/apollo-server-core/dist/plugin/usageReporting/traceDetails.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.makeTraceDetails = void 0;
    var apollo_reporting_protobuf_1 = require_generated();
    function makeTraceDetails(variables, sendVariableValues, operationString) {
      const details = new apollo_reporting_protobuf_1.Trace.Details();
      const variablesToRecord = (() => {
        if (sendVariableValues && "transform" in sendVariableValues) {
          const originalKeys = Object.keys(variables);
          try {
            const modifiedVariables = sendVariableValues.transform({
              variables,
              operationString
            });
            return cleanModifiedVariables(originalKeys, modifiedVariables);
          } catch (e) {
            return handleVariableValueTransformError(originalKeys);
          }
        } else {
          return variables;
        }
      })();
      Object.keys(variablesToRecord).forEach((name) => {
        if (!sendVariableValues || "none" in sendVariableValues && sendVariableValues.none || "all" in sendVariableValues && !sendVariableValues.all || "exceptNames" in sendVariableValues && sendVariableValues.exceptNames.includes(name) || "onlyNames" in sendVariableValues && !sendVariableValues.onlyNames.includes(name)) {
          details.variablesJson[name] = "";
        } else {
          try {
            details.variablesJson[name] = typeof variablesToRecord[name] === "undefined" ? "" : JSON.stringify(variablesToRecord[name]);
          } catch (e) {
            details.variablesJson[name] = JSON.stringify("[Unable to convert value to JSON]");
          }
        }
      });
      return details;
    }
    exports2.makeTraceDetails = makeTraceDetails;
    function handleVariableValueTransformError(variableNames) {
      const modifiedVariables = /* @__PURE__ */ Object.create(null);
      variableNames.forEach((name) => {
        modifiedVariables[name] = "[PREDICATE_FUNCTION_ERROR]";
      });
      return modifiedVariables;
    }
    function cleanModifiedVariables(originalKeys, modifiedVariables) {
      const cleanedVariables = /* @__PURE__ */ Object.create(null);
      originalKeys.forEach((name) => {
        cleanedVariables[name] = modifiedVariables[name];
      });
      return cleanedVariables;
    }
  }
});

// ../../../node_modules/uuid/dist/commonjs-browser/rng.js
var require_rng = __commonJS({
  "../../../node_modules/uuid/dist/commonjs-browser/rng.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = rng;
    var getRandomValues;
    var rnds8 = new Uint8Array(16);
    function rng() {
      if (!getRandomValues) {
        getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
        if (!getRandomValues) {
          throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
        }
      }
      return getRandomValues(rnds8);
    }
  }
});

// ../../../node_modules/uuid/dist/commonjs-browser/regex.js
var require_regex = __commonJS({
  "../../../node_modules/uuid/dist/commonjs-browser/regex.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
    exports2.default = _default;
  }
});

// ../../../node_modules/uuid/dist/commonjs-browser/validate.js
var require_validate = __commonJS({
  "../../../node_modules/uuid/dist/commonjs-browser/validate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _regex = _interopRequireDefault(require_regex());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function validate2(uuid) {
      return typeof uuid === "string" && _regex.default.test(uuid);
    }
    var _default = validate2;
    exports2.default = _default;
  }
});

// ../../../node_modules/uuid/dist/commonjs-browser/stringify.js
var require_stringify = __commonJS({
  "../../../node_modules/uuid/dist/commonjs-browser/stringify.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    exports2.unsafeStringify = unsafeStringify;
    var _validate = _interopRequireDefault(require_validate());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var byteToHex = [];
    for (let i = 0; i < 256; ++i) {
      byteToHex.push((i + 256).toString(16).slice(1));
    }
    function unsafeStringify(arr, offset = 0) {
      return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
    }
    function stringify(arr, offset = 0) {
      const uuid = unsafeStringify(arr, offset);
      if (!(0, _validate.default)(uuid)) {
        throw TypeError("Stringified UUID is invalid");
      }
      return uuid;
    }
    var _default = stringify;
    exports2.default = _default;
  }
});

// ../../../node_modules/uuid/dist/commonjs-browser/v1.js
var require_v1 = __commonJS({
  "../../../node_modules/uuid/dist/commonjs-browser/v1.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _rng = _interopRequireDefault(require_rng());
    var _stringify = require_stringify();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var _nodeId;
    var _clockseq;
    var _lastMSecs = 0;
    var _lastNSecs = 0;
    function v1(options, buf, offset) {
      let i = buf && offset || 0;
      const b = buf || new Array(16);
      options = options || {};
      let node = options.node || _nodeId;
      let clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
      if (node == null || clockseq == null) {
        const seedBytes = options.random || (options.rng || _rng.default)();
        if (node == null) {
          node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
        }
        if (clockseq == null) {
          clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
        }
      }
      let msecs = options.msecs !== void 0 ? options.msecs : Date.now();
      let nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
      const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
      if (dt < 0 && options.clockseq === void 0) {
        clockseq = clockseq + 1 & 16383;
      }
      if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
        nsecs = 0;
      }
      if (nsecs >= 1e4) {
        throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
      }
      _lastMSecs = msecs;
      _lastNSecs = nsecs;
      _clockseq = clockseq;
      msecs += 122192928e5;
      const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
      b[i++] = tl >>> 24 & 255;
      b[i++] = tl >>> 16 & 255;
      b[i++] = tl >>> 8 & 255;
      b[i++] = tl & 255;
      const tmh = msecs / 4294967296 * 1e4 & 268435455;
      b[i++] = tmh >>> 8 & 255;
      b[i++] = tmh & 255;
      b[i++] = tmh >>> 24 & 15 | 16;
      b[i++] = tmh >>> 16 & 255;
      b[i++] = clockseq >>> 8 | 128;
      b[i++] = clockseq & 255;
      for (let n = 0; n < 6; ++n) {
        b[i + n] = node[n];
      }
      return buf || (0, _stringify.unsafeStringify)(b);
    }
    var _default = v1;
    exports2.default = _default;
  }
});

// ../../../node_modules/uuid/dist/commonjs-browser/parse.js
var require_parse = __commonJS({
  "../../../node_modules/uuid/dist/commonjs-browser/parse.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _validate = _interopRequireDefault(require_validate());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function parse2(uuid) {
      if (!(0, _validate.default)(uuid)) {
        throw TypeError("Invalid UUID");
      }
      let v;
      const arr = new Uint8Array(16);
      arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
      arr[1] = v >>> 16 & 255;
      arr[2] = v >>> 8 & 255;
      arr[3] = v & 255;
      arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
      arr[5] = v & 255;
      arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
      arr[7] = v & 255;
      arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
      arr[9] = v & 255;
      arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
      arr[11] = v / 4294967296 & 255;
      arr[12] = v >>> 24 & 255;
      arr[13] = v >>> 16 & 255;
      arr[14] = v >>> 8 & 255;
      arr[15] = v & 255;
      return arr;
    }
    var _default = parse2;
    exports2.default = _default;
  }
});

// ../../../node_modules/uuid/dist/commonjs-browser/v35.js
var require_v35 = __commonJS({
  "../../../node_modules/uuid/dist/commonjs-browser/v35.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.URL = exports2.DNS = void 0;
    exports2.default = v35;
    var _stringify = require_stringify();
    var _parse = _interopRequireDefault(require_parse());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function stringToBytes(str) {
      str = unescape(encodeURIComponent(str));
      const bytes = [];
      for (let i = 0; i < str.length; ++i) {
        bytes.push(str.charCodeAt(i));
      }
      return bytes;
    }
    var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    exports2.DNS = DNS;
    var URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
    exports2.URL = URL;
    function v35(name, version2, hashfunc) {
      function generateUUID(value, namespace, buf, offset) {
        var _namespace;
        if (typeof value === "string") {
          value = stringToBytes(value);
        }
        if (typeof namespace === "string") {
          namespace = (0, _parse.default)(namespace);
        }
        if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
          throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
        }
        let bytes = new Uint8Array(16 + value.length);
        bytes.set(namespace);
        bytes.set(value, namespace.length);
        bytes = hashfunc(bytes);
        bytes[6] = bytes[6] & 15 | version2;
        bytes[8] = bytes[8] & 63 | 128;
        if (buf) {
          offset = offset || 0;
          for (let i = 0; i < 16; ++i) {
            buf[offset + i] = bytes[i];
          }
          return buf;
        }
        return (0, _stringify.unsafeStringify)(bytes);
      }
      try {
        generateUUID.name = name;
      } catch (err) {
      }
      generateUUID.DNS = DNS;
      generateUUID.URL = URL;
      return generateUUID;
    }
  }
});

// ../../../node_modules/uuid/dist/commonjs-browser/md5.js
var require_md5 = __commonJS({
  "../../../node_modules/uuid/dist/commonjs-browser/md5.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    function md5(bytes) {
      if (typeof bytes === "string") {
        const msg = unescape(encodeURIComponent(bytes));
        bytes = new Uint8Array(msg.length);
        for (let i = 0; i < msg.length; ++i) {
          bytes[i] = msg.charCodeAt(i);
        }
      }
      return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
    }
    function md5ToHexEncodedArray(input) {
      const output = [];
      const length32 = input.length * 32;
      const hexTab = "0123456789abcdef";
      for (let i = 0; i < length32; i += 8) {
        const x = input[i >> 5] >>> i % 32 & 255;
        const hex = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);
        output.push(hex);
      }
      return output;
    }
    function getOutputLength(inputLength8) {
      return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
    }
    function wordsToMd5(x, len) {
      x[len >> 5] |= 128 << len % 32;
      x[getOutputLength(len) - 1] = len;
      let a = 1732584193;
      let b = -271733879;
      let c = -1732584194;
      let d = 271733878;
      for (let i = 0; i < x.length; i += 16) {
        const olda = a;
        const oldb = b;
        const oldc = c;
        const oldd = d;
        a = md5ff(a, b, c, d, x[i], 7, -680876936);
        d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
        c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
        b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
        a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
        d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
        c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
        b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
        a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
        d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
        c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
        b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
        a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
        d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
        c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
        b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
        a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
        d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
        c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
        b = md5gg(b, c, d, a, x[i], 20, -373897302);
        a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
        d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
        c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
        b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
        a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
        d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
        c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
        b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
        a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
        d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
        c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
        b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
        a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
        d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
        c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
        b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
        a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
        d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
        c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
        b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
        a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
        d = md5hh(d, a, b, c, x[i], 11, -358537222);
        c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
        b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
        a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
        d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
        c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
        b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
        a = md5ii(a, b, c, d, x[i], 6, -198630844);
        d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
        c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
        b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
        a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
        d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
        c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
        b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
        a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
        d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
        c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
        b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
        a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
        d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
        c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
        b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
        a = safeAdd(a, olda);
        b = safeAdd(b, oldb);
        c = safeAdd(c, oldc);
        d = safeAdd(d, oldd);
      }
      return [a, b, c, d];
    }
    function bytesToWords(input) {
      if (input.length === 0) {
        return [];
      }
      const length8 = input.length * 8;
      const output = new Uint32Array(getOutputLength(length8));
      for (let i = 0; i < length8; i += 8) {
        output[i >> 5] |= (input[i / 8] & 255) << i % 32;
      }
      return output;
    }
    function safeAdd(x, y) {
      const lsw = (x & 65535) + (y & 65535);
      const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
      return msw << 16 | lsw & 65535;
    }
    function bitRotateLeft(num, cnt) {
      return num << cnt | num >>> 32 - cnt;
    }
    function md5cmn(q, a, b, x, s, t) {
      return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
    }
    function md5ff(a, b, c, d, x, s, t) {
      return md5cmn(b & c | ~b & d, a, b, x, s, t);
    }
    function md5gg(a, b, c, d, x, s, t) {
      return md5cmn(b & d | c & ~d, a, b, x, s, t);
    }
    function md5hh(a, b, c, d, x, s, t) {
      return md5cmn(b ^ c ^ d, a, b, x, s, t);
    }
    function md5ii(a, b, c, d, x, s, t) {
      return md5cmn(c ^ (b | ~d), a, b, x, s, t);
    }
    var _default = md5;
    exports2.default = _default;
  }
});

// ../../../node_modules/uuid/dist/commonjs-browser/v3.js
var require_v3 = __commonJS({
  "../../../node_modules/uuid/dist/commonjs-browser/v3.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _v = _interopRequireDefault(require_v35());
    var _md = _interopRequireDefault(require_md5());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var v3 = (0, _v.default)("v3", 48, _md.default);
    var _default = v3;
    exports2.default = _default;
  }
});

// ../../../node_modules/uuid/dist/commonjs-browser/native.js
var require_native = __commonJS({
  "../../../node_modules/uuid/dist/commonjs-browser/native.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
    var _default = {
      randomUUID
    };
    exports2.default = _default;
  }
});

// ../../../node_modules/uuid/dist/commonjs-browser/v4.js
var require_v4 = __commonJS({
  "../../../node_modules/uuid/dist/commonjs-browser/v4.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _native = _interopRequireDefault(require_native());
    var _rng = _interopRequireDefault(require_rng());
    var _stringify = require_stringify();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function v4(options, buf, offset) {
      if (_native.default.randomUUID && !buf && !options) {
        return _native.default.randomUUID();
      }
      options = options || {};
      const rnds = options.random || (options.rng || _rng.default)();
      rnds[6] = rnds[6] & 15 | 64;
      rnds[8] = rnds[8] & 63 | 128;
      if (buf) {
        offset = offset || 0;
        for (let i = 0; i < 16; ++i) {
          buf[offset + i] = rnds[i];
        }
        return buf;
      }
      return (0, _stringify.unsafeStringify)(rnds);
    }
    var _default = v4;
    exports2.default = _default;
  }
});

// ../../../node_modules/uuid/dist/commonjs-browser/sha1.js
var require_sha12 = __commonJS({
  "../../../node_modules/uuid/dist/commonjs-browser/sha1.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    function f(s, x, y, z) {
      switch (s) {
        case 0:
          return x & y ^ ~x & z;
        case 1:
          return x ^ y ^ z;
        case 2:
          return x & y ^ x & z ^ y & z;
        case 3:
          return x ^ y ^ z;
      }
    }
    function ROTL(x, n) {
      return x << n | x >>> 32 - n;
    }
    function sha1(bytes) {
      const K = [1518500249, 1859775393, 2400959708, 3395469782];
      const H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
      if (typeof bytes === "string") {
        const msg = unescape(encodeURIComponent(bytes));
        bytes = [];
        for (let i = 0; i < msg.length; ++i) {
          bytes.push(msg.charCodeAt(i));
        }
      } else if (!Array.isArray(bytes)) {
        bytes = Array.prototype.slice.call(bytes);
      }
      bytes.push(128);
      const l = bytes.length / 4 + 2;
      const N = Math.ceil(l / 16);
      const M = new Array(N);
      for (let i = 0; i < N; ++i) {
        const arr = new Uint32Array(16);
        for (let j = 0; j < 16; ++j) {
          arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
        }
        M[i] = arr;
      }
      M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
      M[N - 1][14] = Math.floor(M[N - 1][14]);
      M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
      for (let i = 0; i < N; ++i) {
        const W = new Uint32Array(80);
        for (let t = 0; t < 16; ++t) {
          W[t] = M[i][t];
        }
        for (let t = 16; t < 80; ++t) {
          W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
        }
        let a = H[0];
        let b = H[1];
        let c = H[2];
        let d = H[3];
        let e = H[4];
        for (let t = 0; t < 80; ++t) {
          const s = Math.floor(t / 20);
          const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;
          e = d;
          d = c;
          c = ROTL(b, 30) >>> 0;
          b = a;
          a = T;
        }
        H[0] = H[0] + a >>> 0;
        H[1] = H[1] + b >>> 0;
        H[2] = H[2] + c >>> 0;
        H[3] = H[3] + d >>> 0;
        H[4] = H[4] + e >>> 0;
      }
      return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
    }
    var _default = sha1;
    exports2.default = _default;
  }
});

// ../../../node_modules/uuid/dist/commonjs-browser/v5.js
var require_v5 = __commonJS({
  "../../../node_modules/uuid/dist/commonjs-browser/v5.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _v = _interopRequireDefault(require_v35());
    var _sha = _interopRequireDefault(require_sha12());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var v5 = (0, _v.default)("v5", 80, _sha.default);
    var _default = v5;
    exports2.default = _default;
  }
});

// ../../../node_modules/uuid/dist/commonjs-browser/nil.js
var require_nil = __commonJS({
  "../../../node_modules/uuid/dist/commonjs-browser/nil.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _default = "00000000-0000-0000-0000-000000000000";
    exports2.default = _default;
  }
});

// ../../../node_modules/uuid/dist/commonjs-browser/version.js
var require_version = __commonJS({
  "../../../node_modules/uuid/dist/commonjs-browser/version.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _validate = _interopRequireDefault(require_validate());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function version2(uuid) {
      if (!(0, _validate.default)(uuid)) {
        throw TypeError("Invalid UUID");
      }
      return parseInt(uuid.slice(14, 15), 16);
    }
    var _default = version2;
    exports2.default = _default;
  }
});

// ../../../node_modules/uuid/dist/commonjs-browser/index.js
var require_commonjs_browser = __commonJS({
  "../../../node_modules/uuid/dist/commonjs-browser/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "NIL", {
      enumerable: true,
      get: function get() {
        return _nil.default;
      }
    });
    Object.defineProperty(exports2, "parse", {
      enumerable: true,
      get: function get() {
        return _parse.default;
      }
    });
    Object.defineProperty(exports2, "stringify", {
      enumerable: true,
      get: function get() {
        return _stringify.default;
      }
    });
    Object.defineProperty(exports2, "v1", {
      enumerable: true,
      get: function get() {
        return _v.default;
      }
    });
    Object.defineProperty(exports2, "v3", {
      enumerable: true,
      get: function get() {
        return _v2.default;
      }
    });
    Object.defineProperty(exports2, "v4", {
      enumerable: true,
      get: function get() {
        return _v3.default;
      }
    });
    Object.defineProperty(exports2, "v5", {
      enumerable: true,
      get: function get() {
        return _v4.default;
      }
    });
    Object.defineProperty(exports2, "validate", {
      enumerable: true,
      get: function get() {
        return _validate.default;
      }
    });
    Object.defineProperty(exports2, "version", {
      enumerable: true,
      get: function get() {
        return _version.default;
      }
    });
    var _v = _interopRequireDefault(require_v1());
    var _v2 = _interopRequireDefault(require_v3());
    var _v3 = _interopRequireDefault(require_v4());
    var _v4 = _interopRequireDefault(require_v5());
    var _nil = _interopRequireDefault(require_nil());
    var _version = _interopRequireDefault(require_version());
    var _validate = _interopRequireDefault(require_validate());
    var _stringify = _interopRequireDefault(require_stringify());
    var _parse = _interopRequireDefault(require_parse());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
  }
});

// ../../../node_modules/graphql-tag/lib/index.js
var lib_exports = {};
__export(lib_exports, {
  default: () => lib_default,
  disableExperimentalFragmentVariables: () => disableExperimentalFragmentVariables,
  disableFragmentWarnings: () => disableFragmentWarnings,
  enableExperimentalFragmentVariables: () => enableExperimentalFragmentVariables,
  gql: () => gql,
  resetCaches: () => resetCaches
});
function normalize(string) {
  return string.replace(/[\s,]+/g, " ").trim();
}
function cacheKeyFromLoc(loc) {
  return normalize(loc.source.body.substring(loc.start, loc.end));
}
function processFragments(ast) {
  var seenKeys = /* @__PURE__ */ new Set();
  var definitions = [];
  ast.definitions.forEach(function(fragmentDefinition) {
    if (fragmentDefinition.kind === "FragmentDefinition") {
      var fragmentName = fragmentDefinition.name.value;
      var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);
      var sourceKeySet = fragmentSourceMap.get(fragmentName);
      if (sourceKeySet && !sourceKeySet.has(sourceKey)) {
        if (printFragmentWarnings) {
          console.warn("Warning: fragment with name " + fragmentName + " already exists.\ngraphql-tag enforces all fragment names across your application to be unique; read more about\nthis in the docs: http://dev.apollodata.com/core/fragments.html#unique-names");
        }
      } else if (!sourceKeySet) {
        fragmentSourceMap.set(fragmentName, sourceKeySet = /* @__PURE__ */ new Set());
      }
      sourceKeySet.add(sourceKey);
      if (!seenKeys.has(sourceKey)) {
        seenKeys.add(sourceKey);
        definitions.push(fragmentDefinition);
      }
    } else {
      definitions.push(fragmentDefinition);
    }
  });
  return __assign(__assign({}, ast), { definitions });
}
function stripLoc(doc) {
  var workSet = new Set(doc.definitions);
  workSet.forEach(function(node) {
    if (node.loc)
      delete node.loc;
    Object.keys(node).forEach(function(key) {
      var value = node[key];
      if (value && typeof value === "object") {
        workSet.add(value);
      }
    });
  });
  var loc = doc.loc;
  if (loc) {
    delete loc.startToken;
    delete loc.endToken;
  }
  return doc;
}
function parseDocument(source) {
  var cacheKey = normalize(source);
  if (!docCache.has(cacheKey)) {
    var parsed = parse(source, {
      experimentalFragmentVariables,
      allowLegacyFragmentVariables: experimentalFragmentVariables
    });
    if (!parsed || parsed.kind !== "Document") {
      throw new Error("Not a valid GraphQL document.");
    }
    docCache.set(cacheKey, stripLoc(processFragments(parsed)));
  }
  return docCache.get(cacheKey);
}
function gql(literals) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  if (typeof literals === "string") {
    literals = [literals];
  }
  var result = literals[0];
  args.forEach(function(arg, i) {
    if (arg && arg.kind === "Document") {
      result += arg.loc.source.body;
    } else {
      result += arg;
    }
    result += literals[i + 1];
  });
  return parseDocument(result);
}
function resetCaches() {
  docCache.clear();
  fragmentSourceMap.clear();
}
function disableFragmentWarnings() {
  printFragmentWarnings = false;
}
function enableExperimentalFragmentVariables() {
  experimentalFragmentVariables = true;
}
function disableExperimentalFragmentVariables() {
  experimentalFragmentVariables = false;
}
var docCache, fragmentSourceMap, printFragmentWarnings, experimentalFragmentVariables, extras, lib_default;
var init_lib = __esm({
  "../../../node_modules/graphql-tag/lib/index.js"() {
    init_tslib_es6();
    init_graphql2();
    docCache = /* @__PURE__ */ new Map();
    fragmentSourceMap = /* @__PURE__ */ new Map();
    printFragmentWarnings = true;
    experimentalFragmentVariables = false;
    extras = {
      gql,
      resetCaches,
      disableFragmentWarnings,
      enableExperimentalFragmentVariables,
      disableExperimentalFragmentVariables
    };
    (function(gql_1) {
      gql_1.gql = extras.gql, gql_1.resetCaches = extras.resetCaches, gql_1.disableFragmentWarnings = extras.disableFragmentWarnings, gql_1.enableExperimentalFragmentVariables = extras.enableExperimentalFragmentVariables, gql_1.disableExperimentalFragmentVariables = extras.disableExperimentalFragmentVariables;
    })(gql || (gql = {}));
    gql["default"] = gql;
    lib_default = gql;
  }
});

// ../../../node_modules/apollo-server-core/dist/gql.js
var require_gql = __commonJS({
  "../../../node_modules/apollo-server-core/dist/gql.js"(exports2) {
    "use strict";
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.gql = void 0;
    var graphql_tag_1 = __importDefault2((init_lib(), __toCommonJS(lib_exports)));
    exports2.gql = graphql_tag_1.default;
  }
});

// ../../../node_modules/apollo-server-core/package.json
var require_package = __commonJS({
  "../../../node_modules/apollo-server-core/package.json"(exports2, module2) {
    module2.exports = {
      name: "apollo-server-core",
      version: "3.12.0",
      description: "Core engine for Apollo GraphQL server",
      main: "dist/index.js",
      types: "dist/index.d.ts",
      repository: {
        type: "git",
        url: "https://github.com/apollographql/apollo-server",
        directory: "packages/apollo-server-core"
      },
      keywords: [
        "GraphQL",
        "Apollo",
        "Server",
        "Javascript"
      ],
      author: "Apollo <packages@apollographql.com>",
      license: "MIT",
      bugs: {
        url: "https://github.com/apollographql/apollo-server/issues"
      },
      homepage: "https://github.com/apollographql/apollo-server#readme",
      engines: {
        node: ">=12.0"
      },
      dependencies: {
        "@apollo/utils.keyvaluecache": "^1.0.1",
        "@apollo/utils.logger": "^1.0.0",
        "@apollo/utils.usagereporting": "^1.0.0",
        "@apollographql/apollo-tools": "^0.5.3",
        "@apollographql/graphql-playground-html": "1.6.29",
        "@graphql-tools/mock": "^8.1.2",
        "@graphql-tools/schema": "^8.0.0",
        "@josephg/resolvable": "^1.0.0",
        "apollo-datasource": "^3.3.2",
        "apollo-reporting-protobuf": "^3.4.0",
        "apollo-server-env": "^4.2.1",
        "apollo-server-errors": "^3.3.1",
        "apollo-server-plugin-base": "^3.7.2",
        "apollo-server-types": "^3.8.0",
        "async-retry": "^1.2.1",
        "fast-json-stable-stringify": "^2.1.0",
        "graphql-tag": "^2.11.0",
        loglevel: "^1.6.8",
        "lru-cache": "^6.0.0",
        "node-abort-controller": "^3.0.1",
        "sha.js": "^2.4.11",
        uuid: "^9.0.0",
        "whatwg-mimetype": "^3.0.0"
      },
      peerDependencies: {
        graphql: "^15.3.0 || ^16.0.0"
      },
      gitHead: "fac578a32d5b6e21164fb649fc61d641d0401774"
    };
  }
});

// ../../../node_modules/apollo-server-core/dist/plugin/schemaReporting/schemaReporter.js
var require_schemaReporter = __commonJS({
  "../../../node_modules/apollo-server-core/dist/plugin/schemaReporting/schemaReporter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SchemaReporter = exports2.schemaReportGql = void 0;
    var gql_1 = require_gql();
    var apollo_server_env_1 = require_index_browser();
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    exports2.schemaReportGql = (0, graphql_1.print)((0, gql_1.gql)`
  mutation SchemaReport($report: SchemaReport!, $coreSchema: String) {
    reportSchema(report: $report, coreSchema: $coreSchema) {
      __typename
      ... on ReportSchemaError {
        message
        code
      }
      ... on ReportSchemaResponse {
        inSeconds
        withCoreSchema
      }
    }
  }
`);
    var SchemaReporter = class {
      constructor(options) {
        var _a;
        this.headers = new apollo_server_env_1.Headers();
        this.headers.set("Content-Type", "application/json");
        this.headers.set("x-api-key", options.apiKey);
        this.headers.set("apollographql-client-name", "ApolloServerPluginSchemaReporting");
        this.headers.set("apollographql-client-version", require_package().version);
        this.endpointUrl = options.endpointUrl || "https://schema-reporting.api.apollographql.com/api/graphql";
        this.schemaReport = options.schemaReport;
        this.coreSchema = options.coreSchema;
        this.isStopped = false;
        this.logger = options.logger;
        this.initialReportingDelayInMs = options.initialReportingDelayInMs;
        this.fallbackReportingDelayInMs = options.fallbackReportingDelayInMs;
        this.fetcher = (_a = options.fetcher) !== null && _a !== void 0 ? _a : apollo_server_env_1.fetch;
      }
      stopped() {
        return this.isStopped;
      }
      start() {
        this.pollTimer = setTimeout(() => this.sendOneReportAndScheduleNext(false), this.initialReportingDelayInMs);
      }
      stop() {
        this.isStopped = true;
        if (this.pollTimer) {
          clearTimeout(this.pollTimer);
          this.pollTimer = void 0;
        }
      }
      async sendOneReportAndScheduleNext(sendNextWithCoreSchema) {
        this.pollTimer = void 0;
        if (this.stopped())
          return;
        try {
          const result = await this.reportSchema(sendNextWithCoreSchema);
          if (!result) {
            return;
          }
          if (!this.stopped()) {
            this.pollTimer = setTimeout(() => this.sendOneReportAndScheduleNext(result.withCoreSchema), result.inSeconds * 1e3);
          }
          return;
        } catch (error) {
          this.logger.error(`Error reporting server info to Apollo during schema reporting: ${error}`);
          if (!this.stopped()) {
            this.pollTimer = setTimeout(() => this.sendOneReportAndScheduleNext(false), this.fallbackReportingDelayInMs);
          }
        }
      }
      async reportSchema(withCoreSchema) {
        const { data, errors } = await this.apolloQuery({
          report: this.schemaReport,
          coreSchema: withCoreSchema ? this.coreSchema : null
        });
        if (errors) {
          throw new Error(errors.map((x) => x.message).join("\n"));
        }
        function msgForUnexpectedResponse(data2) {
          return [
            "Unexpected response shape from Apollo when",
            "reporting schema. If this continues, please reach",
            "out to support@apollographql.com.",
            "Received response:",
            JSON.stringify(data2)
          ].join(" ");
        }
        if (!data || !data.reportSchema) {
          throw new Error(msgForUnexpectedResponse(data));
        }
        if (data.reportSchema.__typename === "ReportSchemaResponse") {
          return data.reportSchema;
        } else if (data.reportSchema.__typename === "ReportSchemaError") {
          this.logger.error([
            "Received input validation error from Apollo:",
            data.reportSchema.message,
            "Stopping reporting. Please fix the input errors."
          ].join(" "));
          this.stop();
          return null;
        }
        throw new Error(msgForUnexpectedResponse(data));
      }
      async apolloQuery(variables) {
        const request = {
          query: exports2.schemaReportGql,
          variables
        };
        const httpRequest = new apollo_server_env_1.Request(this.endpointUrl, {
          method: "POST",
          headers: this.headers,
          body: JSON.stringify(request)
        });
        const httpResponse = await this.fetcher(httpRequest);
        if (!httpResponse.ok) {
          throw new Error([
            `An unexpected HTTP status code (${httpResponse.status}) was`,
            "encountered during schema reporting."
          ].join(" "));
        }
        try {
          return await httpResponse.json();
        } catch (error) {
          throw new Error([
            "Couldn't report schema to Apollo.",
            "Parsing response as JSON failed.",
            "If this continues please reach out to support@apollographql.com",
            error
          ].join(" "));
        }
      }
    };
    exports2.SchemaReporter = SchemaReporter;
  }
});

// ../../../node_modules/apollo-server-core/dist/plugin/schemaIsFederated.js
var require_schemaIsFederated = __commonJS({
  "../../../node_modules/apollo-server-core/dist/plugin/schemaIsFederated.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.schemaIsFederated = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function schemaIsFederated(schema) {
      const serviceType = schema.getType("_Service");
      if (!(0, graphql_1.isObjectType)(serviceType)) {
        return false;
      }
      const sdlField = serviceType.getFields().sdl;
      if (!sdlField) {
        return false;
      }
      const sdlFieldType = sdlField.type;
      if (!(0, graphql_1.isScalarType)(sdlFieldType)) {
        return false;
      }
      return sdlFieldType.name == "String";
    }
    exports2.schemaIsFederated = schemaIsFederated;
  }
});

// ../../../node_modules/apollo-server-core/dist/plugin/schemaReporting/index.js
var require_schemaReporting = __commonJS({
  "../../../node_modules/apollo-server-core/dist/plugin/schemaReporting/index.js"(exports2) {
    "use strict";
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.computeCoreSchemaHash = exports2.ApolloServerPluginSchemaReporting = void 0;
    var os_1 = __importDefault2(require_os());
    var uuid_1 = require_commonjs_browser();
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var schemaReporter_1 = require_schemaReporter();
    var createSHA_1 = __importDefault2(require_createSHA());
    var schemaIsFederated_1 = require_schemaIsFederated();
    function ApolloServerPluginSchemaReporting({ initialDelayMaxMs, overrideReportedSchema, endpointUrl, fetcher } = /* @__PURE__ */ Object.create(null)) {
      const bootId = (0, uuid_1.v4)();
      return {
        __internal_plugin_id__() {
          return "SchemaReporting";
        },
        async serverWillStart({ apollo, schema, logger }) {
          const { key, graphRef } = apollo;
          if (!key) {
            throw Error("To use ApolloServerPluginSchemaReporting, you must provide an Apollo API key, via the APOLLO_KEY environment variable or via `new ApolloServer({apollo: {key})`");
          }
          if (!graphRef) {
            throw Error("To use ApolloServerPluginSchemaReporting, you must provide your graph ref (eg, 'my-graph-id@my-graph-variant'). Try setting the APOLLO_GRAPH_REF environment variable or passing `new ApolloServer({apollo: {graphRef}})`.");
          }
          if (overrideReportedSchema) {
            try {
              const validationErrors = (0, graphql_1.validateSchema)((0, graphql_1.buildSchema)(overrideReportedSchema, { noLocation: true }));
              if (validationErrors.length) {
                throw new Error(validationErrors.map((error) => error.message).join("\n"));
              }
            } catch (err) {
              throw new Error(`The schema provided to overrideReportedSchema failed to parse or validate: ${err.message}`);
            }
          }
          if ((0, schemaIsFederated_1.schemaIsFederated)(schema)) {
            throw Error([
              "Schema reporting is not yet compatible with federated services.",
              "If you're interested in using schema reporting with federated",
              "services, please contact Apollo support. To set up managed federation, see",
              "https://go.apollo.dev/s/managed-federation"
            ].join(" "));
          }
          if (endpointUrl !== void 0) {
            logger.info(`Apollo schema reporting: schema reporting URL override: ${endpointUrl}`);
          }
          const baseSchemaReport = {
            bootId,
            graphRef,
            platform: process.env.APOLLO_SERVER_PLATFORM || "local",
            runtimeVersion: `node ${process.version}`,
            userVersion: process.env.APOLLO_SERVER_USER_VERSION,
            serverId: process.env.APOLLO_SERVER_ID || process.env.HOSTNAME || os_1.default.hostname(),
            libraryVersion: `apollo-server-core@${require_package().version}`
          };
          let currentSchemaReporter;
          return {
            schemaDidLoadOrUpdate({ apiSchema, coreSupergraphSdl }) {
              var _a;
              if (overrideReportedSchema !== void 0) {
                if (currentSchemaReporter) {
                  return;
                } else {
                  logger.info("Apollo schema reporting: schema to report has been overridden");
                }
              }
              const coreSchema = (_a = overrideReportedSchema !== null && overrideReportedSchema !== void 0 ? overrideReportedSchema : coreSupergraphSdl) !== null && _a !== void 0 ? _a : (0, graphql_1.printSchema)(apiSchema);
              const coreSchemaHash = computeCoreSchemaHash(coreSchema);
              const schemaReport = {
                ...baseSchemaReport,
                coreSchemaHash
              };
              currentSchemaReporter === null || currentSchemaReporter === void 0 ? void 0 : currentSchemaReporter.stop();
              currentSchemaReporter = new schemaReporter_1.SchemaReporter({
                schemaReport,
                coreSchema,
                apiKey: key,
                endpointUrl,
                logger,
                initialReportingDelayInMs: Math.floor(Math.random() * (initialDelayMaxMs !== null && initialDelayMaxMs !== void 0 ? initialDelayMaxMs : 1e4)),
                fallbackReportingDelayInMs: 2e4,
                fetcher
              });
              currentSchemaReporter.start();
              logger.info(`Apollo schema reporting: reporting a new schema to Studio! See your graph at https://studio.apollographql.com/graph/${encodeURI(graphRef)}/ with server info ${JSON.stringify(schemaReport)}`);
            },
            async serverWillStop() {
              currentSchemaReporter === null || currentSchemaReporter === void 0 ? void 0 : currentSchemaReporter.stop();
            }
          };
        }
      };
    }
    exports2.ApolloServerPluginSchemaReporting = ApolloServerPluginSchemaReporting;
    function computeCoreSchemaHash(schema) {
      return (0, createSHA_1.default)("sha256").update(schema).digest("hex");
    }
    exports2.computeCoreSchemaHash = computeCoreSchemaHash;
  }
});

// ../../../node_modules/apollo-server-core/dist/plugin/usageReporting/durationHistogram.js
var require_durationHistogram = __commonJS({
  "../../../node_modules/apollo-server-core/dist/plugin/usageReporting/durationHistogram.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DurationHistogram = void 0;
    var DurationHistogram = class _DurationHistogram {
      constructor(options) {
        const initSize = (options === null || options === void 0 ? void 0 : options.initSize) || 74;
        const buckets = options === null || options === void 0 ? void 0 : options.buckets;
        const arrayInitSize = Math.max((buckets === null || buckets === void 0 ? void 0 : buckets.length) || 0, initSize);
        this.buckets = Array(arrayInitSize).fill(0);
        if (buckets) {
          buckets.forEach((val, index) => this.buckets[index] = val);
        }
      }
      toArray() {
        let bufferedZeroes = 0;
        const outputArray = [];
        for (const value of this.buckets) {
          if (value === 0) {
            bufferedZeroes++;
          } else {
            if (bufferedZeroes === 1) {
              outputArray.push(0);
            } else if (bufferedZeroes !== 0) {
              outputArray.push(-bufferedZeroes);
            }
            outputArray.push(Math.floor(value));
            bufferedZeroes = 0;
          }
        }
        return outputArray;
      }
      static durationToBucket(durationNs) {
        const log = Math.log(durationNs / 1e3);
        const unboundedBucket = Math.ceil(log / _DurationHistogram.EXPONENT_LOG);
        return unboundedBucket <= 0 || Number.isNaN(unboundedBucket) ? 0 : unboundedBucket >= _DurationHistogram.BUCKET_COUNT ? _DurationHistogram.BUCKET_COUNT - 1 : unboundedBucket;
      }
      incrementDuration(durationNs, value = 1) {
        this.incrementBucket(_DurationHistogram.durationToBucket(durationNs), value);
        return this;
      }
      incrementBucket(bucket, value = 1) {
        if (bucket >= _DurationHistogram.BUCKET_COUNT) {
          throw Error("Bucket is out of bounds of the buckets array");
        }
        if (bucket >= this.buckets.length) {
          const oldLength = this.buckets.length;
          this.buckets.length = bucket + 1;
          this.buckets.fill(0, oldLength);
        }
        this.buckets[bucket] += value;
      }
      combine(otherHistogram) {
        for (let i = 0; i < otherHistogram.buckets.length; i++) {
          this.incrementBucket(i, otherHistogram.buckets[i]);
        }
      }
    };
    exports2.DurationHistogram = DurationHistogram;
    DurationHistogram.BUCKET_COUNT = 384;
    DurationHistogram.EXPONENT_LOG = Math.log(1.1);
  }
});

// ../../../node_modules/apollo-server-core/dist/plugin/usageReporting/iterateOverTrace.js
var require_iterateOverTrace = __commonJS({
  "../../../node_modules/apollo-server-core/dist/plugin/usageReporting/iterateOverTrace.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.iterateOverTrace = void 0;
    function iterateOverTrace(trace, f, includePath) {
      const rootPath = includePath ? new RootCollectingPathsResponseNamePath() : notCollectingPathsResponseNamePath;
      if (trace.root) {
        if (iterateOverTraceNode(trace.root, rootPath, f))
          return;
      }
      if (trace.queryPlan) {
        if (iterateOverQueryPlan(trace.queryPlan, rootPath, f))
          return;
      }
    }
    exports2.iterateOverTrace = iterateOverTrace;
    function iterateOverQueryPlan(node, rootPath, f) {
      var _a, _b, _c, _d, _e;
      if (!node)
        return false;
      if (((_b = (_a = node.fetch) === null || _a === void 0 ? void 0 : _a.trace) === null || _b === void 0 ? void 0 : _b.root) && node.fetch.serviceName) {
        return iterateOverTraceNode(node.fetch.trace.root, rootPath.child(`service:${node.fetch.serviceName}`), f);
      }
      if ((_c = node.flatten) === null || _c === void 0 ? void 0 : _c.node) {
        return iterateOverQueryPlan(node.flatten.node, rootPath, f);
      }
      if ((_d = node.parallel) === null || _d === void 0 ? void 0 : _d.nodes) {
        return node.parallel.nodes.some((node2) => iterateOverQueryPlan(node2, rootPath, f));
      }
      if ((_e = node.sequence) === null || _e === void 0 ? void 0 : _e.nodes) {
        return node.sequence.nodes.some((node2) => iterateOverQueryPlan(node2, rootPath, f));
      }
      return false;
    }
    function iterateOverTraceNode(node, path, f) {
      var _a, _b;
      if (f(node, path)) {
        return true;
      }
      return (_b = (_a = node.child) === null || _a === void 0 ? void 0 : _a.some((child) => {
        const childPath = child.responseName ? path.child(child.responseName) : path;
        return iterateOverTraceNode(child, childPath, f);
      })) !== null && _b !== void 0 ? _b : false;
    }
    var notCollectingPathsResponseNamePath = {
      toArray() {
        throw Error("not collecting paths!");
      },
      child() {
        return this;
      }
    };
    var RootCollectingPathsResponseNamePath = class {
      toArray() {
        return [];
      }
      child(responseName) {
        return new ChildCollectingPathsResponseNamePath(responseName, this);
      }
    };
    var ChildCollectingPathsResponseNamePath = class _ChildCollectingPathsResponseNamePath {
      constructor(responseName, prev) {
        this.responseName = responseName;
        this.prev = prev;
      }
      toArray() {
        const out = [];
        let curr = this;
        while (curr instanceof _ChildCollectingPathsResponseNamePath) {
          out.push(curr.responseName);
          curr = curr.prev;
        }
        return out.reverse();
      }
      child(responseName) {
        return new _ChildCollectingPathsResponseNamePath(responseName, this);
      }
    };
  }
});

// ../../../node_modules/apollo-server-core/dist/plugin/usageReporting/stats.js
var require_stats = __commonJS({
  "../../../node_modules/apollo-server-core/dist/plugin/usageReporting/stats.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OurContextualizedStats = exports2.OurReport = exports2.SizeEstimator = void 0;
    var durationHistogram_1 = require_durationHistogram();
    var apollo_reporting_protobuf_1 = require_generated();
    var iterateOverTrace_1 = require_iterateOverTrace();
    var SizeEstimator = class {
      constructor() {
        this.bytes = 0;
      }
    };
    exports2.SizeEstimator = SizeEstimator;
    var OurReport = class {
      constructor(header) {
        this.header = header;
        this.tracesPreAggregated = false;
        this.tracesPerQuery = /* @__PURE__ */ Object.create(null);
        this.endTime = null;
        this.operationCount = 0;
        this.sizeEstimator = new SizeEstimator();
      }
      ensureCountsAreIntegers() {
        for (const tracesAndStats of Object.values(this.tracesPerQuery)) {
          tracesAndStats.ensureCountsAreIntegers();
        }
      }
      addTrace({ statsReportKey, trace, asTrace, includeTracesContributingToStats, referencedFieldsByType }) {
        const tracesAndStats = this.getTracesAndStats({
          statsReportKey,
          referencedFieldsByType
        });
        if (asTrace) {
          const encodedTrace = apollo_reporting_protobuf_1.Trace.encode(trace).finish();
          tracesAndStats.trace.push(encodedTrace);
          this.sizeEstimator.bytes += 2 + encodedTrace.length;
        } else {
          tracesAndStats.statsWithContext.addTrace(trace, this.sizeEstimator);
          if (includeTracesContributingToStats) {
            const encodedTrace = apollo_reporting_protobuf_1.Trace.encode(trace).finish();
            tracesAndStats.internalTracesContributingToStats.push(encodedTrace);
            this.sizeEstimator.bytes += 2 + encodedTrace.length;
          }
        }
      }
      getTracesAndStats({ statsReportKey, referencedFieldsByType }) {
        const existing = this.tracesPerQuery[statsReportKey];
        if (existing) {
          return existing;
        }
        this.sizeEstimator.bytes += estimatedBytesForString(statsReportKey);
        for (const [typeName, referencedFieldsForType] of Object.entries(referencedFieldsByType)) {
          this.sizeEstimator.bytes += 2 + 2;
          if (referencedFieldsForType.isInterface) {
            this.sizeEstimator.bytes += 2;
          }
          this.sizeEstimator.bytes += estimatedBytesForString(typeName);
          for (const fieldName of referencedFieldsForType.fieldNames) {
            this.sizeEstimator.bytes += estimatedBytesForString(fieldName);
          }
        }
        return this.tracesPerQuery[statsReportKey] = new OurTracesAndStats(referencedFieldsByType);
      }
    };
    exports2.OurReport = OurReport;
    var OurTracesAndStats = class {
      constructor(referencedFieldsByType) {
        this.referencedFieldsByType = referencedFieldsByType;
        this.trace = [];
        this.statsWithContext = new StatsByContext();
        this.internalTracesContributingToStats = [];
      }
      ensureCountsAreIntegers() {
        this.statsWithContext.ensureCountsAreIntegers();
      }
    };
    var StatsByContext = class {
      constructor() {
        this.map = /* @__PURE__ */ Object.create(null);
      }
      toArray() {
        return Object.values(this.map);
      }
      ensureCountsAreIntegers() {
        for (const contextualizedStats of Object.values(this.map)) {
          contextualizedStats.ensureCountsAreIntegers();
        }
      }
      addTrace(trace, sizeEstimator) {
        this.getContextualizedStats(trace, sizeEstimator).addTrace(trace, sizeEstimator);
      }
      getContextualizedStats(trace, sizeEstimator) {
        const statsContext = {
          clientName: trace.clientName,
          clientVersion: trace.clientVersion
        };
        const statsContextKey = JSON.stringify(statsContext);
        const existing = this.map[statsContextKey];
        if (existing) {
          return existing;
        }
        sizeEstimator.bytes += 20 + estimatedBytesForString(trace.clientName) + estimatedBytesForString(trace.clientVersion);
        const contextualizedStats = new OurContextualizedStats(statsContext);
        this.map[statsContextKey] = contextualizedStats;
        return contextualizedStats;
      }
    };
    var OurContextualizedStats = class {
      constructor(context) {
        this.context = context;
        this.queryLatencyStats = new OurQueryLatencyStats();
        this.perTypeStat = /* @__PURE__ */ Object.create(null);
      }
      ensureCountsAreIntegers() {
        for (const typeStat of Object.values(this.perTypeStat)) {
          typeStat.ensureCountsAreIntegers();
        }
      }
      addTrace(trace, sizeEstimator) {
        var _a;
        const { fieldExecutionWeight } = trace;
        if (!fieldExecutionWeight) {
          this.queryLatencyStats.requestsWithoutFieldInstrumentation++;
        }
        this.queryLatencyStats.requestCount++;
        if (trace.fullQueryCacheHit) {
          this.queryLatencyStats.cacheLatencyCount.incrementDuration(trace.durationNs);
          this.queryLatencyStats.cacheHits++;
        } else {
          this.queryLatencyStats.latencyCount.incrementDuration(trace.durationNs);
        }
        if (!trace.fullQueryCacheHit && ((_a = trace.cachePolicy) === null || _a === void 0 ? void 0 : _a.maxAgeNs) != null) {
          switch (trace.cachePolicy.scope) {
            case apollo_reporting_protobuf_1.Trace.CachePolicy.Scope.PRIVATE:
              this.queryLatencyStats.privateCacheTtlCount.incrementDuration(trace.cachePolicy.maxAgeNs);
              break;
            case apollo_reporting_protobuf_1.Trace.CachePolicy.Scope.PUBLIC:
              this.queryLatencyStats.publicCacheTtlCount.incrementDuration(trace.cachePolicy.maxAgeNs);
              break;
          }
        }
        if (trace.persistedQueryHit) {
          this.queryLatencyStats.persistedQueryHits++;
        }
        if (trace.persistedQueryRegister) {
          this.queryLatencyStats.persistedQueryMisses++;
        }
        if (trace.forbiddenOperation) {
          this.queryLatencyStats.forbiddenOperationCount++;
        }
        if (trace.registeredOperation) {
          this.queryLatencyStats.registeredOperationCount++;
        }
        let hasError = false;
        const traceNodeStats = (node, path) => {
          var _a2, _b, _c, _d, _e;
          if ((_a2 = node.error) === null || _a2 === void 0 ? void 0 : _a2.length) {
            hasError = true;
            let currPathErrorStats = this.queryLatencyStats.rootErrorStats;
            path.toArray().forEach((subPath) => {
              currPathErrorStats = currPathErrorStats.getChild(subPath, sizeEstimator);
            });
            currPathErrorStats.requestsWithErrorsCount += 1;
            currPathErrorStats.errorsCount += node.error.length;
          }
          if (fieldExecutionWeight) {
            const fieldName = node.originalFieldName || node.responseName;
            if (node.parentType && fieldName && node.type && node.endTime != null && node.startTime != null && node.endTime >= node.startTime) {
              const typeStat = this.getTypeStat(node.parentType, sizeEstimator);
              const fieldStat = typeStat.getFieldStat(fieldName, node.type, sizeEstimator);
              fieldStat.errorsCount += (_c = (_b = node.error) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0;
              fieldStat.observedExecutionCount++;
              fieldStat.estimatedExecutionCount += fieldExecutionWeight;
              fieldStat.requestsWithErrorsCount += ((_e = (_d = node.error) === null || _d === void 0 ? void 0 : _d.length) !== null && _e !== void 0 ? _e : 0) > 0 ? 1 : 0;
              fieldStat.latencyCount.incrementDuration(node.endTime - node.startTime, fieldExecutionWeight);
            }
          }
          return false;
        };
        (0, iterateOverTrace_1.iterateOverTrace)(trace, traceNodeStats, true);
        if (hasError) {
          this.queryLatencyStats.requestsWithErrorsCount++;
        }
      }
      getTypeStat(parentType, sizeEstimator) {
        const existing = this.perTypeStat[parentType];
        if (existing) {
          return existing;
        }
        sizeEstimator.bytes += estimatedBytesForString(parentType);
        const typeStat = new OurTypeStat();
        this.perTypeStat[parentType] = typeStat;
        return typeStat;
      }
    };
    exports2.OurContextualizedStats = OurContextualizedStats;
    var OurQueryLatencyStats = class {
      constructor() {
        this.latencyCount = new durationHistogram_1.DurationHistogram();
        this.requestCount = 0;
        this.requestsWithoutFieldInstrumentation = 0;
        this.cacheHits = 0;
        this.persistedQueryHits = 0;
        this.persistedQueryMisses = 0;
        this.cacheLatencyCount = new durationHistogram_1.DurationHistogram();
        this.rootErrorStats = new OurPathErrorStats();
        this.requestsWithErrorsCount = 0;
        this.publicCacheTtlCount = new durationHistogram_1.DurationHistogram();
        this.privateCacheTtlCount = new durationHistogram_1.DurationHistogram();
        this.registeredOperationCount = 0;
        this.forbiddenOperationCount = 0;
      }
    };
    var OurPathErrorStats = class _OurPathErrorStats {
      constructor() {
        this.children = /* @__PURE__ */ Object.create(null);
        this.errorsCount = 0;
        this.requestsWithErrorsCount = 0;
      }
      getChild(subPath, sizeEstimator) {
        const existing = this.children[subPath];
        if (existing) {
          return existing;
        }
        const child = new _OurPathErrorStats();
        this.children[subPath] = child;
        sizeEstimator.bytes += estimatedBytesForString(subPath) + 4;
        return child;
      }
    };
    var OurTypeStat = class {
      constructor() {
        this.perFieldStat = /* @__PURE__ */ Object.create(null);
      }
      getFieldStat(fieldName, returnType, sizeEstimator) {
        const existing = this.perFieldStat[fieldName];
        if (existing) {
          return existing;
        }
        sizeEstimator.bytes += estimatedBytesForString(fieldName) + estimatedBytesForString(returnType) + 10;
        const fieldStat = new OurFieldStat(returnType);
        this.perFieldStat[fieldName] = fieldStat;
        return fieldStat;
      }
      ensureCountsAreIntegers() {
        for (const fieldStat of Object.values(this.perFieldStat)) {
          fieldStat.ensureCountsAreIntegers();
        }
      }
    };
    var OurFieldStat = class {
      constructor(returnType) {
        this.returnType = returnType;
        this.errorsCount = 0;
        this.observedExecutionCount = 0;
        this.estimatedExecutionCount = 0;
        this.requestsWithErrorsCount = 0;
        this.latencyCount = new durationHistogram_1.DurationHistogram();
      }
      ensureCountsAreIntegers() {
        this.estimatedExecutionCount = Math.floor(this.estimatedExecutionCount);
      }
    };
    function estimatedBytesForString(s) {
      return 2 + Buffer.byteLength(s);
    }
  }
});

// ../../../node_modules/apollo-server-core/dist/plugin/usageReporting/defaultSendOperationsAsTrace.js
var require_defaultSendOperationsAsTrace = __commonJS({
  "../../../node_modules/apollo-server-core/dist/plugin/usageReporting/defaultSendOperationsAsTrace.js"(exports2) {
    "use strict";
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defaultSendOperationsAsTrace = void 0;
    var lru_cache_1 = __importDefault2(require_lru_cache2());
    var iterateOverTrace_1 = require_iterateOverTrace();
    var durationHistogram_1 = require_durationHistogram();
    function defaultSendOperationsAsTrace() {
      const cache = new lru_cache_1.default({
        max: Math.pow(2, 20),
        length: (_val, key) => {
          return key && Buffer.byteLength(key) || 0;
        }
      });
      return (trace, statsReportKey) => {
        var _a;
        const endTimeSeconds = (_a = trace.endTime) === null || _a === void 0 ? void 0 : _a.seconds;
        if (endTimeSeconds == null) {
          throw Error("programming error: endTime not set on trace");
        }
        const hasErrors = traceHasErrors(trace);
        const cacheKey = JSON.stringify([
          statsReportKey,
          durationHistogram_1.DurationHistogram.durationToBucket(trace.durationNs),
          Math.floor(endTimeSeconds / 60),
          hasErrors ? Math.floor(endTimeSeconds / 5) : ""
        ]);
        if (cache.get(cacheKey)) {
          return false;
        }
        cache.set(cacheKey, true);
        return true;
      };
    }
    exports2.defaultSendOperationsAsTrace = defaultSendOperationsAsTrace;
    function traceHasErrors(trace) {
      let hasErrors = false;
      function traceNodeStats(node) {
        var _a, _b;
        if (((_b = (_a = node.error) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) > 0) {
          hasErrors = true;
        }
        return hasErrors;
      }
      (0, iterateOverTrace_1.iterateOverTrace)(trace, traceNodeStats, false);
      return hasErrors;
    }
  }
});

// ../../../node_modules/apollo-server-core/dist/plugin/usageReporting/plugin.js
var require_plugin = __commonJS({
  "../../../node_modules/apollo-server-core/dist/plugin/usageReporting/plugin.js"(exports2) {
    "use strict";
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApolloServerPluginUsageReportingDisabled = exports2.makeHTTPRequestHeaders = exports2.ApolloServerPluginUsageReporting = void 0;
    var os_1 = __importDefault2(require_os());
    var util_1 = require_util();
    var zlib_1 = require_zlib();
    var async_retry_1 = __importDefault2(require_lib2());
    var apollo_reporting_protobuf_1 = require_generated();
    var apollo_server_env_1 = require_index_browser();
    var node_abort_controller_1 = require_browser();
    var apollo_server_types_1 = require_dist2();
    var operationDerivedDataCache_1 = require_operationDerivedDataCache();
    var utils_usagereporting_1 = require_dist9();
    var traceTreeBuilder_1 = require_traceTreeBuilder();
    var traceDetails_1 = require_traceDetails();
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var schemaReporting_1 = require_schemaReporting();
    var stats_1 = require_stats();
    var defaultSendOperationsAsTrace_1 = require_defaultSendOperationsAsTrace();
    var utils_usagereporting_2 = require_dist9();
    var gzipPromise = (0, util_1.promisify)(zlib_1.gzip);
    var reportHeaderDefaults = {
      hostname: os_1.default.hostname(),
      agentVersion: `apollo-server-core@${require_package().version}`,
      runtimeVersion: `node ${process.version}`,
      uname: `${os_1.default.platform()}, ${os_1.default.type()}, ${os_1.default.release()}, ${os_1.default.arch()})`
    };
    function ApolloServerPluginUsageReporting(options = /* @__PURE__ */ Object.create(null)) {
      const fieldLevelInstrumentationOption = options.fieldLevelInstrumentation;
      const fieldLevelInstrumentation = typeof fieldLevelInstrumentationOption === "number" ? async () => Math.random() < fieldLevelInstrumentationOption ? 1 / fieldLevelInstrumentationOption : 0 : fieldLevelInstrumentationOption ? fieldLevelInstrumentationOption : async () => true;
      let requestDidStartHandler;
      return {
        __internal_plugin_id__() {
          return "UsageReporting";
        },
        async requestDidStart(requestContext) {
          if (!requestDidStartHandler) {
            throw Error("The usage reporting plugin has been asked to handle a request before the server has started. See https://github.com/apollographql/apollo-server/issues/4588 for more details.");
          }
          return requestDidStartHandler(requestContext);
        },
        async serverWillStart({ logger: serverLogger, apollo, serverlessFramework }) {
          var _a, _b, _c, _d;
          const logger = (_a = options.logger) !== null && _a !== void 0 ? _a : serverLogger;
          const { key, graphRef } = apollo;
          if (!(key && graphRef)) {
            throw new Error("You've enabled usage reporting via ApolloServerPluginUsageReporting, but you also need to provide your Apollo API key and graph ref, via the APOLLO_KEY/APOLLO_GRAPH_REF environment variables or via `new ApolloServer({apollo: {key, graphRef})`.");
          }
          logger.info(`Apollo usage reporting starting! See your graph at https://studio.apollographql.com/graph/${encodeURI(graphRef)}/`);
          const sendReportsImmediately = (_b = options.sendReportsImmediately) !== null && _b !== void 0 ? _b : serverlessFramework;
          let operationDerivedDataCache = null;
          const reportByExecutableSchemaId = /* @__PURE__ */ new Map();
          const getReportWhichMustBeUsedImmediately = (executableSchemaId) => {
            const existing = reportByExecutableSchemaId.get(executableSchemaId);
            if (existing) {
              return existing;
            }
            const report = new stats_1.OurReport(new apollo_reporting_protobuf_1.ReportHeader({
              ...reportHeaderDefaults,
              executableSchemaId,
              graphRef
            }));
            reportByExecutableSchemaId.set(executableSchemaId, report);
            return report;
          };
          const getAndDeleteReport = (executableSchemaId) => {
            const report = reportByExecutableSchemaId.get(executableSchemaId);
            if (report) {
              reportByExecutableSchemaId.delete(executableSchemaId);
              return report;
            }
            return null;
          };
          const overriddenExecutableSchemaId = options.overrideReportedSchema ? (0, schemaReporting_1.computeCoreSchemaHash)(options.overrideReportedSchema) : void 0;
          let lastSeenExecutableSchemaToId;
          let reportTimer;
          if (!sendReportsImmediately) {
            reportTimer = setInterval(() => sendAllReportsAndReportErrors(), options.reportIntervalMs || 10 * 1e3);
          }
          let graphMightSupportTraces = true;
          const sendOperationAsTrace = (_c = options.experimental_sendOperationAsTrace) !== null && _c !== void 0 ? _c : (0, defaultSendOperationsAsTrace_1.defaultSendOperationsAsTrace)();
          const includeTracesContributingToStats = (_d = options.internal_includeTracesContributingToStats) !== null && _d !== void 0 ? _d : false;
          let stopped = false;
          function executableSchemaIdForSchema(schema) {
            if ((lastSeenExecutableSchemaToId === null || lastSeenExecutableSchemaToId === void 0 ? void 0 : lastSeenExecutableSchemaToId.executableSchema) === schema) {
              return lastSeenExecutableSchemaToId.executableSchemaId;
            }
            const id = (0, schemaReporting_1.computeCoreSchemaHash)((0, graphql_1.printSchema)(schema));
            lastSeenExecutableSchemaToId = {
              executableSchema: schema,
              executableSchemaId: id
            };
            return id;
          }
          async function sendAllReportsAndReportErrors() {
            await Promise.all([...reportByExecutableSchemaId.keys()].map((executableSchemaId) => sendReportAndReportErrors(executableSchemaId)));
          }
          async function sendReportAndReportErrors(executableSchemaId) {
            return sendReport(executableSchemaId).catch((err) => {
              if (options.reportErrorFunction) {
                options.reportErrorFunction(err);
              } else {
                logger.error(err.message);
              }
            });
          }
          const sendReport = async (executableSchemaId) => {
            var _a2, _b2;
            let report = getAndDeleteReport(executableSchemaId);
            if (!report || Object.keys(report.tracesPerQuery).length === 0 && report.operationCount === 0) {
              return;
            }
            report.endTime = (0, traceTreeBuilder_1.dateToProtoTimestamp)(/* @__PURE__ */ new Date());
            report.ensureCountsAreIntegers();
            const protobufError = apollo_reporting_protobuf_1.Report.verify(report);
            if (protobufError) {
              throw new Error(`Error verifying report: ${protobufError}`);
            }
            let message = apollo_reporting_protobuf_1.Report.encode(report).finish();
            report = null;
            if (options.debugPrintReports) {
              const decodedReport = apollo_reporting_protobuf_1.Report.decode(message);
              logger.warn(`Apollo usage report: ${JSON.stringify(decodedReport.toJSON())}`);
            }
            const compressed = await gzipPromise(message);
            message = null;
            const fetcher = (_a2 = options.fetcher) !== null && _a2 !== void 0 ? _a2 : apollo_server_env_1.fetch;
            const response = await (0, async_retry_1.default)(async () => {
              var _a3;
              const controller = new node_abort_controller_1.AbortController();
              const abortTimeout = setTimeout(() => {
                controller.abort();
              }, (_a3 = options.requestTimeoutMs) !== null && _a3 !== void 0 ? _a3 : 3e4);
              let curResponse;
              try {
                const requestInit = {
                  method: "POST",
                  headers: {
                    "user-agent": "ApolloServerPluginUsageReporting",
                    "x-api-key": key,
                    "content-encoding": "gzip",
                    accept: "application/json"
                  },
                  body: compressed,
                  agent: options.requestAgent
                };
                requestInit.signal = controller.signal;
                curResponse = await fetcher((options.endpointUrl || "https://usage-reporting.api.apollographql.com") + "/api/ingress/traces", requestInit);
              } finally {
                clearTimeout(abortTimeout);
              }
              if (curResponse.status >= 500 && curResponse.status < 600) {
                throw new Error(`HTTP status ${curResponse.status}, ${await curResponse.text() || "(no body)"}`);
              } else {
                return curResponse;
              }
            }, {
              retries: (options.maxAttempts || 5) - 1,
              minTimeout: options.minimumRetryDelayMs || 100,
              factor: 2
            }).catch((err) => {
              throw new Error(`Error sending report to Apollo servers: ${err.message}`);
            });
            if (response.status < 200 || response.status >= 300) {
              throw new Error(`Error sending report to Apollo servers: HTTP status ${response.status}, ${await response.text() || "(no body)"}`);
            }
            if (graphMightSupportTraces && response.status === 200 && ((_b2 = response.headers.get("content-type")) === null || _b2 === void 0 ? void 0 : _b2.match(/^\s*application\/json\s*(?:;|$)/i))) {
              const body = await response.text();
              let parsedBody;
              try {
                parsedBody = JSON.parse(body);
              } catch (e) {
                throw new Error(`Error parsing response from Apollo servers: ${e}`);
              }
              if (parsedBody.tracesIgnored === true) {
                logger.debug("This graph's organization does not have access to traces; sending all subsequent operations as traces.");
                graphMightSupportTraces = false;
              }
            }
            if (options.debugPrintReports) {
              logger.warn(`Apollo usage report: status ${response.status}`);
            }
          };
          requestDidStartHandler = ({ logger: requestLogger, metrics, schema, request: { http, variables } }) => {
            var _a2;
            const logger2 = (_a2 = requestLogger !== null && requestLogger !== void 0 ? requestLogger : options.logger) !== null && _a2 !== void 0 ? _a2 : serverLogger;
            const treeBuilder = new traceTreeBuilder_1.TraceTreeBuilder({
              rewriteError: options.rewriteError,
              logger: logger2
            });
            treeBuilder.startTiming();
            metrics.startHrTime = treeBuilder.startHrTime;
            let graphqlValidationFailure = false;
            let graphqlUnknownOperationName = false;
            let includeOperationInUsageReporting = null;
            if (http) {
              treeBuilder.trace.http = new apollo_reporting_protobuf_1.Trace.HTTP({
                method: apollo_reporting_protobuf_1.Trace.HTTP.Method[http.method] || apollo_reporting_protobuf_1.Trace.HTTP.Method.UNKNOWN
              });
              if (options.sendHeaders) {
                makeHTTPRequestHeaders(treeBuilder.trace.http, http.headers, options.sendHeaders);
              }
            }
            async function maybeCallIncludeRequestHook(requestContext) {
              if (includeOperationInUsageReporting !== null)
                return;
              if (typeof options.includeRequest !== "function") {
                includeOperationInUsageReporting = true;
                return;
              }
              includeOperationInUsageReporting = await options.includeRequest(requestContext);
              if (typeof includeOperationInUsageReporting !== "boolean") {
                logger2.warn("The 'includeRequest' async predicate function must return a boolean value.");
                includeOperationInUsageReporting = true;
              }
            }
            let didResolveSource = false;
            return {
              async didResolveSource(requestContext) {
                didResolveSource = true;
                if (metrics.persistedQueryHit) {
                  treeBuilder.trace.persistedQueryHit = true;
                }
                if (metrics.persistedQueryRegister) {
                  treeBuilder.trace.persistedQueryRegister = true;
                }
                if (variables) {
                  treeBuilder.trace.details = (0, traceDetails_1.makeTraceDetails)(variables, options.sendVariableValues, requestContext.source);
                }
                const clientInfo = (options.generateClientInfo || defaultGenerateClientInfo)(requestContext);
                if (clientInfo) {
                  const { clientName, clientVersion } = clientInfo;
                  treeBuilder.trace.clientVersion = clientVersion || "";
                  treeBuilder.trace.clientName = clientName || "";
                }
              },
              async validationDidStart() {
                return async (validationErrors) => {
                  graphqlValidationFailure = validationErrors ? validationErrors.length !== 0 : false;
                };
              },
              async didResolveOperation(requestContext) {
                graphqlUnknownOperationName = requestContext.operation === void 0;
                await maybeCallIncludeRequestHook(requestContext);
                if (includeOperationInUsageReporting && !graphqlUnknownOperationName) {
                  if (metrics.captureTraces === void 0) {
                    const rawWeight = await fieldLevelInstrumentation(requestContext);
                    treeBuilder.trace.fieldExecutionWeight = typeof rawWeight === "number" ? rawWeight : rawWeight ? 1 : 0;
                    metrics.captureTraces = !!treeBuilder.trace.fieldExecutionWeight;
                  }
                }
              },
              async executionDidStart() {
                if (!metrics.captureTraces)
                  return;
                return {
                  willResolveField({ info }) {
                    return treeBuilder.willResolveField(info);
                  }
                };
              },
              async willSendResponse(requestContext) {
                if (!didResolveSource)
                  return;
                if (requestContext.errors) {
                  treeBuilder.didEncounterErrors(requestContext.errors);
                }
                const resolvedOperation = !!requestContext.operation;
                await maybeCallIncludeRequestHook(requestContext);
                treeBuilder.stopTiming();
                const executableSchemaId = overriddenExecutableSchemaId !== null && overriddenExecutableSchemaId !== void 0 ? overriddenExecutableSchemaId : executableSchemaIdForSchema(schema);
                if (includeOperationInUsageReporting === false) {
                  if (resolvedOperation)
                    getReportWhichMustBeUsedImmediately(executableSchemaId).operationCount++;
                  return;
                }
                treeBuilder.trace.fullQueryCacheHit = !!metrics.responseCacheHit;
                treeBuilder.trace.forbiddenOperation = !!metrics.forbiddenOperation;
                treeBuilder.trace.registeredOperation = !!metrics.registeredOperation;
                const policyIfCacheable = requestContext.overallCachePolicy.policyIfCacheable();
                if (policyIfCacheable) {
                  treeBuilder.trace.cachePolicy = new apollo_reporting_protobuf_1.Trace.CachePolicy({
                    scope: policyIfCacheable.scope === apollo_server_types_1.CacheScope.Private ? apollo_reporting_protobuf_1.Trace.CachePolicy.Scope.PRIVATE : policyIfCacheable.scope === apollo_server_types_1.CacheScope.Public ? apollo_reporting_protobuf_1.Trace.CachePolicy.Scope.PUBLIC : apollo_reporting_protobuf_1.Trace.CachePolicy.Scope.UNKNOWN,
                    maxAgeNs: policyIfCacheable.maxAge * 1e9
                  });
                }
                if (metrics.queryPlanTrace) {
                  treeBuilder.trace.queryPlan = metrics.queryPlanTrace;
                }
                addTrace().catch(logger2.error);
                async function addTrace() {
                  if (stopped) {
                    return;
                  }
                  await new Promise((res) => setImmediate(res));
                  const executableSchemaId2 = overriddenExecutableSchemaId !== null && overriddenExecutableSchemaId !== void 0 ? overriddenExecutableSchemaId : executableSchemaIdForSchema(schema);
                  const { trace } = treeBuilder;
                  let statsReportKey = void 0;
                  let referencedFieldsByType;
                  if (!requestContext.document) {
                    statsReportKey = `## GraphQLParseFailure
`;
                  } else if (graphqlValidationFailure) {
                    statsReportKey = `## GraphQLValidationFailure
`;
                  } else if (graphqlUnknownOperationName) {
                    statsReportKey = `## GraphQLUnknownOperationName
`;
                  }
                  const isExecutable = statsReportKey === void 0;
                  if (statsReportKey) {
                    if (options.sendUnexecutableOperationDocuments) {
                      trace.unexecutedOperationBody = requestContext.source;
                      trace.unexecutedOperationName = requestContext.request.operationName || "";
                    }
                    referencedFieldsByType = /* @__PURE__ */ Object.create(null);
                  } else {
                    const operationDerivedData = getOperationDerivedData();
                    statsReportKey = `# ${requestContext.operationName || "-"}
${operationDerivedData.signature}`;
                    referencedFieldsByType = operationDerivedData.referencedFieldsByType;
                  }
                  const protobufError = apollo_reporting_protobuf_1.Trace.verify(trace);
                  if (protobufError) {
                    throw new Error(`Error encoding trace: ${protobufError}`);
                  }
                  if (resolvedOperation) {
                    getReportWhichMustBeUsedImmediately(executableSchemaId2).operationCount++;
                  }
                  getReportWhichMustBeUsedImmediately(executableSchemaId2).addTrace({
                    statsReportKey,
                    trace,
                    asTrace: graphMightSupportTraces && (!isExecutable || !!metrics.captureTraces) && sendOperationAsTrace(trace, statsReportKey),
                    includeTracesContributingToStats,
                    referencedFieldsByType
                  });
                  if (sendReportsImmediately || getReportWhichMustBeUsedImmediately(executableSchemaId2).sizeEstimator.bytes >= (options.maxUncompressedReportSize || 4 * 1024 * 1024)) {
                    await sendReportAndReportErrors(executableSchemaId2);
                  }
                }
                function getOperationDerivedData() {
                  var _a3;
                  if (!requestContext.document) {
                    throw new Error("No document?");
                  }
                  const cacheKey = (0, operationDerivedDataCache_1.operationDerivedDataCacheKey)(requestContext.queryHash, requestContext.operationName || "");
                  if (!operationDerivedDataCache || operationDerivedDataCache.forSchema !== schema) {
                    operationDerivedDataCache = {
                      forSchema: schema,
                      cache: (0, operationDerivedDataCache_1.createOperationDerivedDataCache)({ logger: logger2 })
                    };
                  }
                  const cachedOperationDerivedData = operationDerivedDataCache.cache.get(cacheKey);
                  if (cachedOperationDerivedData) {
                    return cachedOperationDerivedData;
                  }
                  const generatedSignature = (options.calculateSignature || utils_usagereporting_1.usageReportingSignature)(requestContext.document, requestContext.operationName || "");
                  const generatedOperationDerivedData = {
                    signature: generatedSignature,
                    referencedFieldsByType: (0, utils_usagereporting_2.calculateReferencedFieldsByType)({
                      document: requestContext.document,
                      schema,
                      resolvedOperationName: (_a3 = requestContext.operationName) !== null && _a3 !== void 0 ? _a3 : null
                    })
                  };
                  operationDerivedDataCache.cache.set(cacheKey, generatedOperationDerivedData);
                  return generatedOperationDerivedData;
                }
              }
            };
          };
          return {
            async serverWillStop() {
              if (reportTimer) {
                clearInterval(reportTimer);
                reportTimer = void 0;
              }
              stopped = true;
              await sendAllReportsAndReportErrors();
            }
          };
        }
      };
    }
    exports2.ApolloServerPluginUsageReporting = ApolloServerPluginUsageReporting;
    function makeHTTPRequestHeaders(http, headers, sendHeaders) {
      if (!sendHeaders || "none" in sendHeaders && sendHeaders.none || "all" in sendHeaders && !sendHeaders.all) {
        return;
      }
      for (const [key, value] of headers) {
        const lowerCaseKey = key.toLowerCase();
        if ("exceptNames" in sendHeaders && sendHeaders.exceptNames.some((exceptHeader) => {
          return exceptHeader.toLowerCase() === lowerCaseKey;
        }) || "onlyNames" in sendHeaders && !sendHeaders.onlyNames.some((header) => {
          return header.toLowerCase() === lowerCaseKey;
        })) {
          continue;
        }
        switch (key) {
          case "authorization":
          case "cookie":
          case "set-cookie":
            break;
          default:
            http.requestHeaders[key] = new apollo_reporting_protobuf_1.Trace.HTTP.Values({
              value: [value]
            });
        }
      }
    }
    exports2.makeHTTPRequestHeaders = makeHTTPRequestHeaders;
    function defaultGenerateClientInfo({ request }) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j;
      const clientNameHeaderKey = "apollographql-client-name";
      const clientVersionHeaderKey = "apollographql-client-version";
      if (((_b = (_a = request.http) === null || _a === void 0 ? void 0 : _a.headers) === null || _b === void 0 ? void 0 : _b.get(clientNameHeaderKey)) || ((_d = (_c = request.http) === null || _c === void 0 ? void 0 : _c.headers) === null || _d === void 0 ? void 0 : _d.get(clientVersionHeaderKey))) {
        return {
          clientName: (_f = (_e = request.http) === null || _e === void 0 ? void 0 : _e.headers) === null || _f === void 0 ? void 0 : _f.get(clientNameHeaderKey),
          clientVersion: (_h = (_g = request.http) === null || _g === void 0 ? void 0 : _g.headers) === null || _h === void 0 ? void 0 : _h.get(clientVersionHeaderKey)
        };
      } else if ((_j = request.extensions) === null || _j === void 0 ? void 0 : _j.clientInfo) {
        return request.extensions.clientInfo;
      } else {
        return {};
      }
    }
    function ApolloServerPluginUsageReportingDisabled() {
      return {
        __internal_plugin_id__() {
          return "UsageReporting";
        }
      };
    }
    exports2.ApolloServerPluginUsageReportingDisabled = ApolloServerPluginUsageReportingDisabled;
  }
});

// ../../../node_modules/apollo-server-core/dist/plugin/usageReporting/options.js
var require_options = __commonJS({
  "../../../node_modules/apollo-server-core/dist/plugin/usageReporting/options.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../../node_modules/apollo-server-core/dist/plugin/usageReporting/index.js
var require_usageReporting = __commonJS({
  "../../../node_modules/apollo-server-core/dist/plugin/usageReporting/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApolloServerPluginUsageReportingDisabled = exports2.ApolloServerPluginUsageReporting = void 0;
    var plugin_1 = require_plugin();
    Object.defineProperty(exports2, "ApolloServerPluginUsageReporting", { enumerable: true, get: function() {
      return plugin_1.ApolloServerPluginUsageReporting;
    } });
    Object.defineProperty(exports2, "ApolloServerPluginUsageReportingDisabled", { enumerable: true, get: function() {
      return plugin_1.ApolloServerPluginUsageReportingDisabled;
    } });
    var options_1 = require_options();
  }
});

// ../../../node_modules/apollo-server-core/dist/plugin/inlineTrace/index.js
var require_inlineTrace = __commonJS({
  "../../../node_modules/apollo-server-core/dist/plugin/inlineTrace/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApolloServerPluginInlineTraceDisabled = exports2.ApolloServerPluginInlineTrace = void 0;
    var apollo_reporting_protobuf_1 = require_generated();
    var traceTreeBuilder_1 = require_traceTreeBuilder();
    var schemaIsFederated_1 = require_schemaIsFederated();
    function ApolloServerPluginInlineTrace(options = /* @__PURE__ */ Object.create(null)) {
      let enabled = options.__onlyIfSchemaIsFederated ? null : true;
      return {
        __internal_plugin_id__() {
          return "InlineTrace";
        },
        async serverWillStart({ schema, logger }) {
          if (enabled === null) {
            enabled = (0, schemaIsFederated_1.schemaIsFederated)(schema);
            if (enabled) {
              logger.info("Enabling inline tracing for this federated service. To disable, use ApolloServerPluginInlineTraceDisabled.");
            }
          }
        },
        async requestDidStart({ request: { http }, metrics }) {
          if (!enabled) {
            return;
          }
          const treeBuilder = new traceTreeBuilder_1.TraceTreeBuilder({
            rewriteError: options.rewriteError
          });
          if ((http === null || http === void 0 ? void 0 : http.headers.get("apollo-federation-include-trace")) !== "ftv1") {
            return;
          }
          if (metrics.captureTraces === false) {
            return;
          }
          metrics.captureTraces = true;
          treeBuilder.startTiming();
          return {
            async executionDidStart() {
              return {
                willResolveField({ info }) {
                  return treeBuilder.willResolveField(info);
                }
              };
            },
            async didEncounterErrors({ errors }) {
              treeBuilder.didEncounterErrors(errors);
            },
            async willSendResponse({ response }) {
              treeBuilder.stopTiming();
              if (metrics.queryPlanTrace) {
                treeBuilder.trace.queryPlan = metrics.queryPlanTrace;
              }
              const encodedUint8Array = apollo_reporting_protobuf_1.Trace.encode(treeBuilder.trace).finish();
              const encodedBuffer = Buffer.from(encodedUint8Array, encodedUint8Array.byteOffset, encodedUint8Array.byteLength);
              const extensions = response.extensions || (response.extensions = /* @__PURE__ */ Object.create(null));
              if (typeof extensions.ftv1 !== "undefined") {
                throw new Error("The `ftv1` extension was already present.");
              }
              extensions.ftv1 = encodedBuffer.toString("base64");
            }
          };
        }
      };
    }
    exports2.ApolloServerPluginInlineTrace = ApolloServerPluginInlineTrace;
    function ApolloServerPluginInlineTraceDisabled() {
      return {
        __internal_plugin_id__() {
          return "InlineTrace";
        }
      };
    }
    exports2.ApolloServerPluginInlineTraceDisabled = ApolloServerPluginInlineTraceDisabled;
  }
});

// ../../../node_modules/apollo-server-core/dist/plugin/cacheControl/index.js
var require_cacheControl = __commonJS({
  "../../../node_modules/apollo-server-core/dist/plugin/cacheControl/index.js"(exports2) {
    "use strict";
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApolloServerPluginCacheControlDisabled = exports2.ApolloServerPluginCacheControl = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var cachePolicy_1 = require_cachePolicy();
    var lru_cache_1 = __importDefault2(require_lru_cache2());
    function ApolloServerPluginCacheControl(options = /* @__PURE__ */ Object.create(null)) {
      const typeAnnotationCache = new lru_cache_1.default();
      const fieldAnnotationCache = new lru_cache_1.default();
      function memoizedCacheAnnotationFromType(t) {
        const existing = typeAnnotationCache.get(t);
        if (existing) {
          return existing;
        }
        const annotation = cacheAnnotationFromType(t);
        typeAnnotationCache.set(t, annotation);
        return annotation;
      }
      function memoizedCacheAnnotationFromField(field) {
        const existing = fieldAnnotationCache.get(field);
        if (existing) {
          return existing;
        }
        const annotation = cacheAnnotationFromField(field);
        fieldAnnotationCache.set(field, annotation);
        return annotation;
      }
      return {
        __internal_plugin_id__() {
          return "CacheControl";
        },
        async serverWillStart({ schema }) {
          typeAnnotationCache.max = Object.values(schema.getTypeMap()).filter(graphql_1.isCompositeType).length;
          fieldAnnotationCache.max = Object.values(schema.getTypeMap()).filter(graphql_1.isObjectType).flatMap((t) => Object.values(t.getFields())).length + Object.values(schema.getTypeMap()).filter(graphql_1.isInterfaceType).flatMap((t) => Object.values(t.getFields())).length;
          return void 0;
        },
        async requestDidStart(requestContext) {
          var _a, _b;
          const defaultMaxAge = (_a = options.defaultMaxAge) !== null && _a !== void 0 ? _a : 0;
          const calculateHttpHeaders = (_b = options.calculateHttpHeaders) !== null && _b !== void 0 ? _b : true;
          const { __testing__cacheHints } = options;
          return {
            async executionDidStart() {
              if (isRestricted(requestContext.overallCachePolicy)) {
                const fakeFieldPolicy = (0, cachePolicy_1.newCachePolicy)();
                return {
                  willResolveField({ info }) {
                    info.cacheControl = {
                      setCacheHint: (dynamicHint) => {
                        fakeFieldPolicy.replace(dynamicHint);
                      },
                      cacheHint: fakeFieldPolicy,
                      cacheHintFromType: memoizedCacheAnnotationFromType
                    };
                  }
                };
              }
              return {
                willResolveField({ info }) {
                  const fieldPolicy = (0, cachePolicy_1.newCachePolicy)();
                  let inheritMaxAge = false;
                  const targetType = (0, graphql_1.getNamedType)(info.returnType);
                  if ((0, graphql_1.isCompositeType)(targetType)) {
                    const typeAnnotation = memoizedCacheAnnotationFromType(targetType);
                    fieldPolicy.replace(typeAnnotation);
                    inheritMaxAge = !!typeAnnotation.inheritMaxAge;
                  }
                  const fieldAnnotation = memoizedCacheAnnotationFromField(info.parentType.getFields()[info.fieldName]);
                  if (fieldAnnotation.inheritMaxAge && fieldPolicy.maxAge === void 0) {
                    inheritMaxAge = true;
                    if (fieldAnnotation.scope) {
                      fieldPolicy.replace({ scope: fieldAnnotation.scope });
                    }
                  } else {
                    fieldPolicy.replace(fieldAnnotation);
                  }
                  info.cacheControl = {
                    setCacheHint: (dynamicHint) => {
                      fieldPolicy.replace(dynamicHint);
                    },
                    cacheHint: fieldPolicy,
                    cacheHintFromType: memoizedCacheAnnotationFromType
                  };
                  return () => {
                    if (fieldPolicy.maxAge === void 0 && ((0, graphql_1.isCompositeType)(targetType) && !inheritMaxAge || !info.path.prev)) {
                      fieldPolicy.restrict({ maxAge: defaultMaxAge });
                    }
                    if (__testing__cacheHints && isRestricted(fieldPolicy)) {
                      const path = (0, graphql_1.responsePathAsArray)(info.path).join(".");
                      if (__testing__cacheHints.has(path)) {
                        throw Error("shouldn't happen: addHint should only be called once per path");
                      }
                      __testing__cacheHints.set(path, {
                        maxAge: fieldPolicy.maxAge,
                        scope: fieldPolicy.scope
                      });
                    }
                    requestContext.overallCachePolicy.restrict(fieldPolicy);
                  };
                }
              };
            },
            async willSendResponse(requestContext2) {
              const { response, overallCachePolicy, requestIsBatched } = requestContext2;
              const policyIfCacheable = overallCachePolicy.policyIfCacheable();
              if (calculateHttpHeaders && policyIfCacheable && !response.errors && response.http && !requestIsBatched) {
                response.http.headers.set("Cache-Control", `max-age=${policyIfCacheable.maxAge}, ${policyIfCacheable.scope.toLowerCase()}`);
              }
            }
          };
        }
      };
    }
    exports2.ApolloServerPluginCacheControl = ApolloServerPluginCacheControl;
    function cacheAnnotationFromDirectives(directives) {
      var _a, _b, _c;
      if (!directives)
        return void 0;
      const cacheControlDirective = directives.find((directive) => directive.name.value === "cacheControl");
      if (!cacheControlDirective)
        return void 0;
      if (!cacheControlDirective.arguments)
        return void 0;
      const maxAgeArgument = cacheControlDirective.arguments.find((argument) => argument.name.value === "maxAge");
      const scopeArgument = cacheControlDirective.arguments.find((argument) => argument.name.value === "scope");
      const inheritMaxAgeArgument = cacheControlDirective.arguments.find((argument) => argument.name.value === "inheritMaxAge");
      const scope = ((_a = scopeArgument === null || scopeArgument === void 0 ? void 0 : scopeArgument.value) === null || _a === void 0 ? void 0 : _a.kind) === "EnumValue" ? scopeArgument.value.value : void 0;
      if (((_b = inheritMaxAgeArgument === null || inheritMaxAgeArgument === void 0 ? void 0 : inheritMaxAgeArgument.value) === null || _b === void 0 ? void 0 : _b.kind) === "BooleanValue" && inheritMaxAgeArgument.value.value) {
        return { inheritMaxAge: true, scope };
      }
      return {
        maxAge: ((_c = maxAgeArgument === null || maxAgeArgument === void 0 ? void 0 : maxAgeArgument.value) === null || _c === void 0 ? void 0 : _c.kind) === "IntValue" ? parseInt(maxAgeArgument.value.value) : void 0,
        scope
      };
    }
    function cacheAnnotationFromType(t) {
      if (t.astNode) {
        const hint = cacheAnnotationFromDirectives(t.astNode.directives);
        if (hint) {
          return hint;
        }
      }
      if (t.extensionASTNodes) {
        for (const node of t.extensionASTNodes) {
          const hint = cacheAnnotationFromDirectives(node.directives);
          if (hint) {
            return hint;
          }
        }
      }
      return {};
    }
    function cacheAnnotationFromField(field) {
      if (field.astNode) {
        const hint = cacheAnnotationFromDirectives(field.astNode.directives);
        if (hint) {
          return hint;
        }
      }
      return {};
    }
    function isRestricted(hint) {
      return hint.maxAge !== void 0 || hint.scope !== void 0;
    }
    function ApolloServerPluginCacheControlDisabled() {
      return {
        __internal_plugin_id__() {
          return "CacheControl";
        }
      };
    }
    exports2.ApolloServerPluginCacheControlDisabled = ApolloServerPluginCacheControlDisabled;
  }
});

// browser-external:https
var require_https = __commonJS({
  "browser-external:https"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "https" has been externalized for browser compatibility. Cannot access "https.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// ../../../node_modules/apollo-server-core/dist/plugin/drainHttpServer/stoppable.js
var require_stoppable = __commonJS({
  "../../../node_modules/apollo-server-core/dist/plugin/drainHttpServer/stoppable.js"(exports2) {
    "use strict";
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Stopper = void 0;
    var https_1 = __importDefault2(require_https());
    var Stopper = class {
      constructor(server) {
        this.server = server;
        this.requestCountPerSocket = /* @__PURE__ */ new Map();
        this.stopped = false;
        server.on(server instanceof https_1.default.Server ? "secureConnection" : "connection", (socket) => {
          this.requestCountPerSocket.set(socket, 0);
          socket.once("close", () => this.requestCountPerSocket.delete(socket));
        });
        server.on("request", (req, res) => {
          var _a;
          this.requestCountPerSocket.set(req.socket, ((_a = this.requestCountPerSocket.get(req.socket)) !== null && _a !== void 0 ? _a : 0) + 1);
          res.once("finish", () => {
            var _a2;
            const pending = ((_a2 = this.requestCountPerSocket.get(req.socket)) !== null && _a2 !== void 0 ? _a2 : 0) - 1;
            this.requestCountPerSocket.set(req.socket, pending);
            if (this.stopped && pending === 0) {
              req.socket.end();
            }
          });
        });
      }
      async stop(stopGracePeriodMillis = Infinity) {
        let gracefully = true;
        await new Promise((resolve) => setImmediate(resolve));
        this.stopped = true;
        let timeout = null;
        if (stopGracePeriodMillis < Infinity) {
          timeout = setTimeout(() => {
            gracefully = false;
            this.requestCountPerSocket.forEach((_, socket) => socket.end());
            setImmediate(() => {
              this.requestCountPerSocket.forEach((_, socket) => socket.destroy());
            });
          }, stopGracePeriodMillis);
        }
        const closePromise = new Promise((resolve) => this.server.close(() => {
          if (timeout) {
            clearTimeout(timeout);
            timeout = null;
          }
          resolve();
        }));
        this.requestCountPerSocket.forEach((requests, socket) => {
          if (requests === 0)
            socket.end();
        });
        await closePromise;
        return gracefully;
      }
    };
    exports2.Stopper = Stopper;
  }
});

// ../../../node_modules/apollo-server-core/dist/plugin/drainHttpServer/index.js
var require_drainHttpServer = __commonJS({
  "../../../node_modules/apollo-server-core/dist/plugin/drainHttpServer/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApolloServerPluginDrainHttpServer = void 0;
    var stoppable_1 = require_stoppable();
    function ApolloServerPluginDrainHttpServer(options) {
      const stopper = new stoppable_1.Stopper(options.httpServer);
      return {
        async serverWillStart() {
          return {
            async drainServer() {
              var _a;
              await stopper.stop((_a = options.stopGracePeriodMillis) !== null && _a !== void 0 ? _a : 1e4);
            }
          };
        }
      };
    }
    exports2.ApolloServerPluginDrainHttpServer = ApolloServerPluginDrainHttpServer;
  }
});

// ../../../node_modules/apollo-server-core/dist/plugin/landingPage/default/index.js
var require_default = __commonJS({
  "../../../node_modules/apollo-server-core/dist/plugin/landingPage/default/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getEmbeddedSandboxHTML = exports2.getEmbeddedExplorerHTML = exports2.ApolloServerPluginLandingPageProductionDefault = exports2.ApolloServerPluginLandingPageLocalDefault = void 0;
    function ApolloServerPluginLandingPageLocalDefault(options = {}) {
      const { version: version2, __internal_apolloStudioEnv__, ...rest } = options;
      return ApolloServerPluginLandingPageDefault(version2, {
        isProd: false,
        apolloStudioEnv: __internal_apolloStudioEnv__,
        ...rest
      });
    }
    exports2.ApolloServerPluginLandingPageLocalDefault = ApolloServerPluginLandingPageLocalDefault;
    function ApolloServerPluginLandingPageProductionDefault(options = {}) {
      const { version: version2, __internal_apolloStudioEnv__, ...rest } = options;
      return ApolloServerPluginLandingPageDefault(version2, {
        isProd: true,
        apolloStudioEnv: __internal_apolloStudioEnv__,
        ...rest
      });
    }
    exports2.ApolloServerPluginLandingPageProductionDefault = ApolloServerPluginLandingPageProductionDefault;
    function encodeConfig(config) {
      return JSON.stringify(encodeURIComponent(JSON.stringify(config)));
    }
    function getConfigStringForHtml(config) {
      return JSON.stringify(config).replace("<", "\\u003c").replace(">", "\\u003e").replace("&", "\\u0026").replace("'", "\\u0027");
    }
    var getEmbeddedExplorerHTML = (version2, config) => {
      const productionLandingPageConfigOrDefault = {
        displayOptions: {},
        persistExplorerState: false,
        ...typeof config.embed === "boolean" ? {} : config.embed
      };
      const embeddedExplorerParams = {
        ...config,
        target: "#embeddableExplorer",
        initialState: {
          ...config,
          displayOptions: {
            ...productionLandingPageConfigOrDefault.displayOptions
          }
        },
        persistExplorerState: productionLandingPageConfigOrDefault.persistExplorerState
      };
      return `
<div class="fallback">
  <h1>Welcome to Apollo Server</h1>
  <p>Apollo Explorer cannot be loaded; it appears that you might be offline.</p>
</div>
<style>
  iframe {
    background-color: white;
  }
</style>
<div
style="width: 100vw; height: 100vh; position: absolute; top: 0;"
id="embeddableExplorer"
></div>
<script src="https://embeddable-explorer.cdn.apollographql.com/${version2}/embeddable-explorer.umd.production.min.js"><\/script>
<script>
  var endpointUrl = window.location.href;
  var embeddedExplorerConfig = ${getConfigStringForHtml(embeddedExplorerParams)};
  new window.EmbeddedExplorer({
    ...embeddedExplorerConfig,
    endpointUrl,
  });
<\/script>
`;
    };
    exports2.getEmbeddedExplorerHTML = getEmbeddedExplorerHTML;
    var getEmbeddedSandboxHTML = (version2, config) => {
      var _a, _b, _c, _d;
      return `
<div class="fallback">
  <h1>Welcome to Apollo Server</h1>
  <p>Apollo Sandbox cannot be loaded; it appears that you might be offline.</p>
</div>
<style>
  iframe {
    background-color: white;
  }
</style>
<div
style="width: 100vw; height: 100vh; position: absolute; top: 0;"
id="embeddableSandbox"
></div>
<script src="https://embeddable-sandbox.cdn.apollographql.com/${version2}/embeddable-sandbox.umd.production.min.js"><\/script>
<script>
  var initialEndpoint = window.location.href;
  new window.EmbeddedSandbox({
    target: '#embeddableSandbox',
    initialEndpoint,
    includeCookies: ${(_a = config.includeCookies) !== null && _a !== void 0 ? _a : "false"},
    initialState: ${getConfigStringForHtml({
        document: (_b = config.document) !== null && _b !== void 0 ? _b : void 0,
        variables: (_c = config.variables) !== null && _c !== void 0 ? _c : void 0,
        headers: (_d = config.headers) !== null && _d !== void 0 ? _d : void 0
      })},
  });
<\/script>
`;
    };
    exports2.getEmbeddedSandboxHTML = getEmbeddedSandboxHTML;
    var getNonEmbeddedLandingPageHTML = (version2, config) => {
      const encodedConfig = encodeConfig(config);
      return `
 <div class="fallback">
  <h1>Welcome to Apollo Server</h1>
  <p>The full landing page cannot be loaded; it appears that you might be offline.</p>
</div>
<script>window.landingPage = ${encodedConfig};<\/script>
<script src="https://apollo-server-landing-page.cdn.apollographql.com/${version2}/static/js/main.js"><\/script>`;
    };
    function ApolloServerPluginLandingPageDefault(maybeVersion, config) {
      const version2 = maybeVersion !== null && maybeVersion !== void 0 ? maybeVersion : "_latest";
      return {
        __internal_installed_implicitly__: false,
        async serverWillStart() {
          return {
            async renderLandingPage() {
              const html = `
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link
      rel="icon"
      href="https://apollo-server-landing-page.cdn.apollographql.com/${version2}/assets/favicon.png"
    />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <link rel="preconnect" href="https://fonts.gstatic.com" />
    <link
      href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro&display=swap"
      rel="stylesheet"
    />
    <meta name="theme-color" content="#000000" />
    <meta name="description" content="Apollo server landing page" />
    <link
      rel="apple-touch-icon"
      href="https://apollo-server-landing-page.cdn.apollographql.com/${version2}/assets/favicon.png"
    />
    <link
      rel="manifest"
      href="https://apollo-server-landing-page.cdn.apollographql.com/${version2}/manifest.json"
    />
    <title>Apollo Server</title>
  </head>
  <body style="margin: 0; overflow-x: hidden; overflow-y: hidden">
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="react-root">
      <style>
        .fallback {
          opacity: 0;
          animation: fadeIn 1s 1s;
          animation-iteration-count: 1;
          animation-fill-mode: forwards;
          padding: 1em;
        }
        @keyframes fadeIn {
          0% {opacity:0;}
          100% {opacity:1; }
        }
      </style>
    ${config.embed ? "graphRef" in config && config.graphRef ? (0, exports2.getEmbeddedExplorerHTML)(version2, config) : (0, exports2.getEmbeddedSandboxHTML)(version2, config) : getNonEmbeddedLandingPageHTML(version2, config)}
    </div>
  </body>
</html>
          `;
              return { html };
            }
          };
        }
      };
    }
  }
});

// ../../../node_modules/cssfilter/lib/default.js
var require_default2 = __commonJS({
  "../../../node_modules/cssfilter/lib/default.js"(exports2) {
    function getDefaultWhiteList() {
      var whiteList = {};
      whiteList["align-content"] = false;
      whiteList["align-items"] = false;
      whiteList["align-self"] = false;
      whiteList["alignment-adjust"] = false;
      whiteList["alignment-baseline"] = false;
      whiteList["all"] = false;
      whiteList["anchor-point"] = false;
      whiteList["animation"] = false;
      whiteList["animation-delay"] = false;
      whiteList["animation-direction"] = false;
      whiteList["animation-duration"] = false;
      whiteList["animation-fill-mode"] = false;
      whiteList["animation-iteration-count"] = false;
      whiteList["animation-name"] = false;
      whiteList["animation-play-state"] = false;
      whiteList["animation-timing-function"] = false;
      whiteList["azimuth"] = false;
      whiteList["backface-visibility"] = false;
      whiteList["background"] = true;
      whiteList["background-attachment"] = true;
      whiteList["background-clip"] = true;
      whiteList["background-color"] = true;
      whiteList["background-image"] = true;
      whiteList["background-origin"] = true;
      whiteList["background-position"] = true;
      whiteList["background-repeat"] = true;
      whiteList["background-size"] = true;
      whiteList["baseline-shift"] = false;
      whiteList["binding"] = false;
      whiteList["bleed"] = false;
      whiteList["bookmark-label"] = false;
      whiteList["bookmark-level"] = false;
      whiteList["bookmark-state"] = false;
      whiteList["border"] = true;
      whiteList["border-bottom"] = true;
      whiteList["border-bottom-color"] = true;
      whiteList["border-bottom-left-radius"] = true;
      whiteList["border-bottom-right-radius"] = true;
      whiteList["border-bottom-style"] = true;
      whiteList["border-bottom-width"] = true;
      whiteList["border-collapse"] = true;
      whiteList["border-color"] = true;
      whiteList["border-image"] = true;
      whiteList["border-image-outset"] = true;
      whiteList["border-image-repeat"] = true;
      whiteList["border-image-slice"] = true;
      whiteList["border-image-source"] = true;
      whiteList["border-image-width"] = true;
      whiteList["border-left"] = true;
      whiteList["border-left-color"] = true;
      whiteList["border-left-style"] = true;
      whiteList["border-left-width"] = true;
      whiteList["border-radius"] = true;
      whiteList["border-right"] = true;
      whiteList["border-right-color"] = true;
      whiteList["border-right-style"] = true;
      whiteList["border-right-width"] = true;
      whiteList["border-spacing"] = true;
      whiteList["border-style"] = true;
      whiteList["border-top"] = true;
      whiteList["border-top-color"] = true;
      whiteList["border-top-left-radius"] = true;
      whiteList["border-top-right-radius"] = true;
      whiteList["border-top-style"] = true;
      whiteList["border-top-width"] = true;
      whiteList["border-width"] = true;
      whiteList["bottom"] = false;
      whiteList["box-decoration-break"] = true;
      whiteList["box-shadow"] = true;
      whiteList["box-sizing"] = true;
      whiteList["box-snap"] = true;
      whiteList["box-suppress"] = true;
      whiteList["break-after"] = true;
      whiteList["break-before"] = true;
      whiteList["break-inside"] = true;
      whiteList["caption-side"] = false;
      whiteList["chains"] = false;
      whiteList["clear"] = true;
      whiteList["clip"] = false;
      whiteList["clip-path"] = false;
      whiteList["clip-rule"] = false;
      whiteList["color"] = true;
      whiteList["color-interpolation-filters"] = true;
      whiteList["column-count"] = false;
      whiteList["column-fill"] = false;
      whiteList["column-gap"] = false;
      whiteList["column-rule"] = false;
      whiteList["column-rule-color"] = false;
      whiteList["column-rule-style"] = false;
      whiteList["column-rule-width"] = false;
      whiteList["column-span"] = false;
      whiteList["column-width"] = false;
      whiteList["columns"] = false;
      whiteList["contain"] = false;
      whiteList["content"] = false;
      whiteList["counter-increment"] = false;
      whiteList["counter-reset"] = false;
      whiteList["counter-set"] = false;
      whiteList["crop"] = false;
      whiteList["cue"] = false;
      whiteList["cue-after"] = false;
      whiteList["cue-before"] = false;
      whiteList["cursor"] = false;
      whiteList["direction"] = false;
      whiteList["display"] = true;
      whiteList["display-inside"] = true;
      whiteList["display-list"] = true;
      whiteList["display-outside"] = true;
      whiteList["dominant-baseline"] = false;
      whiteList["elevation"] = false;
      whiteList["empty-cells"] = false;
      whiteList["filter"] = false;
      whiteList["flex"] = false;
      whiteList["flex-basis"] = false;
      whiteList["flex-direction"] = false;
      whiteList["flex-flow"] = false;
      whiteList["flex-grow"] = false;
      whiteList["flex-shrink"] = false;
      whiteList["flex-wrap"] = false;
      whiteList["float"] = false;
      whiteList["float-offset"] = false;
      whiteList["flood-color"] = false;
      whiteList["flood-opacity"] = false;
      whiteList["flow-from"] = false;
      whiteList["flow-into"] = false;
      whiteList["font"] = true;
      whiteList["font-family"] = true;
      whiteList["font-feature-settings"] = true;
      whiteList["font-kerning"] = true;
      whiteList["font-language-override"] = true;
      whiteList["font-size"] = true;
      whiteList["font-size-adjust"] = true;
      whiteList["font-stretch"] = true;
      whiteList["font-style"] = true;
      whiteList["font-synthesis"] = true;
      whiteList["font-variant"] = true;
      whiteList["font-variant-alternates"] = true;
      whiteList["font-variant-caps"] = true;
      whiteList["font-variant-east-asian"] = true;
      whiteList["font-variant-ligatures"] = true;
      whiteList["font-variant-numeric"] = true;
      whiteList["font-variant-position"] = true;
      whiteList["font-weight"] = true;
      whiteList["grid"] = false;
      whiteList["grid-area"] = false;
      whiteList["grid-auto-columns"] = false;
      whiteList["grid-auto-flow"] = false;
      whiteList["grid-auto-rows"] = false;
      whiteList["grid-column"] = false;
      whiteList["grid-column-end"] = false;
      whiteList["grid-column-start"] = false;
      whiteList["grid-row"] = false;
      whiteList["grid-row-end"] = false;
      whiteList["grid-row-start"] = false;
      whiteList["grid-template"] = false;
      whiteList["grid-template-areas"] = false;
      whiteList["grid-template-columns"] = false;
      whiteList["grid-template-rows"] = false;
      whiteList["hanging-punctuation"] = false;
      whiteList["height"] = true;
      whiteList["hyphens"] = false;
      whiteList["icon"] = false;
      whiteList["image-orientation"] = false;
      whiteList["image-resolution"] = false;
      whiteList["ime-mode"] = false;
      whiteList["initial-letters"] = false;
      whiteList["inline-box-align"] = false;
      whiteList["justify-content"] = false;
      whiteList["justify-items"] = false;
      whiteList["justify-self"] = false;
      whiteList["left"] = false;
      whiteList["letter-spacing"] = true;
      whiteList["lighting-color"] = true;
      whiteList["line-box-contain"] = false;
      whiteList["line-break"] = false;
      whiteList["line-grid"] = false;
      whiteList["line-height"] = false;
      whiteList["line-snap"] = false;
      whiteList["line-stacking"] = false;
      whiteList["line-stacking-ruby"] = false;
      whiteList["line-stacking-shift"] = false;
      whiteList["line-stacking-strategy"] = false;
      whiteList["list-style"] = true;
      whiteList["list-style-image"] = true;
      whiteList["list-style-position"] = true;
      whiteList["list-style-type"] = true;
      whiteList["margin"] = true;
      whiteList["margin-bottom"] = true;
      whiteList["margin-left"] = true;
      whiteList["margin-right"] = true;
      whiteList["margin-top"] = true;
      whiteList["marker-offset"] = false;
      whiteList["marker-side"] = false;
      whiteList["marks"] = false;
      whiteList["mask"] = false;
      whiteList["mask-box"] = false;
      whiteList["mask-box-outset"] = false;
      whiteList["mask-box-repeat"] = false;
      whiteList["mask-box-slice"] = false;
      whiteList["mask-box-source"] = false;
      whiteList["mask-box-width"] = false;
      whiteList["mask-clip"] = false;
      whiteList["mask-image"] = false;
      whiteList["mask-origin"] = false;
      whiteList["mask-position"] = false;
      whiteList["mask-repeat"] = false;
      whiteList["mask-size"] = false;
      whiteList["mask-source-type"] = false;
      whiteList["mask-type"] = false;
      whiteList["max-height"] = true;
      whiteList["max-lines"] = false;
      whiteList["max-width"] = true;
      whiteList["min-height"] = true;
      whiteList["min-width"] = true;
      whiteList["move-to"] = false;
      whiteList["nav-down"] = false;
      whiteList["nav-index"] = false;
      whiteList["nav-left"] = false;
      whiteList["nav-right"] = false;
      whiteList["nav-up"] = false;
      whiteList["object-fit"] = false;
      whiteList["object-position"] = false;
      whiteList["opacity"] = false;
      whiteList["order"] = false;
      whiteList["orphans"] = false;
      whiteList["outline"] = false;
      whiteList["outline-color"] = false;
      whiteList["outline-offset"] = false;
      whiteList["outline-style"] = false;
      whiteList["outline-width"] = false;
      whiteList["overflow"] = false;
      whiteList["overflow-wrap"] = false;
      whiteList["overflow-x"] = false;
      whiteList["overflow-y"] = false;
      whiteList["padding"] = true;
      whiteList["padding-bottom"] = true;
      whiteList["padding-left"] = true;
      whiteList["padding-right"] = true;
      whiteList["padding-top"] = true;
      whiteList["page"] = false;
      whiteList["page-break-after"] = false;
      whiteList["page-break-before"] = false;
      whiteList["page-break-inside"] = false;
      whiteList["page-policy"] = false;
      whiteList["pause"] = false;
      whiteList["pause-after"] = false;
      whiteList["pause-before"] = false;
      whiteList["perspective"] = false;
      whiteList["perspective-origin"] = false;
      whiteList["pitch"] = false;
      whiteList["pitch-range"] = false;
      whiteList["play-during"] = false;
      whiteList["position"] = false;
      whiteList["presentation-level"] = false;
      whiteList["quotes"] = false;
      whiteList["region-fragment"] = false;
      whiteList["resize"] = false;
      whiteList["rest"] = false;
      whiteList["rest-after"] = false;
      whiteList["rest-before"] = false;
      whiteList["richness"] = false;
      whiteList["right"] = false;
      whiteList["rotation"] = false;
      whiteList["rotation-point"] = false;
      whiteList["ruby-align"] = false;
      whiteList["ruby-merge"] = false;
      whiteList["ruby-position"] = false;
      whiteList["shape-image-threshold"] = false;
      whiteList["shape-outside"] = false;
      whiteList["shape-margin"] = false;
      whiteList["size"] = false;
      whiteList["speak"] = false;
      whiteList["speak-as"] = false;
      whiteList["speak-header"] = false;
      whiteList["speak-numeral"] = false;
      whiteList["speak-punctuation"] = false;
      whiteList["speech-rate"] = false;
      whiteList["stress"] = false;
      whiteList["string-set"] = false;
      whiteList["tab-size"] = false;
      whiteList["table-layout"] = false;
      whiteList["text-align"] = true;
      whiteList["text-align-last"] = true;
      whiteList["text-combine-upright"] = true;
      whiteList["text-decoration"] = true;
      whiteList["text-decoration-color"] = true;
      whiteList["text-decoration-line"] = true;
      whiteList["text-decoration-skip"] = true;
      whiteList["text-decoration-style"] = true;
      whiteList["text-emphasis"] = true;
      whiteList["text-emphasis-color"] = true;
      whiteList["text-emphasis-position"] = true;
      whiteList["text-emphasis-style"] = true;
      whiteList["text-height"] = true;
      whiteList["text-indent"] = true;
      whiteList["text-justify"] = true;
      whiteList["text-orientation"] = true;
      whiteList["text-overflow"] = true;
      whiteList["text-shadow"] = true;
      whiteList["text-space-collapse"] = true;
      whiteList["text-transform"] = true;
      whiteList["text-underline-position"] = true;
      whiteList["text-wrap"] = true;
      whiteList["top"] = false;
      whiteList["transform"] = false;
      whiteList["transform-origin"] = false;
      whiteList["transform-style"] = false;
      whiteList["transition"] = false;
      whiteList["transition-delay"] = false;
      whiteList["transition-duration"] = false;
      whiteList["transition-property"] = false;
      whiteList["transition-timing-function"] = false;
      whiteList["unicode-bidi"] = false;
      whiteList["vertical-align"] = false;
      whiteList["visibility"] = false;
      whiteList["voice-balance"] = false;
      whiteList["voice-duration"] = false;
      whiteList["voice-family"] = false;
      whiteList["voice-pitch"] = false;
      whiteList["voice-range"] = false;
      whiteList["voice-rate"] = false;
      whiteList["voice-stress"] = false;
      whiteList["voice-volume"] = false;
      whiteList["volume"] = false;
      whiteList["white-space"] = false;
      whiteList["widows"] = false;
      whiteList["width"] = true;
      whiteList["will-change"] = false;
      whiteList["word-break"] = true;
      whiteList["word-spacing"] = true;
      whiteList["word-wrap"] = true;
      whiteList["wrap-flow"] = false;
      whiteList["wrap-through"] = false;
      whiteList["writing-mode"] = false;
      whiteList["z-index"] = false;
      return whiteList;
    }
    function onAttr(name, value, options) {
    }
    function onIgnoreAttr(name, value, options) {
    }
    var REGEXP_URL_JAVASCRIPT = /javascript\s*\:/img;
    function safeAttrValue(name, value) {
      if (REGEXP_URL_JAVASCRIPT.test(value))
        return "";
      return value;
    }
    exports2.whiteList = getDefaultWhiteList();
    exports2.getDefaultWhiteList = getDefaultWhiteList;
    exports2.onAttr = onAttr;
    exports2.onIgnoreAttr = onIgnoreAttr;
    exports2.safeAttrValue = safeAttrValue;
  }
});

// ../../../node_modules/cssfilter/lib/util.js
var require_util2 = __commonJS({
  "../../../node_modules/cssfilter/lib/util.js"(exports2, module2) {
    module2.exports = {
      indexOf: function(arr, item) {
        var i, j;
        if (Array.prototype.indexOf) {
          return arr.indexOf(item);
        }
        for (i = 0, j = arr.length; i < j; i++) {
          if (arr[i] === item) {
            return i;
          }
        }
        return -1;
      },
      forEach: function(arr, fn, scope) {
        var i, j;
        if (Array.prototype.forEach) {
          return arr.forEach(fn, scope);
        }
        for (i = 0, j = arr.length; i < j; i++) {
          fn.call(scope, arr[i], i, arr);
        }
      },
      trim: function(str) {
        if (String.prototype.trim) {
          return str.trim();
        }
        return str.replace(/(^\s*)|(\s*$)/g, "");
      },
      trimRight: function(str) {
        if (String.prototype.trimRight) {
          return str.trimRight();
        }
        return str.replace(/(\s*$)/g, "");
      }
    };
  }
});

// ../../../node_modules/cssfilter/lib/parser.js
var require_parser2 = __commonJS({
  "../../../node_modules/cssfilter/lib/parser.js"(exports2, module2) {
    var _ = require_util2();
    function parseStyle(css, onAttr) {
      css = _.trimRight(css);
      if (css[css.length - 1] !== ";")
        css += ";";
      var cssLength = css.length;
      var isParenthesisOpen = false;
      var lastPos = 0;
      var i = 0;
      var retCSS = "";
      function addNewAttr() {
        if (!isParenthesisOpen) {
          var source = _.trim(css.slice(lastPos, i));
          var j2 = source.indexOf(":");
          if (j2 !== -1) {
            var name = _.trim(source.slice(0, j2));
            var value = _.trim(source.slice(j2 + 1));
            if (name) {
              var ret = onAttr(lastPos, retCSS.length, name, value, source);
              if (ret)
                retCSS += ret + "; ";
            }
          }
        }
        lastPos = i + 1;
      }
      for (; i < cssLength; i++) {
        var c = css[i];
        if (c === "/" && css[i + 1] === "*") {
          var j = css.indexOf("*/", i + 2);
          if (j === -1)
            break;
          i = j + 1;
          lastPos = i + 1;
          isParenthesisOpen = false;
        } else if (c === "(") {
          isParenthesisOpen = true;
        } else if (c === ")") {
          isParenthesisOpen = false;
        } else if (c === ";") {
          if (isParenthesisOpen) {
          } else {
            addNewAttr();
          }
        } else if (c === "\n") {
          addNewAttr();
        }
      }
      return _.trim(retCSS);
    }
    module2.exports = parseStyle;
  }
});

// ../../../node_modules/cssfilter/lib/css.js
var require_css = __commonJS({
  "../../../node_modules/cssfilter/lib/css.js"(exports2, module2) {
    var DEFAULT = require_default2();
    var parseStyle = require_parser2();
    var _ = require_util2();
    function isNull(obj) {
      return obj === void 0 || obj === null;
    }
    function shallowCopyObject(obj) {
      var ret = {};
      for (var i in obj) {
        ret[i] = obj[i];
      }
      return ret;
    }
    function FilterCSS(options) {
      options = shallowCopyObject(options || {});
      options.whiteList = options.whiteList || DEFAULT.whiteList;
      options.onAttr = options.onAttr || DEFAULT.onAttr;
      options.onIgnoreAttr = options.onIgnoreAttr || DEFAULT.onIgnoreAttr;
      options.safeAttrValue = options.safeAttrValue || DEFAULT.safeAttrValue;
      this.options = options;
    }
    FilterCSS.prototype.process = function(css) {
      css = css || "";
      css = css.toString();
      if (!css)
        return "";
      var me = this;
      var options = me.options;
      var whiteList = options.whiteList;
      var onAttr = options.onAttr;
      var onIgnoreAttr = options.onIgnoreAttr;
      var safeAttrValue = options.safeAttrValue;
      var retCSS = parseStyle(css, function(sourcePosition, position, name, value, source) {
        var check = whiteList[name];
        var isWhite = false;
        if (check === true)
          isWhite = check;
        else if (typeof check === "function")
          isWhite = check(value);
        else if (check instanceof RegExp)
          isWhite = check.test(value);
        if (isWhite !== true)
          isWhite = false;
        value = safeAttrValue(name, value);
        if (!value)
          return;
        var opts = {
          position,
          sourcePosition,
          source,
          isWhite
        };
        if (isWhite) {
          var ret = onAttr(name, value, opts);
          if (isNull(ret)) {
            return name + ":" + value;
          } else {
            return ret;
          }
        } else {
          var ret = onIgnoreAttr(name, value, opts);
          if (!isNull(ret)) {
            return ret;
          }
        }
      });
      return retCSS;
    };
    module2.exports = FilterCSS;
  }
});

// ../../../node_modules/cssfilter/lib/index.js
var require_lib3 = __commonJS({
  "../../../node_modules/cssfilter/lib/index.js"(exports2, module2) {
    var DEFAULT = require_default2();
    var FilterCSS = require_css();
    function filterCSS(html, options) {
      var xss = new FilterCSS(options);
      return xss.process(html);
    }
    exports2 = module2.exports = filterCSS;
    exports2.FilterCSS = FilterCSS;
    for (i in DEFAULT)
      exports2[i] = DEFAULT[i];
    var i;
    if (typeof window !== "undefined") {
      window.filterCSS = module2.exports;
    }
  }
});

// ../../../node_modules/xss/lib/util.js
var require_util3 = __commonJS({
  "../../../node_modules/xss/lib/util.js"(exports2, module2) {
    module2.exports = {
      indexOf: function(arr, item) {
        var i, j;
        if (Array.prototype.indexOf) {
          return arr.indexOf(item);
        }
        for (i = 0, j = arr.length; i < j; i++) {
          if (arr[i] === item) {
            return i;
          }
        }
        return -1;
      },
      forEach: function(arr, fn, scope) {
        var i, j;
        if (Array.prototype.forEach) {
          return arr.forEach(fn, scope);
        }
        for (i = 0, j = arr.length; i < j; i++) {
          fn.call(scope, arr[i], i, arr);
        }
      },
      trim: function(str) {
        if (String.prototype.trim) {
          return str.trim();
        }
        return str.replace(/(^\s*)|(\s*$)/g, "");
      },
      spaceIndex: function(str) {
        var reg = /\s|\n|\t/;
        var match = reg.exec(str);
        return match ? match.index : -1;
      }
    };
  }
});

// ../../../node_modules/xss/lib/default.js
var require_default3 = __commonJS({
  "../../../node_modules/xss/lib/default.js"(exports2) {
    var FilterCSS = require_lib3().FilterCSS;
    var getDefaultCSSWhiteList = require_lib3().getDefaultWhiteList;
    var _ = require_util3();
    function getDefaultWhiteList() {
      return {
        a: ["target", "href", "title"],
        abbr: ["title"],
        address: [],
        area: ["shape", "coords", "href", "alt"],
        article: [],
        aside: [],
        audio: [
          "autoplay",
          "controls",
          "crossorigin",
          "loop",
          "muted",
          "preload",
          "src"
        ],
        b: [],
        bdi: ["dir"],
        bdo: ["dir"],
        big: [],
        blockquote: ["cite"],
        br: [],
        caption: [],
        center: [],
        cite: [],
        code: [],
        col: ["align", "valign", "span", "width"],
        colgroup: ["align", "valign", "span", "width"],
        dd: [],
        del: ["datetime"],
        details: ["open"],
        div: [],
        dl: [],
        dt: [],
        em: [],
        figcaption: [],
        figure: [],
        font: ["color", "size", "face"],
        footer: [],
        h1: [],
        h2: [],
        h3: [],
        h4: [],
        h5: [],
        h6: [],
        header: [],
        hr: [],
        i: [],
        img: ["src", "alt", "title", "width", "height"],
        ins: ["datetime"],
        li: [],
        mark: [],
        nav: [],
        ol: [],
        p: [],
        pre: [],
        s: [],
        section: [],
        small: [],
        span: [],
        sub: [],
        summary: [],
        sup: [],
        strong: [],
        strike: [],
        table: ["width", "border", "align", "valign"],
        tbody: ["align", "valign"],
        td: ["width", "rowspan", "colspan", "align", "valign"],
        tfoot: ["align", "valign"],
        th: ["width", "rowspan", "colspan", "align", "valign"],
        thead: ["align", "valign"],
        tr: ["rowspan", "align", "valign"],
        tt: [],
        u: [],
        ul: [],
        video: [
          "autoplay",
          "controls",
          "crossorigin",
          "loop",
          "muted",
          "playsinline",
          "poster",
          "preload",
          "src",
          "height",
          "width"
        ]
      };
    }
    var defaultCSSFilter = new FilterCSS();
    function onTag(tag, html, options) {
    }
    function onIgnoreTag(tag, html, options) {
    }
    function onTagAttr(tag, name, value) {
    }
    function onIgnoreTagAttr(tag, name, value) {
    }
    function escapeHtml(html) {
      return html.replace(REGEXP_LT, "&lt;").replace(REGEXP_GT, "&gt;");
    }
    function safeAttrValue(tag, name, value, cssFilter) {
      value = friendlyAttrValue(value);
      if (name === "href" || name === "src") {
        value = _.trim(value);
        if (value === "#")
          return "#";
        if (!(value.substr(0, 7) === "http://" || value.substr(0, 8) === "https://" || value.substr(0, 7) === "mailto:" || value.substr(0, 4) === "tel:" || value.substr(0, 11) === "data:image/" || value.substr(0, 6) === "ftp://" || value.substr(0, 2) === "./" || value.substr(0, 3) === "../" || value[0] === "#" || value[0] === "/")) {
          return "";
        }
      } else if (name === "background") {
        REGEXP_DEFAULT_ON_TAG_ATTR_4.lastIndex = 0;
        if (REGEXP_DEFAULT_ON_TAG_ATTR_4.test(value)) {
          return "";
        }
      } else if (name === "style") {
        REGEXP_DEFAULT_ON_TAG_ATTR_7.lastIndex = 0;
        if (REGEXP_DEFAULT_ON_TAG_ATTR_7.test(value)) {
          return "";
        }
        REGEXP_DEFAULT_ON_TAG_ATTR_8.lastIndex = 0;
        if (REGEXP_DEFAULT_ON_TAG_ATTR_8.test(value)) {
          REGEXP_DEFAULT_ON_TAG_ATTR_4.lastIndex = 0;
          if (REGEXP_DEFAULT_ON_TAG_ATTR_4.test(value)) {
            return "";
          }
        }
        if (cssFilter !== false) {
          cssFilter = cssFilter || defaultCSSFilter;
          value = cssFilter.process(value);
        }
      }
      value = escapeAttrValue(value);
      return value;
    }
    var REGEXP_LT = /</g;
    var REGEXP_GT = />/g;
    var REGEXP_QUOTE = /"/g;
    var REGEXP_QUOTE_2 = /&quot;/g;
    var REGEXP_ATTR_VALUE_1 = /&#([a-zA-Z0-9]*);?/gim;
    var REGEXP_ATTR_VALUE_COLON = /&colon;?/gim;
    var REGEXP_ATTR_VALUE_NEWLINE = /&newline;?/gim;
    var REGEXP_DEFAULT_ON_TAG_ATTR_4 = /((j\s*a\s*v\s*a|v\s*b|l\s*i\s*v\s*e)\s*s\s*c\s*r\s*i\s*p\s*t\s*|m\s*o\s*c\s*h\s*a):/gi;
    var REGEXP_DEFAULT_ON_TAG_ATTR_7 = /e\s*x\s*p\s*r\s*e\s*s\s*s\s*i\s*o\s*n\s*\(.*/gi;
    var REGEXP_DEFAULT_ON_TAG_ATTR_8 = /u\s*r\s*l\s*\(.*/gi;
    function escapeQuote(str) {
      return str.replace(REGEXP_QUOTE, "&quot;");
    }
    function unescapeQuote(str) {
      return str.replace(REGEXP_QUOTE_2, '"');
    }
    function escapeHtmlEntities(str) {
      return str.replace(REGEXP_ATTR_VALUE_1, function replaceUnicode(str2, code) {
        return code[0] === "x" || code[0] === "X" ? String.fromCharCode(parseInt(code.substr(1), 16)) : String.fromCharCode(parseInt(code, 10));
      });
    }
    function escapeDangerHtml5Entities(str) {
      return str.replace(REGEXP_ATTR_VALUE_COLON, ":").replace(REGEXP_ATTR_VALUE_NEWLINE, " ");
    }
    function clearNonPrintableCharacter(str) {
      var str2 = "";
      for (var i = 0, len = str.length; i < len; i++) {
        str2 += str.charCodeAt(i) < 32 ? " " : str.charAt(i);
      }
      return _.trim(str2);
    }
    function friendlyAttrValue(str) {
      str = unescapeQuote(str);
      str = escapeHtmlEntities(str);
      str = escapeDangerHtml5Entities(str);
      str = clearNonPrintableCharacter(str);
      return str;
    }
    function escapeAttrValue(str) {
      str = escapeQuote(str);
      str = escapeHtml(str);
      return str;
    }
    function onIgnoreTagStripAll() {
      return "";
    }
    function StripTagBody(tags, next) {
      if (typeof next !== "function") {
        next = function() {
        };
      }
      var isRemoveAllTag = !Array.isArray(tags);
      function isRemoveTag(tag) {
        if (isRemoveAllTag)
          return true;
        return _.indexOf(tags, tag) !== -1;
      }
      var removeList = [];
      var posStart = false;
      return {
        onIgnoreTag: function(tag, html, options) {
          if (isRemoveTag(tag)) {
            if (options.isClosing) {
              var ret = "[/removed]";
              var end = options.position + ret.length;
              removeList.push([
                posStart !== false ? posStart : options.position,
                end
              ]);
              posStart = false;
              return ret;
            } else {
              if (!posStart) {
                posStart = options.position;
              }
              return "[removed]";
            }
          } else {
            return next(tag, html, options);
          }
        },
        remove: function(html) {
          var rethtml = "";
          var lastPos = 0;
          _.forEach(removeList, function(pos) {
            rethtml += html.slice(lastPos, pos[0]);
            lastPos = pos[1];
          });
          rethtml += html.slice(lastPos);
          return rethtml;
        }
      };
    }
    function stripCommentTag(html) {
      var retHtml = "";
      var lastPos = 0;
      while (lastPos < html.length) {
        var i = html.indexOf("<!--", lastPos);
        if (i === -1) {
          retHtml += html.slice(lastPos);
          break;
        }
        retHtml += html.slice(lastPos, i);
        var j = html.indexOf("-->", i);
        if (j === -1) {
          break;
        }
        lastPos = j + 3;
      }
      return retHtml;
    }
    function stripBlankChar(html) {
      var chars = html.split("");
      chars = chars.filter(function(char) {
        var c = char.charCodeAt(0);
        if (c === 127)
          return false;
        if (c <= 31) {
          if (c === 10 || c === 13)
            return true;
          return false;
        }
        return true;
      });
      return chars.join("");
    }
    exports2.whiteList = getDefaultWhiteList();
    exports2.getDefaultWhiteList = getDefaultWhiteList;
    exports2.onTag = onTag;
    exports2.onIgnoreTag = onIgnoreTag;
    exports2.onTagAttr = onTagAttr;
    exports2.onIgnoreTagAttr = onIgnoreTagAttr;
    exports2.safeAttrValue = safeAttrValue;
    exports2.escapeHtml = escapeHtml;
    exports2.escapeQuote = escapeQuote;
    exports2.unescapeQuote = unescapeQuote;
    exports2.escapeHtmlEntities = escapeHtmlEntities;
    exports2.escapeDangerHtml5Entities = escapeDangerHtml5Entities;
    exports2.clearNonPrintableCharacter = clearNonPrintableCharacter;
    exports2.friendlyAttrValue = friendlyAttrValue;
    exports2.escapeAttrValue = escapeAttrValue;
    exports2.onIgnoreTagStripAll = onIgnoreTagStripAll;
    exports2.StripTagBody = StripTagBody;
    exports2.stripCommentTag = stripCommentTag;
    exports2.stripBlankChar = stripBlankChar;
    exports2.cssFilter = defaultCSSFilter;
    exports2.getDefaultCSSWhiteList = getDefaultCSSWhiteList;
  }
});

// ../../../node_modules/xss/lib/parser.js
var require_parser3 = __commonJS({
  "../../../node_modules/xss/lib/parser.js"(exports2) {
    var _ = require_util3();
    function getTagName(html) {
      var i = _.spaceIndex(html);
      var tagName;
      if (i === -1) {
        tagName = html.slice(1, -1);
      } else {
        tagName = html.slice(1, i + 1);
      }
      tagName = _.trim(tagName).toLowerCase();
      if (tagName.slice(0, 1) === "/")
        tagName = tagName.slice(1);
      if (tagName.slice(-1) === "/")
        tagName = tagName.slice(0, -1);
      return tagName;
    }
    function isClosing(html) {
      return html.slice(0, 2) === "</";
    }
    function parseTag(html, onTag, escapeHtml) {
      "use strict";
      var rethtml = "";
      var lastPos = 0;
      var tagStart = false;
      var quoteStart = false;
      var currentPos = 0;
      var len = html.length;
      var currentTagName = "";
      var currentHtml = "";
      chariterator:
        for (currentPos = 0; currentPos < len; currentPos++) {
          var c = html.charAt(currentPos);
          if (tagStart === false) {
            if (c === "<") {
              tagStart = currentPos;
              continue;
            }
          } else {
            if (quoteStart === false) {
              if (c === "<") {
                rethtml += escapeHtml(html.slice(lastPos, currentPos));
                tagStart = currentPos;
                lastPos = currentPos;
                continue;
              }
              if (c === ">" || currentPos === len - 1) {
                rethtml += escapeHtml(html.slice(lastPos, tagStart));
                currentHtml = html.slice(tagStart, currentPos + 1);
                currentTagName = getTagName(currentHtml);
                rethtml += onTag(
                  tagStart,
                  rethtml.length,
                  currentTagName,
                  currentHtml,
                  isClosing(currentHtml)
                );
                lastPos = currentPos + 1;
                tagStart = false;
                continue;
              }
              if (c === '"' || c === "'") {
                var i = 1;
                var ic = html.charAt(currentPos - i);
                while (ic.trim() === "" || ic === "=") {
                  if (ic === "=") {
                    quoteStart = c;
                    continue chariterator;
                  }
                  ic = html.charAt(currentPos - ++i);
                }
              }
            } else {
              if (c === quoteStart) {
                quoteStart = false;
                continue;
              }
            }
          }
        }
      if (lastPos < len) {
        rethtml += escapeHtml(html.substr(lastPos));
      }
      return rethtml;
    }
    var REGEXP_ILLEGAL_ATTR_NAME = /[^a-zA-Z0-9\\_:.-]/gim;
    function parseAttr(html, onAttr) {
      "use strict";
      var lastPos = 0;
      var lastMarkPos = 0;
      var retAttrs = [];
      var tmpName = false;
      var len = html.length;
      function addAttr(name, value) {
        name = _.trim(name);
        name = name.replace(REGEXP_ILLEGAL_ATTR_NAME, "").toLowerCase();
        if (name.length < 1)
          return;
        var ret = onAttr(name, value || "");
        if (ret)
          retAttrs.push(ret);
      }
      for (var i = 0; i < len; i++) {
        var c = html.charAt(i);
        var v, j;
        if (tmpName === false && c === "=") {
          tmpName = html.slice(lastPos, i);
          lastPos = i + 1;
          lastMarkPos = html.charAt(lastPos) === '"' || html.charAt(lastPos) === "'" ? lastPos : findNextQuotationMark(html, i + 1);
          continue;
        }
        if (tmpName !== false) {
          if (i === lastMarkPos) {
            j = html.indexOf(c, i + 1);
            if (j === -1) {
              break;
            } else {
              v = _.trim(html.slice(lastMarkPos + 1, j));
              addAttr(tmpName, v);
              tmpName = false;
              i = j;
              lastPos = i + 1;
              continue;
            }
          }
        }
        if (/\s|\n|\t/.test(c)) {
          html = html.replace(/\s|\n|\t/g, " ");
          if (tmpName === false) {
            j = findNextEqual(html, i);
            if (j === -1) {
              v = _.trim(html.slice(lastPos, i));
              addAttr(v);
              tmpName = false;
              lastPos = i + 1;
              continue;
            } else {
              i = j - 1;
              continue;
            }
          } else {
            j = findBeforeEqual(html, i - 1);
            if (j === -1) {
              v = _.trim(html.slice(lastPos, i));
              v = stripQuoteWrap(v);
              addAttr(tmpName, v);
              tmpName = false;
              lastPos = i + 1;
              continue;
            } else {
              continue;
            }
          }
        }
      }
      if (lastPos < html.length) {
        if (tmpName === false) {
          addAttr(html.slice(lastPos));
        } else {
          addAttr(tmpName, stripQuoteWrap(_.trim(html.slice(lastPos))));
        }
      }
      return _.trim(retAttrs.join(" "));
    }
    function findNextEqual(str, i) {
      for (; i < str.length; i++) {
        var c = str[i];
        if (c === " ")
          continue;
        if (c === "=")
          return i;
        return -1;
      }
    }
    function findNextQuotationMark(str, i) {
      for (; i < str.length; i++) {
        var c = str[i];
        if (c === " ")
          continue;
        if (c === "'" || c === '"')
          return i;
        return -1;
      }
    }
    function findBeforeEqual(str, i) {
      for (; i > 0; i--) {
        var c = str[i];
        if (c === " ")
          continue;
        if (c === "=")
          return i;
        return -1;
      }
    }
    function isQuoteWrapString(text) {
      if (text[0] === '"' && text[text.length - 1] === '"' || text[0] === "'" && text[text.length - 1] === "'") {
        return true;
      } else {
        return false;
      }
    }
    function stripQuoteWrap(text) {
      if (isQuoteWrapString(text)) {
        return text.substr(1, text.length - 2);
      } else {
        return text;
      }
    }
    exports2.parseTag = parseTag;
    exports2.parseAttr = parseAttr;
  }
});

// ../../../node_modules/xss/lib/xss.js
var require_xss = __commonJS({
  "../../../node_modules/xss/lib/xss.js"(exports2, module2) {
    var FilterCSS = require_lib3().FilterCSS;
    var DEFAULT = require_default3();
    var parser = require_parser3();
    var parseTag = parser.parseTag;
    var parseAttr = parser.parseAttr;
    var _ = require_util3();
    function isNull(obj) {
      return obj === void 0 || obj === null;
    }
    function getAttrs(html) {
      var i = _.spaceIndex(html);
      if (i === -1) {
        return {
          html: "",
          closing: html[html.length - 2] === "/"
        };
      }
      html = _.trim(html.slice(i + 1, -1));
      var isClosing = html[html.length - 1] === "/";
      if (isClosing)
        html = _.trim(html.slice(0, -1));
      return {
        html,
        closing: isClosing
      };
    }
    function shallowCopyObject(obj) {
      var ret = {};
      for (var i in obj) {
        ret[i] = obj[i];
      }
      return ret;
    }
    function keysToLowerCase(obj) {
      var ret = {};
      for (var i in obj) {
        if (Array.isArray(obj[i])) {
          ret[i.toLowerCase()] = obj[i].map(function(item) {
            return item.toLowerCase();
          });
        } else {
          ret[i.toLowerCase()] = obj[i];
        }
      }
      return ret;
    }
    function FilterXSS(options) {
      options = shallowCopyObject(options || {});
      if (options.stripIgnoreTag) {
        if (options.onIgnoreTag) {
          console.error(
            'Notes: cannot use these two options "stripIgnoreTag" and "onIgnoreTag" at the same time'
          );
        }
        options.onIgnoreTag = DEFAULT.onIgnoreTagStripAll;
      }
      if (options.whiteList || options.allowList) {
        options.whiteList = keysToLowerCase(options.whiteList || options.allowList);
      } else {
        options.whiteList = DEFAULT.whiteList;
      }
      options.onTag = options.onTag || DEFAULT.onTag;
      options.onTagAttr = options.onTagAttr || DEFAULT.onTagAttr;
      options.onIgnoreTag = options.onIgnoreTag || DEFAULT.onIgnoreTag;
      options.onIgnoreTagAttr = options.onIgnoreTagAttr || DEFAULT.onIgnoreTagAttr;
      options.safeAttrValue = options.safeAttrValue || DEFAULT.safeAttrValue;
      options.escapeHtml = options.escapeHtml || DEFAULT.escapeHtml;
      this.options = options;
      if (options.css === false) {
        this.cssFilter = false;
      } else {
        options.css = options.css || {};
        this.cssFilter = new FilterCSS(options.css);
      }
    }
    FilterXSS.prototype.process = function(html) {
      html = html || "";
      html = html.toString();
      if (!html)
        return "";
      var me = this;
      var options = me.options;
      var whiteList = options.whiteList;
      var onTag = options.onTag;
      var onIgnoreTag = options.onIgnoreTag;
      var onTagAttr = options.onTagAttr;
      var onIgnoreTagAttr = options.onIgnoreTagAttr;
      var safeAttrValue = options.safeAttrValue;
      var escapeHtml = options.escapeHtml;
      var cssFilter = me.cssFilter;
      if (options.stripBlankChar) {
        html = DEFAULT.stripBlankChar(html);
      }
      if (!options.allowCommentTag) {
        html = DEFAULT.stripCommentTag(html);
      }
      var stripIgnoreTagBody = false;
      if (options.stripIgnoreTagBody) {
        stripIgnoreTagBody = DEFAULT.StripTagBody(
          options.stripIgnoreTagBody,
          onIgnoreTag
        );
        onIgnoreTag = stripIgnoreTagBody.onIgnoreTag;
      }
      var retHtml = parseTag(
        html,
        function(sourcePosition, position, tag, html2, isClosing) {
          var info = {
            sourcePosition,
            position,
            isClosing,
            isWhite: Object.prototype.hasOwnProperty.call(whiteList, tag)
          };
          var ret = onTag(tag, html2, info);
          if (!isNull(ret))
            return ret;
          if (info.isWhite) {
            if (info.isClosing) {
              return "</" + tag + ">";
            }
            var attrs = getAttrs(html2);
            var whiteAttrList = whiteList[tag];
            var attrsHtml = parseAttr(attrs.html, function(name, value) {
              var isWhiteAttr = _.indexOf(whiteAttrList, name) !== -1;
              var ret2 = onTagAttr(tag, name, value, isWhiteAttr);
              if (!isNull(ret2))
                return ret2;
              if (isWhiteAttr) {
                value = safeAttrValue(tag, name, value, cssFilter);
                if (value) {
                  return name + '="' + value + '"';
                } else {
                  return name;
                }
              } else {
                ret2 = onIgnoreTagAttr(tag, name, value, isWhiteAttr);
                if (!isNull(ret2))
                  return ret2;
                return;
              }
            });
            html2 = "<" + tag;
            if (attrsHtml)
              html2 += " " + attrsHtml;
            if (attrs.closing)
              html2 += " /";
            html2 += ">";
            return html2;
          } else {
            ret = onIgnoreTag(tag, html2, info);
            if (!isNull(ret))
              return ret;
            return escapeHtml(html2);
          }
        },
        escapeHtml
      );
      if (stripIgnoreTagBody) {
        retHtml = stripIgnoreTagBody.remove(retHtml);
      }
      return retHtml;
    };
    module2.exports = FilterXSS;
  }
});

// ../../../node_modules/xss/lib/index.js
var require_lib4 = __commonJS({
  "../../../node_modules/xss/lib/index.js"(exports2, module2) {
    var DEFAULT = require_default3();
    var parser = require_parser3();
    var FilterXSS = require_xss();
    function filterXSS(html, options) {
      var xss = new FilterXSS(options);
      return xss.process(html);
    }
    exports2 = module2.exports = filterXSS;
    exports2.filterXSS = filterXSS;
    exports2.FilterXSS = FilterXSS;
    (function() {
      for (var i in DEFAULT) {
        exports2[i] = DEFAULT[i];
      }
      for (var j in parser) {
        exports2[j] = parser[j];
      }
    })();
    if (typeof window !== "undefined") {
      window.filterXSS = module2.exports;
    }
    function isWorkerEnv() {
      return typeof self !== "undefined" && typeof DedicatedWorkerGlobalScope !== "undefined" && self instanceof DedicatedWorkerGlobalScope;
    }
    if (isWorkerEnv()) {
      self.filterXSS = module2.exports;
    }
  }
});

// ../../../node_modules/@apollographql/graphql-playground-html/dist/get-loading-markup.js
var require_get_loading_markup = __commonJS({
  "../../../node_modules/@apollographql/graphql-playground-html/dist/get-loading-markup.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var getLoadingMarkup = function() {
      return {
        script: "\n    const loadingWrapper = document.getElementById('loading-wrapper');\n    if (loadingWrapper) {\n      loadingWrapper.classList.add('fadeOut');\n    }\n    ",
        container: '\n<style type="text/css">\n.fadeOut {\n  -webkit-animation: fadeOut 0.5s ease-out forwards;\n  animation: fadeOut 0.5s ease-out forwards;\n}\n\n@-webkit-keyframes fadeIn {\n  from {\n    opacity: 0;\n    -webkit-transform: translateY(-10px);\n    -ms-transform: translateY(-10px);\n    transform: translateY(-10px);\n  }\n  to {\n    opacity: 1;\n    -webkit-transform: translateY(0);\n    -ms-transform: translateY(0);\n    transform: translateY(0);\n  }\n}\n\n@keyframes fadeIn {\n  from {\n    opacity: 0;\n    -webkit-transform: translateY(-10px);\n    -ms-transform: translateY(-10px);\n    transform: translateY(-10px);\n  }\n  to {\n    opacity: 1;\n    -webkit-transform: translateY(0);\n    -ms-transform: translateY(0);\n    transform: translateY(0);\n  }\n}\n\n@-webkit-keyframes fadeOut {\n  from {\n    opacity: 1;\n    -webkit-transform: translateY(0);\n    -ms-transform: translateY(0);\n    transform: translateY(0);\n  }\n  to {\n    opacity: 0;\n    -webkit-transform: translateY(-10px);\n    -ms-transform: translateY(-10px);\n    transform: translateY(-10px);\n  }\n}\n\n@keyframes fadeOut {\n  from {\n    opacity: 1;\n    -webkit-transform: translateY(0);\n    -ms-transform: translateY(0);\n    transform: translateY(0);\n  }\n  to {\n    opacity: 0;\n    -webkit-transform: translateY(-10px);\n    -ms-transform: translateY(-10px);\n    transform: translateY(-10px);\n  }\n}\n\n@-webkit-keyframes appearIn {\n  from {\n    opacity: 0;\n    -webkit-transform: translateY(0px);\n    -ms-transform: translateY(0px);\n    transform: translateY(0px);\n  }\n  to {\n    opacity: 1;\n    -webkit-transform: translateY(0);\n    -ms-transform: translateY(0);\n    transform: translateY(0);\n  }\n}\n\n@keyframes appearIn {\n  from {\n    opacity: 0;\n    -webkit-transform: translateY(0px);\n    -ms-transform: translateY(0px);\n    transform: translateY(0px);\n  }\n  to {\n    opacity: 1;\n    -webkit-transform: translateY(0);\n    -ms-transform: translateY(0);\n    transform: translateY(0);\n  }\n}\n\n@-webkit-keyframes scaleIn {\n  from {\n    -webkit-transform: scale(0);\n    -ms-transform: scale(0);\n    transform: scale(0);\n  }\n  to {\n    -webkit-transform: scale(1);\n    -ms-transform: scale(1);\n    transform: scale(1);\n  }\n}\n\n@keyframes scaleIn {\n  from {\n    -webkit-transform: scale(0);\n    -ms-transform: scale(0);\n    transform: scale(0);\n  }\n  to {\n    -webkit-transform: scale(1);\n    -ms-transform: scale(1);\n    transform: scale(1);\n  }\n}\n\n@-webkit-keyframes innerDrawIn {\n  0% {\n    stroke-dashoffset: 70;\n  }\n  50% {\n    stroke-dashoffset: 140;\n  }\n  100% {\n    stroke-dashoffset: 210;\n  }\n}\n\n@keyframes innerDrawIn {\n  0% {\n    stroke-dashoffset: 70;\n  }\n  50% {\n    stroke-dashoffset: 140;\n  }\n  100% {\n    stroke-dashoffset: 210;\n  }\n}\n\n@-webkit-keyframes outerDrawIn {\n  0% {\n    stroke-dashoffset: 76;\n  }\n  100% {\n    stroke-dashoffset: 152;\n  }\n}\n\n@keyframes outerDrawIn {\n  0% {\n    stroke-dashoffset: 76;\n  }\n  100% {\n    stroke-dashoffset: 152;\n  }\n}\n\n.hHWjkv {\n  -webkit-transform-origin: 0px 0px;\n  -ms-transform-origin: 0px 0px;\n  transform-origin: 0px 0px;\n  -webkit-transform: scale(0);\n  -ms-transform: scale(0);\n  transform: scale(0);\n  -webkit-animation: scaleIn 0.25s linear forwards 0.2222222222222222s;\n  animation: scaleIn 0.25s linear forwards 0.2222222222222222s;\n}\n\n.gCDOzd {\n  -webkit-transform-origin: 0px 0px;\n  -ms-transform-origin: 0px 0px;\n  transform-origin: 0px 0px;\n  -webkit-transform: scale(0);\n  -ms-transform: scale(0);\n  transform: scale(0);\n  -webkit-animation: scaleIn 0.25s linear forwards 0.4222222222222222s;\n  animation: scaleIn 0.25s linear forwards 0.4222222222222222s;\n}\n\n.hmCcxi {\n  -webkit-transform-origin: 0px 0px;\n  -ms-transform-origin: 0px 0px;\n  transform-origin: 0px 0px;\n  -webkit-transform: scale(0);\n  -ms-transform: scale(0);\n  transform: scale(0);\n  -webkit-animation: scaleIn 0.25s linear forwards 0.6222222222222222s;\n  animation: scaleIn 0.25s linear forwards 0.6222222222222222s;\n}\n\n.eHamQi {\n  -webkit-transform-origin: 0px 0px;\n  -ms-transform-origin: 0px 0px;\n  transform-origin: 0px 0px;\n  -webkit-transform: scale(0);\n  -ms-transform: scale(0);\n  transform: scale(0);\n  -webkit-animation: scaleIn 0.25s linear forwards 0.8222222222222223s;\n  animation: scaleIn 0.25s linear forwards 0.8222222222222223s;\n}\n\n.byhgGu {\n  -webkit-transform-origin: 0px 0px;\n  -ms-transform-origin: 0px 0px;\n  transform-origin: 0px 0px;\n  -webkit-transform: scale(0);\n  -ms-transform: scale(0);\n  transform: scale(0);\n  -webkit-animation: scaleIn 0.25s linear forwards 1.0222222222222221s;\n  animation: scaleIn 0.25s linear forwards 1.0222222222222221s;\n}\n\n.llAKP {\n  -webkit-transform-origin: 0px 0px;\n  -ms-transform-origin: 0px 0px;\n  transform-origin: 0px 0px;\n  -webkit-transform: scale(0);\n  -ms-transform: scale(0);\n  transform: scale(0);\n  -webkit-animation: scaleIn 0.25s linear forwards 1.2222222222222223s;\n  animation: scaleIn 0.25s linear forwards 1.2222222222222223s;\n}\n\n.bglIGM {\n  -webkit-transform-origin: 64px 28px;\n  -ms-transform-origin: 64px 28px;\n  transform-origin: 64px 28px;\n  -webkit-transform: scale(0);\n  -ms-transform: scale(0);\n  transform: scale(0);\n  -webkit-animation: scaleIn 0.25s linear forwards 0.2222222222222222s;\n  animation: scaleIn 0.25s linear forwards 0.2222222222222222s;\n}\n\n.ksxRII {\n  -webkit-transform-origin: 95.98500061035156px 46.510000228881836px;\n  -ms-transform-origin: 95.98500061035156px 46.510000228881836px;\n  transform-origin: 95.98500061035156px 46.510000228881836px;\n  -webkit-transform: scale(0);\n  -ms-transform: scale(0);\n  transform: scale(0);\n  -webkit-animation: scaleIn 0.25s linear forwards 0.4222222222222222s;\n  animation: scaleIn 0.25s linear forwards 0.4222222222222222s;\n}\n\n.cWrBmb {\n  -webkit-transform-origin: 95.97162628173828px 83.4900016784668px;\n  -ms-transform-origin: 95.97162628173828px 83.4900016784668px;\n  transform-origin: 95.97162628173828px 83.4900016784668px;\n  -webkit-transform: scale(0);\n  -ms-transform: scale(0);\n  transform: scale(0);\n  -webkit-animation: scaleIn 0.25s linear forwards 0.6222222222222222s;\n  animation: scaleIn 0.25s linear forwards 0.6222222222222222s;\n}\n\n.Wnusb {\n  -webkit-transform-origin: 64px 101.97999572753906px;\n  -ms-transform-origin: 64px 101.97999572753906px;\n  transform-origin: 64px 101.97999572753906px;\n  -webkit-transform: scale(0);\n  -ms-transform: scale(0);\n  transform: scale(0);\n  -webkit-animation: scaleIn 0.25s linear forwards 0.8222222222222223s;\n  animation: scaleIn 0.25s linear forwards 0.8222222222222223s;\n}\n\n.bfPqf {\n  -webkit-transform-origin: 32.03982162475586px 83.4900016784668px;\n  -ms-transform-origin: 32.03982162475586px 83.4900016784668px;\n  transform-origin: 32.03982162475586px 83.4900016784668px;\n  -webkit-transform: scale(0);\n  -ms-transform: scale(0);\n  transform: scale(0);\n  -webkit-animation: scaleIn 0.25s linear forwards 1.0222222222222221s;\n  animation: scaleIn 0.25s linear forwards 1.0222222222222221s;\n}\n\n.edRCTN {\n  -webkit-transform-origin: 32.033552169799805px 46.510000228881836px;\n  -ms-transform-origin: 32.033552169799805px 46.510000228881836px;\n  transform-origin: 32.033552169799805px 46.510000228881836px;\n  -webkit-transform: scale(0);\n  -ms-transform: scale(0);\n  transform: scale(0);\n  -webkit-animation: scaleIn 0.25s linear forwards 1.2222222222222223s;\n  animation: scaleIn 0.25s linear forwards 1.2222222222222223s;\n}\n\n.iEGVWn {\n  opacity: 0;\n  stroke-dasharray: 76;\n  -webkit-animation: outerDrawIn 0.5s ease-out forwards 0.3333333333333333s, appearIn 0.1s ease-out forwards 0.3333333333333333s;\n  animation: outerDrawIn 0.5s ease-out forwards 0.3333333333333333s, appearIn 0.1s ease-out forwards 0.3333333333333333s;\n  -webkit-animation-iteration-count: 1, 1;\n  animation-iteration-count: 1, 1;\n}\n\n.bsocdx {\n  opacity: 0;\n  stroke-dasharray: 76;\n  -webkit-animation: outerDrawIn 0.5s ease-out forwards 0.5333333333333333s, appearIn 0.1s ease-out forwards 0.5333333333333333s;\n  animation: outerDrawIn 0.5s ease-out forwards 0.5333333333333333s, appearIn 0.1s ease-out forwards 0.5333333333333333s;\n  -webkit-animation-iteration-count: 1, 1;\n  animation-iteration-count: 1, 1;\n}\n\n.jAZXmP {\n  opacity: 0;\n  stroke-dasharray: 76;\n  -webkit-animation: outerDrawIn 0.5s ease-out forwards 0.7333333333333334s, appearIn 0.1s ease-out forwards 0.7333333333333334s;\n  animation: outerDrawIn 0.5s ease-out forwards 0.7333333333333334s, appearIn 0.1s ease-out forwards 0.7333333333333334s;\n  -webkit-animation-iteration-count: 1, 1;\n  animation-iteration-count: 1, 1;\n}\n\n.hSeArx {\n  opacity: 0;\n  stroke-dasharray: 76;\n  -webkit-animation: outerDrawIn 0.5s ease-out forwards 0.9333333333333333s, appearIn 0.1s ease-out forwards 0.9333333333333333s;\n  animation: outerDrawIn 0.5s ease-out forwards 0.9333333333333333s, appearIn 0.1s ease-out forwards 0.9333333333333333s;\n  -webkit-animation-iteration-count: 1, 1;\n  animation-iteration-count: 1, 1;\n}\n\n.bVgqGk {\n  opacity: 0;\n  stroke-dasharray: 76;\n  -webkit-animation: outerDrawIn 0.5s ease-out forwards 1.1333333333333333s, appearIn 0.1s ease-out forwards 1.1333333333333333s;\n  animation: outerDrawIn 0.5s ease-out forwards 1.1333333333333333s, appearIn 0.1s ease-out forwards 1.1333333333333333s;\n  -webkit-animation-iteration-count: 1, 1;\n  animation-iteration-count: 1, 1;\n}\n\n.hEFqBt {\n  opacity: 0;\n  stroke-dasharray: 76;\n  -webkit-animation: outerDrawIn 0.5s ease-out forwards 1.3333333333333333s, appearIn 0.1s ease-out forwards 1.3333333333333333s;\n  animation: outerDrawIn 0.5s ease-out forwards 1.3333333333333333s, appearIn 0.1s ease-out forwards 1.3333333333333333s;\n  -webkit-animation-iteration-count: 1, 1;\n  animation-iteration-count: 1, 1;\n}\n\n.dzEKCM {\n  opacity: 0;\n  stroke-dasharray: 70;\n  -webkit-animation: innerDrawIn 1s ease-in-out forwards 1.3666666666666667s, appearIn 0.1s linear forwards 1.3666666666666667s;\n  animation: innerDrawIn 1s ease-in-out forwards 1.3666666666666667s, appearIn 0.1s linear forwards 1.3666666666666667s;\n  -webkit-animation-iteration-count: infinite, 1;\n  animation-iteration-count: infinite, 1;\n}\n\n.DYnPx {\n  opacity: 0;\n  stroke-dasharray: 70;\n  -webkit-animation: innerDrawIn 1s ease-in-out forwards 1.5333333333333332s, appearIn 0.1s linear forwards 1.5333333333333332s;\n  animation: innerDrawIn 1s ease-in-out forwards 1.5333333333333332s, appearIn 0.1s linear forwards 1.5333333333333332s;\n  -webkit-animation-iteration-count: infinite, 1;\n  animation-iteration-count: infinite, 1;\n}\n\n.hjPEAQ {\n  opacity: 0;\n  stroke-dasharray: 70;\n  -webkit-animation: innerDrawIn 1s ease-in-out forwards 1.7000000000000002s, appearIn 0.1s linear forwards 1.7000000000000002s;\n  animation: innerDrawIn 1s ease-in-out forwards 1.7000000000000002s, appearIn 0.1s linear forwards 1.7000000000000002s;\n  -webkit-animation-iteration-count: infinite, 1;\n  animation-iteration-count: infinite, 1;\n}\n\n#loading-wrapper {\n  position: absolute;\n  width: 100vw;\n  height: 100vh;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-align-items: center;\n  -webkit-box-align: center;\n  -ms-flex-align: center;\n  align-items: center;\n  -webkit-box-pack: center;\n  -webkit-justify-content: center;\n  -ms-flex-pack: center;\n  justify-content: center;\n  -webkit-flex-direction: column;\n  -ms-flex-direction: column;\n  flex-direction: column;\n}\n\n.logo {\n  width: 75px;\n  height: 75px;\n  margin-bottom: 20px;\n  opacity: 0;\n  -webkit-animation: fadeIn 0.5s ease-out forwards;\n  animation: fadeIn 0.5s ease-out forwards;\n}\n\n.text {\n  font-size: 32px;\n  font-weight: 200;\n  text-align: center;\n  color: rgba(255, 255, 255, 0.6);\n  opacity: 0;\n  -webkit-animation: fadeIn 0.5s ease-out forwards;\n  animation: fadeIn 0.5s ease-out forwards;\n}\n\n.dGfHfc {\n  font-weight: 400;\n}\n</style>\n<div id="loading-wrapper">\n<svg class="logo" viewBox="0 0 128 128" xmlns:xlink="http://www.w3.org/1999/xlink">\n  <title>GraphQL Playground Logo</title>\n  <defs>\n    <linearGradient id="linearGradient-1" x1="4.86%" x2="96.21%" y1="0%" y2="99.66%">\n      <stop stop-color="#E00082" stop-opacity=".8" offset="0%"></stop>\n      <stop stop-color="#E00082" offset="100%"></stop>\n    </linearGradient>\n  </defs>\n  <g>\n    <rect id="Gradient" width="127.96" height="127.96" y="1" fill="url(#linearGradient-1)" rx="4"></rect>\n    <path id="Border" fill="#E00082" fill-rule="nonzero" d="M4.7 2.84c-1.58 0-2.86 1.28-2.86 2.85v116.57c0 1.57 1.28 2.84 2.85 2.84h116.57c1.57 0 2.84-1.26 2.84-2.83V5.67c0-1.55-1.26-2.83-2.83-2.83H4.67zM4.7 0h116.58c3.14 0 5.68 2.55 5.68 5.7v116.58c0 3.14-2.54 5.68-5.68 5.68H4.68c-3.13 0-5.68-2.54-5.68-5.68V5.68C-1 2.56 1.55 0 4.7 0z"></path>\n    <path class="bglIGM" x="64" y="28" fill="#fff" d="M64 36c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8" style="transform: translate(100px, 100px);"></path>\n    <path class="ksxRII" x="95.98500061035156" y="46.510000228881836" fill="#fff" d="M89.04 50.52c-2.2-3.84-.9-8.73 2.94-10.96 3.83-2.2 8.72-.9 10.95 2.94 2.2 3.84.9 8.73-2.94 10.96-3.85 2.2-8.76.9-10.97-2.94"\n      style="transform: translate(100px, 100px);"></path>\n    <path class="cWrBmb" x="95.97162628173828" y="83.4900016784668" fill="#fff" d="M102.9 87.5c-2.2 3.84-7.1 5.15-10.94 2.94-3.84-2.2-5.14-7.12-2.94-10.96 2.2-3.84 7.12-5.15 10.95-2.94 3.86 2.23 5.16 7.12 2.94 10.96"\n      style="transform: translate(100px, 100px);"></path>\n    <path class="Wnusb" x="64" y="101.97999572753906" fill="#fff" d="M64 110c-4.43 0-8-3.6-8-8.02 0-4.44 3.57-8.02 8-8.02s8 3.58 8 8.02c0 4.4-3.57 8.02-8 8.02"\n      style="transform: translate(100px, 100px);"></path>\n    <path class="bfPqf" x="32.03982162475586" y="83.4900016784668" fill="#fff" d="M25.1 87.5c-2.2-3.84-.9-8.73 2.93-10.96 3.83-2.2 8.72-.9 10.95 2.94 2.2 3.84.9 8.73-2.94 10.96-3.85 2.2-8.74.9-10.95-2.94"\n      style="transform: translate(100px, 100px);"></path>\n    <path class="edRCTN" x="32.033552169799805" y="46.510000228881836" fill="#fff" d="M38.96 50.52c-2.2 3.84-7.12 5.15-10.95 2.94-3.82-2.2-5.12-7.12-2.92-10.96 2.2-3.84 7.12-5.15 10.95-2.94 3.83 2.23 5.14 7.12 2.94 10.96"\n      style="transform: translate(100px, 100px);"></path>\n    <path class="iEGVWn" stroke="#fff" stroke-width="4" stroke-linecap="round" stroke-linejoin="round" d="M63.55 27.5l32.9 19-32.9-19z"></path>\n    <path class="bsocdx" stroke="#fff" stroke-width="4" stroke-linecap="round" stroke-linejoin="round" d="M96 46v38-38z"></path>\n    <path class="jAZXmP" stroke="#fff" stroke-width="4" stroke-linecap="round" stroke-linejoin="round" d="M96.45 84.5l-32.9 19 32.9-19z"></path>\n    <path class="hSeArx" stroke="#fff" stroke-width="4" stroke-linecap="round" stroke-linejoin="round" d="M64.45 103.5l-32.9-19 32.9 19z"></path>\n    <path class="bVgqGk" stroke="#fff" stroke-width="4" stroke-linecap="round" stroke-linejoin="round" d="M32 84V46v38z"></path>\n    <path class="hEFqBt" stroke="#fff" stroke-width="4" stroke-linecap="round" stroke-linejoin="round" d="M31.55 46.5l32.9-19-32.9 19z"></path>\n    <path class="dzEKCM" id="Triangle-Bottom" stroke="#fff" stroke-width="4" d="M30 84h70" stroke-linecap="round"></path>\n    <path class="DYnPx" id="Triangle-Left" stroke="#fff" stroke-width="4" d="M65 26L30 87" stroke-linecap="round"></path>\n    <path class="hjPEAQ" id="Triangle-Right" stroke="#fff" stroke-width="4" d="M98 87L63 26" stroke-linecap="round"></path>\n  </g>\n</svg>\n<div class="text">Loading\n  <span class="dGfHfc">GraphQL Playground</span>\n</div>\n</div>\n'
      };
    };
    exports2.default = getLoadingMarkup;
  }
});

// ../../../node_modules/@apollographql/graphql-playground-html/dist/render-playground-page.js
var require_render_playground_page = __commonJS({
  "../../../node_modules/@apollographql/graphql-playground-html/dist/render-playground-page.js"(exports2) {
    "use strict";
    var __assign2 = exports2 && exports2.__assign || function() {
      __assign2 = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign2.apply(this, arguments);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.renderPlaygroundPage = void 0;
    var xss_1 = require_lib4();
    var get_loading_markup_1 = require_get_loading_markup();
    var filter = function(val) {
      return xss_1.filterXSS(val, {
        // @ts-ignore
        whiteList: [],
        stripIgnoreTag: true,
        stripIgnoreTagBody: ["script"]
      });
    };
    var loading = get_loading_markup_1.default();
    var reactPackageName = "@apollographql/graphql-playground-react";
    var getCdnMarkup = function(_a) {
      var version2 = _a.version, _b = _a.cdnUrl, cdnUrl = _b === void 0 ? "//cdn.jsdelivr.net/npm" : _b, faviconUrl = _a.faviconUrl;
      var buildCDNUrl = function(packageName, suffix) {
        return filter(cdnUrl + "/" + packageName + (version2 ? "@" + version2 : "") + "/" + suffix || "");
      };
      return '\n    <link\n      rel="stylesheet"\n      href="' + buildCDNUrl(reactPackageName, "build/static/css/index.css") + '"\n    />\n    ' + (typeof faviconUrl === "string" ? '<link rel="shortcut icon" href="' + filter(faviconUrl || "") + '" />' : "") + "\n    " + (faviconUrl === void 0 ? '<link rel="shortcut icon" href="' + buildCDNUrl(reactPackageName, "build/favicon.png") + '" />' : "") + '\n    <script\n      src="' + buildCDNUrl(reactPackageName, "build/static/js/middleware.js") + '"\n    ><\/script>\n';
    };
    var renderConfig = function(config) {
      return '<div id="playground-config" style="display: none;">' + xss_1.filterXSS(JSON.stringify(config), {
        // @ts-ignore
        whiteList: []
      }) + "</div>";
    };
    function renderPlaygroundPage(options) {
      var extendedOptions = __assign2(__assign2({}, options), { canSaveConfig: false });
      if (options.subscriptionsEndpoint) {
        extendedOptions.subscriptionEndpoint = filter(options.subscriptionsEndpoint || "");
      }
      if (options.config) {
        extendedOptions.configString = JSON.stringify(options.config, null, 2);
      }
      if (extendedOptions.endpoint) {
        extendedOptions.endpoint = filter(extendedOptions.endpoint || "");
      }
      return '\n  <!DOCTYPE html>\n  <html>\n  <head>\n    <meta charset=utf-8 />\n    <meta name="viewport" content="user-scalable=no, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, minimal-ui">\n    <link href="https://fonts.googleapis.com/css?family=Open+Sans:300,400,600,700|Source+Code+Pro:400,700" rel="stylesheet">\n    <title>' + (filter(extendedOptions.title) || "GraphQL Playground") + "</title>\n    " + (extendedOptions.env === "react" || extendedOptions.env === "electron" ? "" : getCdnMarkup(extendedOptions)) + '\n  </head>\n  <body>\n    <style type="text/css">\n      html {\n        font-family: "Open Sans", sans-serif;\n        overflow: hidden;\n      }\n  \n      body {\n        margin: 0;\n        background: #172a3a;\n      }\n  \n      .playgroundIn {\n        -webkit-animation: playgroundIn 0.5s ease-out forwards;\n        animation: playgroundIn 0.5s ease-out forwards;\n      }\n  \n      @-webkit-keyframes playgroundIn {\n        from {\n          opacity: 0;\n          -webkit-transform: translateY(10px);\n          -ms-transform: translateY(10px);\n          transform: translateY(10px);\n        }\n        to {\n          opacity: 1;\n          -webkit-transform: translateY(0);\n          -ms-transform: translateY(0);\n          transform: translateY(0);\n        }\n      }\n  \n      @keyframes playgroundIn {\n        from {\n          opacity: 0;\n          -webkit-transform: translateY(10px);\n          -ms-transform: translateY(10px);\n          transform: translateY(10px);\n        }\n        to {\n          opacity: 1;\n          -webkit-transform: translateY(0);\n          -ms-transform: translateY(0);\n          transform: translateY(0);\n        }\n      }\n    </style>\n    ' + loading.container + "\n    " + renderConfig(extendedOptions) + `
    <div id="root" />
    <script type="text/javascript">
      window.addEventListener('load', function (event) {
        ` + loading.script + `
  
        const root = document.getElementById('root');
        root.classList.add('playgroundIn');
        const configText = document.getElementById('playground-config').innerText
        if(configText && configText.length) {
          try {
            GraphQLPlayground.init(root, JSON.parse(configText))
          }
          catch(err) {
            console.error("could not find config")
          }
        }
      })
    <\/script>
  </body>
  </html>
`;
    }
    exports2.renderPlaygroundPage = renderPlaygroundPage;
  }
});

// ../../../node_modules/@apollographql/graphql-playground-html/dist/index.js
var require_dist10 = __commonJS({
  "../../../node_modules/@apollographql/graphql-playground-html/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var render_playground_page_1 = require_render_playground_page();
    Object.defineProperty(exports2, "renderPlaygroundPage", { enumerable: true, get: function() {
      return render_playground_page_1.renderPlaygroundPage;
    } });
  }
});

// ../../../node_modules/apollo-server-core/dist/plugin/landingPage/graphqlPlayground/index.js
var require_graphqlPlayground = __commonJS({
  "../../../node_modules/apollo-server-core/dist/plugin/landingPage/graphqlPlayground/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApolloServerPluginLandingPageGraphQLPlayground = void 0;
    var graphql_playground_html_1 = require_dist10();
    var defaultPlaygroundVersion = "1.7.42";
    function ApolloServerPluginLandingPageGraphQLPlayground(options = /* @__PURE__ */ Object.create(null)) {
      return {
        async serverWillStart() {
          return {
            async renderLandingPage() {
              return {
                html: (0, graphql_playground_html_1.renderPlaygroundPage)({
                  version: defaultPlaygroundVersion,
                  ...options
                })
              };
            }
          };
        }
      };
    }
    exports2.ApolloServerPluginLandingPageGraphQLPlayground = ApolloServerPluginLandingPageGraphQLPlayground;
  }
});

// ../../../node_modules/apollo-server-core/dist/plugin/index.js
var require_plugin2 = __commonJS({
  "../../../node_modules/apollo-server-core/dist/plugin/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApolloServerPluginLandingPageGraphQLPlayground = exports2.ApolloServerPluginLandingPageProductionDefault = exports2.ApolloServerPluginLandingPageLocalDefault = exports2.ApolloServerPluginLandingPageDisabled = exports2.ApolloServerPluginDrainHttpServer = exports2.ApolloServerPluginCacheControlDisabled = exports2.ApolloServerPluginCacheControl = exports2.ApolloServerPluginInlineTraceDisabled = exports2.ApolloServerPluginInlineTrace = exports2.ApolloServerPluginSchemaReporting = exports2.ApolloServerPluginUsageReportingDisabled = exports2.ApolloServerPluginUsageReporting = void 0;
    function ApolloServerPluginUsageReporting(options = /* @__PURE__ */ Object.create(null)) {
      return require_usageReporting().ApolloServerPluginUsageReporting(options);
    }
    exports2.ApolloServerPluginUsageReporting = ApolloServerPluginUsageReporting;
    function ApolloServerPluginUsageReportingDisabled() {
      return require_usageReporting().ApolloServerPluginUsageReportingDisabled();
    }
    exports2.ApolloServerPluginUsageReportingDisabled = ApolloServerPluginUsageReportingDisabled;
    function ApolloServerPluginSchemaReporting(options = /* @__PURE__ */ Object.create(null)) {
      return require_schemaReporting().ApolloServerPluginSchemaReporting(options);
    }
    exports2.ApolloServerPluginSchemaReporting = ApolloServerPluginSchemaReporting;
    function ApolloServerPluginInlineTrace(options = /* @__PURE__ */ Object.create(null)) {
      return require_inlineTrace().ApolloServerPluginInlineTrace(options);
    }
    exports2.ApolloServerPluginInlineTrace = ApolloServerPluginInlineTrace;
    function ApolloServerPluginInlineTraceDisabled() {
      return require_inlineTrace().ApolloServerPluginInlineTraceDisabled();
    }
    exports2.ApolloServerPluginInlineTraceDisabled = ApolloServerPluginInlineTraceDisabled;
    function ApolloServerPluginCacheControl(options = /* @__PURE__ */ Object.create(null)) {
      return require_cacheControl().ApolloServerPluginCacheControl(options);
    }
    exports2.ApolloServerPluginCacheControl = ApolloServerPluginCacheControl;
    function ApolloServerPluginCacheControlDisabled() {
      return require_cacheControl().ApolloServerPluginCacheControlDisabled();
    }
    exports2.ApolloServerPluginCacheControlDisabled = ApolloServerPluginCacheControlDisabled;
    function ApolloServerPluginDrainHttpServer(options) {
      return require_drainHttpServer().ApolloServerPluginDrainHttpServer(options);
    }
    exports2.ApolloServerPluginDrainHttpServer = ApolloServerPluginDrainHttpServer;
    function ApolloServerPluginLandingPageDisabled() {
      const plugin = {
        __internal_plugin_id__() {
          return "LandingPageDisabled";
        }
      };
      return plugin;
    }
    exports2.ApolloServerPluginLandingPageDisabled = ApolloServerPluginLandingPageDisabled;
    function ApolloServerPluginLandingPageLocalDefault(options) {
      return require_default().ApolloServerPluginLandingPageLocalDefault(options);
    }
    exports2.ApolloServerPluginLandingPageLocalDefault = ApolloServerPluginLandingPageLocalDefault;
    function ApolloServerPluginLandingPageProductionDefault(options) {
      return require_default().ApolloServerPluginLandingPageProductionDefault(options);
    }
    exports2.ApolloServerPluginLandingPageProductionDefault = ApolloServerPluginLandingPageProductionDefault;
    function ApolloServerPluginLandingPageGraphQLPlayground(options = /* @__PURE__ */ Object.create(null)) {
      return require_graphqlPlayground().ApolloServerPluginLandingPageGraphQLPlayground(options);
    }
    exports2.ApolloServerPluginLandingPageGraphQLPlayground = ApolloServerPluginLandingPageGraphQLPlayground;
  }
});

// ../../../node_modules/apollo-server-core/dist/internalPlugin.js
var require_internalPlugin = __commonJS({
  "../../../node_modules/apollo-server-core/dist/internalPlugin.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.pluginIsInternal = void 0;
    function pluginIsInternal(plugin) {
      return "__internal_plugin_id__" in plugin;
    }
    exports2.pluginIsInternal = pluginIsInternal;
  }
});

// ../../../node_modules/apollo-server-core/dist/utils/schemaManager.js
var require_schemaManager = __commonJS({
  "../../../node_modules/apollo-server-core/dist/utils/schemaManager.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GatewayIsTooOldError = exports2.SchemaManager = void 0;
    var SchemaManager = class {
      constructor(options) {
        this.onSchemaLoadOrUpdateListeners = /* @__PURE__ */ new Set();
        this.isStopped = false;
        this.logger = options.logger;
        this.schemaDerivedDataProvider = options.schemaDerivedDataProvider;
        if ("gateway" in options) {
          this.modeSpecificState = {
            mode: "gateway",
            gateway: options.gateway,
            apolloConfig: options.apolloConfig
          };
        } else {
          this.modeSpecificState = {
            mode: "schema",
            apiSchema: options.apiSchema,
            schemaDerivedData: options.schemaDerivedDataProvider(options.apiSchema)
          };
        }
      }
      async start() {
        if (this.modeSpecificState.mode === "gateway") {
          const gateway = this.modeSpecificState.gateway;
          if (gateway.onSchemaLoadOrUpdate) {
            this.modeSpecificState.unsubscribeFromGateway = gateway.onSchemaLoadOrUpdate((schemaContext) => {
              this.processSchemaLoadOrUpdateEvent(schemaContext);
            });
          } else if (gateway.onSchemaChange) {
            this.modeSpecificState.unsubscribeFromGateway = gateway.onSchemaChange((apiSchema) => {
              this.processSchemaLoadOrUpdateEvent({ apiSchema });
            });
          } else {
            throw new Error("Unexpectedly couldn't find onSchemaChange or onSchemaLoadOrUpdate on gateway");
          }
          const config = await this.modeSpecificState.gateway.load({
            apollo: this.modeSpecificState.apolloConfig
          });
          if (!this.schemaDerivedData) {
            this.processSchemaLoadOrUpdateEvent({ apiSchema: config.schema });
          }
          return config.executor;
        } else {
          this.processSchemaLoadOrUpdateEvent({
            apiSchema: this.modeSpecificState.apiSchema
          }, this.modeSpecificState.schemaDerivedData);
          return null;
        }
      }
      onSchemaLoadOrUpdate(callback) {
        if (this.modeSpecificState.mode === "gateway" && !this.modeSpecificState.gateway.onSchemaLoadOrUpdate) {
          throw new GatewayIsTooOldError([
            `Your gateway is too old to register a 'onSchemaLoadOrUpdate' listener.`,
            `Please update your version of @apollo/gateway to at least 0.35.0.`
          ].join(" "));
        } else {
          if (!this.schemaContext) {
            throw new Error("You must call start() before onSchemaLoadOrUpdate()");
          }
          if (!this.isStopped) {
            try {
              callback(this.schemaContext);
            } catch (e) {
              throw new Error(`An error was thrown from an 'onSchemaLoadOrUpdate' listener: ${e.message}`);
            }
          }
          this.onSchemaLoadOrUpdateListeners.add(callback);
        }
        return () => {
          this.onSchemaLoadOrUpdateListeners.delete(callback);
        };
      }
      getSchemaDerivedData() {
        if (!this.schemaDerivedData) {
          throw new Error("You must call start() before getSchemaDerivedData()");
        }
        return this.schemaDerivedData;
      }
      async stop() {
        var _a, _b, _c, _d;
        this.isStopped = true;
        if (this.modeSpecificState.mode === "gateway") {
          (_b = (_a = this.modeSpecificState).unsubscribeFromGateway) === null || _b === void 0 ? void 0 : _b.call(_a);
          await ((_d = (_c = this.modeSpecificState.gateway).stop) === null || _d === void 0 ? void 0 : _d.call(_c));
        }
      }
      processSchemaLoadOrUpdateEvent(schemaContext, schemaDerivedData) {
        if (!this.isStopped) {
          this.schemaDerivedData = schemaDerivedData !== null && schemaDerivedData !== void 0 ? schemaDerivedData : this.schemaDerivedDataProvider(schemaContext.apiSchema);
          this.schemaContext = schemaContext;
          this.onSchemaLoadOrUpdateListeners.forEach((listener) => {
            try {
              listener(schemaContext);
            } catch (e) {
              this.logger.error("An error was thrown from an 'onSchemaLoadOrUpdate' listener");
              this.logger.error(e);
            }
          });
        }
      }
    };
    exports2.SchemaManager = SchemaManager;
    var GatewayIsTooOldError = class extends Error {
      constructor(message) {
        super(message);
      }
    };
    exports2.GatewayIsTooOldError = GatewayIsTooOldError;
  }
});

// ../../../node_modules/apollo-server-core/dist/utils/UnboundedCache.js
var require_UnboundedCache = __commonJS({
  "../../../node_modules/apollo-server-core/dist/utils/UnboundedCache.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UnboundedCache = void 0;
    var UnboundedCache = class {
      constructor(cache = /* @__PURE__ */ new Map()) {
        this.cache = cache;
      }
      async get(key) {
        const entry = this.cache.get(key);
        if (!entry)
          return void 0;
        if (entry.deadline && entry.deadline <= Date.now()) {
          await this.delete(key);
          return void 0;
        }
        return entry.value;
      }
      async set(key, value, { ttl } = { ttl: null }) {
        this.cache.set(key, {
          value,
          deadline: ttl ? Date.now() + ttl * 1e3 : null
        });
      }
      async delete(key) {
        this.cache.delete(key);
      }
    };
    exports2.UnboundedCache = UnboundedCache;
  }
});

// ../../../node_modules/apollo-server-core/dist/ApolloServer.js
var require_ApolloServer = __commonJS({
  "../../../node_modules/apollo-server-core/dist/ApolloServer.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault2 = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k in mod2)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
            __createBinding2(result, mod2, k);
      }
      __setModuleDefault2(result, mod2);
      return result;
    };
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isImplicitlyInstallablePlugin = exports2.ApolloServerBase = void 0;
    var mock_1 = require_cjs4();
    var schema_1 = require_cjs8();
    var loglevel_1 = __importDefault2(require_loglevel());
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var resolvable_1 = __importDefault2(require_resolvable());
    var utils_keyvaluecache_1 = require_dist3();
    var schemaHash_1 = require_schemaHash();
    var requestPipeline_1 = require_requestPipeline();
    var apollo_server_env_1 = require_index_browser();
    var apollo_tools_1 = require_lib();
    var runHttpQuery_1 = require_runHttpQuery();
    var isNodeLike_1 = __importDefault2(require_isNodeLike());
    var determineApolloConfig_1 = require_determineApolloConfig();
    var plugin_1 = require_plugin2();
    var internalPlugin_1 = require_internalPlugin();
    var cachePolicy_1 = require_cachePolicy();
    var schemaManager_1 = require_schemaManager();
    var uuid = __importStar2(require_commonjs_browser());
    var UnboundedCache_1 = require_UnboundedCache();
    var NoIntrospection = (context) => ({
      Field(node) {
        if (node.name.value === "__schema" || node.name.value === "__type") {
          context.reportError(new graphql_1.GraphQLError("GraphQL introspection is not allowed by Apollo Server, but the query contained __schema or __type. To enable introspection, pass introspection: true to ApolloServer in production", [node]));
        }
      }
    });
    var UnreachableCaseError = class extends Error {
      constructor(val) {
        super(`Unreachable case: ${val}`);
      }
    };
    var recommendedCsrfPreventionRequestHeaders = [
      "x-apollo-operation-name",
      "apollo-require-preflight"
    ];
    var ApolloServerBase = class {
      constructor(config) {
        var _a, _b;
        this.graphqlPath = "/graphql";
        this.requestOptions = /* @__PURE__ */ Object.create(null);
        this.plugins = [];
        this.toDispose = /* @__PURE__ */ new Set();
        this.toDisposeLast = /* @__PURE__ */ new Set();
        this.drainServers = null;
        this.landingPage = null;
        if (!config)
          throw new Error("ApolloServer requires options.");
        this.config = {
          ...config,
          nodeEnv: (_a = config.nodeEnv) !== null && _a !== void 0 ? _a : "development"
        };
        const { context, resolvers, schema, modules, typeDefs, parseOptions = {}, introspection, plugins, gateway, apollo, stopOnTerminationSignals, mocks, mockEntireSchema, documentStore, csrfPrevention, ...requestOptions } = this.config;
        if (config.logger) {
          this.logger = config.logger;
        } else {
          const loglevelLogger = loglevel_1.default.getLogger("apollo-server");
          if (this.config.debug === true) {
            loglevelLogger.setLevel(loglevel_1.default.levels.DEBUG);
          } else {
            loglevelLogger.setLevel(loglevel_1.default.levels.INFO);
          }
          this.logger = loglevelLogger;
        }
        this.apolloConfig = (0, determineApolloConfig_1.determineApolloConfig)(apollo);
        if (gateway && (modules || schema || typeDefs || resolvers)) {
          throw new Error("Cannot define both `gateway` and any of: `modules`, `schema`, `typeDefs`, or `resolvers`");
        }
        this.parseOptions = parseOptions;
        this.context = context;
        this.csrfPreventionRequestHeaders = csrfPrevention === true ? recommendedCsrfPreventionRequestHeaders : csrfPrevention === false ? null : csrfPrevention === void 0 ? null : (_b = csrfPrevention.requestHeaders) !== null && _b !== void 0 ? _b : recommendedCsrfPreventionRequestHeaders;
        const isDev = this.config.nodeEnv !== "production";
        this.stopOnTerminationSignals = typeof stopOnTerminationSignals === "boolean" ? stopOnTerminationSignals : isNodeLike_1.default && this.config.nodeEnv !== "test" && !this.serverlessFramework();
        if (typeof introspection === "boolean" && !introspection || introspection === void 0 && !isDev) {
          const noIntro = [NoIntrospection];
          requestOptions.validationRules = requestOptions.validationRules ? requestOptions.validationRules.concat(noIntro) : noIntro;
        }
        if (requestOptions.cache === "bounded") {
          requestOptions.cache = new utils_keyvaluecache_1.InMemoryLRUCache();
        }
        if (!requestOptions.cache) {
          requestOptions.cache = new UnboundedCache_1.UnboundedCache();
          if (!isDev && (requestOptions.persistedQueries === void 0 || requestOptions.persistedQueries && !requestOptions.persistedQueries.cache)) {
            this.logger.warn('Persisted queries are enabled and are using an unbounded cache. Your server is vulnerable to denial of service attacks via memory exhaustion. Set `cache: "bounded"` or `persistedQueries: false` in your ApolloServer constructor, or see https://go.apollo.dev/s/cache-backends for other alternatives.');
          }
        }
        if (requestOptions.persistedQueries !== false) {
          const { cache: apqCache = requestOptions.cache, ...apqOtherOptions } = requestOptions.persistedQueries || /* @__PURE__ */ Object.create(null);
          requestOptions.persistedQueries = {
            cache: new utils_keyvaluecache_1.PrefixingKeyValueCache(apqCache, requestPipeline_1.APQ_CACHE_PREFIX),
            ...apqOtherOptions
          };
        } else {
          delete requestOptions.persistedQueries;
        }
        this.requestOptions = requestOptions;
        this.ensurePluginInstantiation(plugins, isDev);
        if (gateway) {
          this.state = {
            phase: "initialized",
            schemaManager: new schemaManager_1.SchemaManager({
              gateway,
              apolloConfig: this.apolloConfig,
              schemaDerivedDataProvider: (schema2) => this.generateSchemaDerivedData(schema2),
              logger: this.logger
            })
          };
        } else {
          this.state = {
            phase: "initialized",
            schemaManager: new schemaManager_1.SchemaManager({
              apiSchema: this.maybeAddMocksToConstructedSchema(this.constructSchema()),
              schemaDerivedDataProvider: (schema2) => this.generateSchemaDerivedData(schema2),
              logger: this.logger
            })
          };
        }
        if (this.serverlessFramework()) {
          this._start().catch((e) => this.logStartupError(e));
        }
      }
      async start() {
        if (this.serverlessFramework()) {
          throw new Error("When using an ApolloServer subclass from a serverless framework package, you don't need to call start(); just call createHandler().");
        }
        return await this._start();
      }
      async _start() {
        var _a;
        if (this.state.phase !== "initialized") {
          throw new Error(`called start() with surprising state ${this.state.phase}`);
        }
        const schemaManager = this.state.schemaManager;
        const barrier = (0, resolvable_1.default)();
        this.state = {
          phase: "starting",
          barrier,
          schemaManager
        };
        try {
          const executor = await schemaManager.start();
          this.toDispose.add(async () => {
            await schemaManager.stop();
          });
          if (executor) {
            this.requestOptions.executor = executor;
          }
          const schemaDerivedData = schemaManager.getSchemaDerivedData();
          const service = {
            logger: this.logger,
            schema: schemaDerivedData.schema,
            schemaHash: schemaDerivedData.schemaHash,
            apollo: this.apolloConfig,
            serverlessFramework: this.serverlessFramework()
          };
          if ((_a = this.requestOptions.persistedQueries) === null || _a === void 0 ? void 0 : _a.cache) {
            service.persistedQueries = {
              cache: this.requestOptions.persistedQueries.cache
            };
          }
          const taggedServerListeners = (await Promise.all(this.plugins.map(async (plugin) => ({
            serverListener: plugin.serverWillStart && await plugin.serverWillStart(service),
            installedImplicitly: isImplicitlyInstallablePlugin(plugin) && plugin.__internal_installed_implicitly__
          })))).filter((maybeTaggedServerListener) => typeof maybeTaggedServerListener.serverListener === "object");
          taggedServerListeners.forEach(({ serverListener: { schemaDidLoadOrUpdate } }) => {
            if (schemaDidLoadOrUpdate) {
              try {
                schemaManager.onSchemaLoadOrUpdate(schemaDidLoadOrUpdate);
              } catch (e) {
                if (e instanceof schemaManager_1.GatewayIsTooOldError) {
                  throw new Error([
                    `One of your plugins uses the 'schemaDidLoadOrUpdate' hook,`,
                    `but your gateway version is too old to support this hook.`,
                    `Please update your version of @apollo/gateway to at least 0.35.0.`
                  ].join(" "));
                }
                throw e;
              }
            }
          });
          const serverWillStops = taggedServerListeners.flatMap((l) => l.serverListener.serverWillStop ? [l.serverListener.serverWillStop] : []);
          if (serverWillStops.length) {
            this.toDispose.add(async () => {
              await Promise.all(serverWillStops.map((serverWillStop) => serverWillStop()));
            });
          }
          const drainServerCallbacks = taggedServerListeners.flatMap((l) => l.serverListener.drainServer ? [l.serverListener.drainServer] : []);
          if (drainServerCallbacks.length) {
            this.drainServers = async () => {
              await Promise.all(drainServerCallbacks.map((drainServer) => drainServer()));
            };
          }
          let taggedServerListenersWithRenderLandingPage = taggedServerListeners.filter((l) => l.serverListener.renderLandingPage);
          if (taggedServerListenersWithRenderLandingPage.length > 1) {
            taggedServerListenersWithRenderLandingPage = taggedServerListenersWithRenderLandingPage.filter((l) => !l.installedImplicitly);
          }
          if (taggedServerListenersWithRenderLandingPage.length > 1) {
            throw Error("Only one plugin can implement renderLandingPage.");
          } else if (taggedServerListenersWithRenderLandingPage.length) {
            this.landingPage = await taggedServerListenersWithRenderLandingPage[0].serverListener.renderLandingPage();
          } else {
            this.landingPage = null;
          }
          this.state = {
            phase: "started",
            schemaManager
          };
          this.maybeRegisterTerminationSignalHandlers(["SIGINT", "SIGTERM"]);
        } catch (error) {
          this.state = { phase: "failed to start", error };
          throw error;
        } finally {
          barrier.resolve();
        }
      }
      maybeRegisterTerminationSignalHandlers(signals) {
        if (!this.stopOnTerminationSignals) {
          return;
        }
        let receivedSignal = false;
        const signalHandler = async (signal) => {
          if (receivedSignal) {
            return;
          }
          receivedSignal = true;
          try {
            await this.stop();
          } catch (e) {
            this.logger.error(`stop() threw during ${signal} shutdown`);
            this.logger.error(e);
            process.exit(1);
          }
          process.kill(process.pid, signal);
        };
        signals.forEach((signal) => {
          process.on(signal, signalHandler);
          this.toDisposeLast.add(async () => {
            process.removeListener(signal, signalHandler);
          });
        });
      }
      async _ensureStarted() {
        while (true) {
          switch (this.state.phase) {
            case "initialized":
              throw new Error("You need to call `server.start()` before using your Apollo Server.");
            case "starting":
              await this.state.barrier;
              break;
            case "failed to start":
              this.logStartupError(this.state.error);
              throw new Error("This data graph is missing a valid configuration. More details may be available in the server logs.");
            case "started":
            case "draining":
              return this.state.schemaManager.getSchemaDerivedData();
            case "stopping":
              throw new Error("Cannot execute GraphQL operations while the server is stopping.");
            case "stopped":
              throw new Error("Cannot execute GraphQL operations after the server has stopped.");
            default:
              throw new UnreachableCaseError(this.state);
          }
        }
      }
      async ensureStarted() {
        await this._ensureStarted();
      }
      assertStarted(methodName) {
        if (this.state.phase !== "started" && this.state.phase !== "draining") {
          throw new Error("You must `await server.start()` before calling `server." + methodName + "()`");
        }
      }
      logStartupError(err) {
        this.logger.error("An error occurred during Apollo Server startup. All GraphQL requests will now fail. The startup error was: " + ((err === null || err === void 0 ? void 0 : err.message) || err));
      }
      constructSchema() {
        const { schema, modules, typeDefs, resolvers, parseOptions } = this.config;
        if (schema) {
          return schema;
        }
        if (modules) {
          const { schema: schema2, errors } = (0, apollo_tools_1.buildServiceDefinition)(modules);
          if (errors && errors.length > 0) {
            throw new Error(errors.map((error) => error.message).join("\n\n"));
          }
          return schema2;
        }
        if (!typeDefs) {
          throw Error("Apollo Server requires either an existing schema, modules or typeDefs");
        }
        const augmentedTypeDefs = Array.isArray(typeDefs) ? typeDefs : [typeDefs];
        return (0, schema_1.makeExecutableSchema)({
          typeDefs: augmentedTypeDefs,
          resolvers,
          parseOptions
        });
      }
      maybeAddMocksToConstructedSchema(schema) {
        const { mocks, mockEntireSchema } = this.config;
        if (mocks === false) {
          return schema;
        }
        if (!mocks && typeof mockEntireSchema === "undefined") {
          return schema;
        }
        return (0, mock_1.addMocksToSchema)({
          schema,
          mocks: mocks === true || typeof mocks === "undefined" ? {} : mocks,
          preserveResolvers: typeof mockEntireSchema === "undefined" ? false : !mockEntireSchema
        });
      }
      generateSchemaDerivedData(schema) {
        const schemaHash = (0, schemaHash_1.generateSchemaHash)(schema);
        return {
          schema,
          schemaHash,
          documentStore: this.config.documentStore === void 0 ? new utils_keyvaluecache_1.InMemoryLRUCache() : this.config.documentStore === null ? null : new utils_keyvaluecache_1.PrefixingKeyValueCache(this.config.documentStore, `${uuid.v4()}:`)
        };
      }
      async stop() {
        var _a;
        switch (this.state.phase) {
          case "initialized":
          case "starting":
          case "failed to start":
            throw Error("apolloServer.stop() should only be called after `await apolloServer.start()` has succeeded");
          case "stopped":
            if (this.state.stopError) {
              throw this.state.stopError;
            }
            return;
          case "stopping":
          case "draining": {
            await this.state.barrier;
            const state = this.state;
            if (state.phase !== "stopped") {
              throw Error(`Surprising post-stopping state ${state.phase}`);
            }
            if (state.stopError) {
              throw state.stopError;
            }
            return;
          }
          case "started":
            break;
          default:
            throw new UnreachableCaseError(this.state);
        }
        const barrier = (0, resolvable_1.default)();
        this.state = {
          phase: "draining",
          schemaManager: this.state.schemaManager,
          barrier
        };
        try {
          await ((_a = this.drainServers) === null || _a === void 0 ? void 0 : _a.call(this));
          this.state = { phase: "stopping", barrier };
          await Promise.all([...this.toDispose].map((dispose) => dispose()));
          await Promise.all([...this.toDisposeLast].map((dispose) => dispose()));
        } catch (stopError) {
          this.state = { phase: "stopped", stopError };
          barrier.resolve();
          throw stopError;
        }
        this.state = { phase: "stopped", stopError: null };
      }
      serverlessFramework() {
        return false;
      }
      ensurePluginInstantiation(userPlugins = [], isDev) {
        this.plugins = userPlugins.map((plugin) => {
          if (typeof plugin === "function") {
            return plugin();
          }
          return plugin;
        });
        const alreadyHavePluginWithInternalId = (id) => this.plugins.some((p) => (0, internalPlugin_1.pluginIsInternal)(p) && p.__internal_plugin_id__() === id);
        {
          if (!alreadyHavePluginWithInternalId("CacheControl")) {
            this.plugins.push((0, plugin_1.ApolloServerPluginCacheControl)());
          }
        }
        {
          const alreadyHavePlugin2 = alreadyHavePluginWithInternalId("UsageReporting");
          if (!alreadyHavePlugin2 && this.apolloConfig.key) {
            if (this.apolloConfig.graphRef) {
              this.plugins.unshift((0, plugin_1.ApolloServerPluginUsageReporting)());
            } else {
              this.logger.warn("You have specified an Apollo key but have not specified a graph ref; usage reporting is disabled. To enable usage reporting, set the `APOLLO_GRAPH_REF` environment variable to `your-graph-id@your-graph-variant`. To disable this warning, install `ApolloServerPluginUsageReportingDisabled`.");
            }
          }
        }
        {
          const alreadyHavePlugin2 = alreadyHavePluginWithInternalId("SchemaReporting");
          const enabledViaEnvVar = process.env.APOLLO_SCHEMA_REPORTING === "true";
          if (!alreadyHavePlugin2 && enabledViaEnvVar) {
            if (this.apolloConfig.key) {
              const options = {};
              this.plugins.push((0, plugin_1.ApolloServerPluginSchemaReporting)(options));
            } else {
              throw new Error("You've enabled schema reporting by setting the APOLLO_SCHEMA_REPORTING environment variable to true, but you also need to provide your Apollo API key, via the APOLLO_KEY environment variable or via `new ApolloServer({apollo: {key})");
            }
          }
        }
        {
          const alreadyHavePlugin2 = alreadyHavePluginWithInternalId("InlineTrace");
          if (!alreadyHavePlugin2) {
            this.plugins.push((0, plugin_1.ApolloServerPluginInlineTrace)({ __onlyIfSchemaIsFederated: true }));
          }
        }
        const alreadyHavePlugin = alreadyHavePluginWithInternalId("LandingPageDisabled");
        if (!alreadyHavePlugin) {
          const plugin = isDev ? (0, plugin_1.ApolloServerPluginLandingPageLocalDefault)() : (0, plugin_1.ApolloServerPluginLandingPageProductionDefault)();
          if (!isImplicitlyInstallablePlugin(plugin)) {
            throw Error("default landing page plugin should be implicitly installable?");
          }
          plugin.__internal_installed_implicitly__ = true;
          this.plugins.push(plugin);
        }
      }
      async graphQLServerOptions(integrationContextArgument) {
        const { schema, schemaHash, documentStore } = await this._ensureStarted();
        let context = this.context ? this.context : {};
        try {
          context = typeof this.context === "function" ? await this.context(integrationContextArgument || {}) : context;
        } catch (error) {
          context = () => {
            throw error;
          };
        }
        return {
          schema,
          schemaHash,
          logger: this.logger,
          plugins: this.plugins,
          documentStore,
          context,
          parseOptions: this.parseOptions,
          ...this.requestOptions
        };
      }
      async executeOperation(request, integrationContextArgument) {
        if (this.state.phase === "initialized") {
          await this._start();
        }
        const options = await this.graphQLServerOptions(integrationContextArgument);
        if (typeof options.context === "function") {
          options.context = options.context();
        } else if (typeof options.context === "object") {
          options.context = (0, runHttpQuery_1.cloneObject)(options.context);
        }
        const requestCtx = {
          logger: this.logger,
          schema: options.schema,
          schemaHash: options.schemaHash,
          request: {
            ...request,
            query: request.query && typeof request.query !== "string" ? (0, graphql_1.print)(request.query) : request.query
          },
          context: options.context || /* @__PURE__ */ Object.create(null),
          cache: options.cache,
          metrics: {},
          response: {
            http: {
              headers: new apollo_server_env_1.Headers()
            }
          },
          debug: options.debug,
          overallCachePolicy: (0, cachePolicy_1.newCachePolicy)(),
          requestIsBatched: false
        };
        return (0, requestPipeline_1.processGraphQLRequest)(options, requestCtx);
      }
      getLandingPage() {
        this.assertStarted("getLandingPage");
        return this.landingPage;
      }
    };
    exports2.ApolloServerBase = ApolloServerBase;
    function isImplicitlyInstallablePlugin(p) {
      return "__internal_installed_implicitly__" in p;
    }
    exports2.isImplicitlyInstallablePlugin = isImplicitlyInstallablePlugin;
  }
});

// ../../../node_modules/apollo-server-core/dist/types.js
var require_types7 = __commonJS({
  "../../../node_modules/apollo-server-core/dist/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../../node_modules/apollo-server-core/dist/index.js
var require_dist11 = __commonJS({
  "../../../node_modules/apollo-server-core/dist/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApolloServerBase = exports2.convertNodeHttpToRequest = exports2.formatApolloErrors = exports2.UserInputError = exports2.ForbiddenError = exports2.AuthenticationError = exports2.ValidationError = exports2.SyntaxError = exports2.toApolloError = exports2.ApolloError = exports2.resolveGraphqlOptions = exports2.isHttpQueryError = exports2.HttpQueryError = exports2.runHttpQuery = void 0;
    var runHttpQuery_1 = require_runHttpQuery();
    Object.defineProperty(exports2, "runHttpQuery", { enumerable: true, get: function() {
      return runHttpQuery_1.runHttpQuery;
    } });
    Object.defineProperty(exports2, "HttpQueryError", { enumerable: true, get: function() {
      return runHttpQuery_1.HttpQueryError;
    } });
    Object.defineProperty(exports2, "isHttpQueryError", { enumerable: true, get: function() {
      return runHttpQuery_1.isHttpQueryError;
    } });
    var graphqlOptions_1 = require_graphqlOptions();
    Object.defineProperty(exports2, "resolveGraphqlOptions", { enumerable: true, get: function() {
      return graphqlOptions_1.resolveGraphqlOptions;
    } });
    var apollo_server_errors_1 = require_dist();
    Object.defineProperty(exports2, "ApolloError", { enumerable: true, get: function() {
      return apollo_server_errors_1.ApolloError;
    } });
    Object.defineProperty(exports2, "toApolloError", { enumerable: true, get: function() {
      return apollo_server_errors_1.toApolloError;
    } });
    Object.defineProperty(exports2, "SyntaxError", { enumerable: true, get: function() {
      return apollo_server_errors_1.SyntaxError;
    } });
    Object.defineProperty(exports2, "ValidationError", { enumerable: true, get: function() {
      return apollo_server_errors_1.ValidationError;
    } });
    Object.defineProperty(exports2, "AuthenticationError", { enumerable: true, get: function() {
      return apollo_server_errors_1.AuthenticationError;
    } });
    Object.defineProperty(exports2, "ForbiddenError", { enumerable: true, get: function() {
      return apollo_server_errors_1.ForbiddenError;
    } });
    Object.defineProperty(exports2, "UserInputError", { enumerable: true, get: function() {
      return apollo_server_errors_1.UserInputError;
    } });
    Object.defineProperty(exports2, "formatApolloErrors", { enumerable: true, get: function() {
      return apollo_server_errors_1.formatApolloErrors;
    } });
    var nodeHttpToRequest_1 = require_nodeHttpToRequest();
    Object.defineProperty(exports2, "convertNodeHttpToRequest", { enumerable: true, get: function() {
      return nodeHttpToRequest_1.convertNodeHttpToRequest;
    } });
    var ApolloServer_1 = require_ApolloServer();
    Object.defineProperty(exports2, "ApolloServerBase", { enumerable: true, get: function() {
      return ApolloServer_1.ApolloServerBase;
    } });
    __exportStar2(require_types7(), exports2);
    var apollo_server_types_1 = require_dist2();
    __exportStar2(require_gql(), exports2);
    __exportStar2(require_plugin2(), exports2);
  }
});

// ../../../node_modules/depd/lib/browser/index.js
var require_browser2 = __commonJS({
  "../../../node_modules/depd/lib/browser/index.js"(exports2, module2) {
    "use strict";
    module2.exports = depd;
    function depd(namespace) {
      if (!namespace) {
        throw new TypeError("argument namespace is required");
      }
      function deprecate(message) {
      }
      deprecate._file = void 0;
      deprecate._ignored = true;
      deprecate._namespace = namespace;
      deprecate._traced = false;
      deprecate._warned = /* @__PURE__ */ Object.create(null);
      deprecate.function = wrapfunction;
      deprecate.property = wrapproperty;
      return deprecate;
    }
    function wrapfunction(fn, message) {
      if (typeof fn !== "function") {
        throw new TypeError("argument fn must be a function");
      }
      return fn;
    }
    function wrapproperty(obj, prop, message) {
      if (!obj || typeof obj !== "object" && typeof obj !== "function") {
        throw new TypeError("argument obj must be object");
      }
      var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
      if (!descriptor) {
        throw new TypeError("must call property on owner object");
      }
      if (!descriptor.configurable) {
        throw new TypeError("property must be configurable");
      }
    }
  }
});

// ../../../node_modules/bytes/index.js
var require_bytes = __commonJS({
  "../../../node_modules/bytes/index.js"(exports2, module2) {
    "use strict";
    module2.exports = bytes;
    module2.exports.format = format;
    module2.exports.parse = parse2;
    var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;
    var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;
    var map = {
      b: 1,
      kb: 1 << 10,
      mb: 1 << 20,
      gb: 1 << 30,
      tb: Math.pow(1024, 4),
      pb: Math.pow(1024, 5)
    };
    var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i;
    function bytes(value, options) {
      if (typeof value === "string") {
        return parse2(value);
      }
      if (typeof value === "number") {
        return format(value, options);
      }
      return null;
    }
    function format(value, options) {
      if (!Number.isFinite(value)) {
        return null;
      }
      var mag = Math.abs(value);
      var thousandsSeparator = options && options.thousandsSeparator || "";
      var unitSeparator = options && options.unitSeparator || "";
      var decimalPlaces = options && options.decimalPlaces !== void 0 ? options.decimalPlaces : 2;
      var fixedDecimals = Boolean(options && options.fixedDecimals);
      var unit = options && options.unit || "";
      if (!unit || !map[unit.toLowerCase()]) {
        if (mag >= map.pb) {
          unit = "PB";
        } else if (mag >= map.tb) {
          unit = "TB";
        } else if (mag >= map.gb) {
          unit = "GB";
        } else if (mag >= map.mb) {
          unit = "MB";
        } else if (mag >= map.kb) {
          unit = "KB";
        } else {
          unit = "B";
        }
      }
      var val = value / map[unit.toLowerCase()];
      var str = val.toFixed(decimalPlaces);
      if (!fixedDecimals) {
        str = str.replace(formatDecimalsRegExp, "$1");
      }
      if (thousandsSeparator) {
        str = str.split(".").map(function(s, i) {
          return i === 0 ? s.replace(formatThousandsRegExp, thousandsSeparator) : s;
        }).join(".");
      }
      return str + unitSeparator + unit;
    }
    function parse2(val) {
      if (typeof val === "number" && !isNaN(val)) {
        return val;
      }
      if (typeof val !== "string") {
        return null;
      }
      var results = parseRegExp.exec(val);
      var floatValue;
      var unit = "b";
      if (!results) {
        floatValue = parseInt(val, 10);
        unit = "b";
      } else {
        floatValue = parseFloat(results[1]);
        unit = results[4].toLowerCase();
      }
      if (isNaN(floatValue)) {
        return null;
      }
      return Math.floor(map[unit] * floatValue);
    }
  }
});

// ../../../node_modules/content-type/index.js
var require_content_type = __commonJS({
  "../../../node_modules/content-type/index.js"(exports2) {
    "use strict";
    var PARAM_REGEXP = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g;
    var TEXT_REGEXP = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/;
    var TOKEN_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
    var QESC_REGEXP = /\\([\u000b\u0020-\u00ff])/g;
    var QUOTE_REGEXP = /([\\"])/g;
    var TYPE_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
    exports2.format = format;
    exports2.parse = parse2;
    function format(obj) {
      if (!obj || typeof obj !== "object") {
        throw new TypeError("argument obj is required");
      }
      var parameters = obj.parameters;
      var type = obj.type;
      if (!type || !TYPE_REGEXP.test(type)) {
        throw new TypeError("invalid type");
      }
      var string = type;
      if (parameters && typeof parameters === "object") {
        var param;
        var params = Object.keys(parameters).sort();
        for (var i = 0; i < params.length; i++) {
          param = params[i];
          if (!TOKEN_REGEXP.test(param)) {
            throw new TypeError("invalid parameter name");
          }
          string += "; " + param + "=" + qstring(parameters[param]);
        }
      }
      return string;
    }
    function parse2(string) {
      if (!string) {
        throw new TypeError("argument string is required");
      }
      var header = typeof string === "object" ? getcontenttype(string) : string;
      if (typeof header !== "string") {
        throw new TypeError("argument string is required to be a string");
      }
      var index = header.indexOf(";");
      var type = index !== -1 ? header.slice(0, index).trim() : header.trim();
      if (!TYPE_REGEXP.test(type)) {
        throw new TypeError("invalid media type");
      }
      var obj = new ContentType(type.toLowerCase());
      if (index !== -1) {
        var key;
        var match;
        var value;
        PARAM_REGEXP.lastIndex = index;
        while (match = PARAM_REGEXP.exec(header)) {
          if (match.index !== index) {
            throw new TypeError("invalid parameter format");
          }
          index += match[0].length;
          key = match[1].toLowerCase();
          value = match[2];
          if (value.charCodeAt(0) === 34) {
            value = value.slice(1, -1);
            if (value.indexOf("\\") !== -1) {
              value = value.replace(QESC_REGEXP, "$1");
            }
          }
          obj.parameters[key] = value;
        }
        if (index !== header.length) {
          throw new TypeError("invalid parameter format");
        }
      }
      return obj;
    }
    function getcontenttype(obj) {
      var header;
      if (typeof obj.getHeader === "function") {
        header = obj.getHeader("content-type");
      } else if (typeof obj.headers === "object") {
        header = obj.headers && obj.headers["content-type"];
      }
      if (typeof header !== "string") {
        throw new TypeError("content-type header is missing from object");
      }
      return header;
    }
    function qstring(val) {
      var str = String(val);
      if (TOKEN_REGEXP.test(str)) {
        return str;
      }
      if (str.length > 0 && !TEXT_REGEXP.test(str)) {
        throw new TypeError("invalid parameter value");
      }
      return '"' + str.replace(QUOTE_REGEXP, "\\$1") + '"';
    }
    function ContentType(type) {
      this.parameters = /* @__PURE__ */ Object.create(null);
      this.type = type;
    }
  }
});

// ../../../node_modules/setprototypeof/index.js
var require_setprototypeof = __commonJS({
  "../../../node_modules/setprototypeof/index.js"(exports2, module2) {
    "use strict";
    module2.exports = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? setProtoOf : mixinProperties);
    function setProtoOf(obj, proto) {
      obj.__proto__ = proto;
      return obj;
    }
    function mixinProperties(obj, proto) {
      for (var prop in proto) {
        if (!Object.prototype.hasOwnProperty.call(obj, prop)) {
          obj[prop] = proto[prop];
        }
      }
      return obj;
    }
  }
});

// ../../../node_modules/statuses/codes.json
var require_codes = __commonJS({
  "../../../node_modules/statuses/codes.json"(exports2, module2) {
    module2.exports = {
      "100": "Continue",
      "101": "Switching Protocols",
      "102": "Processing",
      "103": "Early Hints",
      "200": "OK",
      "201": "Created",
      "202": "Accepted",
      "203": "Non-Authoritative Information",
      "204": "No Content",
      "205": "Reset Content",
      "206": "Partial Content",
      "207": "Multi-Status",
      "208": "Already Reported",
      "226": "IM Used",
      "300": "Multiple Choices",
      "301": "Moved Permanently",
      "302": "Found",
      "303": "See Other",
      "304": "Not Modified",
      "305": "Use Proxy",
      "307": "Temporary Redirect",
      "308": "Permanent Redirect",
      "400": "Bad Request",
      "401": "Unauthorized",
      "402": "Payment Required",
      "403": "Forbidden",
      "404": "Not Found",
      "405": "Method Not Allowed",
      "406": "Not Acceptable",
      "407": "Proxy Authentication Required",
      "408": "Request Timeout",
      "409": "Conflict",
      "410": "Gone",
      "411": "Length Required",
      "412": "Precondition Failed",
      "413": "Payload Too Large",
      "414": "URI Too Long",
      "415": "Unsupported Media Type",
      "416": "Range Not Satisfiable",
      "417": "Expectation Failed",
      "418": "I'm a Teapot",
      "421": "Misdirected Request",
      "422": "Unprocessable Entity",
      "423": "Locked",
      "424": "Failed Dependency",
      "425": "Too Early",
      "426": "Upgrade Required",
      "428": "Precondition Required",
      "429": "Too Many Requests",
      "431": "Request Header Fields Too Large",
      "451": "Unavailable For Legal Reasons",
      "500": "Internal Server Error",
      "501": "Not Implemented",
      "502": "Bad Gateway",
      "503": "Service Unavailable",
      "504": "Gateway Timeout",
      "505": "HTTP Version Not Supported",
      "506": "Variant Also Negotiates",
      "507": "Insufficient Storage",
      "508": "Loop Detected",
      "509": "Bandwidth Limit Exceeded",
      "510": "Not Extended",
      "511": "Network Authentication Required"
    };
  }
});

// ../../../node_modules/statuses/index.js
var require_statuses = __commonJS({
  "../../../node_modules/statuses/index.js"(exports2, module2) {
    "use strict";
    var codes = require_codes();
    module2.exports = status;
    status.message = codes;
    status.code = createMessageToStatusCodeMap(codes);
    status.codes = createStatusCodeList(codes);
    status.redirect = {
      300: true,
      301: true,
      302: true,
      303: true,
      305: true,
      307: true,
      308: true
    };
    status.empty = {
      204: true,
      205: true,
      304: true
    };
    status.retry = {
      502: true,
      503: true,
      504: true
    };
    function createMessageToStatusCodeMap(codes2) {
      var map = {};
      Object.keys(codes2).forEach(function forEachCode(code) {
        var message = codes2[code];
        var status2 = Number(code);
        map[message.toLowerCase()] = status2;
      });
      return map;
    }
    function createStatusCodeList(codes2) {
      return Object.keys(codes2).map(function mapCode(code) {
        return Number(code);
      });
    }
    function getStatusCode(message) {
      var msg = message.toLowerCase();
      if (!Object.prototype.hasOwnProperty.call(status.code, msg)) {
        throw new Error('invalid status message: "' + message + '"');
      }
      return status.code[msg];
    }
    function getStatusMessage(code) {
      if (!Object.prototype.hasOwnProperty.call(status.message, code)) {
        throw new Error("invalid status code: " + code);
      }
      return status.message[code];
    }
    function status(code) {
      if (typeof code === "number") {
        return getStatusMessage(code);
      }
      if (typeof code !== "string") {
        throw new TypeError("code must be a number or string");
      }
      var n = parseInt(code, 10);
      if (!isNaN(n)) {
        return getStatusMessage(n);
      }
      return getStatusCode(code);
    }
  }
});

// ../../../node_modules/toidentifier/index.js
var require_toidentifier = __commonJS({
  "../../../node_modules/toidentifier/index.js"(exports2, module2) {
    "use strict";
    module2.exports = toIdentifier;
    function toIdentifier(str) {
      return str.split(" ").map(function(token) {
        return token.slice(0, 1).toUpperCase() + token.slice(1);
      }).join("").replace(/[^ _0-9a-z]/gi, "");
    }
  }
});

// ../../../node_modules/http-errors/index.js
var require_http_errors = __commonJS({
  "../../../node_modules/http-errors/index.js"(exports2, module2) {
    "use strict";
    var deprecate = require_browser2()("http-errors");
    var setPrototypeOf = require_setprototypeof();
    var statuses = require_statuses();
    var inherits = require_inherits_browser();
    var toIdentifier = require_toidentifier();
    module2.exports = createError;
    module2.exports.HttpError = createHttpErrorConstructor();
    module2.exports.isHttpError = createIsHttpErrorFunction(module2.exports.HttpError);
    populateConstructorExports(module2.exports, statuses.codes, module2.exports.HttpError);
    function codeClass(status) {
      return Number(String(status).charAt(0) + "00");
    }
    function createError() {
      var err;
      var msg;
      var status = 500;
      var props = {};
      for (var i = 0; i < arguments.length; i++) {
        var arg = arguments[i];
        var type = typeof arg;
        if (type === "object" && arg instanceof Error) {
          err = arg;
          status = err.status || err.statusCode || status;
        } else if (type === "number" && i === 0) {
          status = arg;
        } else if (type === "string") {
          msg = arg;
        } else if (type === "object") {
          props = arg;
        } else {
          throw new TypeError("argument #" + (i + 1) + " unsupported type " + type);
        }
      }
      if (typeof status === "number" && (status < 400 || status >= 600)) {
        deprecate("non-error status code; use only 4xx or 5xx status codes");
      }
      if (typeof status !== "number" || !statuses.message[status] && (status < 400 || status >= 600)) {
        status = 500;
      }
      var HttpError = createError[status] || createError[codeClass(status)];
      if (!err) {
        err = HttpError ? new HttpError(msg) : new Error(msg || statuses.message[status]);
        Error.captureStackTrace(err, createError);
      }
      if (!HttpError || !(err instanceof HttpError) || err.status !== status) {
        err.expose = status < 500;
        err.status = err.statusCode = status;
      }
      for (var key in props) {
        if (key !== "status" && key !== "statusCode") {
          err[key] = props[key];
        }
      }
      return err;
    }
    function createHttpErrorConstructor() {
      function HttpError() {
        throw new TypeError("cannot construct abstract class");
      }
      inherits(HttpError, Error);
      return HttpError;
    }
    function createClientErrorConstructor(HttpError, name, code) {
      var className = toClassName(name);
      function ClientError(message) {
        var msg = message != null ? message : statuses.message[code];
        var err = new Error(msg);
        Error.captureStackTrace(err, ClientError);
        setPrototypeOf(err, ClientError.prototype);
        Object.defineProperty(err, "message", {
          enumerable: true,
          configurable: true,
          value: msg,
          writable: true
        });
        Object.defineProperty(err, "name", {
          enumerable: false,
          configurable: true,
          value: className,
          writable: true
        });
        return err;
      }
      inherits(ClientError, HttpError);
      nameFunc(ClientError, className);
      ClientError.prototype.status = code;
      ClientError.prototype.statusCode = code;
      ClientError.prototype.expose = true;
      return ClientError;
    }
    function createIsHttpErrorFunction(HttpError) {
      return function isHttpError(val) {
        if (!val || typeof val !== "object") {
          return false;
        }
        if (val instanceof HttpError) {
          return true;
        }
        return val instanceof Error && typeof val.expose === "boolean" && typeof val.statusCode === "number" && val.status === val.statusCode;
      };
    }
    function createServerErrorConstructor(HttpError, name, code) {
      var className = toClassName(name);
      function ServerError(message) {
        var msg = message != null ? message : statuses.message[code];
        var err = new Error(msg);
        Error.captureStackTrace(err, ServerError);
        setPrototypeOf(err, ServerError.prototype);
        Object.defineProperty(err, "message", {
          enumerable: true,
          configurable: true,
          value: msg,
          writable: true
        });
        Object.defineProperty(err, "name", {
          enumerable: false,
          configurable: true,
          value: className,
          writable: true
        });
        return err;
      }
      inherits(ServerError, HttpError);
      nameFunc(ServerError, className);
      ServerError.prototype.status = code;
      ServerError.prototype.statusCode = code;
      ServerError.prototype.expose = false;
      return ServerError;
    }
    function nameFunc(func, name) {
      var desc = Object.getOwnPropertyDescriptor(func, "name");
      if (desc && desc.configurable) {
        desc.value = name;
        Object.defineProperty(func, "name", desc);
      }
    }
    function populateConstructorExports(exports3, codes, HttpError) {
      codes.forEach(function forEachCode(code) {
        var CodeError;
        var name = toIdentifier(statuses.message[code]);
        switch (codeClass(code)) {
          case 400:
            CodeError = createClientErrorConstructor(HttpError, name, code);
            break;
          case 500:
            CodeError = createServerErrorConstructor(HttpError, name, code);
            break;
        }
        if (CodeError) {
          exports3[code] = CodeError;
          exports3[name] = CodeError;
        }
      });
    }
    function toClassName(name) {
      return name.substr(-5) !== "Error" ? name + "Error" : name;
    }
  }
});

// ../../../node_modules/express/node_modules/ms/index.js
var require_ms = __commonJS({
  "../../../node_modules/express/node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse2(val);
      } else if (type === "number" && isNaN(val) === false) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse2(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      if (ms >= d) {
        return Math.round(ms / d) + "d";
      }
      if (ms >= h) {
        return Math.round(ms / h) + "h";
      }
      if (ms >= m) {
        return Math.round(ms / m) + "m";
      }
      if (ms >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      return plural(ms, d, "day") || plural(ms, h, "hour") || plural(ms, m, "minute") || plural(ms, s, "second") || ms + " ms";
    }
    function plural(ms, n, name) {
      if (ms < n) {
        return;
      }
      if (ms < n * 1.5) {
        return Math.floor(ms / n) + " " + name;
      }
      return Math.ceil(ms / n) + " " + name + "s";
    }
  }
});

// ../../../node_modules/express/node_modules/debug/src/debug.js
var require_debug = __commonJS({
  "../../../node_modules/express/node_modules/debug/src/debug.js"(exports2, module2) {
    exports2 = module2.exports = createDebug.debug = createDebug["default"] = createDebug;
    exports2.coerce = coerce;
    exports2.disable = disable;
    exports2.enable = enable;
    exports2.enabled = enabled;
    exports2.humanize = require_ms();
    exports2.names = [];
    exports2.skips = [];
    exports2.formatters = {};
    var prevTime;
    function selectColor(namespace) {
      var hash = 0, i;
      for (i in namespace) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return exports2.colors[Math.abs(hash) % exports2.colors.length];
    }
    function createDebug(namespace) {
      function debug() {
        if (!debug.enabled)
          return;
        var self2 = debug;
        var curr = +/* @__PURE__ */ new Date();
        var ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        args[0] = exports2.coerce(args[0]);
        if ("string" !== typeof args[0]) {
          args.unshift("%O");
        }
        var index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
          if (match === "%%")
            return match;
          index++;
          var formatter = exports2.formatters[format];
          if ("function" === typeof formatter) {
            var val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        exports2.formatArgs.call(self2, args);
        var logFn = debug.log || exports2.log || console.log.bind(console);
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.enabled = exports2.enabled(namespace);
      debug.useColors = exports2.useColors();
      debug.color = selectColor(namespace);
      if ("function" === typeof exports2.init) {
        exports2.init(debug);
      }
      return debug;
    }
    function enable(namespaces) {
      exports2.save(namespaces);
      exports2.names = [];
      exports2.skips = [];
      var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      var len = split.length;
      for (var i = 0; i < len; i++) {
        if (!split[i])
          continue;
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          exports2.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          exports2.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      exports2.enable("");
    }
    function enabled(name) {
      var i, len;
      for (i = 0, len = exports2.skips.length; i < len; i++) {
        if (exports2.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = exports2.names.length; i < len; i++) {
        if (exports2.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error)
        return val.stack || val.message;
      return val;
    }
  }
});

// ../../../node_modules/express/node_modules/debug/src/browser.js
var require_browser3 = __commonJS({
  "../../../node_modules/express/node_modules/debug/src/browser.js"(exports2, module2) {
    exports2 = module2.exports = require_debug();
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = "undefined" != typeof chrome && "undefined" != typeof chrome.storage ? chrome.storage.local : localstorage();
    exports2.colors = [
      "lightseagreen",
      "forestgreen",
      "goldenrod",
      "dodgerblue",
      "darkorchid",
      "crimson"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
        return true;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    exports2.formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (err) {
        return "[UnexpectedJSONParseError]: " + err.message;
      }
    };
    function formatArgs(args) {
      var useColors2 = this.useColors;
      args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports2.humanize(this.diff);
      if (!useColors2)
        return;
      var c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      var index = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function(match) {
        if ("%%" === match)
          return;
        index++;
        if ("%c" === match) {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    function log() {
      return "object" === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
    }
    function save(namespaces) {
      try {
        if (null == namespaces) {
          exports2.storage.removeItem("debug");
        } else {
          exports2.storage.debug = namespaces;
        }
      } catch (e) {
      }
    }
    function load() {
      var r;
      try {
        r = exports2.storage.debug;
      } catch (e) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    exports2.enable(load());
    function localstorage() {
      try {
        return window.localStorage;
      } catch (e) {
      }
    }
  }
});

// browser-external:events
var require_events = __commonJS({
  "browser-external:events"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "events" has been externalized for browser compatibility. Cannot access "events.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:fs
var require_fs = __commonJS({
  "browser-external:fs"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "fs" has been externalized for browser compatibility. Cannot access "fs.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:stream
var require_stream = __commonJS({
  "browser-external:stream"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "stream" has been externalized for browser compatibility. Cannot access "stream.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// ../../../node_modules/destroy/index.js
var require_destroy = __commonJS({
  "../../../node_modules/destroy/index.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require_events().EventEmitter;
    var ReadStream = require_fs().ReadStream;
    var Stream = require_stream();
    var Zlib = require_zlib();
    module2.exports = destroy;
    function destroy(stream, suppress) {
      if (isFsReadStream(stream)) {
        destroyReadStream(stream);
      } else if (isZlibStream(stream)) {
        destroyZlibStream(stream);
      } else if (hasDestroy(stream)) {
        stream.destroy();
      }
      if (isEventEmitter(stream) && suppress) {
        stream.removeAllListeners("error");
        stream.addListener("error", noop);
      }
      return stream;
    }
    function destroyReadStream(stream) {
      stream.destroy();
      if (typeof stream.close === "function") {
        stream.on("open", onOpenClose);
      }
    }
    function closeZlibStream(stream) {
      if (stream._hadError === true) {
        var prop = stream._binding === null ? "_binding" : "_handle";
        stream[prop] = {
          close: function() {
            this[prop] = null;
          }
        };
      }
      stream.close();
    }
    function destroyZlibStream(stream) {
      if (typeof stream.destroy === "function") {
        if (stream._binding) {
          stream.destroy();
          if (stream._processing) {
            stream._needDrain = true;
            stream.once("drain", onDrainClearBinding);
          } else {
            stream._binding.clear();
          }
        } else if (stream._destroy && stream._destroy !== Stream.Transform.prototype._destroy) {
          stream.destroy();
        } else if (stream._destroy && typeof stream.close === "function") {
          stream.destroyed = true;
          stream.close();
        } else {
          stream.destroy();
        }
      } else if (typeof stream.close === "function") {
        closeZlibStream(stream);
      }
    }
    function hasDestroy(stream) {
      return stream instanceof Stream && typeof stream.destroy === "function";
    }
    function isEventEmitter(val) {
      return val instanceof EventEmitter;
    }
    function isFsReadStream(stream) {
      return stream instanceof ReadStream;
    }
    function isZlibStream(stream) {
      return stream instanceof Zlib.Gzip || stream instanceof Zlib.Gunzip || stream instanceof Zlib.Deflate || stream instanceof Zlib.DeflateRaw || stream instanceof Zlib.Inflate || stream instanceof Zlib.InflateRaw || stream instanceof Zlib.Unzip;
    }
    function noop() {
    }
    function onDrainClearBinding() {
      this._binding.clear();
    }
    function onOpenClose() {
      if (typeof this.fd === "number") {
        this.close();
      }
    }
  }
});

// ../../../node_modules/safer-buffer/safer.js
var require_safer = __commonJS({
  "../../../node_modules/safer-buffer/safer.js"(exports2, module2) {
    "use strict";
    var buffer = require_buffer();
    var Buffer2 = buffer.Buffer;
    var safer = {};
    var key;
    for (key in buffer) {
      if (!buffer.hasOwnProperty(key))
        continue;
      if (key === "SlowBuffer" || key === "Buffer")
        continue;
      safer[key] = buffer[key];
    }
    var Safer = safer.Buffer = {};
    for (key in Buffer2) {
      if (!Buffer2.hasOwnProperty(key))
        continue;
      if (key === "allocUnsafe" || key === "allocUnsafeSlow")
        continue;
      Safer[key] = Buffer2[key];
    }
    safer.Buffer.prototype = Buffer2.prototype;
    if (!Safer.from || Safer.from === Uint8Array.from) {
      Safer.from = function(value, encodingOrOffset, length) {
        if (typeof value === "number") {
          throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value);
        }
        if (value && typeof value.length === "undefined") {
          throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
        }
        return Buffer2(value, encodingOrOffset, length);
      };
    }
    if (!Safer.alloc) {
      Safer.alloc = function(size, fill, encoding) {
        if (typeof size !== "number") {
          throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size);
        }
        if (size < 0 || size >= 2 * (1 << 30)) {
          throw new RangeError('The value "' + size + '" is invalid for option "size"');
        }
        var buf = Buffer2(size);
        if (!fill || fill.length === 0) {
          buf.fill(0);
        } else if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
        return buf;
      };
    }
    if (!safer.kStringMaxLength) {
      try {
        safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
      } catch (e) {
      }
    }
    if (!safer.constants) {
      safer.constants = {
        MAX_LENGTH: safer.kMaxLength
      };
      if (safer.kStringMaxLength) {
        safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
      }
    }
    module2.exports = safer;
  }
});

// ../../../node_modules/iconv-lite/lib/bom-handling.js
var require_bom_handling = __commonJS({
  "../../../node_modules/iconv-lite/lib/bom-handling.js"(exports2) {
    "use strict";
    var BOMChar = "\uFEFF";
    exports2.PrependBOM = PrependBOMWrapper;
    function PrependBOMWrapper(encoder, options) {
      this.encoder = encoder;
      this.addBOM = true;
    }
    PrependBOMWrapper.prototype.write = function(str) {
      if (this.addBOM) {
        str = BOMChar + str;
        this.addBOM = false;
      }
      return this.encoder.write(str);
    };
    PrependBOMWrapper.prototype.end = function() {
      return this.encoder.end();
    };
    exports2.StripBOM = StripBOMWrapper;
    function StripBOMWrapper(decoder, options) {
      this.decoder = decoder;
      this.pass = false;
      this.options = options || {};
    }
    StripBOMWrapper.prototype.write = function(buf) {
      var res = this.decoder.write(buf);
      if (this.pass || !res)
        return res;
      if (res[0] === BOMChar) {
        res = res.slice(1);
        if (typeof this.options.stripBOM === "function")
          this.options.stripBOM();
      }
      this.pass = true;
      return res;
    };
    StripBOMWrapper.prototype.end = function() {
      return this.decoder.end();
    };
  }
});

// browser-external:string_decoder
var require_string_decoder = __commonJS({
  "browser-external:string_decoder"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "string_decoder" has been externalized for browser compatibility. Cannot access "string_decoder.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// ../../../node_modules/iconv-lite/encodings/internal.js
var require_internal = __commonJS({
  "../../../node_modules/iconv-lite/encodings/internal.js"(exports2, module2) {
    "use strict";
    var Buffer2 = require_safer().Buffer;
    module2.exports = {
      // Encodings
      utf8: { type: "_internal", bomAware: true },
      cesu8: { type: "_internal", bomAware: true },
      unicode11utf8: "utf8",
      ucs2: { type: "_internal", bomAware: true },
      utf16le: "ucs2",
      binary: { type: "_internal" },
      base64: { type: "_internal" },
      hex: { type: "_internal" },
      // Codec.
      _internal: InternalCodec
    };
    function InternalCodec(codecOptions, iconv) {
      this.enc = codecOptions.encodingName;
      this.bomAware = codecOptions.bomAware;
      if (this.enc === "base64")
        this.encoder = InternalEncoderBase64;
      else if (this.enc === "cesu8") {
        this.enc = "utf8";
        this.encoder = InternalEncoderCesu8;
        if (Buffer2.from("eda0bdedb2a9", "hex").toString() !== "") {
          this.decoder = InternalDecoderCesu8;
          this.defaultCharUnicode = iconv.defaultCharUnicode;
        }
      }
    }
    InternalCodec.prototype.encoder = InternalEncoder;
    InternalCodec.prototype.decoder = InternalDecoder;
    var StringDecoder = require_string_decoder().StringDecoder;
    if (!StringDecoder.prototype.end)
      StringDecoder.prototype.end = function() {
      };
    function InternalDecoder(options, codec) {
      StringDecoder.call(this, codec.enc);
    }
    InternalDecoder.prototype = StringDecoder.prototype;
    function InternalEncoder(options, codec) {
      this.enc = codec.enc;
    }
    InternalEncoder.prototype.write = function(str) {
      return Buffer2.from(str, this.enc);
    };
    InternalEncoder.prototype.end = function() {
    };
    function InternalEncoderBase64(options, codec) {
      this.prevStr = "";
    }
    InternalEncoderBase64.prototype.write = function(str) {
      str = this.prevStr + str;
      var completeQuads = str.length - str.length % 4;
      this.prevStr = str.slice(completeQuads);
      str = str.slice(0, completeQuads);
      return Buffer2.from(str, "base64");
    };
    InternalEncoderBase64.prototype.end = function() {
      return Buffer2.from(this.prevStr, "base64");
    };
    function InternalEncoderCesu8(options, codec) {
    }
    InternalEncoderCesu8.prototype.write = function(str) {
      var buf = Buffer2.alloc(str.length * 3), bufIdx = 0;
      for (var i = 0; i < str.length; i++) {
        var charCode = str.charCodeAt(i);
        if (charCode < 128)
          buf[bufIdx++] = charCode;
        else if (charCode < 2048) {
          buf[bufIdx++] = 192 + (charCode >>> 6);
          buf[bufIdx++] = 128 + (charCode & 63);
        } else {
          buf[bufIdx++] = 224 + (charCode >>> 12);
          buf[bufIdx++] = 128 + (charCode >>> 6 & 63);
          buf[bufIdx++] = 128 + (charCode & 63);
        }
      }
      return buf.slice(0, bufIdx);
    };
    InternalEncoderCesu8.prototype.end = function() {
    };
    function InternalDecoderCesu8(options, codec) {
      this.acc = 0;
      this.contBytes = 0;
      this.accBytes = 0;
      this.defaultCharUnicode = codec.defaultCharUnicode;
    }
    InternalDecoderCesu8.prototype.write = function(buf) {
      var acc = this.acc, contBytes = this.contBytes, accBytes = this.accBytes, res = "";
      for (var i = 0; i < buf.length; i++) {
        var curByte = buf[i];
        if ((curByte & 192) !== 128) {
          if (contBytes > 0) {
            res += this.defaultCharUnicode;
            contBytes = 0;
          }
          if (curByte < 128) {
            res += String.fromCharCode(curByte);
          } else if (curByte < 224) {
            acc = curByte & 31;
            contBytes = 1;
            accBytes = 1;
          } else if (curByte < 240) {
            acc = curByte & 15;
            contBytes = 2;
            accBytes = 1;
          } else {
            res += this.defaultCharUnicode;
          }
        } else {
          if (contBytes > 0) {
            acc = acc << 6 | curByte & 63;
            contBytes--;
            accBytes++;
            if (contBytes === 0) {
              if (accBytes === 2 && acc < 128 && acc > 0)
                res += this.defaultCharUnicode;
              else if (accBytes === 3 && acc < 2048)
                res += this.defaultCharUnicode;
              else
                res += String.fromCharCode(acc);
            }
          } else {
            res += this.defaultCharUnicode;
          }
        }
      }
      this.acc = acc;
      this.contBytes = contBytes;
      this.accBytes = accBytes;
      return res;
    };
    InternalDecoderCesu8.prototype.end = function() {
      var res = 0;
      if (this.contBytes > 0)
        res += this.defaultCharUnicode;
      return res;
    };
  }
});

// ../../../node_modules/iconv-lite/encodings/utf16.js
var require_utf16 = __commonJS({
  "../../../node_modules/iconv-lite/encodings/utf16.js"(exports2) {
    "use strict";
    var Buffer2 = require_safer().Buffer;
    exports2.utf16be = Utf16BECodec;
    function Utf16BECodec() {
    }
    Utf16BECodec.prototype.encoder = Utf16BEEncoder;
    Utf16BECodec.prototype.decoder = Utf16BEDecoder;
    Utf16BECodec.prototype.bomAware = true;
    function Utf16BEEncoder() {
    }
    Utf16BEEncoder.prototype.write = function(str) {
      var buf = Buffer2.from(str, "ucs2");
      for (var i = 0; i < buf.length; i += 2) {
        var tmp = buf[i];
        buf[i] = buf[i + 1];
        buf[i + 1] = tmp;
      }
      return buf;
    };
    Utf16BEEncoder.prototype.end = function() {
    };
    function Utf16BEDecoder() {
      this.overflowByte = -1;
    }
    Utf16BEDecoder.prototype.write = function(buf) {
      if (buf.length == 0)
        return "";
      var buf2 = Buffer2.alloc(buf.length + 1), i = 0, j = 0;
      if (this.overflowByte !== -1) {
        buf2[0] = buf[0];
        buf2[1] = this.overflowByte;
        i = 1;
        j = 2;
      }
      for (; i < buf.length - 1; i += 2, j += 2) {
        buf2[j] = buf[i + 1];
        buf2[j + 1] = buf[i];
      }
      this.overflowByte = i == buf.length - 1 ? buf[buf.length - 1] : -1;
      return buf2.slice(0, j).toString("ucs2");
    };
    Utf16BEDecoder.prototype.end = function() {
    };
    exports2.utf16 = Utf16Codec;
    function Utf16Codec(codecOptions, iconv) {
      this.iconv = iconv;
    }
    Utf16Codec.prototype.encoder = Utf16Encoder;
    Utf16Codec.prototype.decoder = Utf16Decoder;
    function Utf16Encoder(options, codec) {
      options = options || {};
      if (options.addBOM === void 0)
        options.addBOM = true;
      this.encoder = codec.iconv.getEncoder("utf-16le", options);
    }
    Utf16Encoder.prototype.write = function(str) {
      return this.encoder.write(str);
    };
    Utf16Encoder.prototype.end = function() {
      return this.encoder.end();
    };
    function Utf16Decoder(options, codec) {
      this.decoder = null;
      this.initialBytes = [];
      this.initialBytesLen = 0;
      this.options = options || {};
      this.iconv = codec.iconv;
    }
    Utf16Decoder.prototype.write = function(buf) {
      if (!this.decoder) {
        this.initialBytes.push(buf);
        this.initialBytesLen += buf.length;
        if (this.initialBytesLen < 16)
          return "";
        var buf = Buffer2.concat(this.initialBytes), encoding = detectEncoding(buf, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding, this.options);
        this.initialBytes.length = this.initialBytesLen = 0;
      }
      return this.decoder.write(buf);
    };
    Utf16Decoder.prototype.end = function() {
      if (!this.decoder) {
        var buf = Buffer2.concat(this.initialBytes), encoding = detectEncoding(buf, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding, this.options);
        var res = this.decoder.write(buf), trail = this.decoder.end();
        return trail ? res + trail : res;
      }
      return this.decoder.end();
    };
    function detectEncoding(buf, defaultEncoding) {
      var enc = defaultEncoding || "utf-16le";
      if (buf.length >= 2) {
        if (buf[0] == 254 && buf[1] == 255)
          enc = "utf-16be";
        else if (buf[0] == 255 && buf[1] == 254)
          enc = "utf-16le";
        else {
          var asciiCharsLE = 0, asciiCharsBE = 0, _len = Math.min(buf.length - buf.length % 2, 64);
          for (var i = 0; i < _len; i += 2) {
            if (buf[i] === 0 && buf[i + 1] !== 0)
              asciiCharsBE++;
            if (buf[i] !== 0 && buf[i + 1] === 0)
              asciiCharsLE++;
          }
          if (asciiCharsBE > asciiCharsLE)
            enc = "utf-16be";
          else if (asciiCharsBE < asciiCharsLE)
            enc = "utf-16le";
        }
      }
      return enc;
    }
  }
});

// ../../../node_modules/iconv-lite/encodings/utf7.js
var require_utf7 = __commonJS({
  "../../../node_modules/iconv-lite/encodings/utf7.js"(exports2) {
    "use strict";
    var Buffer2 = require_safer().Buffer;
    exports2.utf7 = Utf7Codec;
    exports2.unicode11utf7 = "utf7";
    function Utf7Codec(codecOptions, iconv) {
      this.iconv = iconv;
    }
    Utf7Codec.prototype.encoder = Utf7Encoder;
    Utf7Codec.prototype.decoder = Utf7Decoder;
    Utf7Codec.prototype.bomAware = true;
    var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
    function Utf7Encoder(options, codec) {
      this.iconv = codec.iconv;
    }
    Utf7Encoder.prototype.write = function(str) {
      return Buffer2.from(str.replace(nonDirectChars, (function(chunk) {
        return "+" + (chunk === "+" ? "" : this.iconv.encode(chunk, "utf16-be").toString("base64").replace(/=+$/, "")) + "-";
      }).bind(this)));
    };
    Utf7Encoder.prototype.end = function() {
    };
    function Utf7Decoder(options, codec) {
      this.iconv = codec.iconv;
      this.inBase64 = false;
      this.base64Accum = "";
    }
    var base64Regex = /[A-Za-z0-9\/+]/;
    var base64Chars = [];
    for (i = 0; i < 256; i++)
      base64Chars[i] = base64Regex.test(String.fromCharCode(i));
    var i;
    var plusChar = "+".charCodeAt(0);
    var minusChar = "-".charCodeAt(0);
    var andChar = "&".charCodeAt(0);
    Utf7Decoder.prototype.write = function(buf) {
      var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
      for (var i2 = 0; i2 < buf.length; i2++) {
        if (!inBase64) {
          if (buf[i2] == plusChar) {
            res += this.iconv.decode(buf.slice(lastI, i2), "ascii");
            lastI = i2 + 1;
            inBase64 = true;
          }
        } else {
          if (!base64Chars[buf[i2]]) {
            if (i2 == lastI && buf[i2] == minusChar) {
              res += "+";
            } else {
              var b64str = base64Accum + buf.slice(lastI, i2).toString();
              res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
            }
            if (buf[i2] != minusChar)
              i2--;
            lastI = i2 + 1;
            inBase64 = false;
            base64Accum = "";
          }
        }
      }
      if (!inBase64) {
        res += this.iconv.decode(buf.slice(lastI), "ascii");
      } else {
        var b64str = base64Accum + buf.slice(lastI).toString();
        var canBeDecoded = b64str.length - b64str.length % 8;
        base64Accum = b64str.slice(canBeDecoded);
        b64str = b64str.slice(0, canBeDecoded);
        res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
      }
      this.inBase64 = inBase64;
      this.base64Accum = base64Accum;
      return res;
    };
    Utf7Decoder.prototype.end = function() {
      var res = "";
      if (this.inBase64 && this.base64Accum.length > 0)
        res = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
      this.inBase64 = false;
      this.base64Accum = "";
      return res;
    };
    exports2.utf7imap = Utf7IMAPCodec;
    function Utf7IMAPCodec(codecOptions, iconv) {
      this.iconv = iconv;
    }
    Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
    Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
    Utf7IMAPCodec.prototype.bomAware = true;
    function Utf7IMAPEncoder(options, codec) {
      this.iconv = codec.iconv;
      this.inBase64 = false;
      this.base64Accum = Buffer2.alloc(6);
      this.base64AccumIdx = 0;
    }
    Utf7IMAPEncoder.prototype.write = function(str) {
      var inBase64 = this.inBase64, base64Accum = this.base64Accum, base64AccumIdx = this.base64AccumIdx, buf = Buffer2.alloc(str.length * 5 + 10), bufIdx = 0;
      for (var i2 = 0; i2 < str.length; i2++) {
        var uChar = str.charCodeAt(i2);
        if (32 <= uChar && uChar <= 126) {
          if (inBase64) {
            if (base64AccumIdx > 0) {
              bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
              base64AccumIdx = 0;
            }
            buf[bufIdx++] = minusChar;
            inBase64 = false;
          }
          if (!inBase64) {
            buf[bufIdx++] = uChar;
            if (uChar === andChar)
              buf[bufIdx++] = minusChar;
          }
        } else {
          if (!inBase64) {
            buf[bufIdx++] = andChar;
            inBase64 = true;
          }
          if (inBase64) {
            base64Accum[base64AccumIdx++] = uChar >> 8;
            base64Accum[base64AccumIdx++] = uChar & 255;
            if (base64AccumIdx == base64Accum.length) {
              bufIdx += buf.write(base64Accum.toString("base64").replace(/\//g, ","), bufIdx);
              base64AccumIdx = 0;
            }
          }
        }
      }
      this.inBase64 = inBase64;
      this.base64AccumIdx = base64AccumIdx;
      return buf.slice(0, bufIdx);
    };
    Utf7IMAPEncoder.prototype.end = function() {
      var buf = Buffer2.alloc(10), bufIdx = 0;
      if (this.inBase64) {
        if (this.base64AccumIdx > 0) {
          bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
          this.base64AccumIdx = 0;
        }
        buf[bufIdx++] = minusChar;
        this.inBase64 = false;
      }
      return buf.slice(0, bufIdx);
    };
    function Utf7IMAPDecoder(options, codec) {
      this.iconv = codec.iconv;
      this.inBase64 = false;
      this.base64Accum = "";
    }
    var base64IMAPChars = base64Chars.slice();
    base64IMAPChars[",".charCodeAt(0)] = true;
    Utf7IMAPDecoder.prototype.write = function(buf) {
      var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
      for (var i2 = 0; i2 < buf.length; i2++) {
        if (!inBase64) {
          if (buf[i2] == andChar) {
            res += this.iconv.decode(buf.slice(lastI, i2), "ascii");
            lastI = i2 + 1;
            inBase64 = true;
          }
        } else {
          if (!base64IMAPChars[buf[i2]]) {
            if (i2 == lastI && buf[i2] == minusChar) {
              res += "&";
            } else {
              var b64str = base64Accum + buf.slice(lastI, i2).toString().replace(/,/g, "/");
              res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
            }
            if (buf[i2] != minusChar)
              i2--;
            lastI = i2 + 1;
            inBase64 = false;
            base64Accum = "";
          }
        }
      }
      if (!inBase64) {
        res += this.iconv.decode(buf.slice(lastI), "ascii");
      } else {
        var b64str = base64Accum + buf.slice(lastI).toString().replace(/,/g, "/");
        var canBeDecoded = b64str.length - b64str.length % 8;
        base64Accum = b64str.slice(canBeDecoded);
        b64str = b64str.slice(0, canBeDecoded);
        res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
      }
      this.inBase64 = inBase64;
      this.base64Accum = base64Accum;
      return res;
    };
    Utf7IMAPDecoder.prototype.end = function() {
      var res = "";
      if (this.inBase64 && this.base64Accum.length > 0)
        res = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
      this.inBase64 = false;
      this.base64Accum = "";
      return res;
    };
  }
});

// ../../../node_modules/iconv-lite/encodings/sbcs-codec.js
var require_sbcs_codec = __commonJS({
  "../../../node_modules/iconv-lite/encodings/sbcs-codec.js"(exports2) {
    "use strict";
    var Buffer2 = require_safer().Buffer;
    exports2._sbcs = SBCSCodec;
    function SBCSCodec(codecOptions, iconv) {
      if (!codecOptions)
        throw new Error("SBCS codec is called without the data.");
      if (!codecOptions.chars || codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256)
        throw new Error("Encoding '" + codecOptions.type + "' has incorrect 'chars' (must be of len 128 or 256)");
      if (codecOptions.chars.length === 128) {
        var asciiString = "";
        for (var i = 0; i < 128; i++)
          asciiString += String.fromCharCode(i);
        codecOptions.chars = asciiString + codecOptions.chars;
      }
      this.decodeBuf = Buffer2.from(codecOptions.chars, "ucs2");
      var encodeBuf = Buffer2.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));
      for (var i = 0; i < codecOptions.chars.length; i++)
        encodeBuf[codecOptions.chars.charCodeAt(i)] = i;
      this.encodeBuf = encodeBuf;
    }
    SBCSCodec.prototype.encoder = SBCSEncoder;
    SBCSCodec.prototype.decoder = SBCSDecoder;
    function SBCSEncoder(options, codec) {
      this.encodeBuf = codec.encodeBuf;
    }
    SBCSEncoder.prototype.write = function(str) {
      var buf = Buffer2.alloc(str.length);
      for (var i = 0; i < str.length; i++)
        buf[i] = this.encodeBuf[str.charCodeAt(i)];
      return buf;
    };
    SBCSEncoder.prototype.end = function() {
    };
    function SBCSDecoder(options, codec) {
      this.decodeBuf = codec.decodeBuf;
    }
    SBCSDecoder.prototype.write = function(buf) {
      var decodeBuf = this.decodeBuf;
      var newBuf = Buffer2.alloc(buf.length * 2);
      var idx1 = 0, idx2 = 0;
      for (var i = 0; i < buf.length; i++) {
        idx1 = buf[i] * 2;
        idx2 = i * 2;
        newBuf[idx2] = decodeBuf[idx1];
        newBuf[idx2 + 1] = decodeBuf[idx1 + 1];
      }
      return newBuf.toString("ucs2");
    };
    SBCSDecoder.prototype.end = function() {
    };
  }
});

// ../../../node_modules/iconv-lite/encodings/sbcs-data.js
var require_sbcs_data = __commonJS({
  "../../../node_modules/iconv-lite/encodings/sbcs-data.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      // Not supported by iconv, not sure why.
      "10029": "maccenteuro",
      "maccenteuro": {
        "type": "_sbcs",
        "chars": ""
      },
      "808": "cp808",
      "ibm808": "cp808",
      "cp808": {
        "type": "_sbcs",
        "chars": ""
      },
      "mik": {
        "type": "_sbcs",
        "chars": ""
      },
      // Aliases of generated encodings.
      "ascii8bit": "ascii",
      "usascii": "ascii",
      "ansix34": "ascii",
      "ansix341968": "ascii",
      "ansix341986": "ascii",
      "csascii": "ascii",
      "cp367": "ascii",
      "ibm367": "ascii",
      "isoir6": "ascii",
      "iso646us": "ascii",
      "iso646irv": "ascii",
      "us": "ascii",
      "latin1": "iso88591",
      "latin2": "iso88592",
      "latin3": "iso88593",
      "latin4": "iso88594",
      "latin5": "iso88599",
      "latin6": "iso885910",
      "latin7": "iso885913",
      "latin8": "iso885914",
      "latin9": "iso885915",
      "latin10": "iso885916",
      "csisolatin1": "iso88591",
      "csisolatin2": "iso88592",
      "csisolatin3": "iso88593",
      "csisolatin4": "iso88594",
      "csisolatincyrillic": "iso88595",
      "csisolatinarabic": "iso88596",
      "csisolatingreek": "iso88597",
      "csisolatinhebrew": "iso88598",
      "csisolatin5": "iso88599",
      "csisolatin6": "iso885910",
      "l1": "iso88591",
      "l2": "iso88592",
      "l3": "iso88593",
      "l4": "iso88594",
      "l5": "iso88599",
      "l6": "iso885910",
      "l7": "iso885913",
      "l8": "iso885914",
      "l9": "iso885915",
      "l10": "iso885916",
      "isoir14": "iso646jp",
      "isoir57": "iso646cn",
      "isoir100": "iso88591",
      "isoir101": "iso88592",
      "isoir109": "iso88593",
      "isoir110": "iso88594",
      "isoir144": "iso88595",
      "isoir127": "iso88596",
      "isoir126": "iso88597",
      "isoir138": "iso88598",
      "isoir148": "iso88599",
      "isoir157": "iso885910",
      "isoir166": "tis620",
      "isoir179": "iso885913",
      "isoir199": "iso885914",
      "isoir203": "iso885915",
      "isoir226": "iso885916",
      "cp819": "iso88591",
      "ibm819": "iso88591",
      "cyrillic": "iso88595",
      "arabic": "iso88596",
      "arabic8": "iso88596",
      "ecma114": "iso88596",
      "asmo708": "iso88596",
      "greek": "iso88597",
      "greek8": "iso88597",
      "ecma118": "iso88597",
      "elot928": "iso88597",
      "hebrew": "iso88598",
      "hebrew8": "iso88598",
      "turkish": "iso88599",
      "turkish8": "iso88599",
      "thai": "iso885911",
      "thai8": "iso885911",
      "celtic": "iso885914",
      "celtic8": "iso885914",
      "isoceltic": "iso885914",
      "tis6200": "tis620",
      "tis62025291": "tis620",
      "tis62025330": "tis620",
      "10000": "macroman",
      "10006": "macgreek",
      "10007": "maccyrillic",
      "10079": "maciceland",
      "10081": "macturkish",
      "cspc8codepage437": "cp437",
      "cspc775baltic": "cp775",
      "cspc850multilingual": "cp850",
      "cspcp852": "cp852",
      "cspc862latinhebrew": "cp862",
      "cpgr": "cp869",
      "msee": "cp1250",
      "mscyrl": "cp1251",
      "msansi": "cp1252",
      "msgreek": "cp1253",
      "msturk": "cp1254",
      "mshebr": "cp1255",
      "msarab": "cp1256",
      "winbaltrim": "cp1257",
      "cp20866": "koi8r",
      "20866": "koi8r",
      "ibm878": "koi8r",
      "cskoi8r": "koi8r",
      "cp21866": "koi8u",
      "21866": "koi8u",
      "ibm1168": "koi8u",
      "strk10482002": "rk1048",
      "tcvn5712": "tcvn",
      "tcvn57121": "tcvn",
      "gb198880": "iso646cn",
      "cn": "iso646cn",
      "csiso14jisc6220ro": "iso646jp",
      "jisc62201969ro": "iso646jp",
      "jp": "iso646jp",
      "cshproman8": "hproman8",
      "r8": "hproman8",
      "roman8": "hproman8",
      "xroman8": "hproman8",
      "ibm1051": "hproman8",
      "mac": "macintosh",
      "csmacintosh": "macintosh"
    };
  }
});

// ../../../node_modules/iconv-lite/encodings/sbcs-data-generated.js
var require_sbcs_data_generated = __commonJS({
  "../../../node_modules/iconv-lite/encodings/sbcs-data-generated.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      "437": "cp437",
      "737": "cp737",
      "775": "cp775",
      "850": "cp850",
      "852": "cp852",
      "855": "cp855",
      "856": "cp856",
      "857": "cp857",
      "858": "cp858",
      "860": "cp860",
      "861": "cp861",
      "862": "cp862",
      "863": "cp863",
      "864": "cp864",
      "865": "cp865",
      "866": "cp866",
      "869": "cp869",
      "874": "windows874",
      "922": "cp922",
      "1046": "cp1046",
      "1124": "cp1124",
      "1125": "cp1125",
      "1129": "cp1129",
      "1133": "cp1133",
      "1161": "cp1161",
      "1162": "cp1162",
      "1163": "cp1163",
      "1250": "windows1250",
      "1251": "windows1251",
      "1252": "windows1252",
      "1253": "windows1253",
      "1254": "windows1254",
      "1255": "windows1255",
      "1256": "windows1256",
      "1257": "windows1257",
      "1258": "windows1258",
      "28591": "iso88591",
      "28592": "iso88592",
      "28593": "iso88593",
      "28594": "iso88594",
      "28595": "iso88595",
      "28596": "iso88596",
      "28597": "iso88597",
      "28598": "iso88598",
      "28599": "iso88599",
      "28600": "iso885910",
      "28601": "iso885911",
      "28603": "iso885913",
      "28604": "iso885914",
      "28605": "iso885915",
      "28606": "iso885916",
      "windows874": {
        "type": "_sbcs",
        "chars": ""
      },
      "win874": "windows874",
      "cp874": "windows874",
      "windows1250": {
        "type": "_sbcs",
        "chars": ""
      },
      "win1250": "windows1250",
      "cp1250": "windows1250",
      "windows1251": {
        "type": "_sbcs",
        "chars": ""
      },
      "win1251": "windows1251",
      "cp1251": "windows1251",
      "windows1252": {
        "type": "_sbcs",
        "chars": ""
      },
      "win1252": "windows1252",
      "cp1252": "windows1252",
      "windows1253": {
        "type": "_sbcs",
        "chars": ""
      },
      "win1253": "windows1253",
      "cp1253": "windows1253",
      "windows1254": {
        "type": "_sbcs",
        "chars": ""
      },
      "win1254": "windows1254",
      "cp1254": "windows1254",
      "windows1255": {
        "type": "_sbcs",
        "chars": ""
      },
      "win1255": "windows1255",
      "cp1255": "windows1255",
      "windows1256": {
        "type": "_sbcs",
        "chars": ""
      },
      "win1256": "windows1256",
      "cp1256": "windows1256",
      "windows1257": {
        "type": "_sbcs",
        "chars": ""
      },
      "win1257": "windows1257",
      "cp1257": "windows1257",
      "windows1258": {
        "type": "_sbcs",
        "chars": ""
      },
      "win1258": "windows1258",
      "cp1258": "windows1258",
      "iso88591": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28591": "iso88591",
      "iso88592": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28592": "iso88592",
      "iso88593": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28593": "iso88593",
      "iso88594": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28594": "iso88594",
      "iso88595": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28595": "iso88595",
      "iso88596": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28596": "iso88596",
      "iso88597": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28597": "iso88597",
      "iso88598": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28598": "iso88598",
      "iso88599": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28599": "iso88599",
      "iso885910": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28600": "iso885910",
      "iso885911": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28601": "iso885911",
      "iso885913": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28603": "iso885913",
      "iso885914": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28604": "iso885914",
      "iso885915": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28605": "iso885915",
      "iso885916": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28606": "iso885916",
      "cp437": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm437": "cp437",
      "csibm437": "cp437",
      "cp737": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm737": "cp737",
      "csibm737": "cp737",
      "cp775": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm775": "cp775",
      "csibm775": "cp775",
      "cp850": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm850": "cp850",
      "csibm850": "cp850",
      "cp852": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm852": "cp852",
      "csibm852": "cp852",
      "cp855": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm855": "cp855",
      "csibm855": "cp855",
      "cp856": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm856": "cp856",
      "csibm856": "cp856",
      "cp857": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm857": "cp857",
      "csibm857": "cp857",
      "cp858": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm858": "cp858",
      "csibm858": "cp858",
      "cp860": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm860": "cp860",
      "csibm860": "cp860",
      "cp861": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm861": "cp861",
      "csibm861": "cp861",
      "cp862": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm862": "cp862",
      "csibm862": "cp862",
      "cp863": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm863": "cp863",
      "csibm863": "cp863",
      "cp864": {
        "type": "_sbcs",
        "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
      },
      "ibm864": "cp864",
      "csibm864": "cp864",
      "cp865": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm865": "cp865",
      "csibm865": "cp865",
      "cp866": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm866": "cp866",
      "csibm866": "cp866",
      "cp869": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm869": "cp869",
      "csibm869": "cp869",
      "cp922": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm922": "cp922",
      "csibm922": "cp922",
      "cp1046": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm1046": "cp1046",
      "csibm1046": "cp1046",
      "cp1124": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm1124": "cp1124",
      "csibm1124": "cp1124",
      "cp1125": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm1125": "cp1125",
      "csibm1125": "cp1125",
      "cp1129": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm1129": "cp1129",
      "csibm1129": "cp1129",
      "cp1133": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm1133": "cp1133",
      "csibm1133": "cp1133",
      "cp1161": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm1161": "cp1161",
      "csibm1161": "cp1161",
      "cp1162": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm1162": "cp1162",
      "csibm1162": "cp1162",
      "cp1163": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm1163": "cp1163",
      "csibm1163": "cp1163",
      "maccroatian": {
        "type": "_sbcs",
        "chars": ""
      },
      "maccyrillic": {
        "type": "_sbcs",
        "chars": ""
      },
      "macgreek": {
        "type": "_sbcs",
        "chars": ""
      },
      "maciceland": {
        "type": "_sbcs",
        "chars": ""
      },
      "macroman": {
        "type": "_sbcs",
        "chars": ""
      },
      "macromania": {
        "type": "_sbcs",
        "chars": ""
      },
      "macthai": {
        "type": "_sbcs",
        "chars": "\uFEFF"
      },
      "macturkish": {
        "type": "_sbcs",
        "chars": ""
      },
      "macukraine": {
        "type": "_sbcs",
        "chars": ""
      },
      "koi8r": {
        "type": "_sbcs",
        "chars": ""
      },
      "koi8u": {
        "type": "_sbcs",
        "chars": ""
      },
      "koi8ru": {
        "type": "_sbcs",
        "chars": ""
      },
      "koi8t": {
        "type": "_sbcs",
        "chars": ""
      },
      "armscii8": {
        "type": "_sbcs",
        "chars": ")(.,-"
      },
      "rk1048": {
        "type": "_sbcs",
        "chars": ""
      },
      "tcvn": {
        "type": "_sbcs",
        "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
      },
      "georgianacademy": {
        "type": "_sbcs",
        "chars": ""
      },
      "georgianps": {
        "type": "_sbcs",
        "chars": ""
      },
      "pt154": {
        "type": "_sbcs",
        "chars": ""
      },
      "viscii": {
        "type": "_sbcs",
        "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
      },
      "iso646cn": {
        "type": "_sbcs",
        "chars": "\0\x07\b	\n\v\f\r\x1B !\"#%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}"
      },
      "iso646jp": {
        "type": "_sbcs",
        "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}"
      },
      "hproman8": {
        "type": "_sbcs",
        "chars": ""
      },
      "macintosh": {
        "type": "_sbcs",
        "chars": ""
      },
      "ascii": {
        "type": "_sbcs",
        "chars": ""
      },
      "tis620": {
        "type": "_sbcs",
        "chars": ""
      }
    };
  }
});

// ../../../node_modules/iconv-lite/encodings/dbcs-codec.js
var require_dbcs_codec = __commonJS({
  "../../../node_modules/iconv-lite/encodings/dbcs-codec.js"(exports2) {
    "use strict";
    var Buffer2 = require_safer().Buffer;
    exports2._dbcs = DBCSCodec;
    var UNASSIGNED = -1;
    var GB18030_CODE = -2;
    var SEQ_START = -10;
    var NODE_START = -1e3;
    var UNASSIGNED_NODE = new Array(256);
    var DEF_CHAR = -1;
    for (i = 0; i < 256; i++)
      UNASSIGNED_NODE[i] = UNASSIGNED;
    var i;
    function DBCSCodec(codecOptions, iconv) {
      this.encodingName = codecOptions.encodingName;
      if (!codecOptions)
        throw new Error("DBCS codec is called without the data.");
      if (!codecOptions.table)
        throw new Error("Encoding '" + this.encodingName + "' has no data.");
      var mappingTable = codecOptions.table();
      this.decodeTables = [];
      this.decodeTables[0] = UNASSIGNED_NODE.slice(0);
      this.decodeTableSeq = [];
      for (var i2 = 0; i2 < mappingTable.length; i2++)
        this._addDecodeChunk(mappingTable[i2]);
      this.defaultCharUnicode = iconv.defaultCharUnicode;
      this.encodeTable = [];
      this.encodeTableSeq = [];
      var skipEncodeChars = {};
      if (codecOptions.encodeSkipVals)
        for (var i2 = 0; i2 < codecOptions.encodeSkipVals.length; i2++) {
          var val = codecOptions.encodeSkipVals[i2];
          if (typeof val === "number")
            skipEncodeChars[val] = true;
          else
            for (var j = val.from; j <= val.to; j++)
              skipEncodeChars[j] = true;
        }
      this._fillEncodeTable(0, 0, skipEncodeChars);
      if (codecOptions.encodeAdd) {
        for (var uChar in codecOptions.encodeAdd)
          if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar))
            this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
      }
      this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
      if (this.defCharSB === UNASSIGNED)
        this.defCharSB = this.encodeTable[0]["?"];
      if (this.defCharSB === UNASSIGNED)
        this.defCharSB = "?".charCodeAt(0);
      if (typeof codecOptions.gb18030 === "function") {
        this.gb18030 = codecOptions.gb18030();
        var thirdByteNodeIdx = this.decodeTables.length;
        var thirdByteNode = this.decodeTables[thirdByteNodeIdx] = UNASSIGNED_NODE.slice(0);
        var fourthByteNodeIdx = this.decodeTables.length;
        var fourthByteNode = this.decodeTables[fourthByteNodeIdx] = UNASSIGNED_NODE.slice(0);
        for (var i2 = 129; i2 <= 254; i2++) {
          var secondByteNodeIdx = NODE_START - this.decodeTables[0][i2];
          var secondByteNode = this.decodeTables[secondByteNodeIdx];
          for (var j = 48; j <= 57; j++)
            secondByteNode[j] = NODE_START - thirdByteNodeIdx;
        }
        for (var i2 = 129; i2 <= 254; i2++)
          thirdByteNode[i2] = NODE_START - fourthByteNodeIdx;
        for (var i2 = 48; i2 <= 57; i2++)
          fourthByteNode[i2] = GB18030_CODE;
      }
    }
    DBCSCodec.prototype.encoder = DBCSEncoder;
    DBCSCodec.prototype.decoder = DBCSDecoder;
    DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
      var bytes = [];
      for (; addr > 0; addr >>= 8)
        bytes.push(addr & 255);
      if (bytes.length == 0)
        bytes.push(0);
      var node = this.decodeTables[0];
      for (var i2 = bytes.length - 1; i2 > 0; i2--) {
        var val = node[bytes[i2]];
        if (val == UNASSIGNED) {
          node[bytes[i2]] = NODE_START - this.decodeTables.length;
          this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
        } else if (val <= NODE_START) {
          node = this.decodeTables[NODE_START - val];
        } else
          throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
      }
      return node;
    };
    DBCSCodec.prototype._addDecodeChunk = function(chunk) {
      var curAddr = parseInt(chunk[0], 16);
      var writeTable = this._getDecodeTrieNode(curAddr);
      curAddr = curAddr & 255;
      for (var k = 1; k < chunk.length; k++) {
        var part = chunk[k];
        if (typeof part === "string") {
          for (var l = 0; l < part.length; ) {
            var code = part.charCodeAt(l++);
            if (55296 <= code && code < 56320) {
              var codeTrail = part.charCodeAt(l++);
              if (56320 <= codeTrail && codeTrail < 57344)
                writeTable[curAddr++] = 65536 + (code - 55296) * 1024 + (codeTrail - 56320);
              else
                throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + chunk[0]);
            } else if (4080 < code && code <= 4095) {
              var len = 4095 - code + 2;
              var seq = [];
              for (var m = 0; m < len; m++)
                seq.push(part.charCodeAt(l++));
              writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
              this.decodeTableSeq.push(seq);
            } else
              writeTable[curAddr++] = code;
          }
        } else if (typeof part === "number") {
          var charCode = writeTable[curAddr - 1] + 1;
          for (var l = 0; l < part; l++)
            writeTable[curAddr++] = charCode++;
        } else
          throw new Error("Incorrect type '" + typeof part + "' given in " + this.encodingName + " at chunk " + chunk[0]);
      }
      if (curAddr > 255)
        throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
    };
    DBCSCodec.prototype._getEncodeBucket = function(uCode) {
      var high = uCode >> 8;
      if (this.encodeTable[high] === void 0)
        this.encodeTable[high] = UNASSIGNED_NODE.slice(0);
      return this.encodeTable[high];
    };
    DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
      var bucket = this._getEncodeBucket(uCode);
      var low = uCode & 255;
      if (bucket[low] <= SEQ_START)
        this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode;
      else if (bucket[low] == UNASSIGNED)
        bucket[low] = dbcsCode;
    };
    DBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {
      var uCode = seq[0];
      var bucket = this._getEncodeBucket(uCode);
      var low = uCode & 255;
      var node;
      if (bucket[low] <= SEQ_START) {
        node = this.encodeTableSeq[SEQ_START - bucket[low]];
      } else {
        node = {};
        if (bucket[low] !== UNASSIGNED)
          node[DEF_CHAR] = bucket[low];
        bucket[low] = SEQ_START - this.encodeTableSeq.length;
        this.encodeTableSeq.push(node);
      }
      for (var j = 1; j < seq.length - 1; j++) {
        var oldVal = node[uCode];
        if (typeof oldVal === "object")
          node = oldVal;
        else {
          node = node[uCode] = {};
          if (oldVal !== void 0)
            node[DEF_CHAR] = oldVal;
        }
      }
      uCode = seq[seq.length - 1];
      node[uCode] = dbcsCode;
    };
    DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
      var node = this.decodeTables[nodeIdx];
      for (var i2 = 0; i2 < 256; i2++) {
        var uCode = node[i2];
        var mbCode = prefix + i2;
        if (skipEncodeChars[mbCode])
          continue;
        if (uCode >= 0)
          this._setEncodeChar(uCode, mbCode);
        else if (uCode <= NODE_START)
          this._fillEncodeTable(NODE_START - uCode, mbCode << 8, skipEncodeChars);
        else if (uCode <= SEQ_START)
          this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
      }
    };
    function DBCSEncoder(options, codec) {
      this.leadSurrogate = -1;
      this.seqObj = void 0;
      this.encodeTable = codec.encodeTable;
      this.encodeTableSeq = codec.encodeTableSeq;
      this.defaultCharSingleByte = codec.defCharSB;
      this.gb18030 = codec.gb18030;
    }
    DBCSEncoder.prototype.write = function(str) {
      var newBuf = Buffer2.alloc(str.length * (this.gb18030 ? 4 : 3)), leadSurrogate = this.leadSurrogate, seqObj = this.seqObj, nextChar = -1, i2 = 0, j = 0;
      while (true) {
        if (nextChar === -1) {
          if (i2 == str.length)
            break;
          var uCode = str.charCodeAt(i2++);
        } else {
          var uCode = nextChar;
          nextChar = -1;
        }
        if (55296 <= uCode && uCode < 57344) {
          if (uCode < 56320) {
            if (leadSurrogate === -1) {
              leadSurrogate = uCode;
              continue;
            } else {
              leadSurrogate = uCode;
              uCode = UNASSIGNED;
            }
          } else {
            if (leadSurrogate !== -1) {
              uCode = 65536 + (leadSurrogate - 55296) * 1024 + (uCode - 56320);
              leadSurrogate = -1;
            } else {
              uCode = UNASSIGNED;
            }
          }
        } else if (leadSurrogate !== -1) {
          nextChar = uCode;
          uCode = UNASSIGNED;
          leadSurrogate = -1;
        }
        var dbcsCode = UNASSIGNED;
        if (seqObj !== void 0 && uCode != UNASSIGNED) {
          var resCode = seqObj[uCode];
          if (typeof resCode === "object") {
            seqObj = resCode;
            continue;
          } else if (typeof resCode == "number") {
            dbcsCode = resCode;
          } else if (resCode == void 0) {
            resCode = seqObj[DEF_CHAR];
            if (resCode !== void 0) {
              dbcsCode = resCode;
              nextChar = uCode;
            } else {
            }
          }
          seqObj = void 0;
        } else if (uCode >= 0) {
          var subtable = this.encodeTable[uCode >> 8];
          if (subtable !== void 0)
            dbcsCode = subtable[uCode & 255];
          if (dbcsCode <= SEQ_START) {
            seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];
            continue;
          }
          if (dbcsCode == UNASSIGNED && this.gb18030) {
            var idx = findIdx(this.gb18030.uChars, uCode);
            if (idx != -1) {
              var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
              newBuf[j++] = 129 + Math.floor(dbcsCode / 12600);
              dbcsCode = dbcsCode % 12600;
              newBuf[j++] = 48 + Math.floor(dbcsCode / 1260);
              dbcsCode = dbcsCode % 1260;
              newBuf[j++] = 129 + Math.floor(dbcsCode / 10);
              dbcsCode = dbcsCode % 10;
              newBuf[j++] = 48 + dbcsCode;
              continue;
            }
          }
        }
        if (dbcsCode === UNASSIGNED)
          dbcsCode = this.defaultCharSingleByte;
        if (dbcsCode < 256) {
          newBuf[j++] = dbcsCode;
        } else if (dbcsCode < 65536) {
          newBuf[j++] = dbcsCode >> 8;
          newBuf[j++] = dbcsCode & 255;
        } else {
          newBuf[j++] = dbcsCode >> 16;
          newBuf[j++] = dbcsCode >> 8 & 255;
          newBuf[j++] = dbcsCode & 255;
        }
      }
      this.seqObj = seqObj;
      this.leadSurrogate = leadSurrogate;
      return newBuf.slice(0, j);
    };
    DBCSEncoder.prototype.end = function() {
      if (this.leadSurrogate === -1 && this.seqObj === void 0)
        return;
      var newBuf = Buffer2.alloc(10), j = 0;
      if (this.seqObj) {
        var dbcsCode = this.seqObj[DEF_CHAR];
        if (dbcsCode !== void 0) {
          if (dbcsCode < 256) {
            newBuf[j++] = dbcsCode;
          } else {
            newBuf[j++] = dbcsCode >> 8;
            newBuf[j++] = dbcsCode & 255;
          }
        } else {
        }
        this.seqObj = void 0;
      }
      if (this.leadSurrogate !== -1) {
        newBuf[j++] = this.defaultCharSingleByte;
        this.leadSurrogate = -1;
      }
      return newBuf.slice(0, j);
    };
    DBCSEncoder.prototype.findIdx = findIdx;
    function DBCSDecoder(options, codec) {
      this.nodeIdx = 0;
      this.prevBuf = Buffer2.alloc(0);
      this.decodeTables = codec.decodeTables;
      this.decodeTableSeq = codec.decodeTableSeq;
      this.defaultCharUnicode = codec.defaultCharUnicode;
      this.gb18030 = codec.gb18030;
    }
    DBCSDecoder.prototype.write = function(buf) {
      var newBuf = Buffer2.alloc(buf.length * 2), nodeIdx = this.nodeIdx, prevBuf = this.prevBuf, prevBufOffset = this.prevBuf.length, seqStart = -this.prevBuf.length, uCode;
      if (prevBufOffset > 0)
        prevBuf = Buffer2.concat([prevBuf, buf.slice(0, 10)]);
      for (var i2 = 0, j = 0; i2 < buf.length; i2++) {
        var curByte = i2 >= 0 ? buf[i2] : prevBuf[i2 + prevBufOffset];
        var uCode = this.decodeTables[nodeIdx][curByte];
        if (uCode >= 0) {
        } else if (uCode === UNASSIGNED) {
          i2 = seqStart;
          uCode = this.defaultCharUnicode.charCodeAt(0);
        } else if (uCode === GB18030_CODE) {
          var curSeq = seqStart >= 0 ? buf.slice(seqStart, i2 + 1) : prevBuf.slice(seqStart + prevBufOffset, i2 + 1 + prevBufOffset);
          var ptr = (curSeq[0] - 129) * 12600 + (curSeq[1] - 48) * 1260 + (curSeq[2] - 129) * 10 + (curSeq[3] - 48);
          var idx = findIdx(this.gb18030.gbChars, ptr);
          uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
        } else if (uCode <= NODE_START) {
          nodeIdx = NODE_START - uCode;
          continue;
        } else if (uCode <= SEQ_START) {
          var seq = this.decodeTableSeq[SEQ_START - uCode];
          for (var k = 0; k < seq.length - 1; k++) {
            uCode = seq[k];
            newBuf[j++] = uCode & 255;
            newBuf[j++] = uCode >> 8;
          }
          uCode = seq[seq.length - 1];
        } else
          throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);
        if (uCode > 65535) {
          uCode -= 65536;
          var uCodeLead = 55296 + Math.floor(uCode / 1024);
          newBuf[j++] = uCodeLead & 255;
          newBuf[j++] = uCodeLead >> 8;
          uCode = 56320 + uCode % 1024;
        }
        newBuf[j++] = uCode & 255;
        newBuf[j++] = uCode >> 8;
        nodeIdx = 0;
        seqStart = i2 + 1;
      }
      this.nodeIdx = nodeIdx;
      this.prevBuf = seqStart >= 0 ? buf.slice(seqStart) : prevBuf.slice(seqStart + prevBufOffset);
      return newBuf.slice(0, j).toString("ucs2");
    };
    DBCSDecoder.prototype.end = function() {
      var ret = "";
      while (this.prevBuf.length > 0) {
        ret += this.defaultCharUnicode;
        var buf = this.prevBuf.slice(1);
        this.prevBuf = Buffer2.alloc(0);
        this.nodeIdx = 0;
        if (buf.length > 0)
          ret += this.write(buf);
      }
      this.nodeIdx = 0;
      return ret;
    };
    function findIdx(table, val) {
      if (table[0] > val)
        return -1;
      var l = 0, r = table.length;
      while (l < r - 1) {
        var mid = l + Math.floor((r - l + 1) / 2);
        if (table[mid] <= val)
          l = mid;
        else
          r = mid;
      }
      return l;
    }
  }
});

// ../../../node_modules/iconv-lite/encodings/tables/shiftjis.json
var require_shiftjis = __commonJS({
  "../../../node_modules/iconv-lite/encodings/tables/shiftjis.json"(exports2, module2) {
    module2.exports = [
      ["0", "\0", 128],
      ["a1", "", 62],
      ["8140", "", 9, ""],
      ["8180", ""],
      ["81b8", ""],
      ["81c8", ""],
      ["81da", ""],
      ["81f0", ""],
      ["81fc", ""],
      ["824f", "", 9],
      ["8260", "", 25],
      ["8281", "", 25],
      ["829f", "", 82],
      ["8340", "", 62],
      ["8380", "", 22],
      ["839f", "", 16, "", 6],
      ["83bf", "", 16, "", 6],
      ["8440", "", 5, "", 25],
      ["8470", "", 5, "", 7],
      ["8480", "", 17],
      ["849f", ""],
      ["8740", "", 19, "", 9],
      ["875f", ""],
      ["877e", ""],
      ["8780", "", 4, ""],
      ["889f", ""],
      ["8940", ""],
      ["8980", ""],
      ["8a40", ""],
      ["8a80", ""],
      ["8b40", ""],
      ["8b80", ""],
      ["8c40", ""],
      ["8c80", ""],
      ["8d40", ""],
      ["8d80", ""],
      ["8e40", ""],
      ["8e80", ""],
      ["8f40", ""],
      ["8f80", ""],
      ["9040", ""],
      ["9080", ""],
      ["9140", ""],
      ["9180", ""],
      ["9240", ""],
      ["9280", ""],
      ["9340", ""],
      ["9380", ""],
      ["9440", ""],
      ["9480", ""],
      ["9540", ""],
      ["9580", ""],
      ["9640", ""],
      ["9680", ""],
      ["9740", ""],
      ["9780", ""],
      ["9840", ""],
      ["989f", ""],
      ["9940", ""],
      ["9980", ""],
      ["9a40", ""],
      ["9a80", ""],
      ["9b40", ""],
      ["9b80", ""],
      ["9c40", ""],
      ["9c80", ""],
      ["9d40", ""],
      ["9d80", ""],
      ["9e40", ""],
      ["9e80", ""],
      ["9f40", ""],
      ["9f80", ""],
      ["e040", ""],
      ["e080", ""],
      ["e140", ""],
      ["e180", ""],
      ["e240", ""],
      ["e280", ""],
      ["e340", ""],
      ["e380", ""],
      ["e440", ""],
      ["e480", ""],
      ["e540", ""],
      ["e580", ""],
      ["e640", ""],
      ["e680", ""],
      ["e740", ""],
      ["e780", ""],
      ["e840", ""],
      ["e880", ""],
      ["e940", ""],
      ["e980", ""],
      ["ea40", ""],
      ["ea80", ""],
      ["ed40", ""],
      ["ed80", ""],
      ["ee40", ""],
      ["ee80", ""],
      ["eeef", "", 9, ""],
      ["f040", "", 62],
      ["f080", "", 124],
      ["f140", "", 62],
      ["f180", "", 124],
      ["f240", "", 62],
      ["f280", "", 124],
      ["f340", "", 62],
      ["f380", "", 124],
      ["f440", "", 62],
      ["f480", "", 124],
      ["f540", "", 62],
      ["f580", "", 124],
      ["f640", "", 62],
      ["f680", "", 124],
      ["f740", "", 62],
      ["f780", "", 124],
      ["f840", "", 62],
      ["f880", "", 124],
      ["f940", ""],
      ["fa40", "", 9, "", 9, ""],
      ["fa80", ""],
      ["fb40", ""],
      ["fb80", ""],
      ["fc40", ""]
    ];
  }
});

// ../../../node_modules/iconv-lite/encodings/tables/eucjp.json
var require_eucjp = __commonJS({
  "../../../node_modules/iconv-lite/encodings/tables/eucjp.json"(exports2, module2) {
    module2.exports = [
      ["0", "\0", 127],
      ["8ea1", "", 62],
      ["a1a1", "", 9, ""],
      ["a2a1", ""],
      ["a2ba", ""],
      ["a2ca", ""],
      ["a2dc", ""],
      ["a2f2", ""],
      ["a2fe", ""],
      ["a3b0", "", 9],
      ["a3c1", "", 25],
      ["a3e1", "", 25],
      ["a4a1", "", 82],
      ["a5a1", "", 85],
      ["a6a1", "", 16, "", 6],
      ["a6c1", "", 16, "", 6],
      ["a7a1", "", 5, "", 25],
      ["a7d1", "", 5, "", 25],
      ["a8a1", ""],
      ["ada1", "", 19, "", 9],
      ["adc0", ""],
      ["addf", "", 4, ""],
      ["b0a1", ""],
      ["b1a1", ""],
      ["b2a1", ""],
      ["b3a1", ""],
      ["b4a1", ""],
      ["b5a1", ""],
      ["b6a1", ""],
      ["b7a1", ""],
      ["b8a1", ""],
      ["b9a1", ""],
      ["baa1", ""],
      ["bba1", ""],
      ["bca1", ""],
      ["bda1", ""],
      ["bea1", ""],
      ["bfa1", ""],
      ["c0a1", ""],
      ["c1a1", ""],
      ["c2a1", ""],
      ["c3a1", ""],
      ["c4a1", ""],
      ["c5a1", ""],
      ["c6a1", ""],
      ["c7a1", ""],
      ["c8a1", ""],
      ["c9a1", ""],
      ["caa1", ""],
      ["cba1", ""],
      ["cca1", ""],
      ["cda1", ""],
      ["cea1", ""],
      ["cfa1", ""],
      ["d0a1", ""],
      ["d1a1", ""],
      ["d2a1", ""],
      ["d3a1", ""],
      ["d4a1", ""],
      ["d5a1", ""],
      ["d6a1", ""],
      ["d7a1", ""],
      ["d8a1", ""],
      ["d9a1", ""],
      ["daa1", ""],
      ["dba1", ""],
      ["dca1", ""],
      ["dda1", ""],
      ["dea1", ""],
      ["dfa1", ""],
      ["e0a1", ""],
      ["e1a1", ""],
      ["e2a1", ""],
      ["e3a1", ""],
      ["e4a1", ""],
      ["e5a1", ""],
      ["e6a1", ""],
      ["e7a1", ""],
      ["e8a1", ""],
      ["e9a1", ""],
      ["eaa1", ""],
      ["eba1", ""],
      ["eca1", ""],
      ["eda1", ""],
      ["eea1", ""],
      ["efa1", ""],
      ["f0a1", ""],
      ["f1a1", ""],
      ["f2a1", ""],
      ["f3a1", ""],
      ["f4a1", ""],
      ["f9a1", ""],
      ["faa1", ""],
      ["fba1", ""],
      ["fca1", ""],
      ["fcf1", "", 9, ""],
      ["8fa2af", ""],
      ["8fa2c2", ""],
      ["8fa2eb", ""],
      ["8fa6e1", ""],
      ["8fa6e7", ""],
      ["8fa6e9", ""],
      ["8fa6ec", ""],
      ["8fa6f1", ""],
      ["8fa7c2", "", 10, ""],
      ["8fa7f2", "", 10, ""],
      ["8fa9a1", ""],
      ["8fa9a4", ""],
      ["8fa9a6", ""],
      ["8fa9a8", ""],
      ["8fa9ab", ""],
      ["8fa9af", ""],
      ["8fa9c1", ""],
      ["8faaa1", ""],
      ["8faaba", ""],
      ["8faba1", ""],
      ["8fabbd", ""],
      ["8fabc5", ""],
      ["8fb0a1", ""],
      ["8fb1a1", ""],
      ["8fb2a1", "", 4, ""],
      ["8fb3a1", ""],
      ["8fb4a1", ""],
      ["8fb5a1", ""],
      ["8fb6a1", "", 5, "", 4, ""],
      ["8fb7a1", "", 4, ""],
      ["8fb8a1", ""],
      ["8fb9a1", ""],
      ["8fbaa1", "", 4, ""],
      ["8fbba1", ""],
      ["8fbca1", "", 4, ""],
      ["8fbda1", "", 4, ""],
      ["8fbea1", "", 4, ""],
      ["8fbfa1", ""],
      ["8fc0a1", ""],
      ["8fc1a1", ""],
      ["8fc2a1", ""],
      ["8fc3a1", "", 4, ""],
      ["8fc4a1", ""],
      ["8fc5a1", ""],
      ["8fc6a1", ""],
      ["8fc7a1", ""],
      ["8fc8a1", ""],
      ["8fc9a1", "", 4, "", 4, ""],
      ["8fcaa1", ""],
      ["8fcba1", ""],
      ["8fcca1", "", 9, ""],
      ["8fcda1", "", 5, ""],
      ["8fcea1", "", 6, ""],
      ["8fcfa1", ""],
      ["8fd0a1", ""],
      ["8fd1a1", ""],
      ["8fd2a1", "", 5],
      ["8fd3a1", ""],
      ["8fd4a1", "", 4, ""],
      ["8fd5a1", ""],
      ["8fd6a1", ""],
      ["8fd7a1", ""],
      ["8fd8a1", ""],
      ["8fd9a1", "", 4, "", 6, ""],
      ["8fdaa1", "", 4, ""],
      ["8fdba1", "", 6, ""],
      ["8fdca1", "", 4, ""],
      ["8fdda1", "", 4, ""],
      ["8fdea1", "", 4, ""],
      ["8fdfa1", ""],
      ["8fe0a1", ""],
      ["8fe1a1", "", 4, ""],
      ["8fe2a1", ""],
      ["8fe3a1", "", 5, "", 4, ""],
      ["8fe4a1", "", 4, ""],
      ["8fe5a1", "", 4, ""],
      ["8fe6a1", ""],
      ["8fe7a1", ""],
      ["8fe8a1", "", 4, ""],
      ["8fe9a1", "", 4],
      ["8feaa1", "", 4, ""],
      ["8feba1", "", 4, ""],
      ["8feca1", ""],
      ["8feda1", "", 4, "", 4, ""]
    ];
  }
});

// ../../../node_modules/iconv-lite/encodings/tables/cp936.json
var require_cp936 = __commonJS({
  "../../../node_modules/iconv-lite/encodings/tables/cp936.json"(exports2, module2) {
    module2.exports = [
      ["0", "\0", 127, ""],
      ["8140", "", 5, "", 9, "", 6, ""],
      ["8180", "", 6, "", 4, "", 4, "", 5, ""],
      ["8240", "", 4, "", 8, "", 4, "", 11],
      ["8280", "", 10, "", 4, "", 7, "", 5, "", 8, "", 20, "", 4, "", 6, ""],
      ["8340", "", 17, "", 5, "", 10, "", 4, "", 9, ""],
      ["8380", "", 5, "", 13, "", 28, "", 4, "", 4, "", 5],
      ["8440", "", 5, "", 5, ""],
      ["8480", "", 9, "", 4, "", 6, "", 6, "", 9, "", 5, "", 10, "", 7, ""],
      ["8540", "", 9, ""],
      ["8580", "", 4, "", 6, "", 4, "", 4, "", 7, ""],
      ["8640", "", 4, "", 5, "", 4, "", 5, ""],
      ["8680", "", 4, "", 4, "", 5, "", 6, "", 8, "", 4, "", 4, "", 4, ""],
      ["8740", "", 7, "", 11, "", 4, "", 4],
      ["8780", "", 7, "", 6, "", 14, "", 10, "", 6, "", 12, "", 8, "", 5, "", 6],
      ["8840", "", 9, "", 4, "", 4, ""],
      ["8880", "", 4, "", 6, "", 8, "", 6, "", 7, "", 4, "", 4, "", 7],
      ["8940", "", 5, "", 6, "", 4, "", 5, "", 4, "", 16, ""],
      ["8980", "", 4, "", 4, "", 7, "", 17, "", 10, "", 13, "", 5, "", 7, "", 4, ""],
      ["8a40", "", 4, "", 12, ""],
      ["8a80", "", 5, "", 6, "", 4, "", 11, "", 6, "", 4, "", 4, "", 9, "", 5],
      ["8b40", "", 8, "", 17, "", 6, "", 13, ""],
      ["8b80", "", 4, "", 4, "", 5, "", 4, "", 4, "", 22, "", 11, "", 25, "", 7, "", 6],
      ["8c40", "", 7, ""],
      ["8c80", "", 8, "", 4, "", 6, "", 6, "", 6, "", 4, "", 4, "", 4],
      ["8d40", "", 5, "", 5, "", 5, "", 6, "", 9, "", 4],
      ["8d80", "", 5, "", 4, "", 4, "", 4, "", 7, "", 7, "", 10, "", 10, "", 12, "", 21, ""],
      ["8e40", "", 21, "", 12, "", 6, "", 12, ""],
      ["8e80", "", 4, "", 7, "", 4, "", 4, "", 5, "", 6, "", 4, "", 14, "", 4, "", 4, "", 6],
      ["8f40", "", 5, "", 11, "", 8, ""],
      ["8f80", "", 6, "", 14, "", 5, "", 5, "", 4, ""],
      ["9040", "", 4, "", 4, "", 6, ""],
      ["9080", "", 7, "", 4, "", 4, "", 4, "", 4, "", 18, "", 6],
      ["9140", "", 6, "", 6, "", 18, "", 4, ""],
      ["9180", "", 6, "", 8, "", 9, "", 5, "", 4, "", 4, "", 16, "", 13, "", 8, "", 5, "", 4, ""],
      ["9240", "", 6, "", 5, ""],
      ["9280", "", 5, "", 7, "", 6, ""],
      ["9340", "", 6, "", 4, "", 4, "", 5, ""],
      ["9380", "", 5, "", 4, "", 6, "", 4, "", 7, "", 9, "", 6, "", 8, "", 4, "", 6, ""],
      ["9440", "", 24, "", 7, "", 7, "", 4, "", 8],
      ["9480", "", 4, "", 4, "", 14, "", 7, "", 7, ""],
      ["9540", "", 4, "", 4, "", 6, ""],
      ["9580", "", 4, "", 4, "", 8, "", 4, "", 4, "", 25, "", 7, "", 5, ""],
      ["9640", "", 5, "", 4, ""],
      ["9680", "", 7, "", 9, "", 7, "", 4, "", 6, "", 6, "", 5],
      ["9740", "", 7, "", 8, "", 7, "", 9, ""],
      ["9780", "", 6, "", 5, "", 4, "", 9, "", 4, "", 11, "", 7, "", 16, ""],
      ["9840", "", 4, "", 5, "", 9, ""],
      ["9880", "", 7, "", 5, "", 11, "", 9, "", 9, "", 11, "", 5, "", 5, "", 6, "", 4, "", 7, "", 6, ""],
      ["9940", "", 4, "", 10, "", 6, "", 8, "", 4, "", 7, "", 5],
      ["9980", "", 114, "", 6],
      ["9a40", "", 11, "", 7, "", 13, ""],
      ["9a80", "", 4, "", 7, "", 7, "", 6, "", 4, "", 4, "", 7, "", 6, "", 4, "", 4, ""],
      ["9b40", "", 4, ""],
      ["9b80", "", 5, "", 4, "", 4, "", 5, ""],
      ["9c40", "", 7, ""],
      ["9c80", "", 7, "", 7, "", 10, "", 14, "", 4, "", 6, "", 5],
      ["9d40", "", 7, "", 4, "", 9, "", 6, ""],
      ["9d80", "", 9, "", 5, "", 6, "", 12, "", 4, "", 10, "", 5, "", 5, "", 6, "", 10, ""],
      ["9e40", "", 7, "", 32, "", 7, "", 6, "", 6],
      ["9e80", "", 9, "", 17, "", 13, "", 11, "", 12, "", 12, ""],
      ["9f40", "", 6, "", 10, "", 4, "", 10, "", 7, ""],
      ["9f80", "", 13, "", 12, "", 4, "", 4, "", 5, "", 4, "", 4, "", 6, "", 5, "", 8, "", 9, "", 4],
      ["a040", "", 9, "", 5, "", 9, "", 11, "", 19],
      ["a080", "", 9, "", 6, "", 4, "", 11, "", 11, "", 6, ""],
      ["a1a1", "", 7, ""],
      ["a2a1", "", 9],
      ["a2b1", "", 19, "", 19, "", 9],
      ["a2e5", "", 9],
      ["a2f1", "", 11],
      ["a3a1", "", 88, ""],
      ["a4a1", "", 82],
      ["a5a1", "", 85],
      ["a6a1", "", 16, "", 6],
      ["a6c1", "", 16, "", 6],
      ["a6e0", ""],
      ["a6ee", ""],
      ["a6f4", ""],
      ["a7a1", "", 5, "", 25],
      ["a7d1", "", 5, "", 25],
      ["a840", "", 35, "", 6],
      ["a880", "", 7, ""],
      ["a8a1", ""],
      ["a8bd", ""],
      ["a8c0", ""],
      ["a8c5", "", 36],
      ["a940", "", 8, ""],
      ["a959", ""],
      ["a95c", ""],
      ["a960", "", 9, "", 8],
      ["a980", "", 4, ""],
      ["a996", ""],
      ["a9a4", "", 75],
      ["aa40", "", 5, "", 5, "", 8],
      ["aa80", "", 7, "", 10, ""],
      ["ab40", "", 11, "", 4, "", 5, "", 4],
      ["ab80", "", 6, "", 4],
      ["ac40", "", 10, "", 8, "", 5, "", 4, "", 11],
      ["ac80", "", 6, "", 12, "", 4, ""],
      ["ad40", "", 10, "", 7, "", 15, "", 12],
      ["ad80", "", 9, "", 8, "", 6, ""],
      ["ae40", "", 6, "", 7, "", 4, ""],
      ["ae80", "", 7, "", 6, "", 4, ""],
      ["af40", "", 4, ""],
      ["af80", ""],
      ["b040", "", 6, "", 5, "", 4, "", 6, "", 7, ""],
      ["b080", "", 7, "", 8, "", 9, ""],
      ["b140", "", 4, "", 7, "", 10, ""],
      ["b180", "", 4, "", 7, "", 7, ""],
      ["b240", "", 11, "", 5, "", 11, "", 4],
      ["b280", "", 12, "", 8, "", 4, ""],
      ["b340", "", 5, ""],
      ["b380", "", 11, "", 7, "", 6, ""],
      ["b440", "", 7, "", 9],
      ["b480", "", 4, "", 5, "", 6, ""],
      ["b540", "", 5, "", 9, "", 4, "", 14, "", 4, "", 8, ""],
      ["b580", "", 6, "", 4, ""],
      ["b640", "", 6, "", 11, "", 10, "", 4, "", 5, ""],
      ["b680", "", 6, "", 4, ""],
      ["b740", "", 14, "", 5, "", 9, "", 4, "", 16],
      ["b780", "", 6, ""],
      ["b840", "", 4, "", 10, "", 10, "", 9, "", 5, ""],
      ["b880", "", 4, ""],
      ["b940", "", 5, "", 10, "", 6, ""],
      ["b980", "", 7, ""],
      ["ba40", "", 4, "", 4, "", 7, "", 5, ""],
      ["ba80", "", 4, "", 5, "", 12, "", 5, ""],
      ["bb40", "", 9, "", 36, "", 5, "", 9],
      ["bb80", "", 6, "", 4, ""],
      ["bc40", "", 6, "", 6, "", 5, "", 7, "", 13, "", 5],
      ["bc80", "", 14, "", 6, ""],
      ["bd40", "", 54, "", 7],
      ["bd80", "", 32, ""],
      ["be40", "", 12, "", 6, "", 42],
      ["be80", "", 32, ""],
      ["bf40", "", 62],
      ["bf80", "", 4, "", 4, "", 21, ""],
      ["c040", "", 35, "", 23, ""],
      ["c080", "", 6, "", 9, ""],
      ["c140", "", 4, "", 7, "", 4, "", 4, "", 6, ""],
      ["c180", "", 4, "", 4, "", 5, ""],
      ["c240", "", 6, "", 5, ""],
      ["c280", "", 13, "", 5, "", 11, ""],
      ["c340", "", 5, "", 4, "", 6, ""],
      ["c380", "", 12, "", 4, ""],
      ["c440", "", 5, "", 4, "", 4, "", 5, "", 4, ""],
      ["c480", "", 7, "", 5, "", 6, ""],
      ["c540", "", 14, "", 4, "", 5, "", 4, "", 5, ""],
      ["c580", "", 7, "", 7, ""],
      ["c640", ""],
      ["c680", "", 4, "", 9, ""],
      ["c740", "", 4, "", 4, "", 6, "", 6, "", 6, ""],
      ["c780", ""],
      ["c840", "", 4, "", 5, "", 5, "", 7, "", 5, "", 7, ""],
      ["c880", "", 6, "", 4, "", 4, ""],
      ["c940", "", 4, "", 7, "", 12, ""],
      ["c980", "", 4, "", 4, "", 10, ""],
      ["ca40", "", 8, "", 8, "", 9, "", 4, "", 10],
      ["ca80", "", 4, "", 8, ""],
      ["cb40", "", 6, "", 10, "", 6, "", 5, "", 6, "", 6, "", 4, ""],
      ["cb80", "", 5, "", 6, "", 14, ""],
      ["cc40", "", 4, "", 10, "", 15, "", 13, ""],
      ["cc80", "", 11, "", 4, "", 7, ""],
      ["cd40", "", 6, "", 6, "", 4, "", 5, "", 4, "", 4, ""],
      ["cd80", ""],
      ["ce40", "", 6, "", 5, "", 7, ""],
      ["ce80", "", 4, "", 6, "", 4, ""],
      ["cf40", "", 4, "", 4, "", 6, "", 9],
      ["cf80", "", 5, "", 7, "", 4, ""],
      ["d040", "", 13, "", 5, "", 5, "", 5, "", 6, ""],
      ["d080", "", 4, "", 4, "", 5, ""],
      ["d140", "", 4, "", 4, "", 6, "", 5],
      ["d180", "", 4, "", 4, "", 4, ""],
      ["d240", "", 8, "", 24, "", 5, "", 19, ""],
      ["d280", "", 26, ""],
      ["d340", "", 30, "", 6],
      ["d380", "", 4, "", 5, "", 21, ""],
      ["d440", "", 31, "", 8, "", 21],
      ["d480", "", 25, "", 6, ""],
      ["d540", "", 7, "", 7, "", 46],
      ["d580", "", 32, ""],
      ["d640", "", 34, "", 27],
      ["d680", "", 30, ""],
      ["d740", "", 31, "", 4, "", 25],
      ["d780", "", 24, ""],
      ["d840", "", 8, "", 7, "", 5, "", 6, "", 6, "", 6, ""],
      ["d880", "", 6, "", 20, ""],
      ["d940", "", 62],
      ["d980", "", 32, ""],
      ["da40", "", 14, "", 8, "", 4, "", 9, ""],
      ["da80", "", 12, ""],
      ["db40", "", 6, "", 7, "", 4, ""],
      ["db80", "", 4, "", 5, "", 11, ""],
      ["dc40", "", 4, "", 6, "", 6, "", 11, "", 6, "", 7],
      ["dc80", "", 10, "", 21, ""],
      ["dd40", "", 62],
      ["dd80", "", 32, ""],
      ["de40", "", 32, ""],
      ["de80", "", 4, ""],
      ["df40", "", 5, "", 4, "", 4, "", 5, "", 4, "", 6, ""],
      ["df80", "", 4, ""],
      ["e040", "", 19, ""],
      ["e080", "", 10, "", 6, "", 8, ""],
      ["e140", "", 4, "", 6, "", 5, "", 5, ""],
      ["e180", "", 10, "", 9, "", 8, ""],
      ["e240", "", 62],
      ["e280", "", 32, "", 5, ""],
      ["e340", "", 45, "", 16],
      ["e380", "", 7, "", 24, ""],
      ["e440", "", 5, "", 24, "", 31],
      ["e480", "", 32, ""],
      ["e540", "", 51, "", 10],
      ["e580", "", 31, ""],
      ["e640", "", 34, "", 27],
      ["e680", "", 29, ""],
      ["e740", "", 7, "", 54],
      ["e780", "", 32, "", 6, "", 4, ""],
      ["e840", "", 14, "", 43, ""],
      ["e880", "", 20, ""],
      ["e940", "", 7, "", 42],
      ["e980", "", 32, ""],
      ["ea40", "", 27, "", 6, ""],
      ["ea80", "", 4, "", 12, ""],
      ["eb40", "", 9, "", 7, "", 9, "", 6, ""],
      ["eb80", "", 4, ""],
      ["ec40", "", 8, "", 4, "", 18, "", 7],
      ["ec80", "", 4, "", 7, "", 4, "", 4, ""],
      ["ed40", "", 6, "", 46],
      ["ed80", "", 4, "", 23, ""],
      ["ee40", "", 62],
      ["ee80", "", 32, "", 4, "", 6, ""],
      ["ef40", "", 5, "", 37, "", 4],
      ["ef80", "", 30, "", 4, "", 8, ""],
      ["f040", "", 4, "", 28, "", 26],
      ["f080", "", 9, "", 12, "", 4, "", 6, ""],
      ["f140", "", 10, "", 47],
      ["f180", "", 32, ""],
      ["f240", "", 62],
      ["f280", "", 32, ""],
      ["f340", "", 17, "", 6, "", 4, ""],
      ["f380", "", 8, "", 6, ""],
      ["f440", "", 5, "", 10, "", 10, "", 7, "", 5],
      ["f480", "", 32, ""],
      ["f540", "", 62],
      ["f580", "", 32, ""],
      ["f640", "", 62],
      ["f680", "", 32, "", 5, "", 5, "", 4, "", 7, ""],
      ["f740", "", 62],
      ["f780", "", 4, "", 4, ""],
      ["f840", "", 62],
      ["f880", "", 32],
      ["f940", "", 62],
      ["f980", "", 32],
      ["fa40", "", 62],
      ["fa80", "", 32],
      ["fb40", "", 27, "", 9, ""],
      ["fb80", "", 5, "", 8, "", 5, ""],
      ["fc40", "", 8, "", 4, "", 8, "", 6],
      ["fc80", "", 4, "", 5, "", 8, ""],
      ["fd40", "", 4, "", 4, "", 10, "", 38],
      ["fd80", "", 5, "", 11, "", 4, ""],
      ["fe40", ""]
    ];
  }
});

// ../../../node_modules/iconv-lite/encodings/tables/gbk-added.json
var require_gbk_added = __commonJS({
  "../../../node_modules/iconv-lite/encodings/tables/gbk-added.json"(exports2, module2) {
    module2.exports = [
      ["a140", "", 62],
      ["a180", "", 32],
      ["a240", "", 62],
      ["a280", "", 32],
      ["a2ab", "", 5],
      ["a2e3", ""],
      ["a2ef", ""],
      ["a2fd", ""],
      ["a340", "", 62],
      ["a380", "", 31, ""],
      ["a440", "", 62],
      ["a480", "", 32],
      ["a4f4", "", 10],
      ["a540", "", 62],
      ["a580", "", 32],
      ["a5f7", "", 7],
      ["a640", "", 62],
      ["a680", "", 32],
      ["a6b9", "", 7],
      ["a6d9", "", 6],
      ["a6ec", ""],
      ["a6f3", ""],
      ["a6f6", "", 8],
      ["a740", "", 62],
      ["a780", "", 32],
      ["a7c2", "", 14],
      ["a7f2", "", 12],
      ["a896", "", 10],
      ["a8bc", ""],
      ["a8bf", ""],
      ["a8c1", ""],
      ["a8ea", "", 20],
      ["a958", ""],
      ["a95b", ""],
      ["a95d", ""],
      ["a989", "", 11],
      ["a997", "", 12],
      ["a9f0", "", 14],
      ["aaa1", "", 93],
      ["aba1", "", 93],
      ["aca1", "", 93],
      ["ada1", "", 93],
      ["aea1", "", 93],
      ["afa1", "", 93],
      ["d7fa", "", 4],
      ["f8a1", "", 93],
      ["f9a1", "", 93],
      ["faa1", "", 93],
      ["fba1", "", 93],
      ["fca1", "", 93],
      ["fda1", "", 93],
      ["fe50", ""],
      ["fe80", "", 6, "", 93]
    ];
  }
});

// ../../../node_modules/iconv-lite/encodings/tables/gb18030-ranges.json
var require_gb18030_ranges = __commonJS({
  "../../../node_modules/iconv-lite/encodings/tables/gb18030-ranges.json"(exports2, module2) {
    module2.exports = { uChars: [128, 165, 169, 178, 184, 216, 226, 235, 238, 244, 248, 251, 253, 258, 276, 284, 300, 325, 329, 334, 364, 463, 465, 467, 469, 471, 473, 475, 477, 506, 594, 610, 712, 716, 730, 930, 938, 962, 970, 1026, 1104, 1106, 8209, 8215, 8218, 8222, 8231, 8241, 8244, 8246, 8252, 8365, 8452, 8454, 8458, 8471, 8482, 8556, 8570, 8596, 8602, 8713, 8720, 8722, 8726, 8731, 8737, 8740, 8742, 8748, 8751, 8760, 8766, 8777, 8781, 8787, 8802, 8808, 8816, 8854, 8858, 8870, 8896, 8979, 9322, 9372, 9548, 9588, 9616, 9622, 9634, 9652, 9662, 9672, 9676, 9680, 9702, 9735, 9738, 9793, 9795, 11906, 11909, 11913, 11917, 11928, 11944, 11947, 11951, 11956, 11960, 11964, 11979, 12284, 12292, 12312, 12319, 12330, 12351, 12436, 12447, 12535, 12543, 12586, 12842, 12850, 12964, 13200, 13215, 13218, 13253, 13263, 13267, 13270, 13384, 13428, 13727, 13839, 13851, 14617, 14703, 14801, 14816, 14964, 15183, 15471, 15585, 16471, 16736, 17208, 17325, 17330, 17374, 17623, 17997, 18018, 18212, 18218, 18301, 18318, 18760, 18811, 18814, 18820, 18823, 18844, 18848, 18872, 19576, 19620, 19738, 19887, 40870, 59244, 59336, 59367, 59413, 59417, 59423, 59431, 59437, 59443, 59452, 59460, 59478, 59493, 63789, 63866, 63894, 63976, 63986, 64016, 64018, 64021, 64025, 64034, 64037, 64042, 65074, 65093, 65107, 65112, 65127, 65132, 65375, 65510, 65536], gbChars: [0, 36, 38, 45, 50, 81, 89, 95, 96, 100, 103, 104, 105, 109, 126, 133, 148, 172, 175, 179, 208, 306, 307, 308, 309, 310, 311, 312, 313, 341, 428, 443, 544, 545, 558, 741, 742, 749, 750, 805, 819, 820, 7922, 7924, 7925, 7927, 7934, 7943, 7944, 7945, 7950, 8062, 8148, 8149, 8152, 8164, 8174, 8236, 8240, 8262, 8264, 8374, 8380, 8381, 8384, 8388, 8390, 8392, 8393, 8394, 8396, 8401, 8406, 8416, 8419, 8424, 8437, 8439, 8445, 8482, 8485, 8496, 8521, 8603, 8936, 8946, 9046, 9050, 9063, 9066, 9076, 9092, 9100, 9108, 9111, 9113, 9131, 9162, 9164, 9218, 9219, 11329, 11331, 11334, 11336, 11346, 11361, 11363, 11366, 11370, 11372, 11375, 11389, 11682, 11686, 11687, 11692, 11694, 11714, 11716, 11723, 11725, 11730, 11736, 11982, 11989, 12102, 12336, 12348, 12350, 12384, 12393, 12395, 12397, 12510, 12553, 12851, 12962, 12973, 13738, 13823, 13919, 13933, 14080, 14298, 14585, 14698, 15583, 15847, 16318, 16434, 16438, 16481, 16729, 17102, 17122, 17315, 17320, 17402, 17418, 17859, 17909, 17911, 17915, 17916, 17936, 17939, 17961, 18664, 18703, 18814, 18962, 19043, 33469, 33470, 33471, 33484, 33485, 33490, 33497, 33501, 33505, 33513, 33520, 33536, 33550, 37845, 37921, 37948, 38029, 38038, 38064, 38065, 38066, 38069, 38075, 38076, 38078, 39108, 39109, 39113, 39114, 39115, 39116, 39265, 39394, 189e3] };
  }
});

// ../../../node_modules/iconv-lite/encodings/tables/cp949.json
var require_cp949 = __commonJS({
  "../../../node_modules/iconv-lite/encodings/tables/cp949.json"(exports2, module2) {
    module2.exports = [
      ["0", "\0", 127],
      ["8141", "", 4, "", 6, ""],
      ["8161", "", 9, "", 5, ""],
      ["8181", "", 18, "", 4, "", 6, "", 5, "", 6, "", 7, "", 7, "", 4, "", 4, ""],
      ["8241", "", 7, "", 5],
      ["8261", "", 6, "", 5, ""],
      ["8281", "", 7, "", 7, "", 4, "", 10, "", 5, "", 17, "", 7, "", 6, "", 7, "", 18],
      ["8341", "", 5, "", 5, "", 7],
      ["8361", "", 18, ""],
      ["8381", "", 4, "", 6, "", 5, "", 5, "", 46, "", 6, "", 5, "", 8],
      ["8441", "", 5, "", 8],
      ["8461", "", 18],
      ["8481", "", 7, "", 6, "", 5, "", 10, "", 5, "", 18, "", 5, "", 6, "", 5, "", 26, ""],
      ["8541", "", 5, "", 4, "", 6, "", 4],
      ["8561", "", 5, "", 5, "", 6, ""],
      ["8581", "", 6, "", 6, "", 9, "", 26, "", 29, "", 6, "", 5, ""],
      ["8641", "", 6, "", 5, ""],
      ["8661", "", 6, "", 10],
      ["8681", "", 22, "", 4, "", 6, "", 5, "", 6, "", 22, "", 4, ""],
      ["8741", "", 9, "", 15],
      ["8761", "", 18, ""],
      ["8781", "", 5, "", 7, "", 7, "", 5, "", 6, "", 5, "", 18, "", 6, "", 26, "", 6, "", 4],
      ["8841", "", 4, "", 5, "", 6, "", 4],
      ["8861", "", 4, ""],
      ["8881", "", 15, "", 4, "", 6, "", 5, "", 54, ""],
      ["8941", "", 6, "", 5, ""],
      ["8961", "", 10, "", 5, ""],
      ["8981", "", 21, "", 18, "", 18, "", 6, "", 6, "", 7, "", 15],
      ["8a41", "", 10, "", 6, ""],
      ["8a61", "", 4, "", 18, ""],
      ["8a81", "", 4, "", 19, "", 5, "", 7, "", 5, "", 6, "", 5, "", 4, "", 5, "", 26, ""],
      ["8b41", "", 5, "", 4, "", 6, ""],
      ["8b61", "", 6, "", 8],
      ["8b81", "", 52, "", 4, "", 6, "", 5, "", 18, "", 18],
      ["8c41", "", 15, "", 4],
      ["8c61", "", 6, "", 5, "", 6, "", 5],
      ["8c81", "", 12, "", 26, "", 50, "", 5, "", 16],
      ["8d41", "", 16, "", 8],
      ["8d61", "", 17, ""],
      ["8d81", "", 4, "", 33, "", 6, "", 7, "", 6, "", 9, "", 6, "", 5, "", 6, ""],
      ["8e41", "", 6, "", 5, "", 8],
      ["8e61", "", 4, "", 19],
      ["8e81", "", 13, "", 6, "", 4, "", 6, "", 5, "", 6, "", 5, "", 11, "", 7, "", 6, "", 5, "", 7],
      ["8f41", "", 7, "", 17],
      ["8f61", "", 7, "", 6, "", 4],
      ["8f81", "", 5, "", 7, "", 5, "", 6, "", 5, "", 18, "", 6, "", 26, "", 6, "", 5],
      ["9041", "", 6, "", 5, ""],
      ["9061", "", 5, "", 15],
      ["9081", "", 12, "", 6, "", 5, "", 4, "", 6, "", 4, "", 5, "", 11, "", 33, ""],
      ["9141", "", 6, "", 5],
      ["9161", "", 9, "", 5],
      ["9181", "", 20, "", 4, "", 5, "", 14, "", 33, "", 7, "", 5, "", 6],
      ["9241", "", 7, "", 4, ""],
      ["9261", "", 7, "", 7, "", 4],
      ["9281", "", 21, "", 18, "", 6, "", 7, "", 6, "", 35, ""],
      ["9341", "", 4, ""],
      ["9361", "", 6, "", 8],
      ["9381", "", 37, "", 4, "", 4, "", 6, "", 5, "", 7, "", 22, ""],
      ["9441", "", 5, "", 5, "", 8],
      ["9461", "", 5, "", 6, "", 12],
      ["9481", "", 5, "", 6, "", 6, "", 9, "", 22, "", 4, "", 6, "", 10, "", 6, "", 24],
      ["9541", "", 11, "", 5, ""],
      ["9561", "", 6, "", 5, ""],
      ["9581", "", 6, "", 35, "", 4, "", 4, "", 4, "", 6, "", 5, "", 13, "", 14],
      ["9641", "", 23, ""],
      ["9661", "", 6, "", 5, "", 8],
      ["9681", "", 10, "", 5, "", 13, "", 33, "", 6, "", 44],
      ["9741", "", 16, "", 8],
      ["9761", "", 17, "", 7],
      ["9781", "", 11, "", 5, "", 6, "", 89, ""],
      ["9841", "", 16, "", 5, ""],
      ["9861", "", 6, "", 15],
      ["9881", "", 21, "", 6, "", 5, "", 4, "", 6, "", 5, "", 6, "", 5, "", 6, "", 5, ""],
      ["9941", "", 6, "", 5, ""],
      ["9961", "", 6, "", 5, ""],
      ["9981", "", 8, "", 5, "", 4, "", 11, "", 5, "", 6, "", 6, "", 6, "", 7, "", 6, "", 5, ""],
      ["9a41", "", 16],
      ["9a61", "", 6, "", 6, ""],
      ["9a81", "", 4, "", 6, "", 5, "", 5, "", 6, "", 5, "", 5, "", 33, "", 5, "", 6, ""],
      ["9b41", "", 6, "", 8],
      ["9b61", "", 17, "", 7],
      ["9b81", "", 25, "", 4, "", 5, "", 50, "", 22, ""],
      ["9c41", "", 4, "", 5, "", 5],
      ["9c61", "", 8, "", 6, "", 9],
      ["9c81", "", 8, "", 6, "", 6, "", 9, "", 26, "", 6, "", 5, "", 18, "", 6, "", 12],
      ["9d41", "", 13, "", 8],
      ["9d61", "", 25],
      ["9d81", "", 8, "", 5, "", 9, "", 6, "", 10, "", 6, "", 5, "", 6, "", 5, ""],
      ["9e41", "", 7, "", 9, ""],
      ["9e61", "", 4, "", 6, ""],
      ["9e81", "", 6, "", 6, "", 6, "", 5, "", 10, "", 5, "", 6, "", 5, "", 6, ""],
      ["9f41", "", 5, "", 4, "", 5, ""],
      ["9f61", "", 6, "", 5, ""],
      ["9f81", "", 4, "", 5, "", 6, "", 5, "", 6, "", 4, "", 6, "", 7, "", 4, "", 4, ""],
      ["a041", "", 5, "", 6, ""],
      ["a061", "", 5, "", 13],
      ["a081", "", 4, "", 4, "", 4, "", 6, "", 5, "", 6, "", 5, "", 26, "", 4, "", 5, "", 7, ""],
      ["a141", "", 18, ""],
      ["a161", "", 6, "", 5, ""],
      ["a181", "", 14, "", 5, "", 4, "", 9, ""],
      ["a241", "", 5, "", 18],
      ["a261", "", 6, "", 18],
      ["a281", "", 7, "", 6, "", 7, ""],
      ["a341", "", 6, "", 10, ""],
      ["a361", "", 6, "", 16],
      ["a381", "", 16, "", 4, "", 58, "", 32, ""],
      ["a441", "", 5, ""],
      ["a461", "", 5, "", 12],
      ["a481", "", 28, "", 93],
      ["a541", "", 4, "", 6, "", 5, ""],
      ["a561", "", 17, "", 5, ""],
      ["a581", "", 16, "", 14, "", 9],
      ["a5b0", "", 9],
      ["a5c1", "", 16, "", 6],
      ["a5e1", "", 16, "", 6],
      ["a641", "", 19, ""],
      ["a661", "", 5, "", 5, "", 6],
      ["a681", "", 6, "", 18, "", 7],
      ["a741", "", 4, "", 6, "", 7],
      ["a761", "", 22, ""],
      ["a781", "", 6, "", 5, "", 7, "", 9, "", 9, "", 4, "", 5, "", 4, ""],
      ["a841", "", 10, "", 14],
      ["a861", "", 18, "", 6],
      ["a881", "", 19, "", 11, ""],
      ["a8a6", ""],
      ["a8a8", ""],
      ["a8b1", "", 27, "", 25, "", 14, ""],
      ["a941", "", 14, "", 10],
      ["a961", "", 18],
      ["a981", "", 14, "", 6, "", 27, "", 25, "", 14, ""],
      ["aa41", "", 6, "", 4, ""],
      ["aa61", "", 4, "", 5, "", 6, ""],
      ["aa81", "", 29, "", 82],
      ["ab41", "", 6, "", 5, ""],
      ["ab61", "", 6, "", 5, "", 5],
      ["ab81", "", 8, "", 6, "", 12, "", 85],
      ["ac41", "", 5, "", 6, ""],
      ["ac61", "", 11, "", 4],
      ["ac81", "", 28, "", 5, "", 25],
      ["acd1", "", 5, "", 25],
      ["ad41", "", 6, "", 5, "", 7],
      ["ad61", "", 6, "", 10, ""],
      ["ad81", "", 5, "", 18, ""],
      ["ae41", "", 5, "", 16],
      ["ae61", "", 5, "", 6, "", 4],
      ["ae81", "", 6, "", 5, ""],
      ["af41", "", 19],
      ["af61", "", 13, "", 5, ""],
      ["af81", "", 5, "", 6, "", 5, ""],
      ["b041", "", 5, "", 5, "", 12],
      ["b061", "", 5, "", 19],
      ["b081", "", 13, "", 6, "", 5, "", 7, "", 4, ""],
      ["b141", "", 6, "", 5, ""],
      ["b161", "", 6, "", 5, "", 11],
      ["b181", "", 14, "", 6, ""],
      ["b241", "", 6, "", 5, ""],
      ["b261", "", 18, "", 5, ""],
      ["b281", "", 5, "", 18, "", 6, ""],
      ["b341", "", 19, ""],
      ["b361", "", 5, "", 5, "", 5],
      ["b381", "", 5, "", 5, "", 19, "", 4, ""],
      ["b441", "", 5, "", 6, "", 5],
      ["b461", "", 6, "", 10, ""],
      ["b481", "", 6, "", 18, "", 4, "", 4, ""],
      ["b541", "", 14, "", 5],
      ["b561", "", 5, "", 5, "", 4],
      ["b581", "", 6, "", 5, "", 11, ""],
      ["b641", "", 7, "", 17],
      ["b661", "", 15, ""],
      ["b681", "", 5, "", 6, "", 5, ""],
      ["b741", "", 13, "", 6, ""],
      ["b761", "", 20, ""],
      ["b781", "", 6, "", 14, ""],
      ["b841", "", 7, "", 17],
      ["b861", "", 8, "", 13],
      ["b881", "", 5, "", 24, "", 4, ""],
      ["b941", "", 6, "", 5, ""],
      ["b961", "", 14, "", 6, ""],
      ["b981", "", 22, "", 4, "", 4, ""],
      ["ba41", "", 5, "", 6, ""],
      ["ba61", "", 5, "", 4, "", 5],
      ["ba81", "", 6, "", 9, ""],
      ["bb41", "", 4, "", 5, "", 4, ""],
      ["bb61", "", 6, "", 5, ""],
      ["bb81", "", 31, ""],
      ["bc41", "", 17, ""],
      ["bc61", "", 5, "", 6, ""],
      ["bc81", "", 4, "", 6, "", 5, "", 5, "", 4, ""],
      ["bd41", "", 7, "", 7, ""],
      ["bd61", "", 5, "", 13],
      ["bd81", "", 5, "", 25, ""],
      ["be41", "", 7, "", 14],
      ["be61", "", 7, "", 7, ""],
      ["be81", "", 4, "", 4, "", 5, "", 8, "", 6, ""],
      ["bf41", "", 10, "", 14],
      ["bf61", "", 18, ""],
      ["bf81", "", 5, "", 7, "", 6, "", 5, ""],
      ["c041", "", 5, "", 6, "", 5],
      ["c061", "", 25],
      ["c081", "", 6, "", 5, "", 7, ""],
      ["c141", "", 5, "", 6, ""],
      ["c161", "", 19, ""],
      ["c181", "", 31, ""],
      ["c241", "", 4, "", 5, ""],
      ["c261", "", 4, "", 5, "", 6, ""],
      ["c281", "", 5, "", 7, "", 9, ""],
      ["c341", "", 4],
      ["c361", "", 4, "", 5, "", 11],
      ["c381", "", 5, "", 7, "", 5, ""],
      ["c441", "", 7, "", 7, ""],
      ["c461", "", 5, "", 4],
      ["c481", "", 5, "", 11, ""],
      ["c541", "", 6, "", 5, ""],
      ["c561", "", 6, "", 5, "", 4],
      ["c581", "", 6, "", 5, ""],
      ["c641", "", 6, "", 5],
      ["c6a1", ""],
      ["c7a1", ""],
      ["c8a1", ""],
      ["caa1", ""],
      ["cba1", ""],
      ["cca1", ""],
      ["cda1", ""],
      ["cea1", ""],
      ["cfa1", ""],
      ["d0a1", ""],
      ["d1a1", "", 5, "", 4, ""],
      ["d2a1", "", 4, "", 5, "", 10, "", 7, "", 5, ""],
      ["d3a1", ""],
      ["d4a1", ""],
      ["d5a1", ""],
      ["d6a1", ""],
      ["d7a1", ""],
      ["d8a1", ""],
      ["d9a1", ""],
      ["daa1", ""],
      ["dba1", ""],
      ["dca1", ""],
      ["dda1", ""],
      ["dea1", ""],
      ["dfa1", ""],
      ["e0a1", ""],
      ["e1a1", ""],
      ["e2a1", ""],
      ["e3a1", ""],
      ["e4a1", ""],
      ["e5a1", ""],
      ["e6a1", ""],
      ["e7a1", ""],
      ["e8a1", ""],
      ["e9a1", ""],
      ["eaa1", ""],
      ["eba1", ""],
      ["eca1", ""],
      ["eda1", ""],
      ["eea1", ""],
      ["efa1", ""],
      ["f0a1", ""],
      ["f1a1", ""],
      ["f2a1", ""],
      ["f3a1", ""],
      ["f4a1", ""],
      ["f5a1", ""],
      ["f6a1", ""],
      ["f7a1", ""],
      ["f8a1", ""],
      ["f9a1", ""],
      ["faa1", ""],
      ["fba1", ""],
      ["fca1", ""],
      ["fda1", ""]
    ];
  }
});

// ../../../node_modules/iconv-lite/encodings/tables/cp950.json
var require_cp950 = __commonJS({
  "../../../node_modules/iconv-lite/encodings/tables/cp950.json"(exports2, module2) {
    module2.exports = [
      ["0", "\0", 127],
      ["a140", ""],
      ["a1a1", "", 4, ""],
      ["a240", "", 7, ""],
      ["a2a1", "", 9, "", 9, "", 8, "", 25, "", 21],
      ["a340", "", 16, "", 6, "", 16, "", 6, "", 10],
      ["a3a1", "", 25, ""],
      ["a3e1", ""],
      ["a440", ""],
      ["a4a1", ""],
      ["a540", ""],
      ["a5a1", ""],
      ["a640", ""],
      ["a6a1", ""],
      ["a740", ""],
      ["a7a1", ""],
      ["a840", ""],
      ["a8a1", ""],
      ["a940", ""],
      ["a9a1", ""],
      ["aa40", ""],
      ["aaa1", ""],
      ["ab40", ""],
      ["aba1", ""],
      ["ac40", ""],
      ["aca1", ""],
      ["ad40", ""],
      ["ada1", ""],
      ["ae40", ""],
      ["aea1", ""],
      ["af40", ""],
      ["afa1", ""],
      ["b040", ""],
      ["b0a1", ""],
      ["b140", ""],
      ["b1a1", ""],
      ["b240", ""],
      ["b2a1", ""],
      ["b340", ""],
      ["b3a1", ""],
      ["b440", ""],
      ["b4a1", ""],
      ["b540", ""],
      ["b5a1", ""],
      ["b640", ""],
      ["b6a1", ""],
      ["b740", ""],
      ["b7a1", ""],
      ["b840", ""],
      ["b8a1", ""],
      ["b940", ""],
      ["b9a1", ""],
      ["ba40", ""],
      ["baa1", ""],
      ["bb40", ""],
      ["bba1", ""],
      ["bc40", ""],
      ["bca1", ""],
      ["bd40", ""],
      ["bda1", ""],
      ["be40", ""],
      ["bea1", ""],
      ["bf40", ""],
      ["bfa1", ""],
      ["c040", ""],
      ["c0a1", ""],
      ["c140", ""],
      ["c1a1", ""],
      ["c240", ""],
      ["c2a1", ""],
      ["c340", ""],
      ["c3a1", ""],
      ["c440", ""],
      ["c4a1", ""],
      ["c540", ""],
      ["c5a1", ""],
      ["c640", ""],
      ["c940", ""],
      ["c9a1", ""],
      ["ca40", ""],
      ["caa1", ""],
      ["cb40", ""],
      ["cba1", ""],
      ["cc40", ""],
      ["cca1", ""],
      ["cd40", ""],
      ["cda1", ""],
      ["ce40", ""],
      ["cea1", ""],
      ["cf40", ""],
      ["cfa1", ""],
      ["d040", ""],
      ["d0a1", ""],
      ["d140", ""],
      ["d1a1", ""],
      ["d240", ""],
      ["d2a1", ""],
      ["d340", ""],
      ["d3a1", ""],
      ["d440", ""],
      ["d4a1", ""],
      ["d540", ""],
      ["d5a1", ""],
      ["d640", ""],
      ["d6a1", ""],
      ["d740", ""],
      ["d7a1", ""],
      ["d840", ""],
      ["d8a1", ""],
      ["d940", ""],
      ["d9a1", ""],
      ["da40", ""],
      ["daa1", ""],
      ["db40", ""],
      ["dba1", ""],
      ["dc40", ""],
      ["dca1", ""],
      ["dd40", ""],
      ["dda1", ""],
      ["de40", ""],
      ["dea1", ""],
      ["df40", ""],
      ["dfa1", ""],
      ["e040", ""],
      ["e0a1", ""],
      ["e140", ""],
      ["e1a1", ""],
      ["e240", ""],
      ["e2a1", ""],
      ["e340", ""],
      ["e3a1", ""],
      ["e440", ""],
      ["e4a1", ""],
      ["e540", ""],
      ["e5a1", ""],
      ["e640", ""],
      ["e6a1", ""],
      ["e740", ""],
      ["e7a1", ""],
      ["e840", ""],
      ["e8a1", ""],
      ["e940", ""],
      ["e9a1", ""],
      ["ea40", ""],
      ["eaa1", ""],
      ["eb40", ""],
      ["eba1", ""],
      ["ec40", ""],
      ["eca1", ""],
      ["ed40", ""],
      ["eda1", ""],
      ["ee40", ""],
      ["eea1", ""],
      ["ef40", ""],
      ["efa1", ""],
      ["f040", ""],
      ["f0a1", ""],
      ["f140", ""],
      ["f1a1", ""],
      ["f240", ""],
      ["f2a1", ""],
      ["f340", ""],
      ["f3a1", ""],
      ["f440", ""],
      ["f4a1", ""],
      ["f540", ""],
      ["f5a1", ""],
      ["f640", ""],
      ["f6a1", ""],
      ["f740", ""],
      ["f7a1", ""],
      ["f840", ""],
      ["f8a1", ""],
      ["f940", ""],
      ["f9a1", ""]
    ];
  }
});

// ../../../node_modules/iconv-lite/encodings/tables/big5-added.json
var require_big5_added = __commonJS({
  "../../../node_modules/iconv-lite/encodings/tables/big5-added.json"(exports2, module2) {
    module2.exports = [
      ["8740", ""],
      ["8767", ""],
      ["87a1", ""],
      ["8840", "", 4, ""],
      ["88a1", ""],
      ["8940", ""],
      ["8943", ""],
      ["8946", ""],
      ["894c", ""],
      ["89a1", ""],
      ["89ab", ""],
      ["89b0", ""],
      ["89b5", ""],
      ["89c1", ""],
      ["89c5", ""],
      ["8a40", ""],
      ["8a43", ""],
      ["8a64", ""],
      ["8a76", ""],
      ["8aa1", ""],
      ["8aac", ""],
      ["8ab2", ""],
      ["8abb", ""],
      ["8ac9", ""],
      ["8ace", ""],
      ["8adf", ""],
      ["8af6", ""],
      ["8b40", ""],
      ["8b55", ""],
      ["8ba1", ""],
      ["8bde", ""],
      ["8c40", ""],
      ["8ca1", ""],
      ["8ca7", ""],
      ["8cc9", ""],
      ["8cce", ""],
      ["8ce6", ""],
      ["8d40", ""],
      ["8d42", ""],
      ["8da1", ""],
      ["8e40", ""],
      ["8ea1", ""],
      ["8f40", ""],
      ["8fa1", ""],
      ["9040", ""],
      ["90a1", ""],
      ["9140", ""],
      ["91a1", ""],
      ["9240", ""],
      ["92a1", ""],
      ["9340", ""],
      ["93a1", ""],
      ["9440", ""],
      ["94a1", ""],
      ["9540", ""],
      ["95a1", ""],
      ["9640", ""],
      ["96a1", ""],
      ["9740", ""],
      ["97a1", ""],
      ["9840", ""],
      ["98a1", ""],
      ["9940", ""],
      ["99a1", ""],
      ["9a40", ""],
      ["9aa1", ""],
      ["9b40", ""],
      ["9b62", ""],
      ["9ba1", ""],
      ["9c40", ""],
      ["9ca1", ""],
      ["9d40", ""],
      ["9da1", ""],
      ["9e40", ""],
      ["9ea1", ""],
      ["9ead", ""],
      ["9ec5", ""],
      ["9ef5", ""],
      ["9f40", ""],
      ["9f4f", ""],
      ["9fa1", ""],
      ["9fae", ""],
      ["9fb2", ""],
      ["9fc1", ""],
      ["9fc9", ""],
      ["9fdb", ""],
      ["9fe7", ""],
      ["9feb", ""],
      ["9ff0", ""],
      ["a040", ""],
      ["a055", ""],
      ["a058", ""],
      ["a05b", ""],
      ["a063", ""],
      ["a073", ""],
      ["a0a1", ""],
      ["a0a6", ""],
      ["a0ae", ""],
      ["a0b0", ""],
      ["a0d4", ""],
      ["a0e2", ""],
      ["a3c0", "", 31, ""],
      ["c6a1", "", 9, "", 9, "", 9, "", 23],
      ["c740", "", 58, ""],
      ["c7a1", "", 81, "", 5, "", 4],
      ["c840", "", 26, "", 25, ""],
      ["c8a1", ""],
      ["c8cd", ""],
      ["c8f5", ""],
      ["f9fe", ""],
      ["fa40", ""],
      ["faa1", ""],
      ["fb40", ""],
      ["fba1", ""],
      ["fc40", ""],
      ["fca1", ""],
      ["fd40", ""],
      ["fda1", ""],
      ["fe40", ""],
      ["fea1", ""]
    ];
  }
});

// ../../../node_modules/iconv-lite/encodings/dbcs-data.js
var require_dbcs_data = __commonJS({
  "../../../node_modules/iconv-lite/encodings/dbcs-data.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      // == Japanese/ShiftJIS ====================================================
      // All japanese encodings are based on JIS X set of standards:
      // JIS X 0201 - Single-byte encoding of ASCII +  + Kana chars at 0xA1-0xDF.
      // JIS X 0208 - Main set of 6879 characters, placed in 94x94 plane, to be encoded by 2 bytes. 
      //              Has several variations in 1978, 1983, 1990 and 1997.
      // JIS X 0212 - Supplementary plane of 6067 chars in 94x94 plane. 1990. Effectively dead.
      // JIS X 0213 - Extension and modern replacement of 0208 and 0212. Total chars: 11233.
      //              2 planes, first is superset of 0208, second - revised 0212.
      //              Introduced in 2000, revised 2004. Some characters are in Unicode Plane 2 (0x2xxxx)
      // Byte encodings are:
      //  * Shift_JIS: Compatible with 0201, uses not defined chars in top half as lead bytes for double-byte
      //               encoding of 0208. Lead byte ranges: 0x81-0x9F, 0xE0-0xEF; Trail byte ranges: 0x40-0x7E, 0x80-0x9E, 0x9F-0xFC.
      //               Windows CP932 is a superset of Shift_JIS. Some companies added more chars, notably KDDI.
      //  * EUC-JP:    Up to 3 bytes per character. Used mostly on *nixes.
      //               0x00-0x7F       - lower part of 0201
      //               0x8E, 0xA1-0xDF - upper part of 0201
      //               (0xA1-0xFE)x2   - 0208 plane (94x94).
      //               0x8F, (0xA1-0xFE)x2 - 0212 plane (94x94).
      //  * JIS X 208: 7-bit, direct encoding of 0208. Byte ranges: 0x21-0x7E (94 values). Uncommon.
      //               Used as-is in ISO2022 family.
      //  * ISO2022-JP: Stateful encoding, with escape sequences to switch between ASCII, 
      //                0201-1976 Roman, 0208-1978, 0208-1983.
      //  * ISO2022-JP-1: Adds esc seq for 0212-1990.
      //  * ISO2022-JP-2: Adds esc seq for GB2313-1980, KSX1001-1992, ISO8859-1, ISO8859-7.
      //  * ISO2022-JP-3: Adds esc seq for 0201-1976 Kana set, 0213-2000 Planes 1, 2.
      //  * ISO2022-JP-2004: Adds 0213-2004 Plane 1.
      //
      // After JIS X 0213 appeared, Shift_JIS-2004, EUC-JISX0213 and ISO2022-JP-2004 followed, with just changing the planes.
      //
      // Overall, it seems that it's a mess :( http://www8.plala.or.jp/tkubota1/unicode-symbols-map2.html
      "shiftjis": {
        type: "_dbcs",
        table: function() {
          return require_shiftjis();
        },
        encodeAdd: { "": 92, "": 126 },
        encodeSkipVals: [{ from: 60736, to: 63808 }]
      },
      "csshiftjis": "shiftjis",
      "mskanji": "shiftjis",
      "sjis": "shiftjis",
      "windows31j": "shiftjis",
      "ms31j": "shiftjis",
      "xsjis": "shiftjis",
      "windows932": "shiftjis",
      "ms932": "shiftjis",
      "932": "shiftjis",
      "cp932": "shiftjis",
      "eucjp": {
        type: "_dbcs",
        table: function() {
          return require_eucjp();
        },
        encodeAdd: { "": 92, "": 126 }
      },
      // TODO: KDDI extension to Shift_JIS
      // TODO: IBM CCSID 942 = CP932, but F0-F9 custom chars and other char changes.
      // TODO: IBM CCSID 943 = Shift_JIS = CP932 with original Shift_JIS lower 128 chars.
      // == Chinese/GBK ==========================================================
      // http://en.wikipedia.org/wiki/GBK
      // We mostly implement W3C recommendation: https://www.w3.org/TR/encoding/#gbk-encoder
      // Oldest GB2312 (1981, ~7600 chars) is a subset of CP936
      "gb2312": "cp936",
      "gb231280": "cp936",
      "gb23121980": "cp936",
      "csgb2312": "cp936",
      "csiso58gb231280": "cp936",
      "euccn": "cp936",
      // Microsoft's CP936 is a subset and approximation of GBK.
      "windows936": "cp936",
      "ms936": "cp936",
      "936": "cp936",
      "cp936": {
        type: "_dbcs",
        table: function() {
          return require_cp936();
        }
      },
      // GBK (~22000 chars) is an extension of CP936 that added user-mapped chars and some other.
      "gbk": {
        type: "_dbcs",
        table: function() {
          return require_cp936().concat(require_gbk_added());
        }
      },
      "xgbk": "gbk",
      "isoir58": "gbk",
      // GB18030 is an algorithmic extension of GBK.
      // Main source: https://www.w3.org/TR/encoding/#gbk-encoder
      // http://icu-project.org/docs/papers/gb18030.html
      // http://source.icu-project.org/repos/icu/data/trunk/charset/data/xml/gb-18030-2000.xml
      // http://www.khngai.com/chinese/charmap/tblgbk.php?page=0
      "gb18030": {
        type: "_dbcs",
        table: function() {
          return require_cp936().concat(require_gbk_added());
        },
        gb18030: function() {
          return require_gb18030_ranges();
        },
        encodeSkipVals: [128],
        encodeAdd: { "": 41699 }
      },
      "chinese": "gb18030",
      // == Korean ===============================================================
      // EUC-KR, KS_C_5601 and KS X 1001 are exactly the same.
      "windows949": "cp949",
      "ms949": "cp949",
      "949": "cp949",
      "cp949": {
        type: "_dbcs",
        table: function() {
          return require_cp949();
        }
      },
      "cseuckr": "cp949",
      "csksc56011987": "cp949",
      "euckr": "cp949",
      "isoir149": "cp949",
      "korean": "cp949",
      "ksc56011987": "cp949",
      "ksc56011989": "cp949",
      "ksc5601": "cp949",
      // == Big5/Taiwan/Hong Kong ================================================
      // There are lots of tables for Big5 and cp950. Please see the following links for history:
      // http://moztw.org/docs/big5/  http://www.haible.de/bruno/charsets/conversion-tables/Big5.html
      // Variations, in roughly number of defined chars:
      //  * Windows CP 950: Microsoft variant of Big5. Canonical: http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP950.TXT
      //  * Windows CP 951: Microsoft variant of Big5-HKSCS-2001. Seems to be never public. http://me.abelcheung.org/articles/research/what-is-cp951/
      //  * Big5-2003 (Taiwan standard) almost superset of cp950.
      //  * Unicode-at-on (UAO) / Mozilla 1.8. Falling out of use on the Web. Not supported by other browsers.
      //  * Big5-HKSCS (-2001, -2004, -2008). Hong Kong standard. 
      //    many unicode code points moved from PUA to Supplementary plane (U+2XXXX) over the years.
      //    Plus, it has 4 combining sequences.
      //    Seems that Mozilla refused to support it for 10 yrs. https://bugzilla.mozilla.org/show_bug.cgi?id=162431 https://bugzilla.mozilla.org/show_bug.cgi?id=310299
      //    because big5-hkscs is the only encoding to include astral characters in non-algorithmic way.
      //    Implementations are not consistent within browsers; sometimes labeled as just big5.
      //    MS Internet Explorer switches from big5 to big5-hkscs when a patch applied.
      //    Great discussion & recap of what's going on https://bugzilla.mozilla.org/show_bug.cgi?id=912470#c31
      //    In the encoder, it might make sense to support encoding old PUA mappings to Big5 bytes seq-s.
      //    Official spec: http://www.ogcio.gov.hk/en/business/tech_promotion/ccli/terms/doc/2003cmp_2008.txt
      //                   http://www.ogcio.gov.hk/tc/business/tech_promotion/ccli/terms/doc/hkscs-2008-big5-iso.txt
      // 
      // Current understanding of how to deal with Big5(-HKSCS) is in the Encoding Standard, http://encoding.spec.whatwg.org/#big5-encoder
      // Unicode mapping (http://www.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/OTHER/BIG5.TXT) is said to be wrong.
      "windows950": "cp950",
      "ms950": "cp950",
      "950": "cp950",
      "cp950": {
        type: "_dbcs",
        table: function() {
          return require_cp950();
        }
      },
      // Big5 has many variations and is an extension of cp950. We use Encoding Standard's as a consensus.
      "big5": "big5hkscs",
      "big5hkscs": {
        type: "_dbcs",
        table: function() {
          return require_cp950().concat(require_big5_added());
        },
        encodeSkipVals: [41676]
      },
      "cnbig5": "big5hkscs",
      "csbig5": "big5hkscs",
      "xxbig5": "big5hkscs"
    };
  }
});

// ../../../node_modules/iconv-lite/encodings/index.js
var require_encodings = __commonJS({
  "../../../node_modules/iconv-lite/encodings/index.js"(exports2, module2) {
    "use strict";
    var modules = [
      require_internal(),
      require_utf16(),
      require_utf7(),
      require_sbcs_codec(),
      require_sbcs_data(),
      require_sbcs_data_generated(),
      require_dbcs_codec(),
      require_dbcs_data()
    ];
    for (i = 0; i < modules.length; i++) {
      module2 = modules[i];
      for (enc in module2)
        if (Object.prototype.hasOwnProperty.call(module2, enc))
          exports2[enc] = module2[enc];
    }
    var module2;
    var enc;
    var i;
  }
});

// (disabled):../../../node_modules/iconv-lite/lib/streams
var require_streams = __commonJS({
  "(disabled):../../../node_modules/iconv-lite/lib/streams"() {
  }
});

// (disabled):../../../node_modules/iconv-lite/lib/extend-node
var require_extend_node = __commonJS({
  "(disabled):../../../node_modules/iconv-lite/lib/extend-node"() {
  }
});

// ../../../node_modules/iconv-lite/lib/index.js
var require_lib5 = __commonJS({
  "../../../node_modules/iconv-lite/lib/index.js"(exports2, module2) {
    "use strict";
    var Buffer2 = require_safer().Buffer;
    var bomHandling = require_bom_handling();
    var iconv = module2.exports;
    iconv.encodings = null;
    iconv.defaultCharUnicode = "";
    iconv.defaultCharSingleByte = "?";
    iconv.encode = function encode(str, encoding, options) {
      str = "" + (str || "");
      var encoder = iconv.getEncoder(encoding, options);
      var res = encoder.write(str);
      var trail = encoder.end();
      return trail && trail.length > 0 ? Buffer2.concat([res, trail]) : res;
    };
    iconv.decode = function decode(buf, encoding, options) {
      if (typeof buf === "string") {
        if (!iconv.skipDecodeWarning) {
          console.error("Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding");
          iconv.skipDecodeWarning = true;
        }
        buf = Buffer2.from("" + (buf || ""), "binary");
      }
      var decoder = iconv.getDecoder(encoding, options);
      var res = decoder.write(buf);
      var trail = decoder.end();
      return trail ? res + trail : res;
    };
    iconv.encodingExists = function encodingExists(enc) {
      try {
        iconv.getCodec(enc);
        return true;
      } catch (e) {
        return false;
      }
    };
    iconv.toEncoding = iconv.encode;
    iconv.fromEncoding = iconv.decode;
    iconv._codecDataCache = {};
    iconv.getCodec = function getCodec(encoding) {
      if (!iconv.encodings)
        iconv.encodings = require_encodings();
      var enc = iconv._canonicalizeEncoding(encoding);
      var codecOptions = {};
      while (true) {
        var codec = iconv._codecDataCache[enc];
        if (codec)
          return codec;
        var codecDef = iconv.encodings[enc];
        switch (typeof codecDef) {
          case "string":
            enc = codecDef;
            break;
          case "object":
            for (var key in codecDef)
              codecOptions[key] = codecDef[key];
            if (!codecOptions.encodingName)
              codecOptions.encodingName = enc;
            enc = codecDef.type;
            break;
          case "function":
            if (!codecOptions.encodingName)
              codecOptions.encodingName = enc;
            codec = new codecDef(codecOptions, iconv);
            iconv._codecDataCache[codecOptions.encodingName] = codec;
            return codec;
          default:
            throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '" + enc + "')");
        }
      }
    };
    iconv._canonicalizeEncoding = function(encoding) {
      return ("" + encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
    };
    iconv.getEncoder = function getEncoder(encoding, options) {
      var codec = iconv.getCodec(encoding), encoder = new codec.encoder(options, codec);
      if (codec.bomAware && options && options.addBOM)
        encoder = new bomHandling.PrependBOM(encoder, options);
      return encoder;
    };
    iconv.getDecoder = function getDecoder(encoding, options) {
      var codec = iconv.getCodec(encoding), decoder = new codec.decoder(options, codec);
      if (codec.bomAware && !(options && options.stripBOM === false))
        decoder = new bomHandling.StripBOM(decoder, options);
      return decoder;
    };
    var nodeVer = typeof process !== "undefined" && process.versions && process.versions.node;
    if (nodeVer) {
      nodeVerArr = nodeVer.split(".").map(Number);
      if (nodeVerArr[0] > 0 || nodeVerArr[1] >= 10) {
        require_streams()(iconv);
      }
      require_extend_node()(iconv);
    }
    var nodeVerArr;
    if (false) {
      console.error("iconv-lite warning: javascript files use encoding different from utf-8. See https://github.com/ashtuchkin/iconv-lite/wiki/Javascript-source-file-encodings for more info.");
    }
  }
});

// ../../../node_modules/unpipe/index.js
var require_unpipe = __commonJS({
  "../../../node_modules/unpipe/index.js"(exports2, module2) {
    "use strict";
    module2.exports = unpipe;
    function hasPipeDataListeners(stream) {
      var listeners = stream.listeners("data");
      for (var i = 0; i < listeners.length; i++) {
        if (listeners[i].name === "ondata") {
          return true;
        }
      }
      return false;
    }
    function unpipe(stream) {
      if (!stream) {
        throw new TypeError("argument stream is required");
      }
      if (typeof stream.unpipe === "function") {
        stream.unpipe();
        return;
      }
      if (!hasPipeDataListeners(stream)) {
        return;
      }
      var listener;
      var listeners = stream.listeners("close");
      for (var i = 0; i < listeners.length; i++) {
        listener = listeners[i];
        if (listener.name !== "cleanup" && listener.name !== "onclose") {
          continue;
        }
        listener.call(stream);
      }
    }
  }
});

// browser-external:async_hooks
var require_async_hooks = __commonJS({
  "browser-external:async_hooks"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "async_hooks" has been externalized for browser compatibility. Cannot access "async_hooks.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// ../../../node_modules/express/node_modules/raw-body/index.js
var require_raw_body = __commonJS({
  "../../../node_modules/express/node_modules/raw-body/index.js"(exports2, module2) {
    "use strict";
    var asyncHooks = tryRequireAsyncHooks();
    var bytes = require_bytes();
    var createError = require_http_errors();
    var iconv = require_lib5();
    var unpipe = require_unpipe();
    module2.exports = getRawBody;
    var ICONV_ENCODING_MESSAGE_REGEXP = /^Encoding not recognized: /;
    function getDecoder(encoding) {
      if (!encoding)
        return null;
      try {
        return iconv.getDecoder(encoding);
      } catch (e) {
        if (!ICONV_ENCODING_MESSAGE_REGEXP.test(e.message))
          throw e;
        throw createError(415, "specified encoding unsupported", {
          encoding,
          type: "encoding.unsupported"
        });
      }
    }
    function getRawBody(stream, options, callback) {
      var done = callback;
      var opts = options || {};
      if (options === true || typeof options === "string") {
        opts = {
          encoding: options
        };
      }
      if (typeof options === "function") {
        done = options;
        opts = {};
      }
      if (done !== void 0 && typeof done !== "function") {
        throw new TypeError("argument callback must be a function");
      }
      if (!done && !global.Promise) {
        throw new TypeError("argument callback is required");
      }
      var encoding = opts.encoding !== true ? opts.encoding : "utf-8";
      var limit = bytes.parse(opts.limit);
      var length = opts.length != null && !isNaN(opts.length) ? parseInt(opts.length, 10) : null;
      if (done) {
        return readStream(stream, encoding, length, limit, wrap2(done));
      }
      return new Promise(function executor(resolve, reject) {
        readStream(stream, encoding, length, limit, function onRead(err, buf) {
          if (err)
            return reject(err);
          resolve(buf);
        });
      });
    }
    function halt(stream) {
      unpipe(stream);
      if (typeof stream.pause === "function") {
        stream.pause();
      }
    }
    function readStream(stream, encoding, length, limit, callback) {
      var complete = false;
      var sync = true;
      if (limit !== null && length !== null && length > limit) {
        return done(createError(413, "request entity too large", {
          expected: length,
          length,
          limit,
          type: "entity.too.large"
        }));
      }
      var state = stream._readableState;
      if (stream._decoder || state && (state.encoding || state.decoder)) {
        return done(createError(500, "stream encoding should not be set", {
          type: "stream.encoding.set"
        }));
      }
      if (typeof stream.readable !== "undefined" && !stream.readable) {
        return done(createError(500, "stream is not readable", {
          type: "stream.not.readable"
        }));
      }
      var received = 0;
      var decoder;
      try {
        decoder = getDecoder(encoding);
      } catch (err) {
        return done(err);
      }
      var buffer = decoder ? "" : [];
      stream.on("aborted", onAborted);
      stream.on("close", cleanup);
      stream.on("data", onData);
      stream.on("end", onEnd);
      stream.on("error", onEnd);
      sync = false;
      function done() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        complete = true;
        if (sync) {
          process.nextTick(invokeCallback);
        } else {
          invokeCallback();
        }
        function invokeCallback() {
          cleanup();
          if (args[0]) {
            halt(stream);
          }
          callback.apply(null, args);
        }
      }
      function onAborted() {
        if (complete)
          return;
        done(createError(400, "request aborted", {
          code: "ECONNABORTED",
          expected: length,
          length,
          received,
          type: "request.aborted"
        }));
      }
      function onData(chunk) {
        if (complete)
          return;
        received += chunk.length;
        if (limit !== null && received > limit) {
          done(createError(413, "request entity too large", {
            limit,
            received,
            type: "entity.too.large"
          }));
        } else if (decoder) {
          buffer += decoder.write(chunk);
        } else {
          buffer.push(chunk);
        }
      }
      function onEnd(err) {
        if (complete)
          return;
        if (err)
          return done(err);
        if (length !== null && received !== length) {
          done(createError(400, "request size did not match content length", {
            expected: length,
            length,
            received,
            type: "request.size.invalid"
          }));
        } else {
          var string = decoder ? buffer + (decoder.end() || "") : Buffer.concat(buffer);
          done(null, string);
        }
      }
      function cleanup() {
        buffer = null;
        stream.removeListener("aborted", onAborted);
        stream.removeListener("data", onData);
        stream.removeListener("end", onEnd);
        stream.removeListener("error", onEnd);
        stream.removeListener("close", cleanup);
      }
    }
    function tryRequireAsyncHooks() {
      try {
        return require_async_hooks();
      } catch (e) {
        return {};
      }
    }
    function wrap2(fn) {
      var res;
      if (asyncHooks.AsyncResource) {
        res = new asyncHooks.AsyncResource(fn.name || "bound-anonymous-fn");
      }
      if (!res || !res.runInAsyncScope) {
        return fn;
      }
      return res.runInAsyncScope.bind(res, fn, null);
    }
  }
});

// ../../../node_modules/ee-first/index.js
var require_ee_first = __commonJS({
  "../../../node_modules/ee-first/index.js"(exports2, module2) {
    "use strict";
    module2.exports = first;
    function first(stuff, done) {
      if (!Array.isArray(stuff))
        throw new TypeError("arg must be an array of [ee, events...] arrays");
      var cleanups = [];
      for (var i = 0; i < stuff.length; i++) {
        var arr = stuff[i];
        if (!Array.isArray(arr) || arr.length < 2)
          throw new TypeError("each array member must be [ee, events...]");
        var ee = arr[0];
        for (var j = 1; j < arr.length; j++) {
          var event = arr[j];
          var fn = listener(event, callback);
          ee.on(event, fn);
          cleanups.push({
            ee,
            event,
            fn
          });
        }
      }
      function callback() {
        cleanup();
        done.apply(null, arguments);
      }
      function cleanup() {
        var x;
        for (var i2 = 0; i2 < cleanups.length; i2++) {
          x = cleanups[i2];
          x.ee.removeListener(x.event, x.fn);
        }
      }
      function thunk(fn2) {
        done = fn2;
      }
      thunk.cancel = cleanup;
      return thunk;
    }
    function listener(event, done) {
      return function onevent(arg1) {
        var args = new Array(arguments.length);
        var ee = this;
        var err = event === "error" ? arg1 : null;
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        done(err, ee, event, args);
      };
    }
  }
});

// ../../../node_modules/on-finished/index.js
var require_on_finished = __commonJS({
  "../../../node_modules/on-finished/index.js"(exports2, module2) {
    "use strict";
    module2.exports = onFinished;
    module2.exports.isFinished = isFinished;
    var asyncHooks = tryRequireAsyncHooks();
    var first = require_ee_first();
    var defer = typeof setImmediate === "function" ? setImmediate : function(fn) {
      process.nextTick(fn.bind.apply(fn, arguments));
    };
    function onFinished(msg, listener) {
      if (isFinished(msg) !== false) {
        defer(listener, null, msg);
        return msg;
      }
      attachListener(msg, wrap2(listener));
      return msg;
    }
    function isFinished(msg) {
      var socket = msg.socket;
      if (typeof msg.finished === "boolean") {
        return Boolean(msg.finished || socket && !socket.writable);
      }
      if (typeof msg.complete === "boolean") {
        return Boolean(msg.upgrade || !socket || !socket.readable || msg.complete && !msg.readable);
      }
      return void 0;
    }
    function attachFinishedListener(msg, callback) {
      var eeMsg;
      var eeSocket;
      var finished = false;
      function onFinish(error) {
        eeMsg.cancel();
        eeSocket.cancel();
        finished = true;
        callback(error);
      }
      eeMsg = eeSocket = first([[msg, "end", "finish"]], onFinish);
      function onSocket(socket) {
        msg.removeListener("socket", onSocket);
        if (finished)
          return;
        if (eeMsg !== eeSocket)
          return;
        eeSocket = first([[socket, "error", "close"]], onFinish);
      }
      if (msg.socket) {
        onSocket(msg.socket);
        return;
      }
      msg.on("socket", onSocket);
      if (msg.socket === void 0) {
        patchAssignSocket(msg, onSocket);
      }
    }
    function attachListener(msg, listener) {
      var attached = msg.__onFinished;
      if (!attached || !attached.queue) {
        attached = msg.__onFinished = createListener(msg);
        attachFinishedListener(msg, attached);
      }
      attached.queue.push(listener);
    }
    function createListener(msg) {
      function listener(err) {
        if (msg.__onFinished === listener)
          msg.__onFinished = null;
        if (!listener.queue)
          return;
        var queue = listener.queue;
        listener.queue = null;
        for (var i = 0; i < queue.length; i++) {
          queue[i](err, msg);
        }
      }
      listener.queue = [];
      return listener;
    }
    function patchAssignSocket(res, callback) {
      var assignSocket = res.assignSocket;
      if (typeof assignSocket !== "function")
        return;
      res.assignSocket = function _assignSocket(socket) {
        assignSocket.call(this, socket);
        callback(socket);
      };
    }
    function tryRequireAsyncHooks() {
      try {
        return require_async_hooks();
      } catch (e) {
        return {};
      }
    }
    function wrap2(fn) {
      var res;
      if (asyncHooks.AsyncResource) {
        res = new asyncHooks.AsyncResource(fn.name || "bound-anonymous-fn");
      }
      if (!res || !res.runInAsyncScope) {
        return fn;
      }
      return res.runInAsyncScope.bind(res, fn, null);
    }
  }
});

// ../../../node_modules/express/node_modules/body-parser/lib/read.js
var require_read = __commonJS({
  "../../../node_modules/express/node_modules/body-parser/lib/read.js"(exports2, module2) {
    "use strict";
    var createError = require_http_errors();
    var destroy = require_destroy();
    var getBody = require_raw_body();
    var iconv = require_lib5();
    var onFinished = require_on_finished();
    var unpipe = require_unpipe();
    var zlib = require_zlib();
    module2.exports = read;
    function read(req, res, next, parse2, debug, options) {
      var length;
      var opts = options;
      var stream;
      req._body = true;
      var encoding = opts.encoding !== null ? opts.encoding : null;
      var verify = opts.verify;
      try {
        stream = contentstream(req, debug, opts.inflate);
        length = stream.length;
        stream.length = void 0;
      } catch (err) {
        return next(err);
      }
      opts.length = length;
      opts.encoding = verify ? null : encoding;
      if (opts.encoding === null && encoding !== null && !iconv.encodingExists(encoding)) {
        return next(createError(415, 'unsupported charset "' + encoding.toUpperCase() + '"', {
          charset: encoding.toLowerCase(),
          type: "charset.unsupported"
        }));
      }
      debug("read body");
      getBody(stream, opts, function(error, body) {
        if (error) {
          var _error;
          if (error.type === "encoding.unsupported") {
            _error = createError(415, 'unsupported charset "' + encoding.toUpperCase() + '"', {
              charset: encoding.toLowerCase(),
              type: "charset.unsupported"
            });
          } else {
            _error = createError(400, error);
          }
          if (stream !== req) {
            unpipe(req);
            destroy(stream, true);
          }
          dump(req, function onfinished() {
            next(createError(400, _error));
          });
          return;
        }
        if (verify) {
          try {
            debug("verify body");
            verify(req, res, body, encoding);
          } catch (err) {
            next(createError(403, err, {
              body,
              type: err.type || "entity.verify.failed"
            }));
            return;
          }
        }
        var str = body;
        try {
          debug("parse body");
          str = typeof body !== "string" && encoding !== null ? iconv.decode(body, encoding) : body;
          req.body = parse2(str);
        } catch (err) {
          next(createError(400, err, {
            body: str,
            type: err.type || "entity.parse.failed"
          }));
          return;
        }
        next();
      });
    }
    function contentstream(req, debug, inflate) {
      var encoding = (req.headers["content-encoding"] || "identity").toLowerCase();
      var length = req.headers["content-length"];
      var stream;
      debug('content-encoding "%s"', encoding);
      if (inflate === false && encoding !== "identity") {
        throw createError(415, "content encoding unsupported", {
          encoding,
          type: "encoding.unsupported"
        });
      }
      switch (encoding) {
        case "deflate":
          stream = zlib.createInflate();
          debug("inflate body");
          req.pipe(stream);
          break;
        case "gzip":
          stream = zlib.createGunzip();
          debug("gunzip body");
          req.pipe(stream);
          break;
        case "identity":
          stream = req;
          stream.length = length;
          break;
        default:
          throw createError(415, 'unsupported content encoding "' + encoding + '"', {
            encoding,
            type: "encoding.unsupported"
          });
      }
      return stream;
    }
    function dump(req, callback) {
      if (onFinished.isFinished(req)) {
        callback(null);
      } else {
        onFinished(req, callback);
        req.resume();
      }
    }
  }
});

// ../../../node_modules/media-typer/index.js
var require_media_typer = __commonJS({
  "../../../node_modules/media-typer/index.js"(exports2) {
    var paramRegExp = /; *([!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) *= *("(?:[ !\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u0020-\u007e])*"|[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) */g;
    var textRegExp = /^[\u0020-\u007e\u0080-\u00ff]+$/;
    var tokenRegExp = /^[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+$/;
    var qescRegExp = /\\([\u0000-\u007f])/g;
    var quoteRegExp = /([\\"])/g;
    var subtypeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/;
    var typeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/;
    var typeRegExp = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;
    exports2.format = format;
    exports2.parse = parse2;
    function format(obj) {
      if (!obj || typeof obj !== "object") {
        throw new TypeError("argument obj is required");
      }
      var parameters = obj.parameters;
      var subtype = obj.subtype;
      var suffix = obj.suffix;
      var type = obj.type;
      if (!type || !typeNameRegExp.test(type)) {
        throw new TypeError("invalid type");
      }
      if (!subtype || !subtypeNameRegExp.test(subtype)) {
        throw new TypeError("invalid subtype");
      }
      var string = type + "/" + subtype;
      if (suffix) {
        if (!typeNameRegExp.test(suffix)) {
          throw new TypeError("invalid suffix");
        }
        string += "+" + suffix;
      }
      if (parameters && typeof parameters === "object") {
        var param;
        var params = Object.keys(parameters).sort();
        for (var i = 0; i < params.length; i++) {
          param = params[i];
          if (!tokenRegExp.test(param)) {
            throw new TypeError("invalid parameter name");
          }
          string += "; " + param + "=" + qstring(parameters[param]);
        }
      }
      return string;
    }
    function parse2(string) {
      if (!string) {
        throw new TypeError("argument string is required");
      }
      if (typeof string === "object") {
        string = getcontenttype(string);
      }
      if (typeof string !== "string") {
        throw new TypeError("argument string is required to be a string");
      }
      var index = string.indexOf(";");
      var type = index !== -1 ? string.substr(0, index) : string;
      var key;
      var match;
      var obj = splitType(type);
      var params = {};
      var value;
      paramRegExp.lastIndex = index;
      while (match = paramRegExp.exec(string)) {
        if (match.index !== index) {
          throw new TypeError("invalid parameter format");
        }
        index += match[0].length;
        key = match[1].toLowerCase();
        value = match[2];
        if (value[0] === '"') {
          value = value.substr(1, value.length - 2).replace(qescRegExp, "$1");
        }
        params[key] = value;
      }
      if (index !== -1 && index !== string.length) {
        throw new TypeError("invalid parameter format");
      }
      obj.parameters = params;
      return obj;
    }
    function getcontenttype(obj) {
      if (typeof obj.getHeader === "function") {
        return obj.getHeader("content-type");
      }
      if (typeof obj.headers === "object") {
        return obj.headers && obj.headers["content-type"];
      }
    }
    function qstring(val) {
      var str = String(val);
      if (tokenRegExp.test(str)) {
        return str;
      }
      if (str.length > 0 && !textRegExp.test(str)) {
        throw new TypeError("invalid parameter value");
      }
      return '"' + str.replace(quoteRegExp, "\\$1") + '"';
    }
    function splitType(string) {
      var match = typeRegExp.exec(string.toLowerCase());
      if (!match) {
        throw new TypeError("invalid media type");
      }
      var type = match[1];
      var subtype = match[2];
      var suffix;
      var index = subtype.lastIndexOf("+");
      if (index !== -1) {
        suffix = subtype.substr(index + 1);
        subtype = subtype.substr(0, index);
      }
      var obj = {
        type,
        subtype,
        suffix
      };
      return obj;
    }
  }
});

// ../../../node_modules/mime-db/db.json
var require_db = __commonJS({
  "../../../node_modules/mime-db/db.json"(exports2, module2) {
    module2.exports = {
      "application/1d-interleaved-parityfec": {
        source: "iana"
      },
      "application/3gpdash-qoe-report+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/3gpp-ims+xml": {
        source: "iana",
        compressible: true
      },
      "application/3gpphal+json": {
        source: "iana",
        compressible: true
      },
      "application/3gpphalforms+json": {
        source: "iana",
        compressible: true
      },
      "application/a2l": {
        source: "iana"
      },
      "application/ace+cbor": {
        source: "iana"
      },
      "application/activemessage": {
        source: "iana"
      },
      "application/activity+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-directory+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcost+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcostparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointprop+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointpropparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-error+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamcontrol+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamparams+json": {
        source: "iana",
        compressible: true
      },
      "application/aml": {
        source: "iana"
      },
      "application/andrew-inset": {
        source: "iana",
        extensions: ["ez"]
      },
      "application/applefile": {
        source: "iana"
      },
      "application/applixware": {
        source: "apache",
        extensions: ["aw"]
      },
      "application/at+jwt": {
        source: "iana"
      },
      "application/atf": {
        source: "iana"
      },
      "application/atfx": {
        source: "iana"
      },
      "application/atom+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atom"]
      },
      "application/atomcat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomcat"]
      },
      "application/atomdeleted+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomdeleted"]
      },
      "application/atomicmail": {
        source: "iana"
      },
      "application/atomsvc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomsvc"]
      },
      "application/atsc-dwd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dwd"]
      },
      "application/atsc-dynamic-event-message": {
        source: "iana"
      },
      "application/atsc-held+xml": {
        source: "iana",
        compressible: true,
        extensions: ["held"]
      },
      "application/atsc-rdt+json": {
        source: "iana",
        compressible: true
      },
      "application/atsc-rsat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsat"]
      },
      "application/atxml": {
        source: "iana"
      },
      "application/auth-policy+xml": {
        source: "iana",
        compressible: true
      },
      "application/bacnet-xdd+zip": {
        source: "iana",
        compressible: false
      },
      "application/batch-smtp": {
        source: "iana"
      },
      "application/bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/beep+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/calendar+json": {
        source: "iana",
        compressible: true
      },
      "application/calendar+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xcs"]
      },
      "application/call-completion": {
        source: "iana"
      },
      "application/cals-1840": {
        source: "iana"
      },
      "application/captive+json": {
        source: "iana",
        compressible: true
      },
      "application/cbor": {
        source: "iana"
      },
      "application/cbor-seq": {
        source: "iana"
      },
      "application/cccex": {
        source: "iana"
      },
      "application/ccmp+xml": {
        source: "iana",
        compressible: true
      },
      "application/ccxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ccxml"]
      },
      "application/cdfx+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdfx"]
      },
      "application/cdmi-capability": {
        source: "iana",
        extensions: ["cdmia"]
      },
      "application/cdmi-container": {
        source: "iana",
        extensions: ["cdmic"]
      },
      "application/cdmi-domain": {
        source: "iana",
        extensions: ["cdmid"]
      },
      "application/cdmi-object": {
        source: "iana",
        extensions: ["cdmio"]
      },
      "application/cdmi-queue": {
        source: "iana",
        extensions: ["cdmiq"]
      },
      "application/cdni": {
        source: "iana"
      },
      "application/cea": {
        source: "iana"
      },
      "application/cea-2018+xml": {
        source: "iana",
        compressible: true
      },
      "application/cellml+xml": {
        source: "iana",
        compressible: true
      },
      "application/cfw": {
        source: "iana"
      },
      "application/city+json": {
        source: "iana",
        compressible: true
      },
      "application/clr": {
        source: "iana"
      },
      "application/clue+xml": {
        source: "iana",
        compressible: true
      },
      "application/clue_info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cms": {
        source: "iana"
      },
      "application/cnrp+xml": {
        source: "iana",
        compressible: true
      },
      "application/coap-group+json": {
        source: "iana",
        compressible: true
      },
      "application/coap-payload": {
        source: "iana"
      },
      "application/commonground": {
        source: "iana"
      },
      "application/conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cose": {
        source: "iana"
      },
      "application/cose-key": {
        source: "iana"
      },
      "application/cose-key-set": {
        source: "iana"
      },
      "application/cpl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cpl"]
      },
      "application/csrattrs": {
        source: "iana"
      },
      "application/csta+xml": {
        source: "iana",
        compressible: true
      },
      "application/cstadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/csvm+json": {
        source: "iana",
        compressible: true
      },
      "application/cu-seeme": {
        source: "apache",
        extensions: ["cu"]
      },
      "application/cwt": {
        source: "iana"
      },
      "application/cybercash": {
        source: "iana"
      },
      "application/dart": {
        compressible: true
      },
      "application/dash+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpd"]
      },
      "application/dash-patch+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpp"]
      },
      "application/dashdelta": {
        source: "iana"
      },
      "application/davmount+xml": {
        source: "iana",
        compressible: true,
        extensions: ["davmount"]
      },
      "application/dca-rft": {
        source: "iana"
      },
      "application/dcd": {
        source: "iana"
      },
      "application/dec-dx": {
        source: "iana"
      },
      "application/dialog-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/dicom": {
        source: "iana"
      },
      "application/dicom+json": {
        source: "iana",
        compressible: true
      },
      "application/dicom+xml": {
        source: "iana",
        compressible: true
      },
      "application/dii": {
        source: "iana"
      },
      "application/dit": {
        source: "iana"
      },
      "application/dns": {
        source: "iana"
      },
      "application/dns+json": {
        source: "iana",
        compressible: true
      },
      "application/dns-message": {
        source: "iana"
      },
      "application/docbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dbk"]
      },
      "application/dots+cbor": {
        source: "iana"
      },
      "application/dskpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/dssc+der": {
        source: "iana",
        extensions: ["dssc"]
      },
      "application/dssc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdssc"]
      },
      "application/dvcs": {
        source: "iana"
      },
      "application/ecmascript": {
        source: "iana",
        compressible: true,
        extensions: ["es", "ecma"]
      },
      "application/edi-consent": {
        source: "iana"
      },
      "application/edi-x12": {
        source: "iana",
        compressible: false
      },
      "application/edifact": {
        source: "iana",
        compressible: false
      },
      "application/efi": {
        source: "iana"
      },
      "application/elm+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/elm+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.cap+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/emergencycalldata.comment+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.control+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.deviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.ecall.msd": {
        source: "iana"
      },
      "application/emergencycalldata.providerinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.serviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.subscriberinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.veds+xml": {
        source: "iana",
        compressible: true
      },
      "application/emma+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emma"]
      },
      "application/emotionml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emotionml"]
      },
      "application/encaprtp": {
        source: "iana"
      },
      "application/epp+xml": {
        source: "iana",
        compressible: true
      },
      "application/epub+zip": {
        source: "iana",
        compressible: false,
        extensions: ["epub"]
      },
      "application/eshop": {
        source: "iana"
      },
      "application/exi": {
        source: "iana",
        extensions: ["exi"]
      },
      "application/expect-ct-report+json": {
        source: "iana",
        compressible: true
      },
      "application/express": {
        source: "iana",
        extensions: ["exp"]
      },
      "application/fastinfoset": {
        source: "iana"
      },
      "application/fastsoap": {
        source: "iana"
      },
      "application/fdt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fdt"]
      },
      "application/fhir+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fhir+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fido.trusted-apps+json": {
        compressible: true
      },
      "application/fits": {
        source: "iana"
      },
      "application/flexfec": {
        source: "iana"
      },
      "application/font-sfnt": {
        source: "iana"
      },
      "application/font-tdpfr": {
        source: "iana",
        extensions: ["pfr"]
      },
      "application/font-woff": {
        source: "iana",
        compressible: false
      },
      "application/framework-attributes+xml": {
        source: "iana",
        compressible: true
      },
      "application/geo+json": {
        source: "iana",
        compressible: true,
        extensions: ["geojson"]
      },
      "application/geo+json-seq": {
        source: "iana"
      },
      "application/geopackage+sqlite3": {
        source: "iana"
      },
      "application/geoxacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/gltf-buffer": {
        source: "iana"
      },
      "application/gml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["gml"]
      },
      "application/gpx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["gpx"]
      },
      "application/gxf": {
        source: "apache",
        extensions: ["gxf"]
      },
      "application/gzip": {
        source: "iana",
        compressible: false,
        extensions: ["gz"]
      },
      "application/h224": {
        source: "iana"
      },
      "application/held+xml": {
        source: "iana",
        compressible: true
      },
      "application/hjson": {
        extensions: ["hjson"]
      },
      "application/http": {
        source: "iana"
      },
      "application/hyperstudio": {
        source: "iana",
        extensions: ["stk"]
      },
      "application/ibe-key-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pkg-reply+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pp-data": {
        source: "iana"
      },
      "application/iges": {
        source: "iana"
      },
      "application/im-iscomposing+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/index": {
        source: "iana"
      },
      "application/index.cmd": {
        source: "iana"
      },
      "application/index.obj": {
        source: "iana"
      },
      "application/index.response": {
        source: "iana"
      },
      "application/index.vnd": {
        source: "iana"
      },
      "application/inkml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ink", "inkml"]
      },
      "application/iotp": {
        source: "iana"
      },
      "application/ipfix": {
        source: "iana",
        extensions: ["ipfix"]
      },
      "application/ipp": {
        source: "iana"
      },
      "application/isup": {
        source: "iana"
      },
      "application/its+xml": {
        source: "iana",
        compressible: true,
        extensions: ["its"]
      },
      "application/java-archive": {
        source: "apache",
        compressible: false,
        extensions: ["jar", "war", "ear"]
      },
      "application/java-serialized-object": {
        source: "apache",
        compressible: false,
        extensions: ["ser"]
      },
      "application/java-vm": {
        source: "apache",
        compressible: false,
        extensions: ["class"]
      },
      "application/javascript": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["js", "mjs"]
      },
      "application/jf2feed+json": {
        source: "iana",
        compressible: true
      },
      "application/jose": {
        source: "iana"
      },
      "application/jose+json": {
        source: "iana",
        compressible: true
      },
      "application/jrd+json": {
        source: "iana",
        compressible: true
      },
      "application/jscalendar+json": {
        source: "iana",
        compressible: true
      },
      "application/json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["json", "map"]
      },
      "application/json-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/json-seq": {
        source: "iana"
      },
      "application/json5": {
        extensions: ["json5"]
      },
      "application/jsonml+json": {
        source: "apache",
        compressible: true,
        extensions: ["jsonml"]
      },
      "application/jwk+json": {
        source: "iana",
        compressible: true
      },
      "application/jwk-set+json": {
        source: "iana",
        compressible: true
      },
      "application/jwt": {
        source: "iana"
      },
      "application/kpml-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/kpml-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/ld+json": {
        source: "iana",
        compressible: true,
        extensions: ["jsonld"]
      },
      "application/lgr+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lgr"]
      },
      "application/link-format": {
        source: "iana"
      },
      "application/load-control+xml": {
        source: "iana",
        compressible: true
      },
      "application/lost+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lostxml"]
      },
      "application/lostsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/lpf+zip": {
        source: "iana",
        compressible: false
      },
      "application/lxf": {
        source: "iana"
      },
      "application/mac-binhex40": {
        source: "iana",
        extensions: ["hqx"]
      },
      "application/mac-compactpro": {
        source: "apache",
        extensions: ["cpt"]
      },
      "application/macwriteii": {
        source: "iana"
      },
      "application/mads+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mads"]
      },
      "application/manifest+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["webmanifest"]
      },
      "application/marc": {
        source: "iana",
        extensions: ["mrc"]
      },
      "application/marcxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mrcx"]
      },
      "application/mathematica": {
        source: "iana",
        extensions: ["ma", "nb", "mb"]
      },
      "application/mathml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mathml"]
      },
      "application/mathml-content+xml": {
        source: "iana",
        compressible: true
      },
      "application/mathml-presentation+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-associated-procedure-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-deregister+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-envelope+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-protection-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-reception-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-schedule+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-user-service-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbox": {
        source: "iana",
        extensions: ["mbox"]
      },
      "application/media-policy-dataset+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpf"]
      },
      "application/media_control+xml": {
        source: "iana",
        compressible: true
      },
      "application/mediaservercontrol+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mscml"]
      },
      "application/merge-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/metalink+xml": {
        source: "apache",
        compressible: true,
        extensions: ["metalink"]
      },
      "application/metalink4+xml": {
        source: "iana",
        compressible: true,
        extensions: ["meta4"]
      },
      "application/mets+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mets"]
      },
      "application/mf4": {
        source: "iana"
      },
      "application/mikey": {
        source: "iana"
      },
      "application/mipc": {
        source: "iana"
      },
      "application/missing-blocks+cbor-seq": {
        source: "iana"
      },
      "application/mmt-aei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["maei"]
      },
      "application/mmt-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musd"]
      },
      "application/mods+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mods"]
      },
      "application/moss-keys": {
        source: "iana"
      },
      "application/moss-signature": {
        source: "iana"
      },
      "application/mosskey-data": {
        source: "iana"
      },
      "application/mosskey-request": {
        source: "iana"
      },
      "application/mp21": {
        source: "iana",
        extensions: ["m21", "mp21"]
      },
      "application/mp4": {
        source: "iana",
        extensions: ["mp4s", "m4p"]
      },
      "application/mpeg4-generic": {
        source: "iana"
      },
      "application/mpeg4-iod": {
        source: "iana"
      },
      "application/mpeg4-iod-xmt": {
        source: "iana"
      },
      "application/mrb-consumer+xml": {
        source: "iana",
        compressible: true
      },
      "application/mrb-publish+xml": {
        source: "iana",
        compressible: true
      },
      "application/msc-ivr+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msc-mixer+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msword": {
        source: "iana",
        compressible: false,
        extensions: ["doc", "dot"]
      },
      "application/mud+json": {
        source: "iana",
        compressible: true
      },
      "application/multipart-core": {
        source: "iana"
      },
      "application/mxf": {
        source: "iana",
        extensions: ["mxf"]
      },
      "application/n-quads": {
        source: "iana",
        extensions: ["nq"]
      },
      "application/n-triples": {
        source: "iana",
        extensions: ["nt"]
      },
      "application/nasdata": {
        source: "iana"
      },
      "application/news-checkgroups": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-groupinfo": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-transmission": {
        source: "iana"
      },
      "application/nlsml+xml": {
        source: "iana",
        compressible: true
      },
      "application/node": {
        source: "iana",
        extensions: ["cjs"]
      },
      "application/nss": {
        source: "iana"
      },
      "application/oauth-authz-req+jwt": {
        source: "iana"
      },
      "application/oblivious-dns-message": {
        source: "iana"
      },
      "application/ocsp-request": {
        source: "iana"
      },
      "application/ocsp-response": {
        source: "iana"
      },
      "application/octet-stream": {
        source: "iana",
        compressible: false,
        extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
      },
      "application/oda": {
        source: "iana",
        extensions: ["oda"]
      },
      "application/odm+xml": {
        source: "iana",
        compressible: true
      },
      "application/odx": {
        source: "iana"
      },
      "application/oebps-package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["opf"]
      },
      "application/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogx"]
      },
      "application/omdoc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["omdoc"]
      },
      "application/onenote": {
        source: "apache",
        extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
      },
      "application/opc-nodeset+xml": {
        source: "iana",
        compressible: true
      },
      "application/oscore": {
        source: "iana"
      },
      "application/oxps": {
        source: "iana",
        extensions: ["oxps"]
      },
      "application/p21": {
        source: "iana"
      },
      "application/p21+zip": {
        source: "iana",
        compressible: false
      },
      "application/p2p-overlay+xml": {
        source: "iana",
        compressible: true,
        extensions: ["relo"]
      },
      "application/parityfec": {
        source: "iana"
      },
      "application/passport": {
        source: "iana"
      },
      "application/patch-ops-error+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xer"]
      },
      "application/pdf": {
        source: "iana",
        compressible: false,
        extensions: ["pdf"]
      },
      "application/pdx": {
        source: "iana"
      },
      "application/pem-certificate-chain": {
        source: "iana"
      },
      "application/pgp-encrypted": {
        source: "iana",
        compressible: false,
        extensions: ["pgp"]
      },
      "application/pgp-keys": {
        source: "iana",
        extensions: ["asc"]
      },
      "application/pgp-signature": {
        source: "iana",
        extensions: ["asc", "sig"]
      },
      "application/pics-rules": {
        source: "apache",
        extensions: ["prf"]
      },
      "application/pidf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pidf-diff+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pkcs10": {
        source: "iana",
        extensions: ["p10"]
      },
      "application/pkcs12": {
        source: "iana"
      },
      "application/pkcs7-mime": {
        source: "iana",
        extensions: ["p7m", "p7c"]
      },
      "application/pkcs7-signature": {
        source: "iana",
        extensions: ["p7s"]
      },
      "application/pkcs8": {
        source: "iana",
        extensions: ["p8"]
      },
      "application/pkcs8-encrypted": {
        source: "iana"
      },
      "application/pkix-attr-cert": {
        source: "iana",
        extensions: ["ac"]
      },
      "application/pkix-cert": {
        source: "iana",
        extensions: ["cer"]
      },
      "application/pkix-crl": {
        source: "iana",
        extensions: ["crl"]
      },
      "application/pkix-pkipath": {
        source: "iana",
        extensions: ["pkipath"]
      },
      "application/pkixcmp": {
        source: "iana",
        extensions: ["pki"]
      },
      "application/pls+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pls"]
      },
      "application/poc-settings+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/postscript": {
        source: "iana",
        compressible: true,
        extensions: ["ai", "eps", "ps"]
      },
      "application/ppsp-tracker+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+xml": {
        source: "iana",
        compressible: true
      },
      "application/provenance+xml": {
        source: "iana",
        compressible: true,
        extensions: ["provx"]
      },
      "application/prs.alvestrand.titrax-sheet": {
        source: "iana"
      },
      "application/prs.cww": {
        source: "iana",
        extensions: ["cww"]
      },
      "application/prs.cyn": {
        source: "iana",
        charset: "7-BIT"
      },
      "application/prs.hpub+zip": {
        source: "iana",
        compressible: false
      },
      "application/prs.nprend": {
        source: "iana"
      },
      "application/prs.plucker": {
        source: "iana"
      },
      "application/prs.rdf-xml-crypt": {
        source: "iana"
      },
      "application/prs.xsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/pskc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pskcxml"]
      },
      "application/pvd+json": {
        source: "iana",
        compressible: true
      },
      "application/qsig": {
        source: "iana"
      },
      "application/raml+yaml": {
        compressible: true,
        extensions: ["raml"]
      },
      "application/raptorfec": {
        source: "iana"
      },
      "application/rdap+json": {
        source: "iana",
        compressible: true
      },
      "application/rdf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rdf", "owl"]
      },
      "application/reginfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rif"]
      },
      "application/relax-ng-compact-syntax": {
        source: "iana",
        extensions: ["rnc"]
      },
      "application/remote-printing": {
        source: "iana"
      },
      "application/reputon+json": {
        source: "iana",
        compressible: true
      },
      "application/resource-lists+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rl"]
      },
      "application/resource-lists-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rld"]
      },
      "application/rfc+xml": {
        source: "iana",
        compressible: true
      },
      "application/riscos": {
        source: "iana"
      },
      "application/rlmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/rls-services+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rs"]
      },
      "application/route-apd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rapd"]
      },
      "application/route-s-tsid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sls"]
      },
      "application/route-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rusd"]
      },
      "application/rpki-ghostbusters": {
        source: "iana",
        extensions: ["gbr"]
      },
      "application/rpki-manifest": {
        source: "iana",
        extensions: ["mft"]
      },
      "application/rpki-publication": {
        source: "iana"
      },
      "application/rpki-roa": {
        source: "iana",
        extensions: ["roa"]
      },
      "application/rpki-updown": {
        source: "iana"
      },
      "application/rsd+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rsd"]
      },
      "application/rss+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rss"]
      },
      "application/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "application/rtploopback": {
        source: "iana"
      },
      "application/rtx": {
        source: "iana"
      },
      "application/samlassertion+xml": {
        source: "iana",
        compressible: true
      },
      "application/samlmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/sarif+json": {
        source: "iana",
        compressible: true
      },
      "application/sarif-external-properties+json": {
        source: "iana",
        compressible: true
      },
      "application/sbe": {
        source: "iana"
      },
      "application/sbml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sbml"]
      },
      "application/scaip+xml": {
        source: "iana",
        compressible: true
      },
      "application/scim+json": {
        source: "iana",
        compressible: true
      },
      "application/scvp-cv-request": {
        source: "iana",
        extensions: ["scq"]
      },
      "application/scvp-cv-response": {
        source: "iana",
        extensions: ["scs"]
      },
      "application/scvp-vp-request": {
        source: "iana",
        extensions: ["spq"]
      },
      "application/scvp-vp-response": {
        source: "iana",
        extensions: ["spp"]
      },
      "application/sdp": {
        source: "iana",
        extensions: ["sdp"]
      },
      "application/secevent+jwt": {
        source: "iana"
      },
      "application/senml+cbor": {
        source: "iana"
      },
      "application/senml+json": {
        source: "iana",
        compressible: true
      },
      "application/senml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["senmlx"]
      },
      "application/senml-etch+cbor": {
        source: "iana"
      },
      "application/senml-etch+json": {
        source: "iana",
        compressible: true
      },
      "application/senml-exi": {
        source: "iana"
      },
      "application/sensml+cbor": {
        source: "iana"
      },
      "application/sensml+json": {
        source: "iana",
        compressible: true
      },
      "application/sensml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sensmlx"]
      },
      "application/sensml-exi": {
        source: "iana"
      },
      "application/sep+xml": {
        source: "iana",
        compressible: true
      },
      "application/sep-exi": {
        source: "iana"
      },
      "application/session-info": {
        source: "iana"
      },
      "application/set-payment": {
        source: "iana"
      },
      "application/set-payment-initiation": {
        source: "iana",
        extensions: ["setpay"]
      },
      "application/set-registration": {
        source: "iana"
      },
      "application/set-registration-initiation": {
        source: "iana",
        extensions: ["setreg"]
      },
      "application/sgml": {
        source: "iana"
      },
      "application/sgml-open-catalog": {
        source: "iana"
      },
      "application/shf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["shf"]
      },
      "application/sieve": {
        source: "iana",
        extensions: ["siv", "sieve"]
      },
      "application/simple-filter+xml": {
        source: "iana",
        compressible: true
      },
      "application/simple-message-summary": {
        source: "iana"
      },
      "application/simplesymbolcontainer": {
        source: "iana"
      },
      "application/sipc": {
        source: "iana"
      },
      "application/slate": {
        source: "iana"
      },
      "application/smil": {
        source: "iana"
      },
      "application/smil+xml": {
        source: "iana",
        compressible: true,
        extensions: ["smi", "smil"]
      },
      "application/smpte336m": {
        source: "iana"
      },
      "application/soap+fastinfoset": {
        source: "iana"
      },
      "application/soap+xml": {
        source: "iana",
        compressible: true
      },
      "application/sparql-query": {
        source: "iana",
        extensions: ["rq"]
      },
      "application/sparql-results+xml": {
        source: "iana",
        compressible: true,
        extensions: ["srx"]
      },
      "application/spdx+json": {
        source: "iana",
        compressible: true
      },
      "application/spirits-event+xml": {
        source: "iana",
        compressible: true
      },
      "application/sql": {
        source: "iana"
      },
      "application/srgs": {
        source: "iana",
        extensions: ["gram"]
      },
      "application/srgs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["grxml"]
      },
      "application/sru+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sru"]
      },
      "application/ssdl+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ssdl"]
      },
      "application/ssml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ssml"]
      },
      "application/stix+json": {
        source: "iana",
        compressible: true
      },
      "application/swid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["swidtag"]
      },
      "application/tamp-apex-update": {
        source: "iana"
      },
      "application/tamp-apex-update-confirm": {
        source: "iana"
      },
      "application/tamp-community-update": {
        source: "iana"
      },
      "application/tamp-community-update-confirm": {
        source: "iana"
      },
      "application/tamp-error": {
        source: "iana"
      },
      "application/tamp-sequence-adjust": {
        source: "iana"
      },
      "application/tamp-sequence-adjust-confirm": {
        source: "iana"
      },
      "application/tamp-status-query": {
        source: "iana"
      },
      "application/tamp-status-response": {
        source: "iana"
      },
      "application/tamp-update": {
        source: "iana"
      },
      "application/tamp-update-confirm": {
        source: "iana"
      },
      "application/tar": {
        compressible: true
      },
      "application/taxii+json": {
        source: "iana",
        compressible: true
      },
      "application/td+json": {
        source: "iana",
        compressible: true
      },
      "application/tei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tei", "teicorpus"]
      },
      "application/tetra_isi": {
        source: "iana"
      },
      "application/thraud+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tfi"]
      },
      "application/timestamp-query": {
        source: "iana"
      },
      "application/timestamp-reply": {
        source: "iana"
      },
      "application/timestamped-data": {
        source: "iana",
        extensions: ["tsd"]
      },
      "application/tlsrpt+gzip": {
        source: "iana"
      },
      "application/tlsrpt+json": {
        source: "iana",
        compressible: true
      },
      "application/tnauthlist": {
        source: "iana"
      },
      "application/token-introspection+jwt": {
        source: "iana"
      },
      "application/toml": {
        compressible: true,
        extensions: ["toml"]
      },
      "application/trickle-ice-sdpfrag": {
        source: "iana"
      },
      "application/trig": {
        source: "iana",
        extensions: ["trig"]
      },
      "application/ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ttml"]
      },
      "application/tve-trigger": {
        source: "iana"
      },
      "application/tzif": {
        source: "iana"
      },
      "application/tzif-leap": {
        source: "iana"
      },
      "application/ubjson": {
        compressible: false,
        extensions: ["ubj"]
      },
      "application/ulpfec": {
        source: "iana"
      },
      "application/urc-grpsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/urc-ressheet+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsheet"]
      },
      "application/urc-targetdesc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["td"]
      },
      "application/urc-uisocketdesc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vcard+json": {
        source: "iana",
        compressible: true
      },
      "application/vcard+xml": {
        source: "iana",
        compressible: true
      },
      "application/vemmi": {
        source: "iana"
      },
      "application/vividence.scriptfile": {
        source: "apache"
      },
      "application/vnd.1000minds.decision-model+xml": {
        source: "iana",
        compressible: true,
        extensions: ["1km"]
      },
      "application/vnd.3gpp-prose+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-prose-pc3ch+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-v2x-local-service-information": {
        source: "iana"
      },
      "application/vnd.3gpp.5gnas": {
        source: "iana"
      },
      "application/vnd.3gpp.access-transfer-events+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.bsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gmop+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gtpc": {
        source: "iana"
      },
      "application/vnd.3gpp.interworking-data": {
        source: "iana"
      },
      "application/vnd.3gpp.lpp": {
        source: "iana"
      },
      "application/vnd.3gpp.mc-signalling-ear": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-payload": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-signalling": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-floor-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-signed+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-init-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-transmission-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mid-call+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ngap": {
        source: "iana"
      },
      "application/vnd.3gpp.pfcp": {
        source: "iana"
      },
      "application/vnd.3gpp.pic-bw-large": {
        source: "iana",
        extensions: ["plb"]
      },
      "application/vnd.3gpp.pic-bw-small": {
        source: "iana",
        extensions: ["psb"]
      },
      "application/vnd.3gpp.pic-bw-var": {
        source: "iana",
        extensions: ["pvb"]
      },
      "application/vnd.3gpp.s1ap": {
        source: "iana"
      },
      "application/vnd.3gpp.sms": {
        source: "iana"
      },
      "application/vnd.3gpp.sms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-ext+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.state-and-event-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ussd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.bcmcsinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.sms": {
        source: "iana"
      },
      "application/vnd.3gpp2.tcap": {
        source: "iana",
        extensions: ["tcap"]
      },
      "application/vnd.3lightssoftware.imagescal": {
        source: "iana"
      },
      "application/vnd.3m.post-it-notes": {
        source: "iana",
        extensions: ["pwn"]
      },
      "application/vnd.accpac.simply.aso": {
        source: "iana",
        extensions: ["aso"]
      },
      "application/vnd.accpac.simply.imp": {
        source: "iana",
        extensions: ["imp"]
      },
      "application/vnd.acucobol": {
        source: "iana",
        extensions: ["acu"]
      },
      "application/vnd.acucorp": {
        source: "iana",
        extensions: ["atc", "acutc"]
      },
      "application/vnd.adobe.air-application-installer-package+zip": {
        source: "apache",
        compressible: false,
        extensions: ["air"]
      },
      "application/vnd.adobe.flash.movie": {
        source: "iana"
      },
      "application/vnd.adobe.formscentral.fcdt": {
        source: "iana",
        extensions: ["fcdt"]
      },
      "application/vnd.adobe.fxp": {
        source: "iana",
        extensions: ["fxp", "fxpl"]
      },
      "application/vnd.adobe.partial-upload": {
        source: "iana"
      },
      "application/vnd.adobe.xdp+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdp"]
      },
      "application/vnd.adobe.xfdf": {
        source: "iana",
        extensions: ["xfdf"]
      },
      "application/vnd.aether.imp": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata-pagedef": {
        source: "iana"
      },
      "application/vnd.afpc.cmoca-cmresource": {
        source: "iana"
      },
      "application/vnd.afpc.foca-charset": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codedfont": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codepage": {
        source: "iana"
      },
      "application/vnd.afpc.modca": {
        source: "iana"
      },
      "application/vnd.afpc.modca-cmtable": {
        source: "iana"
      },
      "application/vnd.afpc.modca-formdef": {
        source: "iana"
      },
      "application/vnd.afpc.modca-mediummap": {
        source: "iana"
      },
      "application/vnd.afpc.modca-objectcontainer": {
        source: "iana"
      },
      "application/vnd.afpc.modca-overlay": {
        source: "iana"
      },
      "application/vnd.afpc.modca-pagesegment": {
        source: "iana"
      },
      "application/vnd.age": {
        source: "iana",
        extensions: ["age"]
      },
      "application/vnd.ah-barcode": {
        source: "iana"
      },
      "application/vnd.ahead.space": {
        source: "iana",
        extensions: ["ahead"]
      },
      "application/vnd.airzip.filesecure.azf": {
        source: "iana",
        extensions: ["azf"]
      },
      "application/vnd.airzip.filesecure.azs": {
        source: "iana",
        extensions: ["azs"]
      },
      "application/vnd.amadeus+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.amazon.ebook": {
        source: "apache",
        extensions: ["azw"]
      },
      "application/vnd.amazon.mobi8-ebook": {
        source: "iana"
      },
      "application/vnd.americandynamics.acc": {
        source: "iana",
        extensions: ["acc"]
      },
      "application/vnd.amiga.ami": {
        source: "iana",
        extensions: ["ami"]
      },
      "application/vnd.amundsen.maze+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.android.ota": {
        source: "iana"
      },
      "application/vnd.android.package-archive": {
        source: "apache",
        compressible: false,
        extensions: ["apk"]
      },
      "application/vnd.anki": {
        source: "iana"
      },
      "application/vnd.anser-web-certificate-issue-initiation": {
        source: "iana",
        extensions: ["cii"]
      },
      "application/vnd.anser-web-funds-transfer-initiation": {
        source: "apache",
        extensions: ["fti"]
      },
      "application/vnd.antix.game-component": {
        source: "iana",
        extensions: ["atx"]
      },
      "application/vnd.apache.arrow.file": {
        source: "iana"
      },
      "application/vnd.apache.arrow.stream": {
        source: "iana"
      },
      "application/vnd.apache.thrift.binary": {
        source: "iana"
      },
      "application/vnd.apache.thrift.compact": {
        source: "iana"
      },
      "application/vnd.apache.thrift.json": {
        source: "iana"
      },
      "application/vnd.api+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.aplextor.warrp+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apothekende.reservation+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apple.installer+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpkg"]
      },
      "application/vnd.apple.keynote": {
        source: "iana",
        extensions: ["key"]
      },
      "application/vnd.apple.mpegurl": {
        source: "iana",
        extensions: ["m3u8"]
      },
      "application/vnd.apple.numbers": {
        source: "iana",
        extensions: ["numbers"]
      },
      "application/vnd.apple.pages": {
        source: "iana",
        extensions: ["pages"]
      },
      "application/vnd.apple.pkpass": {
        compressible: false,
        extensions: ["pkpass"]
      },
      "application/vnd.arastra.swi": {
        source: "iana"
      },
      "application/vnd.aristanetworks.swi": {
        source: "iana",
        extensions: ["swi"]
      },
      "application/vnd.artisan+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.artsquare": {
        source: "iana"
      },
      "application/vnd.astraea-software.iota": {
        source: "iana",
        extensions: ["iota"]
      },
      "application/vnd.audiograph": {
        source: "iana",
        extensions: ["aep"]
      },
      "application/vnd.autopackage": {
        source: "iana"
      },
      "application/vnd.avalon+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.avistar+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.balsamiq.bmml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["bmml"]
      },
      "application/vnd.balsamiq.bmpr": {
        source: "iana"
      },
      "application/vnd.banana-accounting": {
        source: "iana"
      },
      "application/vnd.bbf.usp.error": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bekitzur-stech+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bint.med-content": {
        source: "iana"
      },
      "application/vnd.biopax.rdf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.blink-idb-value-wrapper": {
        source: "iana"
      },
      "application/vnd.blueice.multipass": {
        source: "iana",
        extensions: ["mpm"]
      },
      "application/vnd.bluetooth.ep.oob": {
        source: "iana"
      },
      "application/vnd.bluetooth.le.oob": {
        source: "iana"
      },
      "application/vnd.bmi": {
        source: "iana",
        extensions: ["bmi"]
      },
      "application/vnd.bpf": {
        source: "iana"
      },
      "application/vnd.bpf3": {
        source: "iana"
      },
      "application/vnd.businessobjects": {
        source: "iana",
        extensions: ["rep"]
      },
      "application/vnd.byu.uapi+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cab-jscript": {
        source: "iana"
      },
      "application/vnd.canon-cpdl": {
        source: "iana"
      },
      "application/vnd.canon-lips": {
        source: "iana"
      },
      "application/vnd.capasystems-pg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cendio.thinlinc.clientconf": {
        source: "iana"
      },
      "application/vnd.century-systems.tcp_stream": {
        source: "iana"
      },
      "application/vnd.chemdraw+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdxml"]
      },
      "application/vnd.chess-pgn": {
        source: "iana"
      },
      "application/vnd.chipnuts.karaoke-mmd": {
        source: "iana",
        extensions: ["mmd"]
      },
      "application/vnd.ciedi": {
        source: "iana"
      },
      "application/vnd.cinderella": {
        source: "iana",
        extensions: ["cdy"]
      },
      "application/vnd.cirpack.isdn-ext": {
        source: "iana"
      },
      "application/vnd.citationstyles.style+xml": {
        source: "iana",
        compressible: true,
        extensions: ["csl"]
      },
      "application/vnd.claymore": {
        source: "iana",
        extensions: ["cla"]
      },
      "application/vnd.cloanto.rp9": {
        source: "iana",
        extensions: ["rp9"]
      },
      "application/vnd.clonk.c4group": {
        source: "iana",
        extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
      },
      "application/vnd.cluetrust.cartomobile-config": {
        source: "iana",
        extensions: ["c11amc"]
      },
      "application/vnd.cluetrust.cartomobile-config-pkg": {
        source: "iana",
        extensions: ["c11amz"]
      },
      "application/vnd.coffeescript": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet-template": {
        source: "iana"
      },
      "application/vnd.collection+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.doc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.next+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.comicbook+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.comicbook-rar": {
        source: "iana"
      },
      "application/vnd.commerce-battelle": {
        source: "iana"
      },
      "application/vnd.commonspace": {
        source: "iana",
        extensions: ["csp"]
      },
      "application/vnd.contact.cmsg": {
        source: "iana",
        extensions: ["cdbcmsg"]
      },
      "application/vnd.coreos.ignition+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cosmocaller": {
        source: "iana",
        extensions: ["cmc"]
      },
      "application/vnd.crick.clicker": {
        source: "iana",
        extensions: ["clkx"]
      },
      "application/vnd.crick.clicker.keyboard": {
        source: "iana",
        extensions: ["clkk"]
      },
      "application/vnd.crick.clicker.palette": {
        source: "iana",
        extensions: ["clkp"]
      },
      "application/vnd.crick.clicker.template": {
        source: "iana",
        extensions: ["clkt"]
      },
      "application/vnd.crick.clicker.wordbank": {
        source: "iana",
        extensions: ["clkw"]
      },
      "application/vnd.criticaltools.wbs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wbs"]
      },
      "application/vnd.cryptii.pipe+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.crypto-shade-file": {
        source: "iana"
      },
      "application/vnd.cryptomator.encrypted": {
        source: "iana"
      },
      "application/vnd.cryptomator.vault": {
        source: "iana"
      },
      "application/vnd.ctc-posml": {
        source: "iana",
        extensions: ["pml"]
      },
      "application/vnd.ctct.ws+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cups-pdf": {
        source: "iana"
      },
      "application/vnd.cups-postscript": {
        source: "iana"
      },
      "application/vnd.cups-ppd": {
        source: "iana",
        extensions: ["ppd"]
      },
      "application/vnd.cups-raster": {
        source: "iana"
      },
      "application/vnd.cups-raw": {
        source: "iana"
      },
      "application/vnd.curl": {
        source: "iana"
      },
      "application/vnd.curl.car": {
        source: "apache",
        extensions: ["car"]
      },
      "application/vnd.curl.pcurl": {
        source: "apache",
        extensions: ["pcurl"]
      },
      "application/vnd.cyan.dean.root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cybank": {
        source: "iana"
      },
      "application/vnd.cyclonedx+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cyclonedx+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.d2l.coursepackage1p0+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.d3m-dataset": {
        source: "iana"
      },
      "application/vnd.d3m-problem": {
        source: "iana"
      },
      "application/vnd.dart": {
        source: "iana",
        compressible: true,
        extensions: ["dart"]
      },
      "application/vnd.data-vision.rdz": {
        source: "iana",
        extensions: ["rdz"]
      },
      "application/vnd.datapackage+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dataresource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dbf": {
        source: "iana",
        extensions: ["dbf"]
      },
      "application/vnd.debian.binary-package": {
        source: "iana"
      },
      "application/vnd.dece.data": {
        source: "iana",
        extensions: ["uvf", "uvvf", "uvd", "uvvd"]
      },
      "application/vnd.dece.ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uvt", "uvvt"]
      },
      "application/vnd.dece.unspecified": {
        source: "iana",
        extensions: ["uvx", "uvvx"]
      },
      "application/vnd.dece.zip": {
        source: "iana",
        extensions: ["uvz", "uvvz"]
      },
      "application/vnd.denovo.fcselayout-link": {
        source: "iana",
        extensions: ["fe_launch"]
      },
      "application/vnd.desmume.movie": {
        source: "iana"
      },
      "application/vnd.dir-bi.plate-dl-nosuffix": {
        source: "iana"
      },
      "application/vnd.dm.delegation+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dna": {
        source: "iana",
        extensions: ["dna"]
      },
      "application/vnd.document+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dolby.mlp": {
        source: "apache",
        extensions: ["mlp"]
      },
      "application/vnd.dolby.mobile.1": {
        source: "iana"
      },
      "application/vnd.dolby.mobile.2": {
        source: "iana"
      },
      "application/vnd.doremir.scorecloud-binary-document": {
        source: "iana"
      },
      "application/vnd.dpgraph": {
        source: "iana",
        extensions: ["dpg"]
      },
      "application/vnd.dreamfactory": {
        source: "iana",
        extensions: ["dfac"]
      },
      "application/vnd.drive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ds-keypoint": {
        source: "apache",
        extensions: ["kpxx"]
      },
      "application/vnd.dtg.local": {
        source: "iana"
      },
      "application/vnd.dtg.local.flash": {
        source: "iana"
      },
      "application/vnd.dtg.local.html": {
        source: "iana"
      },
      "application/vnd.dvb.ait": {
        source: "iana",
        extensions: ["ait"]
      },
      "application/vnd.dvb.dvbisl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.dvbj": {
        source: "iana"
      },
      "application/vnd.dvb.esgcontainer": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcdftnotifaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess2": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgpdd": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcroaming": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-base": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-enhancement": {
        source: "iana"
      },
      "application/vnd.dvb.notif-aggregate-root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-container+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-generic+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-msglist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-init+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.pfr": {
        source: "iana"
      },
      "application/vnd.dvb.service": {
        source: "iana",
        extensions: ["svc"]
      },
      "application/vnd.dxr": {
        source: "iana"
      },
      "application/vnd.dynageo": {
        source: "iana",
        extensions: ["geo"]
      },
      "application/vnd.dzr": {
        source: "iana"
      },
      "application/vnd.easykaraoke.cdgdownload": {
        source: "iana"
      },
      "application/vnd.ecdis-update": {
        source: "iana"
      },
      "application/vnd.ecip.rlp": {
        source: "iana"
      },
      "application/vnd.eclipse.ditto+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ecowin.chart": {
        source: "iana",
        extensions: ["mag"]
      },
      "application/vnd.ecowin.filerequest": {
        source: "iana"
      },
      "application/vnd.ecowin.fileupdate": {
        source: "iana"
      },
      "application/vnd.ecowin.series": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesrequest": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesupdate": {
        source: "iana"
      },
      "application/vnd.efi.img": {
        source: "iana"
      },
      "application/vnd.efi.iso": {
        source: "iana"
      },
      "application/vnd.emclient.accessrequest+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.enliven": {
        source: "iana",
        extensions: ["nml"]
      },
      "application/vnd.enphase.envoy": {
        source: "iana"
      },
      "application/vnd.eprints.data+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.epson.esf": {
        source: "iana",
        extensions: ["esf"]
      },
      "application/vnd.epson.msf": {
        source: "iana",
        extensions: ["msf"]
      },
      "application/vnd.epson.quickanime": {
        source: "iana",
        extensions: ["qam"]
      },
      "application/vnd.epson.salt": {
        source: "iana",
        extensions: ["slt"]
      },
      "application/vnd.epson.ssf": {
        source: "iana",
        extensions: ["ssf"]
      },
      "application/vnd.ericsson.quickcall": {
        source: "iana"
      },
      "application/vnd.espass-espass+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.eszigno3+xml": {
        source: "iana",
        compressible: true,
        extensions: ["es3", "et3"]
      },
      "application/vnd.etsi.aoc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.asic-e+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.asic-s+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.cug+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvcommand+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-bc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-cod+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-npvr+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvservice+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mcid+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mheg5": {
        source: "iana"
      },
      "application/vnd.etsi.overload-control-policy-dataset+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.pstn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.sci+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.simservs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.timestamp-token": {
        source: "iana"
      },
      "application/vnd.etsi.tsl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.tsl.der": {
        source: "iana"
      },
      "application/vnd.eu.kasparian.car+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.eudora.data": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.profile": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.settings": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.theme": {
        source: "iana"
      },
      "application/vnd.exstream-empower+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.exstream-package": {
        source: "iana"
      },
      "application/vnd.ezpix-album": {
        source: "iana",
        extensions: ["ez2"]
      },
      "application/vnd.ezpix-package": {
        source: "iana",
        extensions: ["ez3"]
      },
      "application/vnd.f-secure.mobile": {
        source: "iana"
      },
      "application/vnd.familysearch.gedcom+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.fastcopy-disk-image": {
        source: "iana"
      },
      "application/vnd.fdf": {
        source: "iana",
        extensions: ["fdf"]
      },
      "application/vnd.fdsn.mseed": {
        source: "iana",
        extensions: ["mseed"]
      },
      "application/vnd.fdsn.seed": {
        source: "iana",
        extensions: ["seed", "dataless"]
      },
      "application/vnd.ffsns": {
        source: "iana"
      },
      "application/vnd.ficlab.flb+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.filmit.zfc": {
        source: "iana"
      },
      "application/vnd.fints": {
        source: "iana"
      },
      "application/vnd.firemonkeys.cloudcell": {
        source: "iana"
      },
      "application/vnd.flographit": {
        source: "iana",
        extensions: ["gph"]
      },
      "application/vnd.fluxtime.clip": {
        source: "iana",
        extensions: ["ftc"]
      },
      "application/vnd.font-fontforge-sfd": {
        source: "iana"
      },
      "application/vnd.framemaker": {
        source: "iana",
        extensions: ["fm", "frame", "maker", "book"]
      },
      "application/vnd.frogans.fnc": {
        source: "iana",
        extensions: ["fnc"]
      },
      "application/vnd.frogans.ltf": {
        source: "iana",
        extensions: ["ltf"]
      },
      "application/vnd.fsc.weblaunch": {
        source: "iana",
        extensions: ["fsc"]
      },
      "application/vnd.fujifilm.fb.docuworks": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.binder": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.jfi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fujitsu.oasys": {
        source: "iana",
        extensions: ["oas"]
      },
      "application/vnd.fujitsu.oasys2": {
        source: "iana",
        extensions: ["oa2"]
      },
      "application/vnd.fujitsu.oasys3": {
        source: "iana",
        extensions: ["oa3"]
      },
      "application/vnd.fujitsu.oasysgp": {
        source: "iana",
        extensions: ["fg5"]
      },
      "application/vnd.fujitsu.oasysprs": {
        source: "iana",
        extensions: ["bh2"]
      },
      "application/vnd.fujixerox.art-ex": {
        source: "iana"
      },
      "application/vnd.fujixerox.art4": {
        source: "iana"
      },
      "application/vnd.fujixerox.ddd": {
        source: "iana",
        extensions: ["ddd"]
      },
      "application/vnd.fujixerox.docuworks": {
        source: "iana",
        extensions: ["xdw"]
      },
      "application/vnd.fujixerox.docuworks.binder": {
        source: "iana",
        extensions: ["xbd"]
      },
      "application/vnd.fujixerox.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujixerox.hbpl": {
        source: "iana"
      },
      "application/vnd.fut-misnet": {
        source: "iana"
      },
      "application/vnd.futoin+cbor": {
        source: "iana"
      },
      "application/vnd.futoin+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fuzzysheet": {
        source: "iana",
        extensions: ["fzs"]
      },
      "application/vnd.genomatix.tuxedo": {
        source: "iana",
        extensions: ["txd"]
      },
      "application/vnd.gentics.grd+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geo+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geocube+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geogebra.file": {
        source: "iana",
        extensions: ["ggb"]
      },
      "application/vnd.geogebra.slides": {
        source: "iana"
      },
      "application/vnd.geogebra.tool": {
        source: "iana",
        extensions: ["ggt"]
      },
      "application/vnd.geometry-explorer": {
        source: "iana",
        extensions: ["gex", "gre"]
      },
      "application/vnd.geonext": {
        source: "iana",
        extensions: ["gxt"]
      },
      "application/vnd.geoplan": {
        source: "iana",
        extensions: ["g2w"]
      },
      "application/vnd.geospace": {
        source: "iana",
        extensions: ["g3w"]
      },
      "application/vnd.gerber": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt-response": {
        source: "iana"
      },
      "application/vnd.gmx": {
        source: "iana",
        extensions: ["gmx"]
      },
      "application/vnd.google-apps.document": {
        compressible: false,
        extensions: ["gdoc"]
      },
      "application/vnd.google-apps.presentation": {
        compressible: false,
        extensions: ["gslides"]
      },
      "application/vnd.google-apps.spreadsheet": {
        compressible: false,
        extensions: ["gsheet"]
      },
      "application/vnd.google-earth.kml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["kml"]
      },
      "application/vnd.google-earth.kmz": {
        source: "iana",
        compressible: false,
        extensions: ["kmz"]
      },
      "application/vnd.gov.sk.e-form+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.gov.sk.e-form+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.gov.sk.xmldatacontainer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.grafeq": {
        source: "iana",
        extensions: ["gqf", "gqs"]
      },
      "application/vnd.gridmp": {
        source: "iana"
      },
      "application/vnd.groove-account": {
        source: "iana",
        extensions: ["gac"]
      },
      "application/vnd.groove-help": {
        source: "iana",
        extensions: ["ghf"]
      },
      "application/vnd.groove-identity-message": {
        source: "iana",
        extensions: ["gim"]
      },
      "application/vnd.groove-injector": {
        source: "iana",
        extensions: ["grv"]
      },
      "application/vnd.groove-tool-message": {
        source: "iana",
        extensions: ["gtm"]
      },
      "application/vnd.groove-tool-template": {
        source: "iana",
        extensions: ["tpl"]
      },
      "application/vnd.groove-vcard": {
        source: "iana",
        extensions: ["vcg"]
      },
      "application/vnd.hal+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hal+xml": {
        source: "iana",
        compressible: true,
        extensions: ["hal"]
      },
      "application/vnd.handheld-entertainment+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zmm"]
      },
      "application/vnd.hbci": {
        source: "iana",
        extensions: ["hbci"]
      },
      "application/vnd.hc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hcl-bireports": {
        source: "iana"
      },
      "application/vnd.hdt": {
        source: "iana"
      },
      "application/vnd.heroku+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hhe.lesson-player": {
        source: "iana",
        extensions: ["les"]
      },
      "application/vnd.hl7cda+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hl7v2+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hp-hpgl": {
        source: "iana",
        extensions: ["hpgl"]
      },
      "application/vnd.hp-hpid": {
        source: "iana",
        extensions: ["hpid"]
      },
      "application/vnd.hp-hps": {
        source: "iana",
        extensions: ["hps"]
      },
      "application/vnd.hp-jlyt": {
        source: "iana",
        extensions: ["jlt"]
      },
      "application/vnd.hp-pcl": {
        source: "iana",
        extensions: ["pcl"]
      },
      "application/vnd.hp-pclxl": {
        source: "iana",
        extensions: ["pclxl"]
      },
      "application/vnd.httphone": {
        source: "iana"
      },
      "application/vnd.hydrostatix.sof-data": {
        source: "iana",
        extensions: ["sfd-hdstx"]
      },
      "application/vnd.hyper+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyper-item+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyperdrive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hzn-3d-crossword": {
        source: "iana"
      },
      "application/vnd.ibm.afplinedata": {
        source: "iana"
      },
      "application/vnd.ibm.electronic-media": {
        source: "iana"
      },
      "application/vnd.ibm.minipay": {
        source: "iana",
        extensions: ["mpy"]
      },
      "application/vnd.ibm.modcap": {
        source: "iana",
        extensions: ["afp", "listafp", "list3820"]
      },
      "application/vnd.ibm.rights-management": {
        source: "iana",
        extensions: ["irm"]
      },
      "application/vnd.ibm.secure-container": {
        source: "iana",
        extensions: ["sc"]
      },
      "application/vnd.iccprofile": {
        source: "iana",
        extensions: ["icc", "icm"]
      },
      "application/vnd.ieee.1905": {
        source: "iana"
      },
      "application/vnd.igloader": {
        source: "iana",
        extensions: ["igl"]
      },
      "application/vnd.imagemeter.folder+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.imagemeter.image+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.immervision-ivp": {
        source: "iana",
        extensions: ["ivp"]
      },
      "application/vnd.immervision-ivu": {
        source: "iana",
        extensions: ["ivu"]
      },
      "application/vnd.ims.imsccv1p1": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p2": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p3": {
        source: "iana"
      },
      "application/vnd.ims.lis.v2.result+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy.id+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings.simple+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informedcontrol.rms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informix-visionary": {
        source: "iana"
      },
      "application/vnd.infotech.project": {
        source: "iana"
      },
      "application/vnd.infotech.project+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.innopath.wamp.notification": {
        source: "iana"
      },
      "application/vnd.insors.igm": {
        source: "iana",
        extensions: ["igm"]
      },
      "application/vnd.intercon.formnet": {
        source: "iana",
        extensions: ["xpw", "xpx"]
      },
      "application/vnd.intergeo": {
        source: "iana",
        extensions: ["i2g"]
      },
      "application/vnd.intertrust.digibox": {
        source: "iana"
      },
      "application/vnd.intertrust.nncp": {
        source: "iana"
      },
      "application/vnd.intu.qbo": {
        source: "iana",
        extensions: ["qbo"]
      },
      "application/vnd.intu.qfx": {
        source: "iana",
        extensions: ["qfx"]
      },
      "application/vnd.iptc.g2.catalogitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.conceptitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.knowledgeitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.packageitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.planningitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ipunplugged.rcprofile": {
        source: "iana",
        extensions: ["rcprofile"]
      },
      "application/vnd.irepository.package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["irp"]
      },
      "application/vnd.is-xpr": {
        source: "iana",
        extensions: ["xpr"]
      },
      "application/vnd.isac.fcs": {
        source: "iana",
        extensions: ["fcs"]
      },
      "application/vnd.iso11783-10+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.jam": {
        source: "iana",
        extensions: ["jam"]
      },
      "application/vnd.japannet-directory-service": {
        source: "iana"
      },
      "application/vnd.japannet-jpnstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-payment-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-registration": {
        source: "iana"
      },
      "application/vnd.japannet-registration-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-setstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-verification": {
        source: "iana"
      },
      "application/vnd.japannet-verification-wakeup": {
        source: "iana"
      },
      "application/vnd.jcp.javame.midlet-rms": {
        source: "iana",
        extensions: ["rms"]
      },
      "application/vnd.jisp": {
        source: "iana",
        extensions: ["jisp"]
      },
      "application/vnd.joost.joda-archive": {
        source: "iana",
        extensions: ["joda"]
      },
      "application/vnd.jsk.isdn-ngn": {
        source: "iana"
      },
      "application/vnd.kahootz": {
        source: "iana",
        extensions: ["ktz", "ktr"]
      },
      "application/vnd.kde.karbon": {
        source: "iana",
        extensions: ["karbon"]
      },
      "application/vnd.kde.kchart": {
        source: "iana",
        extensions: ["chrt"]
      },
      "application/vnd.kde.kformula": {
        source: "iana",
        extensions: ["kfo"]
      },
      "application/vnd.kde.kivio": {
        source: "iana",
        extensions: ["flw"]
      },
      "application/vnd.kde.kontour": {
        source: "iana",
        extensions: ["kon"]
      },
      "application/vnd.kde.kpresenter": {
        source: "iana",
        extensions: ["kpr", "kpt"]
      },
      "application/vnd.kde.kspread": {
        source: "iana",
        extensions: ["ksp"]
      },
      "application/vnd.kde.kword": {
        source: "iana",
        extensions: ["kwd", "kwt"]
      },
      "application/vnd.kenameaapp": {
        source: "iana",
        extensions: ["htke"]
      },
      "application/vnd.kidspiration": {
        source: "iana",
        extensions: ["kia"]
      },
      "application/vnd.kinar": {
        source: "iana",
        extensions: ["kne", "knp"]
      },
      "application/vnd.koan": {
        source: "iana",
        extensions: ["skp", "skd", "skt", "skm"]
      },
      "application/vnd.kodak-descriptor": {
        source: "iana",
        extensions: ["sse"]
      },
      "application/vnd.las": {
        source: "iana"
      },
      "application/vnd.las.las+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.las.las+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lasxml"]
      },
      "application/vnd.laszip": {
        source: "iana"
      },
      "application/vnd.leap+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.liberty-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.llamagraphics.life-balance.desktop": {
        source: "iana",
        extensions: ["lbd"]
      },
      "application/vnd.llamagraphics.life-balance.exchange+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lbe"]
      },
      "application/vnd.logipipe.circuit+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.loom": {
        source: "iana"
      },
      "application/vnd.lotus-1-2-3": {
        source: "iana",
        extensions: ["123"]
      },
      "application/vnd.lotus-approach": {
        source: "iana",
        extensions: ["apr"]
      },
      "application/vnd.lotus-freelance": {
        source: "iana",
        extensions: ["pre"]
      },
      "application/vnd.lotus-notes": {
        source: "iana",
        extensions: ["nsf"]
      },
      "application/vnd.lotus-organizer": {
        source: "iana",
        extensions: ["org"]
      },
      "application/vnd.lotus-screencam": {
        source: "iana",
        extensions: ["scm"]
      },
      "application/vnd.lotus-wordpro": {
        source: "iana",
        extensions: ["lwp"]
      },
      "application/vnd.macports.portpkg": {
        source: "iana",
        extensions: ["portpkg"]
      },
      "application/vnd.mapbox-vector-tile": {
        source: "iana",
        extensions: ["mvt"]
      },
      "application/vnd.marlin.drm.actiontoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.conftoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.license+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.mdcf": {
        source: "iana"
      },
      "application/vnd.mason+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.maxar.archive.3tz+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.maxmind.maxmind-db": {
        source: "iana"
      },
      "application/vnd.mcd": {
        source: "iana",
        extensions: ["mcd"]
      },
      "application/vnd.medcalcdata": {
        source: "iana",
        extensions: ["mc1"]
      },
      "application/vnd.mediastation.cdkey": {
        source: "iana",
        extensions: ["cdkey"]
      },
      "application/vnd.meridian-slingshot": {
        source: "iana"
      },
      "application/vnd.mfer": {
        source: "iana",
        extensions: ["mwf"]
      },
      "application/vnd.mfmp": {
        source: "iana",
        extensions: ["mfm"]
      },
      "application/vnd.micro+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.micrografx.flo": {
        source: "iana",
        extensions: ["flo"]
      },
      "application/vnd.micrografx.igx": {
        source: "iana",
        extensions: ["igx"]
      },
      "application/vnd.microsoft.portable-executable": {
        source: "iana"
      },
      "application/vnd.microsoft.windows.thumbnail-cache": {
        source: "iana"
      },
      "application/vnd.miele+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.mif": {
        source: "iana",
        extensions: ["mif"]
      },
      "application/vnd.minisoft-hp3000-save": {
        source: "iana"
      },
      "application/vnd.mitsubishi.misty-guard.trustweb": {
        source: "iana"
      },
      "application/vnd.mobius.daf": {
        source: "iana",
        extensions: ["daf"]
      },
      "application/vnd.mobius.dis": {
        source: "iana",
        extensions: ["dis"]
      },
      "application/vnd.mobius.mbk": {
        source: "iana",
        extensions: ["mbk"]
      },
      "application/vnd.mobius.mqy": {
        source: "iana",
        extensions: ["mqy"]
      },
      "application/vnd.mobius.msl": {
        source: "iana",
        extensions: ["msl"]
      },
      "application/vnd.mobius.plc": {
        source: "iana",
        extensions: ["plc"]
      },
      "application/vnd.mobius.txf": {
        source: "iana",
        extensions: ["txf"]
      },
      "application/vnd.mophun.application": {
        source: "iana",
        extensions: ["mpn"]
      },
      "application/vnd.mophun.certificate": {
        source: "iana",
        extensions: ["mpc"]
      },
      "application/vnd.motorola.flexsuite": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.adsi": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.fis": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.gotap": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.kmr": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.ttc": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.wem": {
        source: "iana"
      },
      "application/vnd.motorola.iprm": {
        source: "iana"
      },
      "application/vnd.mozilla.xul+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xul"]
      },
      "application/vnd.ms-3mfdocument": {
        source: "iana"
      },
      "application/vnd.ms-artgalry": {
        source: "iana",
        extensions: ["cil"]
      },
      "application/vnd.ms-asf": {
        source: "iana"
      },
      "application/vnd.ms-cab-compressed": {
        source: "iana",
        extensions: ["cab"]
      },
      "application/vnd.ms-color.iccprofile": {
        source: "apache"
      },
      "application/vnd.ms-excel": {
        source: "iana",
        compressible: false,
        extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
      },
      "application/vnd.ms-excel.addin.macroenabled.12": {
        source: "iana",
        extensions: ["xlam"]
      },
      "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
        source: "iana",
        extensions: ["xlsb"]
      },
      "application/vnd.ms-excel.sheet.macroenabled.12": {
        source: "iana",
        extensions: ["xlsm"]
      },
      "application/vnd.ms-excel.template.macroenabled.12": {
        source: "iana",
        extensions: ["xltm"]
      },
      "application/vnd.ms-fontobject": {
        source: "iana",
        compressible: true,
        extensions: ["eot"]
      },
      "application/vnd.ms-htmlhelp": {
        source: "iana",
        extensions: ["chm"]
      },
      "application/vnd.ms-ims": {
        source: "iana",
        extensions: ["ims"]
      },
      "application/vnd.ms-lrm": {
        source: "iana",
        extensions: ["lrm"]
      },
      "application/vnd.ms-office.activex+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-officetheme": {
        source: "iana",
        extensions: ["thmx"]
      },
      "application/vnd.ms-opentype": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-outlook": {
        compressible: false,
        extensions: ["msg"]
      },
      "application/vnd.ms-package.obfuscated-opentype": {
        source: "apache"
      },
      "application/vnd.ms-pki.seccat": {
        source: "apache",
        extensions: ["cat"]
      },
      "application/vnd.ms-pki.stl": {
        source: "apache",
        extensions: ["stl"]
      },
      "application/vnd.ms-playready.initiator+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-powerpoint": {
        source: "iana",
        compressible: false,
        extensions: ["ppt", "pps", "pot"]
      },
      "application/vnd.ms-powerpoint.addin.macroenabled.12": {
        source: "iana",
        extensions: ["ppam"]
      },
      "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
        source: "iana",
        extensions: ["pptm"]
      },
      "application/vnd.ms-powerpoint.slide.macroenabled.12": {
        source: "iana",
        extensions: ["sldm"]
      },
      "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
        source: "iana",
        extensions: ["ppsm"]
      },
      "application/vnd.ms-powerpoint.template.macroenabled.12": {
        source: "iana",
        extensions: ["potm"]
      },
      "application/vnd.ms-printdevicecapabilities+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-printing.printticket+xml": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-printschematicket+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-project": {
        source: "iana",
        extensions: ["mpp", "mpt"]
      },
      "application/vnd.ms-tnef": {
        source: "iana"
      },
      "application/vnd.ms-windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.nwprinting.oob": {
        source: "iana"
      },
      "application/vnd.ms-windows.printerpairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.wsd.oob": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-resp": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-resp": {
        source: "iana"
      },
      "application/vnd.ms-word.document.macroenabled.12": {
        source: "iana",
        extensions: ["docm"]
      },
      "application/vnd.ms-word.template.macroenabled.12": {
        source: "iana",
        extensions: ["dotm"]
      },
      "application/vnd.ms-works": {
        source: "iana",
        extensions: ["wps", "wks", "wcm", "wdb"]
      },
      "application/vnd.ms-wpl": {
        source: "iana",
        extensions: ["wpl"]
      },
      "application/vnd.ms-xpsdocument": {
        source: "iana",
        compressible: false,
        extensions: ["xps"]
      },
      "application/vnd.msa-disk-image": {
        source: "iana"
      },
      "application/vnd.mseq": {
        source: "iana",
        extensions: ["mseq"]
      },
      "application/vnd.msign": {
        source: "iana"
      },
      "application/vnd.multiad.creator": {
        source: "iana"
      },
      "application/vnd.multiad.creator.cif": {
        source: "iana"
      },
      "application/vnd.music-niff": {
        source: "iana"
      },
      "application/vnd.musician": {
        source: "iana",
        extensions: ["mus"]
      },
      "application/vnd.muvee.style": {
        source: "iana",
        extensions: ["msty"]
      },
      "application/vnd.mynfc": {
        source: "iana",
        extensions: ["taglet"]
      },
      "application/vnd.nacamar.ybrid+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ncd.control": {
        source: "iana"
      },
      "application/vnd.ncd.reference": {
        source: "iana"
      },
      "application/vnd.nearst.inv+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nebumind.line": {
        source: "iana"
      },
      "application/vnd.nervana": {
        source: "iana"
      },
      "application/vnd.netfpx": {
        source: "iana"
      },
      "application/vnd.neurolanguage.nlu": {
        source: "iana",
        extensions: ["nlu"]
      },
      "application/vnd.nimn": {
        source: "iana"
      },
      "application/vnd.nintendo.nitro.rom": {
        source: "iana"
      },
      "application/vnd.nintendo.snes.rom": {
        source: "iana"
      },
      "application/vnd.nitf": {
        source: "iana",
        extensions: ["ntf", "nitf"]
      },
      "application/vnd.noblenet-directory": {
        source: "iana",
        extensions: ["nnd"]
      },
      "application/vnd.noblenet-sealer": {
        source: "iana",
        extensions: ["nns"]
      },
      "application/vnd.noblenet-web": {
        source: "iana",
        extensions: ["nnw"]
      },
      "application/vnd.nokia.catalogs": {
        source: "iana"
      },
      "application/vnd.nokia.conml+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.conml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.iptv.config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.isds-radio-presets": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.landmarkcollection+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.n-gage.ac+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ac"]
      },
      "application/vnd.nokia.n-gage.data": {
        source: "iana",
        extensions: ["ngdat"]
      },
      "application/vnd.nokia.n-gage.symbian.install": {
        source: "iana",
        extensions: ["n-gage"]
      },
      "application/vnd.nokia.ncd": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.radio-preset": {
        source: "iana",
        extensions: ["rpst"]
      },
      "application/vnd.nokia.radio-presets": {
        source: "iana",
        extensions: ["rpss"]
      },
      "application/vnd.novadigm.edm": {
        source: "iana",
        extensions: ["edm"]
      },
      "application/vnd.novadigm.edx": {
        source: "iana",
        extensions: ["edx"]
      },
      "application/vnd.novadigm.ext": {
        source: "iana",
        extensions: ["ext"]
      },
      "application/vnd.ntt-local.content-share": {
        source: "iana"
      },
      "application/vnd.ntt-local.file-transfer": {
        source: "iana"
      },
      "application/vnd.ntt-local.ogw_remote-access": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_remote": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_tcp_stream": {
        source: "iana"
      },
      "application/vnd.oasis.opendocument.chart": {
        source: "iana",
        extensions: ["odc"]
      },
      "application/vnd.oasis.opendocument.chart-template": {
        source: "iana",
        extensions: ["otc"]
      },
      "application/vnd.oasis.opendocument.database": {
        source: "iana",
        extensions: ["odb"]
      },
      "application/vnd.oasis.opendocument.formula": {
        source: "iana",
        extensions: ["odf"]
      },
      "application/vnd.oasis.opendocument.formula-template": {
        source: "iana",
        extensions: ["odft"]
      },
      "application/vnd.oasis.opendocument.graphics": {
        source: "iana",
        compressible: false,
        extensions: ["odg"]
      },
      "application/vnd.oasis.opendocument.graphics-template": {
        source: "iana",
        extensions: ["otg"]
      },
      "application/vnd.oasis.opendocument.image": {
        source: "iana",
        extensions: ["odi"]
      },
      "application/vnd.oasis.opendocument.image-template": {
        source: "iana",
        extensions: ["oti"]
      },
      "application/vnd.oasis.opendocument.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["odp"]
      },
      "application/vnd.oasis.opendocument.presentation-template": {
        source: "iana",
        extensions: ["otp"]
      },
      "application/vnd.oasis.opendocument.spreadsheet": {
        source: "iana",
        compressible: false,
        extensions: ["ods"]
      },
      "application/vnd.oasis.opendocument.spreadsheet-template": {
        source: "iana",
        extensions: ["ots"]
      },
      "application/vnd.oasis.opendocument.text": {
        source: "iana",
        compressible: false,
        extensions: ["odt"]
      },
      "application/vnd.oasis.opendocument.text-master": {
        source: "iana",
        extensions: ["odm"]
      },
      "application/vnd.oasis.opendocument.text-template": {
        source: "iana",
        extensions: ["ott"]
      },
      "application/vnd.oasis.opendocument.text-web": {
        source: "iana",
        extensions: ["oth"]
      },
      "application/vnd.obn": {
        source: "iana"
      },
      "application/vnd.ocf+cbor": {
        source: "iana"
      },
      "application/vnd.oci.image.manifest.v1+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oftn.l10n+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessdownload+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessstreaming+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.cspg-hexbinary": {
        source: "iana"
      },
      "application/vnd.oipf.dae.svg+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.dae.xhtml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.mippvcontrolmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.pae.gem": {
        source: "iana"
      },
      "application/vnd.oipf.spdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.spdlist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.ueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.userprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.olpc-sugar": {
        source: "iana",
        extensions: ["xo"]
      },
      "application/vnd.oma-scws-config": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-request": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-response": {
        source: "iana"
      },
      "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.drm-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.imd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.ltkm": {
        source: "iana"
      },
      "application/vnd.oma.bcast.notification+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.provisioningtrigger": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgboot": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgdd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sgdu": {
        source: "iana"
      },
      "application/vnd.oma.bcast.simple-symbol-container": {
        source: "iana"
      },
      "application/vnd.oma.bcast.smartcard-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sprov+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.stkm": {
        source: "iana"
      },
      "application/vnd.oma.cab-address-book+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-feature-handler+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-pcc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-subs-invite+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-user-prefs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.dcd": {
        source: "iana"
      },
      "application/vnd.oma.dcdc": {
        source: "iana"
      },
      "application/vnd.oma.dd2+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dd2"]
      },
      "application/vnd.oma.drm.risd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.group-usage-list+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+cbor": {
        source: "iana"
      },
      "application/vnd.oma.lwm2m+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+tlv": {
        source: "iana"
      },
      "application/vnd.oma.pal+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.detailed-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.final-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.groups+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.invocation-descriptor+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.optimized-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.push": {
        source: "iana"
      },
      "application/vnd.oma.scidm.messages+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.xcap-directory+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.omads-email+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-file+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-folder+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omaloc-supl-init": {
        source: "iana"
      },
      "application/vnd.onepager": {
        source: "iana"
      },
      "application/vnd.onepagertamp": {
        source: "iana"
      },
      "application/vnd.onepagertamx": {
        source: "iana"
      },
      "application/vnd.onepagertat": {
        source: "iana"
      },
      "application/vnd.onepagertatp": {
        source: "iana"
      },
      "application/vnd.onepagertatx": {
        source: "iana"
      },
      "application/vnd.openblox.game+xml": {
        source: "iana",
        compressible: true,
        extensions: ["obgx"]
      },
      "application/vnd.openblox.game-binary": {
        source: "iana"
      },
      "application/vnd.openeye.oeb": {
        source: "iana"
      },
      "application/vnd.openofficeorg.extension": {
        source: "apache",
        extensions: ["oxt"]
      },
      "application/vnd.openstreetmap.data+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osm"]
      },
      "application/vnd.opentimestamps.ots": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawing+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["pptx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide": {
        source: "iana",
        extensions: ["sldx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
        source: "iana",
        extensions: ["ppsx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template": {
        source: "iana",
        extensions: ["potx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
        source: "iana",
        compressible: false,
        extensions: ["xlsx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
        source: "iana",
        extensions: ["xltx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.theme+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.vmldrawing": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
        source: "iana",
        compressible: false,
        extensions: ["docx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
        source: "iana",
        extensions: ["dotx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.core-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.relationships+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oracle.resource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.orange.indata": {
        source: "iana"
      },
      "application/vnd.osa.netdeploy": {
        source: "iana"
      },
      "application/vnd.osgeo.mapguide.package": {
        source: "iana",
        extensions: ["mgp"]
      },
      "application/vnd.osgi.bundle": {
        source: "iana"
      },
      "application/vnd.osgi.dp": {
        source: "iana",
        extensions: ["dp"]
      },
      "application/vnd.osgi.subsystem": {
        source: "iana",
        extensions: ["esa"]
      },
      "application/vnd.otps.ct-kip+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oxli.countgraph": {
        source: "iana"
      },
      "application/vnd.pagerduty+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.palm": {
        source: "iana",
        extensions: ["pdb", "pqa", "oprc"]
      },
      "application/vnd.panoply": {
        source: "iana"
      },
      "application/vnd.paos.xml": {
        source: "iana"
      },
      "application/vnd.patentdive": {
        source: "iana"
      },
      "application/vnd.patientecommsdoc": {
        source: "iana"
      },
      "application/vnd.pawaafile": {
        source: "iana",
        extensions: ["paw"]
      },
      "application/vnd.pcos": {
        source: "iana"
      },
      "application/vnd.pg.format": {
        source: "iana",
        extensions: ["str"]
      },
      "application/vnd.pg.osasli": {
        source: "iana",
        extensions: ["ei6"]
      },
      "application/vnd.piaccess.application-licence": {
        source: "iana"
      },
      "application/vnd.picsel": {
        source: "iana",
        extensions: ["efif"]
      },
      "application/vnd.pmi.widget": {
        source: "iana",
        extensions: ["wg"]
      },
      "application/vnd.poc.group-advertisement+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.pocketlearn": {
        source: "iana",
        extensions: ["plf"]
      },
      "application/vnd.powerbuilder6": {
        source: "iana",
        extensions: ["pbd"]
      },
      "application/vnd.powerbuilder6-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder7": {
        source: "iana"
      },
      "application/vnd.powerbuilder7-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder75": {
        source: "iana"
      },
      "application/vnd.powerbuilder75-s": {
        source: "iana"
      },
      "application/vnd.preminet": {
        source: "iana"
      },
      "application/vnd.previewsystems.box": {
        source: "iana",
        extensions: ["box"]
      },
      "application/vnd.proteus.magazine": {
        source: "iana",
        extensions: ["mgz"]
      },
      "application/vnd.psfs": {
        source: "iana"
      },
      "application/vnd.publishare-delta-tree": {
        source: "iana",
        extensions: ["qps"]
      },
      "application/vnd.pvi.ptid1": {
        source: "iana",
        extensions: ["ptid"]
      },
      "application/vnd.pwg-multiplexed": {
        source: "iana"
      },
      "application/vnd.pwg-xhtml-print+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.qualcomm.brew-app-res": {
        source: "iana"
      },
      "application/vnd.quarantainenet": {
        source: "iana"
      },
      "application/vnd.quark.quarkxpress": {
        source: "iana",
        extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
      },
      "application/vnd.quobject-quoxdocument": {
        source: "iana"
      },
      "application/vnd.radisys.moml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-stream+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-base+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-detect+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-group+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-speech+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-transform+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rainstor.data": {
        source: "iana"
      },
      "application/vnd.rapid": {
        source: "iana"
      },
      "application/vnd.rar": {
        source: "iana",
        extensions: ["rar"]
      },
      "application/vnd.realvnc.bed": {
        source: "iana",
        extensions: ["bed"]
      },
      "application/vnd.recordare.musicxml": {
        source: "iana",
        extensions: ["mxl"]
      },
      "application/vnd.recordare.musicxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musicxml"]
      },
      "application/vnd.renlearn.rlprint": {
        source: "iana"
      },
      "application/vnd.resilient.logic": {
        source: "iana"
      },
      "application/vnd.restful+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rig.cryptonote": {
        source: "iana",
        extensions: ["cryptonote"]
      },
      "application/vnd.rim.cod": {
        source: "apache",
        extensions: ["cod"]
      },
      "application/vnd.rn-realmedia": {
        source: "apache",
        extensions: ["rm"]
      },
      "application/vnd.rn-realmedia-vbr": {
        source: "apache",
        extensions: ["rmvb"]
      },
      "application/vnd.route66.link66+xml": {
        source: "iana",
        compressible: true,
        extensions: ["link66"]
      },
      "application/vnd.rs-274x": {
        source: "iana"
      },
      "application/vnd.ruckus.download": {
        source: "iana"
      },
      "application/vnd.s3sms": {
        source: "iana"
      },
      "application/vnd.sailingtracker.track": {
        source: "iana",
        extensions: ["st"]
      },
      "application/vnd.sar": {
        source: "iana"
      },
      "application/vnd.sbm.cid": {
        source: "iana"
      },
      "application/vnd.sbm.mid2": {
        source: "iana"
      },
      "application/vnd.scribus": {
        source: "iana"
      },
      "application/vnd.sealed.3df": {
        source: "iana"
      },
      "application/vnd.sealed.csf": {
        source: "iana"
      },
      "application/vnd.sealed.doc": {
        source: "iana"
      },
      "application/vnd.sealed.eml": {
        source: "iana"
      },
      "application/vnd.sealed.mht": {
        source: "iana"
      },
      "application/vnd.sealed.net": {
        source: "iana"
      },
      "application/vnd.sealed.ppt": {
        source: "iana"
      },
      "application/vnd.sealed.tiff": {
        source: "iana"
      },
      "application/vnd.sealed.xls": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.html": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.pdf": {
        source: "iana"
      },
      "application/vnd.seemail": {
        source: "iana",
        extensions: ["see"]
      },
      "application/vnd.seis+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.sema": {
        source: "iana",
        extensions: ["sema"]
      },
      "application/vnd.semd": {
        source: "iana",
        extensions: ["semd"]
      },
      "application/vnd.semf": {
        source: "iana",
        extensions: ["semf"]
      },
      "application/vnd.shade-save-file": {
        source: "iana"
      },
      "application/vnd.shana.informed.formdata": {
        source: "iana",
        extensions: ["ifm"]
      },
      "application/vnd.shana.informed.formtemplate": {
        source: "iana",
        extensions: ["itp"]
      },
      "application/vnd.shana.informed.interchange": {
        source: "iana",
        extensions: ["iif"]
      },
      "application/vnd.shana.informed.package": {
        source: "iana",
        extensions: ["ipk"]
      },
      "application/vnd.shootproof+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shopkick+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shp": {
        source: "iana"
      },
      "application/vnd.shx": {
        source: "iana"
      },
      "application/vnd.sigrok.session": {
        source: "iana"
      },
      "application/vnd.simtech-mindmapper": {
        source: "iana",
        extensions: ["twd", "twds"]
      },
      "application/vnd.siren+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.smaf": {
        source: "iana",
        extensions: ["mmf"]
      },
      "application/vnd.smart.notebook": {
        source: "iana"
      },
      "application/vnd.smart.teacher": {
        source: "iana",
        extensions: ["teacher"]
      },
      "application/vnd.snesdev-page-table": {
        source: "iana"
      },
      "application/vnd.software602.filler.form+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fo"]
      },
      "application/vnd.software602.filler.form-xml-zip": {
        source: "iana"
      },
      "application/vnd.solent.sdkm+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sdkm", "sdkd"]
      },
      "application/vnd.spotfire.dxp": {
        source: "iana",
        extensions: ["dxp"]
      },
      "application/vnd.spotfire.sfs": {
        source: "iana",
        extensions: ["sfs"]
      },
      "application/vnd.sqlite3": {
        source: "iana"
      },
      "application/vnd.sss-cod": {
        source: "iana"
      },
      "application/vnd.sss-dtf": {
        source: "iana"
      },
      "application/vnd.sss-ntf": {
        source: "iana"
      },
      "application/vnd.stardivision.calc": {
        source: "apache",
        extensions: ["sdc"]
      },
      "application/vnd.stardivision.draw": {
        source: "apache",
        extensions: ["sda"]
      },
      "application/vnd.stardivision.impress": {
        source: "apache",
        extensions: ["sdd"]
      },
      "application/vnd.stardivision.math": {
        source: "apache",
        extensions: ["smf"]
      },
      "application/vnd.stardivision.writer": {
        source: "apache",
        extensions: ["sdw", "vor"]
      },
      "application/vnd.stardivision.writer-global": {
        source: "apache",
        extensions: ["sgl"]
      },
      "application/vnd.stepmania.package": {
        source: "iana",
        extensions: ["smzip"]
      },
      "application/vnd.stepmania.stepchart": {
        source: "iana",
        extensions: ["sm"]
      },
      "application/vnd.street-stream": {
        source: "iana"
      },
      "application/vnd.sun.wadl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wadl"]
      },
      "application/vnd.sun.xml.calc": {
        source: "apache",
        extensions: ["sxc"]
      },
      "application/vnd.sun.xml.calc.template": {
        source: "apache",
        extensions: ["stc"]
      },
      "application/vnd.sun.xml.draw": {
        source: "apache",
        extensions: ["sxd"]
      },
      "application/vnd.sun.xml.draw.template": {
        source: "apache",
        extensions: ["std"]
      },
      "application/vnd.sun.xml.impress": {
        source: "apache",
        extensions: ["sxi"]
      },
      "application/vnd.sun.xml.impress.template": {
        source: "apache",
        extensions: ["sti"]
      },
      "application/vnd.sun.xml.math": {
        source: "apache",
        extensions: ["sxm"]
      },
      "application/vnd.sun.xml.writer": {
        source: "apache",
        extensions: ["sxw"]
      },
      "application/vnd.sun.xml.writer.global": {
        source: "apache",
        extensions: ["sxg"]
      },
      "application/vnd.sun.xml.writer.template": {
        source: "apache",
        extensions: ["stw"]
      },
      "application/vnd.sus-calendar": {
        source: "iana",
        extensions: ["sus", "susp"]
      },
      "application/vnd.svd": {
        source: "iana",
        extensions: ["svd"]
      },
      "application/vnd.swiftview-ics": {
        source: "iana"
      },
      "application/vnd.sycle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.syft+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.symbian.install": {
        source: "apache",
        extensions: ["sis", "sisx"]
      },
      "application/vnd.syncml+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xsm"]
      },
      "application/vnd.syncml.dm+wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["bdm"]
      },
      "application/vnd.syncml.dm+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xdm"]
      },
      "application/vnd.syncml.dm.notification": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["ddf"]
      },
      "application/vnd.syncml.dmtnds+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmtnds+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.syncml.ds.notification": {
        source: "iana"
      },
      "application/vnd.tableschema+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tao.intent-module-archive": {
        source: "iana",
        extensions: ["tao"]
      },
      "application/vnd.tcpdump.pcap": {
        source: "iana",
        extensions: ["pcap", "cap", "dmp"]
      },
      "application/vnd.think-cell.ppttc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tmd.mediaflex.api+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tml": {
        source: "iana"
      },
      "application/vnd.tmobile-livetv": {
        source: "iana",
        extensions: ["tmo"]
      },
      "application/vnd.tri.onesource": {
        source: "iana"
      },
      "application/vnd.trid.tpt": {
        source: "iana",
        extensions: ["tpt"]
      },
      "application/vnd.triscape.mxs": {
        source: "iana",
        extensions: ["mxs"]
      },
      "application/vnd.trueapp": {
        source: "iana",
        extensions: ["tra"]
      },
      "application/vnd.truedoc": {
        source: "iana"
      },
      "application/vnd.ubisoft.webplayer": {
        source: "iana"
      },
      "application/vnd.ufdl": {
        source: "iana",
        extensions: ["ufd", "ufdl"]
      },
      "application/vnd.uiq.theme": {
        source: "iana",
        extensions: ["utz"]
      },
      "application/vnd.umajin": {
        source: "iana",
        extensions: ["umj"]
      },
      "application/vnd.unity": {
        source: "iana",
        extensions: ["unityweb"]
      },
      "application/vnd.uoml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uoml"]
      },
      "application/vnd.uplanet.alert": {
        source: "iana"
      },
      "application/vnd.uplanet.alert-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.channel": {
        source: "iana"
      },
      "application/vnd.uplanet.channel-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.list": {
        source: "iana"
      },
      "application/vnd.uplanet.list-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.signal": {
        source: "iana"
      },
      "application/vnd.uri-map": {
        source: "iana"
      },
      "application/vnd.valve.source.material": {
        source: "iana"
      },
      "application/vnd.vcx": {
        source: "iana",
        extensions: ["vcx"]
      },
      "application/vnd.vd-study": {
        source: "iana"
      },
      "application/vnd.vectorworks": {
        source: "iana"
      },
      "application/vnd.vel+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.verimatrix.vcas": {
        source: "iana"
      },
      "application/vnd.veritone.aion+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.veryant.thin": {
        source: "iana"
      },
      "application/vnd.ves.encrypted": {
        source: "iana"
      },
      "application/vnd.vidsoft.vidconference": {
        source: "iana"
      },
      "application/vnd.visio": {
        source: "iana",
        extensions: ["vsd", "vst", "vss", "vsw"]
      },
      "application/vnd.visionary": {
        source: "iana",
        extensions: ["vis"]
      },
      "application/vnd.vividence.scriptfile": {
        source: "iana"
      },
      "application/vnd.vsf": {
        source: "iana",
        extensions: ["vsf"]
      },
      "application/vnd.wap.sic": {
        source: "iana"
      },
      "application/vnd.wap.slc": {
        source: "iana"
      },
      "application/vnd.wap.wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["wbxml"]
      },
      "application/vnd.wap.wmlc": {
        source: "iana",
        extensions: ["wmlc"]
      },
      "application/vnd.wap.wmlscriptc": {
        source: "iana",
        extensions: ["wmlsc"]
      },
      "application/vnd.webturbo": {
        source: "iana",
        extensions: ["wtb"]
      },
      "application/vnd.wfa.dpp": {
        source: "iana"
      },
      "application/vnd.wfa.p2p": {
        source: "iana"
      },
      "application/vnd.wfa.wsc": {
        source: "iana"
      },
      "application/vnd.windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.wmc": {
        source: "iana"
      },
      "application/vnd.wmf.bootstrap": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica.package": {
        source: "iana"
      },
      "application/vnd.wolfram.player": {
        source: "iana",
        extensions: ["nbp"]
      },
      "application/vnd.wordperfect": {
        source: "iana",
        extensions: ["wpd"]
      },
      "application/vnd.wqd": {
        source: "iana",
        extensions: ["wqd"]
      },
      "application/vnd.wrq-hp3000-labelled": {
        source: "iana"
      },
      "application/vnd.wt.stf": {
        source: "iana",
        extensions: ["stf"]
      },
      "application/vnd.wv.csp+wbxml": {
        source: "iana"
      },
      "application/vnd.wv.csp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.wv.ssp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xacml+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xara": {
        source: "iana",
        extensions: ["xar"]
      },
      "application/vnd.xfdl": {
        source: "iana",
        extensions: ["xfdl"]
      },
      "application/vnd.xfdl.webform": {
        source: "iana"
      },
      "application/vnd.xmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xmpie.cpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.dpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.plan": {
        source: "iana"
      },
      "application/vnd.xmpie.ppkg": {
        source: "iana"
      },
      "application/vnd.xmpie.xlim": {
        source: "iana"
      },
      "application/vnd.yamaha.hv-dic": {
        source: "iana",
        extensions: ["hvd"]
      },
      "application/vnd.yamaha.hv-script": {
        source: "iana",
        extensions: ["hvs"]
      },
      "application/vnd.yamaha.hv-voice": {
        source: "iana",
        extensions: ["hvp"]
      },
      "application/vnd.yamaha.openscoreformat": {
        source: "iana",
        extensions: ["osf"]
      },
      "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osfpvg"]
      },
      "application/vnd.yamaha.remote-setup": {
        source: "iana"
      },
      "application/vnd.yamaha.smaf-audio": {
        source: "iana",
        extensions: ["saf"]
      },
      "application/vnd.yamaha.smaf-phrase": {
        source: "iana",
        extensions: ["spf"]
      },
      "application/vnd.yamaha.through-ngn": {
        source: "iana"
      },
      "application/vnd.yamaha.tunnel-udpencap": {
        source: "iana"
      },
      "application/vnd.yaoweme": {
        source: "iana"
      },
      "application/vnd.yellowriver-custom-menu": {
        source: "iana",
        extensions: ["cmp"]
      },
      "application/vnd.youtube.yt": {
        source: "iana"
      },
      "application/vnd.zul": {
        source: "iana",
        extensions: ["zir", "zirz"]
      },
      "application/vnd.zzazz.deck+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zaz"]
      },
      "application/voicexml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["vxml"]
      },
      "application/voucher-cms+json": {
        source: "iana",
        compressible: true
      },
      "application/vq-rtcpxr": {
        source: "iana"
      },
      "application/wasm": {
        source: "iana",
        compressible: true,
        extensions: ["wasm"]
      },
      "application/watcherinfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wif"]
      },
      "application/webpush-options+json": {
        source: "iana",
        compressible: true
      },
      "application/whoispp-query": {
        source: "iana"
      },
      "application/whoispp-response": {
        source: "iana"
      },
      "application/widget": {
        source: "iana",
        extensions: ["wgt"]
      },
      "application/winhlp": {
        source: "apache",
        extensions: ["hlp"]
      },
      "application/wita": {
        source: "iana"
      },
      "application/wordperfect5.1": {
        source: "iana"
      },
      "application/wsdl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wsdl"]
      },
      "application/wspolicy+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wspolicy"]
      },
      "application/x-7z-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["7z"]
      },
      "application/x-abiword": {
        source: "apache",
        extensions: ["abw"]
      },
      "application/x-ace-compressed": {
        source: "apache",
        extensions: ["ace"]
      },
      "application/x-amf": {
        source: "apache"
      },
      "application/x-apple-diskimage": {
        source: "apache",
        extensions: ["dmg"]
      },
      "application/x-arj": {
        compressible: false,
        extensions: ["arj"]
      },
      "application/x-authorware-bin": {
        source: "apache",
        extensions: ["aab", "x32", "u32", "vox"]
      },
      "application/x-authorware-map": {
        source: "apache",
        extensions: ["aam"]
      },
      "application/x-authorware-seg": {
        source: "apache",
        extensions: ["aas"]
      },
      "application/x-bcpio": {
        source: "apache",
        extensions: ["bcpio"]
      },
      "application/x-bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/x-bittorrent": {
        source: "apache",
        extensions: ["torrent"]
      },
      "application/x-blorb": {
        source: "apache",
        extensions: ["blb", "blorb"]
      },
      "application/x-bzip": {
        source: "apache",
        compressible: false,
        extensions: ["bz"]
      },
      "application/x-bzip2": {
        source: "apache",
        compressible: false,
        extensions: ["bz2", "boz"]
      },
      "application/x-cbr": {
        source: "apache",
        extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
      },
      "application/x-cdlink": {
        source: "apache",
        extensions: ["vcd"]
      },
      "application/x-cfs-compressed": {
        source: "apache",
        extensions: ["cfs"]
      },
      "application/x-chat": {
        source: "apache",
        extensions: ["chat"]
      },
      "application/x-chess-pgn": {
        source: "apache",
        extensions: ["pgn"]
      },
      "application/x-chrome-extension": {
        extensions: ["crx"]
      },
      "application/x-cocoa": {
        source: "nginx",
        extensions: ["cco"]
      },
      "application/x-compress": {
        source: "apache"
      },
      "application/x-conference": {
        source: "apache",
        extensions: ["nsc"]
      },
      "application/x-cpio": {
        source: "apache",
        extensions: ["cpio"]
      },
      "application/x-csh": {
        source: "apache",
        extensions: ["csh"]
      },
      "application/x-deb": {
        compressible: false
      },
      "application/x-debian-package": {
        source: "apache",
        extensions: ["deb", "udeb"]
      },
      "application/x-dgc-compressed": {
        source: "apache",
        extensions: ["dgc"]
      },
      "application/x-director": {
        source: "apache",
        extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
      },
      "application/x-doom": {
        source: "apache",
        extensions: ["wad"]
      },
      "application/x-dtbncx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ncx"]
      },
      "application/x-dtbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dtb"]
      },
      "application/x-dtbresource+xml": {
        source: "apache",
        compressible: true,
        extensions: ["res"]
      },
      "application/x-dvi": {
        source: "apache",
        compressible: false,
        extensions: ["dvi"]
      },
      "application/x-envoy": {
        source: "apache",
        extensions: ["evy"]
      },
      "application/x-eva": {
        source: "apache",
        extensions: ["eva"]
      },
      "application/x-font-bdf": {
        source: "apache",
        extensions: ["bdf"]
      },
      "application/x-font-dos": {
        source: "apache"
      },
      "application/x-font-framemaker": {
        source: "apache"
      },
      "application/x-font-ghostscript": {
        source: "apache",
        extensions: ["gsf"]
      },
      "application/x-font-libgrx": {
        source: "apache"
      },
      "application/x-font-linux-psf": {
        source: "apache",
        extensions: ["psf"]
      },
      "application/x-font-pcf": {
        source: "apache",
        extensions: ["pcf"]
      },
      "application/x-font-snf": {
        source: "apache",
        extensions: ["snf"]
      },
      "application/x-font-speedo": {
        source: "apache"
      },
      "application/x-font-sunos-news": {
        source: "apache"
      },
      "application/x-font-type1": {
        source: "apache",
        extensions: ["pfa", "pfb", "pfm", "afm"]
      },
      "application/x-font-vfont": {
        source: "apache"
      },
      "application/x-freearc": {
        source: "apache",
        extensions: ["arc"]
      },
      "application/x-futuresplash": {
        source: "apache",
        extensions: ["spl"]
      },
      "application/x-gca-compressed": {
        source: "apache",
        extensions: ["gca"]
      },
      "application/x-glulx": {
        source: "apache",
        extensions: ["ulx"]
      },
      "application/x-gnumeric": {
        source: "apache",
        extensions: ["gnumeric"]
      },
      "application/x-gramps-xml": {
        source: "apache",
        extensions: ["gramps"]
      },
      "application/x-gtar": {
        source: "apache",
        extensions: ["gtar"]
      },
      "application/x-gzip": {
        source: "apache"
      },
      "application/x-hdf": {
        source: "apache",
        extensions: ["hdf"]
      },
      "application/x-httpd-php": {
        compressible: true,
        extensions: ["php"]
      },
      "application/x-install-instructions": {
        source: "apache",
        extensions: ["install"]
      },
      "application/x-iso9660-image": {
        source: "apache",
        extensions: ["iso"]
      },
      "application/x-iwork-keynote-sffkey": {
        extensions: ["key"]
      },
      "application/x-iwork-numbers-sffnumbers": {
        extensions: ["numbers"]
      },
      "application/x-iwork-pages-sffpages": {
        extensions: ["pages"]
      },
      "application/x-java-archive-diff": {
        source: "nginx",
        extensions: ["jardiff"]
      },
      "application/x-java-jnlp-file": {
        source: "apache",
        compressible: false,
        extensions: ["jnlp"]
      },
      "application/x-javascript": {
        compressible: true
      },
      "application/x-keepass2": {
        extensions: ["kdbx"]
      },
      "application/x-latex": {
        source: "apache",
        compressible: false,
        extensions: ["latex"]
      },
      "application/x-lua-bytecode": {
        extensions: ["luac"]
      },
      "application/x-lzh-compressed": {
        source: "apache",
        extensions: ["lzh", "lha"]
      },
      "application/x-makeself": {
        source: "nginx",
        extensions: ["run"]
      },
      "application/x-mie": {
        source: "apache",
        extensions: ["mie"]
      },
      "application/x-mobipocket-ebook": {
        source: "apache",
        extensions: ["prc", "mobi"]
      },
      "application/x-mpegurl": {
        compressible: false
      },
      "application/x-ms-application": {
        source: "apache",
        extensions: ["application"]
      },
      "application/x-ms-shortcut": {
        source: "apache",
        extensions: ["lnk"]
      },
      "application/x-ms-wmd": {
        source: "apache",
        extensions: ["wmd"]
      },
      "application/x-ms-wmz": {
        source: "apache",
        extensions: ["wmz"]
      },
      "application/x-ms-xbap": {
        source: "apache",
        extensions: ["xbap"]
      },
      "application/x-msaccess": {
        source: "apache",
        extensions: ["mdb"]
      },
      "application/x-msbinder": {
        source: "apache",
        extensions: ["obd"]
      },
      "application/x-mscardfile": {
        source: "apache",
        extensions: ["crd"]
      },
      "application/x-msclip": {
        source: "apache",
        extensions: ["clp"]
      },
      "application/x-msdos-program": {
        extensions: ["exe"]
      },
      "application/x-msdownload": {
        source: "apache",
        extensions: ["exe", "dll", "com", "bat", "msi"]
      },
      "application/x-msmediaview": {
        source: "apache",
        extensions: ["mvb", "m13", "m14"]
      },
      "application/x-msmetafile": {
        source: "apache",
        extensions: ["wmf", "wmz", "emf", "emz"]
      },
      "application/x-msmoney": {
        source: "apache",
        extensions: ["mny"]
      },
      "application/x-mspublisher": {
        source: "apache",
        extensions: ["pub"]
      },
      "application/x-msschedule": {
        source: "apache",
        extensions: ["scd"]
      },
      "application/x-msterminal": {
        source: "apache",
        extensions: ["trm"]
      },
      "application/x-mswrite": {
        source: "apache",
        extensions: ["wri"]
      },
      "application/x-netcdf": {
        source: "apache",
        extensions: ["nc", "cdf"]
      },
      "application/x-ns-proxy-autoconfig": {
        compressible: true,
        extensions: ["pac"]
      },
      "application/x-nzb": {
        source: "apache",
        extensions: ["nzb"]
      },
      "application/x-perl": {
        source: "nginx",
        extensions: ["pl", "pm"]
      },
      "application/x-pilot": {
        source: "nginx",
        extensions: ["prc", "pdb"]
      },
      "application/x-pkcs12": {
        source: "apache",
        compressible: false,
        extensions: ["p12", "pfx"]
      },
      "application/x-pkcs7-certificates": {
        source: "apache",
        extensions: ["p7b", "spc"]
      },
      "application/x-pkcs7-certreqresp": {
        source: "apache",
        extensions: ["p7r"]
      },
      "application/x-pki-message": {
        source: "iana"
      },
      "application/x-rar-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["rar"]
      },
      "application/x-redhat-package-manager": {
        source: "nginx",
        extensions: ["rpm"]
      },
      "application/x-research-info-systems": {
        source: "apache",
        extensions: ["ris"]
      },
      "application/x-sea": {
        source: "nginx",
        extensions: ["sea"]
      },
      "application/x-sh": {
        source: "apache",
        compressible: true,
        extensions: ["sh"]
      },
      "application/x-shar": {
        source: "apache",
        extensions: ["shar"]
      },
      "application/x-shockwave-flash": {
        source: "apache",
        compressible: false,
        extensions: ["swf"]
      },
      "application/x-silverlight-app": {
        source: "apache",
        extensions: ["xap"]
      },
      "application/x-sql": {
        source: "apache",
        extensions: ["sql"]
      },
      "application/x-stuffit": {
        source: "apache",
        compressible: false,
        extensions: ["sit"]
      },
      "application/x-stuffitx": {
        source: "apache",
        extensions: ["sitx"]
      },
      "application/x-subrip": {
        source: "apache",
        extensions: ["srt"]
      },
      "application/x-sv4cpio": {
        source: "apache",
        extensions: ["sv4cpio"]
      },
      "application/x-sv4crc": {
        source: "apache",
        extensions: ["sv4crc"]
      },
      "application/x-t3vm-image": {
        source: "apache",
        extensions: ["t3"]
      },
      "application/x-tads": {
        source: "apache",
        extensions: ["gam"]
      },
      "application/x-tar": {
        source: "apache",
        compressible: true,
        extensions: ["tar"]
      },
      "application/x-tcl": {
        source: "apache",
        extensions: ["tcl", "tk"]
      },
      "application/x-tex": {
        source: "apache",
        extensions: ["tex"]
      },
      "application/x-tex-tfm": {
        source: "apache",
        extensions: ["tfm"]
      },
      "application/x-texinfo": {
        source: "apache",
        extensions: ["texinfo", "texi"]
      },
      "application/x-tgif": {
        source: "apache",
        extensions: ["obj"]
      },
      "application/x-ustar": {
        source: "apache",
        extensions: ["ustar"]
      },
      "application/x-virtualbox-hdd": {
        compressible: true,
        extensions: ["hdd"]
      },
      "application/x-virtualbox-ova": {
        compressible: true,
        extensions: ["ova"]
      },
      "application/x-virtualbox-ovf": {
        compressible: true,
        extensions: ["ovf"]
      },
      "application/x-virtualbox-vbox": {
        compressible: true,
        extensions: ["vbox"]
      },
      "application/x-virtualbox-vbox-extpack": {
        compressible: false,
        extensions: ["vbox-extpack"]
      },
      "application/x-virtualbox-vdi": {
        compressible: true,
        extensions: ["vdi"]
      },
      "application/x-virtualbox-vhd": {
        compressible: true,
        extensions: ["vhd"]
      },
      "application/x-virtualbox-vmdk": {
        compressible: true,
        extensions: ["vmdk"]
      },
      "application/x-wais-source": {
        source: "apache",
        extensions: ["src"]
      },
      "application/x-web-app-manifest+json": {
        compressible: true,
        extensions: ["webapp"]
      },
      "application/x-www-form-urlencoded": {
        source: "iana",
        compressible: true
      },
      "application/x-x509-ca-cert": {
        source: "iana",
        extensions: ["der", "crt", "pem"]
      },
      "application/x-x509-ca-ra-cert": {
        source: "iana"
      },
      "application/x-x509-next-ca-cert": {
        source: "iana"
      },
      "application/x-xfig": {
        source: "apache",
        extensions: ["fig"]
      },
      "application/x-xliff+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/x-xpinstall": {
        source: "apache",
        compressible: false,
        extensions: ["xpi"]
      },
      "application/x-xz": {
        source: "apache",
        extensions: ["xz"]
      },
      "application/x-zmachine": {
        source: "apache",
        extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
      },
      "application/x400-bp": {
        source: "iana"
      },
      "application/xacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/xaml+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xaml"]
      },
      "application/xcap-att+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xav"]
      },
      "application/xcap-caps+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xca"]
      },
      "application/xcap-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdf"]
      },
      "application/xcap-el+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xel"]
      },
      "application/xcap-error+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcap-ns+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xns"]
      },
      "application/xcon-conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcon-conference-info-diff+xml": {
        source: "iana",
        compressible: true
      },
      "application/xenc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xenc"]
      },
      "application/xhtml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xhtml", "xht"]
      },
      "application/xhtml-voice+xml": {
        source: "apache",
        compressible: true
      },
      "application/xliff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml", "xsl", "xsd", "rng"]
      },
      "application/xml-dtd": {
        source: "iana",
        compressible: true,
        extensions: ["dtd"]
      },
      "application/xml-external-parsed-entity": {
        source: "iana"
      },
      "application/xml-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/xmpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/xop+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xop"]
      },
      "application/xproc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xpl"]
      },
      "application/xslt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xsl", "xslt"]
      },
      "application/xspf+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xspf"]
      },
      "application/xv+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mxml", "xhvml", "xvml", "xvm"]
      },
      "application/yang": {
        source: "iana",
        extensions: ["yang"]
      },
      "application/yang-data+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-data+xml": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/yin+xml": {
        source: "iana",
        compressible: true,
        extensions: ["yin"]
      },
      "application/zip": {
        source: "iana",
        compressible: false,
        extensions: ["zip"]
      },
      "application/zlib": {
        source: "iana"
      },
      "application/zstd": {
        source: "iana"
      },
      "audio/1d-interleaved-parityfec": {
        source: "iana"
      },
      "audio/32kadpcm": {
        source: "iana"
      },
      "audio/3gpp": {
        source: "iana",
        compressible: false,
        extensions: ["3gpp"]
      },
      "audio/3gpp2": {
        source: "iana"
      },
      "audio/aac": {
        source: "iana"
      },
      "audio/ac3": {
        source: "iana"
      },
      "audio/adpcm": {
        source: "apache",
        extensions: ["adp"]
      },
      "audio/amr": {
        source: "iana",
        extensions: ["amr"]
      },
      "audio/amr-wb": {
        source: "iana"
      },
      "audio/amr-wb+": {
        source: "iana"
      },
      "audio/aptx": {
        source: "iana"
      },
      "audio/asc": {
        source: "iana"
      },
      "audio/atrac-advanced-lossless": {
        source: "iana"
      },
      "audio/atrac-x": {
        source: "iana"
      },
      "audio/atrac3": {
        source: "iana"
      },
      "audio/basic": {
        source: "iana",
        compressible: false,
        extensions: ["au", "snd"]
      },
      "audio/bv16": {
        source: "iana"
      },
      "audio/bv32": {
        source: "iana"
      },
      "audio/clearmode": {
        source: "iana"
      },
      "audio/cn": {
        source: "iana"
      },
      "audio/dat12": {
        source: "iana"
      },
      "audio/dls": {
        source: "iana"
      },
      "audio/dsr-es201108": {
        source: "iana"
      },
      "audio/dsr-es202050": {
        source: "iana"
      },
      "audio/dsr-es202211": {
        source: "iana"
      },
      "audio/dsr-es202212": {
        source: "iana"
      },
      "audio/dv": {
        source: "iana"
      },
      "audio/dvi4": {
        source: "iana"
      },
      "audio/eac3": {
        source: "iana"
      },
      "audio/encaprtp": {
        source: "iana"
      },
      "audio/evrc": {
        source: "iana"
      },
      "audio/evrc-qcp": {
        source: "iana"
      },
      "audio/evrc0": {
        source: "iana"
      },
      "audio/evrc1": {
        source: "iana"
      },
      "audio/evrcb": {
        source: "iana"
      },
      "audio/evrcb0": {
        source: "iana"
      },
      "audio/evrcb1": {
        source: "iana"
      },
      "audio/evrcnw": {
        source: "iana"
      },
      "audio/evrcnw0": {
        source: "iana"
      },
      "audio/evrcnw1": {
        source: "iana"
      },
      "audio/evrcwb": {
        source: "iana"
      },
      "audio/evrcwb0": {
        source: "iana"
      },
      "audio/evrcwb1": {
        source: "iana"
      },
      "audio/evs": {
        source: "iana"
      },
      "audio/flexfec": {
        source: "iana"
      },
      "audio/fwdred": {
        source: "iana"
      },
      "audio/g711-0": {
        source: "iana"
      },
      "audio/g719": {
        source: "iana"
      },
      "audio/g722": {
        source: "iana"
      },
      "audio/g7221": {
        source: "iana"
      },
      "audio/g723": {
        source: "iana"
      },
      "audio/g726-16": {
        source: "iana"
      },
      "audio/g726-24": {
        source: "iana"
      },
      "audio/g726-32": {
        source: "iana"
      },
      "audio/g726-40": {
        source: "iana"
      },
      "audio/g728": {
        source: "iana"
      },
      "audio/g729": {
        source: "iana"
      },
      "audio/g7291": {
        source: "iana"
      },
      "audio/g729d": {
        source: "iana"
      },
      "audio/g729e": {
        source: "iana"
      },
      "audio/gsm": {
        source: "iana"
      },
      "audio/gsm-efr": {
        source: "iana"
      },
      "audio/gsm-hr-08": {
        source: "iana"
      },
      "audio/ilbc": {
        source: "iana"
      },
      "audio/ip-mr_v2.5": {
        source: "iana"
      },
      "audio/isac": {
        source: "apache"
      },
      "audio/l16": {
        source: "iana"
      },
      "audio/l20": {
        source: "iana"
      },
      "audio/l24": {
        source: "iana",
        compressible: false
      },
      "audio/l8": {
        source: "iana"
      },
      "audio/lpc": {
        source: "iana"
      },
      "audio/melp": {
        source: "iana"
      },
      "audio/melp1200": {
        source: "iana"
      },
      "audio/melp2400": {
        source: "iana"
      },
      "audio/melp600": {
        source: "iana"
      },
      "audio/mhas": {
        source: "iana"
      },
      "audio/midi": {
        source: "apache",
        extensions: ["mid", "midi", "kar", "rmi"]
      },
      "audio/mobile-xmf": {
        source: "iana",
        extensions: ["mxmf"]
      },
      "audio/mp3": {
        compressible: false,
        extensions: ["mp3"]
      },
      "audio/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["m4a", "mp4a"]
      },
      "audio/mp4a-latm": {
        source: "iana"
      },
      "audio/mpa": {
        source: "iana"
      },
      "audio/mpa-robust": {
        source: "iana"
      },
      "audio/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
      },
      "audio/mpeg4-generic": {
        source: "iana"
      },
      "audio/musepack": {
        source: "apache"
      },
      "audio/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["oga", "ogg", "spx", "opus"]
      },
      "audio/opus": {
        source: "iana"
      },
      "audio/parityfec": {
        source: "iana"
      },
      "audio/pcma": {
        source: "iana"
      },
      "audio/pcma-wb": {
        source: "iana"
      },
      "audio/pcmu": {
        source: "iana"
      },
      "audio/pcmu-wb": {
        source: "iana"
      },
      "audio/prs.sid": {
        source: "iana"
      },
      "audio/qcelp": {
        source: "iana"
      },
      "audio/raptorfec": {
        source: "iana"
      },
      "audio/red": {
        source: "iana"
      },
      "audio/rtp-enc-aescm128": {
        source: "iana"
      },
      "audio/rtp-midi": {
        source: "iana"
      },
      "audio/rtploopback": {
        source: "iana"
      },
      "audio/rtx": {
        source: "iana"
      },
      "audio/s3m": {
        source: "apache",
        extensions: ["s3m"]
      },
      "audio/scip": {
        source: "iana"
      },
      "audio/silk": {
        source: "apache",
        extensions: ["sil"]
      },
      "audio/smv": {
        source: "iana"
      },
      "audio/smv-qcp": {
        source: "iana"
      },
      "audio/smv0": {
        source: "iana"
      },
      "audio/sofa": {
        source: "iana"
      },
      "audio/sp-midi": {
        source: "iana"
      },
      "audio/speex": {
        source: "iana"
      },
      "audio/t140c": {
        source: "iana"
      },
      "audio/t38": {
        source: "iana"
      },
      "audio/telephone-event": {
        source: "iana"
      },
      "audio/tetra_acelp": {
        source: "iana"
      },
      "audio/tetra_acelp_bb": {
        source: "iana"
      },
      "audio/tone": {
        source: "iana"
      },
      "audio/tsvcis": {
        source: "iana"
      },
      "audio/uemclip": {
        source: "iana"
      },
      "audio/ulpfec": {
        source: "iana"
      },
      "audio/usac": {
        source: "iana"
      },
      "audio/vdvi": {
        source: "iana"
      },
      "audio/vmr-wb": {
        source: "iana"
      },
      "audio/vnd.3gpp.iufp": {
        source: "iana"
      },
      "audio/vnd.4sb": {
        source: "iana"
      },
      "audio/vnd.audiokoz": {
        source: "iana"
      },
      "audio/vnd.celp": {
        source: "iana"
      },
      "audio/vnd.cisco.nse": {
        source: "iana"
      },
      "audio/vnd.cmles.radio-events": {
        source: "iana"
      },
      "audio/vnd.cns.anp1": {
        source: "iana"
      },
      "audio/vnd.cns.inf1": {
        source: "iana"
      },
      "audio/vnd.dece.audio": {
        source: "iana",
        extensions: ["uva", "uvva"]
      },
      "audio/vnd.digital-winds": {
        source: "iana",
        extensions: ["eol"]
      },
      "audio/vnd.dlna.adts": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.1": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.2": {
        source: "iana"
      },
      "audio/vnd.dolby.mlp": {
        source: "iana"
      },
      "audio/vnd.dolby.mps": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2x": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2z": {
        source: "iana"
      },
      "audio/vnd.dolby.pulse.1": {
        source: "iana"
      },
      "audio/vnd.dra": {
        source: "iana",
        extensions: ["dra"]
      },
      "audio/vnd.dts": {
        source: "iana",
        extensions: ["dts"]
      },
      "audio/vnd.dts.hd": {
        source: "iana",
        extensions: ["dtshd"]
      },
      "audio/vnd.dts.uhd": {
        source: "iana"
      },
      "audio/vnd.dvb.file": {
        source: "iana"
      },
      "audio/vnd.everad.plj": {
        source: "iana"
      },
      "audio/vnd.hns.audio": {
        source: "iana"
      },
      "audio/vnd.lucent.voice": {
        source: "iana",
        extensions: ["lvp"]
      },
      "audio/vnd.ms-playready.media.pya": {
        source: "iana",
        extensions: ["pya"]
      },
      "audio/vnd.nokia.mobile-xmf": {
        source: "iana"
      },
      "audio/vnd.nortel.vbk": {
        source: "iana"
      },
      "audio/vnd.nuera.ecelp4800": {
        source: "iana",
        extensions: ["ecelp4800"]
      },
      "audio/vnd.nuera.ecelp7470": {
        source: "iana",
        extensions: ["ecelp7470"]
      },
      "audio/vnd.nuera.ecelp9600": {
        source: "iana",
        extensions: ["ecelp9600"]
      },
      "audio/vnd.octel.sbc": {
        source: "iana"
      },
      "audio/vnd.presonus.multitrack": {
        source: "iana"
      },
      "audio/vnd.qcelp": {
        source: "iana"
      },
      "audio/vnd.rhetorex.32kadpcm": {
        source: "iana"
      },
      "audio/vnd.rip": {
        source: "iana",
        extensions: ["rip"]
      },
      "audio/vnd.rn-realaudio": {
        compressible: false
      },
      "audio/vnd.sealedmedia.softseal.mpeg": {
        source: "iana"
      },
      "audio/vnd.vmx.cvsd": {
        source: "iana"
      },
      "audio/vnd.wave": {
        compressible: false
      },
      "audio/vorbis": {
        source: "iana",
        compressible: false
      },
      "audio/vorbis-config": {
        source: "iana"
      },
      "audio/wav": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/wave": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/webm": {
        source: "apache",
        compressible: false,
        extensions: ["weba"]
      },
      "audio/x-aac": {
        source: "apache",
        compressible: false,
        extensions: ["aac"]
      },
      "audio/x-aiff": {
        source: "apache",
        extensions: ["aif", "aiff", "aifc"]
      },
      "audio/x-caf": {
        source: "apache",
        compressible: false,
        extensions: ["caf"]
      },
      "audio/x-flac": {
        source: "apache",
        extensions: ["flac"]
      },
      "audio/x-m4a": {
        source: "nginx",
        extensions: ["m4a"]
      },
      "audio/x-matroska": {
        source: "apache",
        extensions: ["mka"]
      },
      "audio/x-mpegurl": {
        source: "apache",
        extensions: ["m3u"]
      },
      "audio/x-ms-wax": {
        source: "apache",
        extensions: ["wax"]
      },
      "audio/x-ms-wma": {
        source: "apache",
        extensions: ["wma"]
      },
      "audio/x-pn-realaudio": {
        source: "apache",
        extensions: ["ram", "ra"]
      },
      "audio/x-pn-realaudio-plugin": {
        source: "apache",
        extensions: ["rmp"]
      },
      "audio/x-realaudio": {
        source: "nginx",
        extensions: ["ra"]
      },
      "audio/x-tta": {
        source: "apache"
      },
      "audio/x-wav": {
        source: "apache",
        extensions: ["wav"]
      },
      "audio/xm": {
        source: "apache",
        extensions: ["xm"]
      },
      "chemical/x-cdx": {
        source: "apache",
        extensions: ["cdx"]
      },
      "chemical/x-cif": {
        source: "apache",
        extensions: ["cif"]
      },
      "chemical/x-cmdf": {
        source: "apache",
        extensions: ["cmdf"]
      },
      "chemical/x-cml": {
        source: "apache",
        extensions: ["cml"]
      },
      "chemical/x-csml": {
        source: "apache",
        extensions: ["csml"]
      },
      "chemical/x-pdb": {
        source: "apache"
      },
      "chemical/x-xyz": {
        source: "apache",
        extensions: ["xyz"]
      },
      "font/collection": {
        source: "iana",
        extensions: ["ttc"]
      },
      "font/otf": {
        source: "iana",
        compressible: true,
        extensions: ["otf"]
      },
      "font/sfnt": {
        source: "iana"
      },
      "font/ttf": {
        source: "iana",
        compressible: true,
        extensions: ["ttf"]
      },
      "font/woff": {
        source: "iana",
        extensions: ["woff"]
      },
      "font/woff2": {
        source: "iana",
        extensions: ["woff2"]
      },
      "image/aces": {
        source: "iana",
        extensions: ["exr"]
      },
      "image/apng": {
        compressible: false,
        extensions: ["apng"]
      },
      "image/avci": {
        source: "iana",
        extensions: ["avci"]
      },
      "image/avcs": {
        source: "iana",
        extensions: ["avcs"]
      },
      "image/avif": {
        source: "iana",
        compressible: false,
        extensions: ["avif"]
      },
      "image/bmp": {
        source: "iana",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/cgm": {
        source: "iana",
        extensions: ["cgm"]
      },
      "image/dicom-rle": {
        source: "iana",
        extensions: ["drle"]
      },
      "image/emf": {
        source: "iana",
        extensions: ["emf"]
      },
      "image/fits": {
        source: "iana",
        extensions: ["fits"]
      },
      "image/g3fax": {
        source: "iana",
        extensions: ["g3"]
      },
      "image/gif": {
        source: "iana",
        compressible: false,
        extensions: ["gif"]
      },
      "image/heic": {
        source: "iana",
        extensions: ["heic"]
      },
      "image/heic-sequence": {
        source: "iana",
        extensions: ["heics"]
      },
      "image/heif": {
        source: "iana",
        extensions: ["heif"]
      },
      "image/heif-sequence": {
        source: "iana",
        extensions: ["heifs"]
      },
      "image/hej2k": {
        source: "iana",
        extensions: ["hej2"]
      },
      "image/hsj2": {
        source: "iana",
        extensions: ["hsj2"]
      },
      "image/ief": {
        source: "iana",
        extensions: ["ief"]
      },
      "image/jls": {
        source: "iana",
        extensions: ["jls"]
      },
      "image/jp2": {
        source: "iana",
        compressible: false,
        extensions: ["jp2", "jpg2"]
      },
      "image/jpeg": {
        source: "iana",
        compressible: false,
        extensions: ["jpeg", "jpg", "jpe"]
      },
      "image/jph": {
        source: "iana",
        extensions: ["jph"]
      },
      "image/jphc": {
        source: "iana",
        extensions: ["jhc"]
      },
      "image/jpm": {
        source: "iana",
        compressible: false,
        extensions: ["jpm"]
      },
      "image/jpx": {
        source: "iana",
        compressible: false,
        extensions: ["jpx", "jpf"]
      },
      "image/jxr": {
        source: "iana",
        extensions: ["jxr"]
      },
      "image/jxra": {
        source: "iana",
        extensions: ["jxra"]
      },
      "image/jxrs": {
        source: "iana",
        extensions: ["jxrs"]
      },
      "image/jxs": {
        source: "iana",
        extensions: ["jxs"]
      },
      "image/jxsc": {
        source: "iana",
        extensions: ["jxsc"]
      },
      "image/jxsi": {
        source: "iana",
        extensions: ["jxsi"]
      },
      "image/jxss": {
        source: "iana",
        extensions: ["jxss"]
      },
      "image/ktx": {
        source: "iana",
        extensions: ["ktx"]
      },
      "image/ktx2": {
        source: "iana",
        extensions: ["ktx2"]
      },
      "image/naplps": {
        source: "iana"
      },
      "image/pjpeg": {
        compressible: false
      },
      "image/png": {
        source: "iana",
        compressible: false,
        extensions: ["png"]
      },
      "image/prs.btif": {
        source: "iana",
        extensions: ["btif"]
      },
      "image/prs.pti": {
        source: "iana",
        extensions: ["pti"]
      },
      "image/pwg-raster": {
        source: "iana"
      },
      "image/sgi": {
        source: "apache",
        extensions: ["sgi"]
      },
      "image/svg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["svg", "svgz"]
      },
      "image/t38": {
        source: "iana",
        extensions: ["t38"]
      },
      "image/tiff": {
        source: "iana",
        compressible: false,
        extensions: ["tif", "tiff"]
      },
      "image/tiff-fx": {
        source: "iana",
        extensions: ["tfx"]
      },
      "image/vnd.adobe.photoshop": {
        source: "iana",
        compressible: true,
        extensions: ["psd"]
      },
      "image/vnd.airzip.accelerator.azv": {
        source: "iana",
        extensions: ["azv"]
      },
      "image/vnd.cns.inf2": {
        source: "iana"
      },
      "image/vnd.dece.graphic": {
        source: "iana",
        extensions: ["uvi", "uvvi", "uvg", "uvvg"]
      },
      "image/vnd.djvu": {
        source: "iana",
        extensions: ["djvu", "djv"]
      },
      "image/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "image/vnd.dwg": {
        source: "iana",
        extensions: ["dwg"]
      },
      "image/vnd.dxf": {
        source: "iana",
        extensions: ["dxf"]
      },
      "image/vnd.fastbidsheet": {
        source: "iana",
        extensions: ["fbs"]
      },
      "image/vnd.fpx": {
        source: "iana",
        extensions: ["fpx"]
      },
      "image/vnd.fst": {
        source: "iana",
        extensions: ["fst"]
      },
      "image/vnd.fujixerox.edmics-mmr": {
        source: "iana",
        extensions: ["mmr"]
      },
      "image/vnd.fujixerox.edmics-rlc": {
        source: "iana",
        extensions: ["rlc"]
      },
      "image/vnd.globalgraphics.pgb": {
        source: "iana"
      },
      "image/vnd.microsoft.icon": {
        source: "iana",
        compressible: true,
        extensions: ["ico"]
      },
      "image/vnd.mix": {
        source: "iana"
      },
      "image/vnd.mozilla.apng": {
        source: "iana"
      },
      "image/vnd.ms-dds": {
        compressible: true,
        extensions: ["dds"]
      },
      "image/vnd.ms-modi": {
        source: "iana",
        extensions: ["mdi"]
      },
      "image/vnd.ms-photo": {
        source: "apache",
        extensions: ["wdp"]
      },
      "image/vnd.net-fpx": {
        source: "iana",
        extensions: ["npx"]
      },
      "image/vnd.pco.b16": {
        source: "iana",
        extensions: ["b16"]
      },
      "image/vnd.radiance": {
        source: "iana"
      },
      "image/vnd.sealed.png": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.gif": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.jpg": {
        source: "iana"
      },
      "image/vnd.svf": {
        source: "iana"
      },
      "image/vnd.tencent.tap": {
        source: "iana",
        extensions: ["tap"]
      },
      "image/vnd.valve.source.texture": {
        source: "iana",
        extensions: ["vtf"]
      },
      "image/vnd.wap.wbmp": {
        source: "iana",
        extensions: ["wbmp"]
      },
      "image/vnd.xiff": {
        source: "iana",
        extensions: ["xif"]
      },
      "image/vnd.zbrush.pcx": {
        source: "iana",
        extensions: ["pcx"]
      },
      "image/webp": {
        source: "apache",
        extensions: ["webp"]
      },
      "image/wmf": {
        source: "iana",
        extensions: ["wmf"]
      },
      "image/x-3ds": {
        source: "apache",
        extensions: ["3ds"]
      },
      "image/x-cmu-raster": {
        source: "apache",
        extensions: ["ras"]
      },
      "image/x-cmx": {
        source: "apache",
        extensions: ["cmx"]
      },
      "image/x-freehand": {
        source: "apache",
        extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
      },
      "image/x-icon": {
        source: "apache",
        compressible: true,
        extensions: ["ico"]
      },
      "image/x-jng": {
        source: "nginx",
        extensions: ["jng"]
      },
      "image/x-mrsid-image": {
        source: "apache",
        extensions: ["sid"]
      },
      "image/x-ms-bmp": {
        source: "nginx",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/x-pcx": {
        source: "apache",
        extensions: ["pcx"]
      },
      "image/x-pict": {
        source: "apache",
        extensions: ["pic", "pct"]
      },
      "image/x-portable-anymap": {
        source: "apache",
        extensions: ["pnm"]
      },
      "image/x-portable-bitmap": {
        source: "apache",
        extensions: ["pbm"]
      },
      "image/x-portable-graymap": {
        source: "apache",
        extensions: ["pgm"]
      },
      "image/x-portable-pixmap": {
        source: "apache",
        extensions: ["ppm"]
      },
      "image/x-rgb": {
        source: "apache",
        extensions: ["rgb"]
      },
      "image/x-tga": {
        source: "apache",
        extensions: ["tga"]
      },
      "image/x-xbitmap": {
        source: "apache",
        extensions: ["xbm"]
      },
      "image/x-xcf": {
        compressible: false
      },
      "image/x-xpixmap": {
        source: "apache",
        extensions: ["xpm"]
      },
      "image/x-xwindowdump": {
        source: "apache",
        extensions: ["xwd"]
      },
      "message/cpim": {
        source: "iana"
      },
      "message/delivery-status": {
        source: "iana"
      },
      "message/disposition-notification": {
        source: "iana",
        extensions: [
          "disposition-notification"
        ]
      },
      "message/external-body": {
        source: "iana"
      },
      "message/feedback-report": {
        source: "iana"
      },
      "message/global": {
        source: "iana",
        extensions: ["u8msg"]
      },
      "message/global-delivery-status": {
        source: "iana",
        extensions: ["u8dsn"]
      },
      "message/global-disposition-notification": {
        source: "iana",
        extensions: ["u8mdn"]
      },
      "message/global-headers": {
        source: "iana",
        extensions: ["u8hdr"]
      },
      "message/http": {
        source: "iana",
        compressible: false
      },
      "message/imdn+xml": {
        source: "iana",
        compressible: true
      },
      "message/news": {
        source: "iana"
      },
      "message/partial": {
        source: "iana",
        compressible: false
      },
      "message/rfc822": {
        source: "iana",
        compressible: true,
        extensions: ["eml", "mime"]
      },
      "message/s-http": {
        source: "iana"
      },
      "message/sip": {
        source: "iana"
      },
      "message/sipfrag": {
        source: "iana"
      },
      "message/tracking-status": {
        source: "iana"
      },
      "message/vnd.si.simp": {
        source: "iana"
      },
      "message/vnd.wfa.wsc": {
        source: "iana",
        extensions: ["wsc"]
      },
      "model/3mf": {
        source: "iana",
        extensions: ["3mf"]
      },
      "model/e57": {
        source: "iana"
      },
      "model/gltf+json": {
        source: "iana",
        compressible: true,
        extensions: ["gltf"]
      },
      "model/gltf-binary": {
        source: "iana",
        compressible: true,
        extensions: ["glb"]
      },
      "model/iges": {
        source: "iana",
        compressible: false,
        extensions: ["igs", "iges"]
      },
      "model/mesh": {
        source: "iana",
        compressible: false,
        extensions: ["msh", "mesh", "silo"]
      },
      "model/mtl": {
        source: "iana",
        extensions: ["mtl"]
      },
      "model/obj": {
        source: "iana",
        extensions: ["obj"]
      },
      "model/step": {
        source: "iana"
      },
      "model/step+xml": {
        source: "iana",
        compressible: true,
        extensions: ["stpx"]
      },
      "model/step+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpz"]
      },
      "model/step-xml+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpxz"]
      },
      "model/stl": {
        source: "iana",
        extensions: ["stl"]
      },
      "model/vnd.collada+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dae"]
      },
      "model/vnd.dwf": {
        source: "iana",
        extensions: ["dwf"]
      },
      "model/vnd.flatland.3dml": {
        source: "iana"
      },
      "model/vnd.gdl": {
        source: "iana",
        extensions: ["gdl"]
      },
      "model/vnd.gs-gdl": {
        source: "apache"
      },
      "model/vnd.gs.gdl": {
        source: "iana"
      },
      "model/vnd.gtw": {
        source: "iana",
        extensions: ["gtw"]
      },
      "model/vnd.moml+xml": {
        source: "iana",
        compressible: true
      },
      "model/vnd.mts": {
        source: "iana",
        extensions: ["mts"]
      },
      "model/vnd.opengex": {
        source: "iana",
        extensions: ["ogex"]
      },
      "model/vnd.parasolid.transmit.binary": {
        source: "iana",
        extensions: ["x_b"]
      },
      "model/vnd.parasolid.transmit.text": {
        source: "iana",
        extensions: ["x_t"]
      },
      "model/vnd.pytha.pyox": {
        source: "iana"
      },
      "model/vnd.rosette.annotated-data-model": {
        source: "iana"
      },
      "model/vnd.sap.vds": {
        source: "iana",
        extensions: ["vds"]
      },
      "model/vnd.usdz+zip": {
        source: "iana",
        compressible: false,
        extensions: ["usdz"]
      },
      "model/vnd.valve.source.compiled-map": {
        source: "iana",
        extensions: ["bsp"]
      },
      "model/vnd.vtu": {
        source: "iana",
        extensions: ["vtu"]
      },
      "model/vrml": {
        source: "iana",
        compressible: false,
        extensions: ["wrl", "vrml"]
      },
      "model/x3d+binary": {
        source: "apache",
        compressible: false,
        extensions: ["x3db", "x3dbz"]
      },
      "model/x3d+fastinfoset": {
        source: "iana",
        extensions: ["x3db"]
      },
      "model/x3d+vrml": {
        source: "apache",
        compressible: false,
        extensions: ["x3dv", "x3dvz"]
      },
      "model/x3d+xml": {
        source: "iana",
        compressible: true,
        extensions: ["x3d", "x3dz"]
      },
      "model/x3d-vrml": {
        source: "iana",
        extensions: ["x3dv"]
      },
      "multipart/alternative": {
        source: "iana",
        compressible: false
      },
      "multipart/appledouble": {
        source: "iana"
      },
      "multipart/byteranges": {
        source: "iana"
      },
      "multipart/digest": {
        source: "iana"
      },
      "multipart/encrypted": {
        source: "iana",
        compressible: false
      },
      "multipart/form-data": {
        source: "iana",
        compressible: false
      },
      "multipart/header-set": {
        source: "iana"
      },
      "multipart/mixed": {
        source: "iana"
      },
      "multipart/multilingual": {
        source: "iana"
      },
      "multipart/parallel": {
        source: "iana"
      },
      "multipart/related": {
        source: "iana",
        compressible: false
      },
      "multipart/report": {
        source: "iana"
      },
      "multipart/signed": {
        source: "iana",
        compressible: false
      },
      "multipart/vnd.bint.med-plus": {
        source: "iana"
      },
      "multipart/voice-message": {
        source: "iana"
      },
      "multipart/x-mixed-replace": {
        source: "iana"
      },
      "text/1d-interleaved-parityfec": {
        source: "iana"
      },
      "text/cache-manifest": {
        source: "iana",
        compressible: true,
        extensions: ["appcache", "manifest"]
      },
      "text/calendar": {
        source: "iana",
        extensions: ["ics", "ifb"]
      },
      "text/calender": {
        compressible: true
      },
      "text/cmd": {
        compressible: true
      },
      "text/coffeescript": {
        extensions: ["coffee", "litcoffee"]
      },
      "text/cql": {
        source: "iana"
      },
      "text/cql-expression": {
        source: "iana"
      },
      "text/cql-identifier": {
        source: "iana"
      },
      "text/css": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["css"]
      },
      "text/csv": {
        source: "iana",
        compressible: true,
        extensions: ["csv"]
      },
      "text/csv-schema": {
        source: "iana"
      },
      "text/directory": {
        source: "iana"
      },
      "text/dns": {
        source: "iana"
      },
      "text/ecmascript": {
        source: "iana"
      },
      "text/encaprtp": {
        source: "iana"
      },
      "text/enriched": {
        source: "iana"
      },
      "text/fhirpath": {
        source: "iana"
      },
      "text/flexfec": {
        source: "iana"
      },
      "text/fwdred": {
        source: "iana"
      },
      "text/gff3": {
        source: "iana"
      },
      "text/grammar-ref-list": {
        source: "iana"
      },
      "text/html": {
        source: "iana",
        compressible: true,
        extensions: ["html", "htm", "shtml"]
      },
      "text/jade": {
        extensions: ["jade"]
      },
      "text/javascript": {
        source: "iana",
        compressible: true
      },
      "text/jcr-cnd": {
        source: "iana"
      },
      "text/jsx": {
        compressible: true,
        extensions: ["jsx"]
      },
      "text/less": {
        compressible: true,
        extensions: ["less"]
      },
      "text/markdown": {
        source: "iana",
        compressible: true,
        extensions: ["markdown", "md"]
      },
      "text/mathml": {
        source: "nginx",
        extensions: ["mml"]
      },
      "text/mdx": {
        compressible: true,
        extensions: ["mdx"]
      },
      "text/mizar": {
        source: "iana"
      },
      "text/n3": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["n3"]
      },
      "text/parameters": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/parityfec": {
        source: "iana"
      },
      "text/plain": {
        source: "iana",
        compressible: true,
        extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
      },
      "text/provenance-notation": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/prs.fallenstein.rst": {
        source: "iana"
      },
      "text/prs.lines.tag": {
        source: "iana",
        extensions: ["dsc"]
      },
      "text/prs.prop.logic": {
        source: "iana"
      },
      "text/raptorfec": {
        source: "iana"
      },
      "text/red": {
        source: "iana"
      },
      "text/rfc822-headers": {
        source: "iana"
      },
      "text/richtext": {
        source: "iana",
        compressible: true,
        extensions: ["rtx"]
      },
      "text/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "text/rtp-enc-aescm128": {
        source: "iana"
      },
      "text/rtploopback": {
        source: "iana"
      },
      "text/rtx": {
        source: "iana"
      },
      "text/sgml": {
        source: "iana",
        extensions: ["sgml", "sgm"]
      },
      "text/shaclc": {
        source: "iana"
      },
      "text/shex": {
        source: "iana",
        extensions: ["shex"]
      },
      "text/slim": {
        extensions: ["slim", "slm"]
      },
      "text/spdx": {
        source: "iana",
        extensions: ["spdx"]
      },
      "text/strings": {
        source: "iana"
      },
      "text/stylus": {
        extensions: ["stylus", "styl"]
      },
      "text/t140": {
        source: "iana"
      },
      "text/tab-separated-values": {
        source: "iana",
        compressible: true,
        extensions: ["tsv"]
      },
      "text/troff": {
        source: "iana",
        extensions: ["t", "tr", "roff", "man", "me", "ms"]
      },
      "text/turtle": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["ttl"]
      },
      "text/ulpfec": {
        source: "iana"
      },
      "text/uri-list": {
        source: "iana",
        compressible: true,
        extensions: ["uri", "uris", "urls"]
      },
      "text/vcard": {
        source: "iana",
        compressible: true,
        extensions: ["vcard"]
      },
      "text/vnd.a": {
        source: "iana"
      },
      "text/vnd.abc": {
        source: "iana"
      },
      "text/vnd.ascii-art": {
        source: "iana"
      },
      "text/vnd.curl": {
        source: "iana",
        extensions: ["curl"]
      },
      "text/vnd.curl.dcurl": {
        source: "apache",
        extensions: ["dcurl"]
      },
      "text/vnd.curl.mcurl": {
        source: "apache",
        extensions: ["mcurl"]
      },
      "text/vnd.curl.scurl": {
        source: "apache",
        extensions: ["scurl"]
      },
      "text/vnd.debian.copyright": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.dmclientscript": {
        source: "iana"
      },
      "text/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "text/vnd.esmertec.theme-descriptor": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.familysearch.gedcom": {
        source: "iana",
        extensions: ["ged"]
      },
      "text/vnd.ficlab.flt": {
        source: "iana"
      },
      "text/vnd.fly": {
        source: "iana",
        extensions: ["fly"]
      },
      "text/vnd.fmi.flexstor": {
        source: "iana",
        extensions: ["flx"]
      },
      "text/vnd.gml": {
        source: "iana"
      },
      "text/vnd.graphviz": {
        source: "iana",
        extensions: ["gv"]
      },
      "text/vnd.hans": {
        source: "iana"
      },
      "text/vnd.hgl": {
        source: "iana"
      },
      "text/vnd.in3d.3dml": {
        source: "iana",
        extensions: ["3dml"]
      },
      "text/vnd.in3d.spot": {
        source: "iana",
        extensions: ["spot"]
      },
      "text/vnd.iptc.newsml": {
        source: "iana"
      },
      "text/vnd.iptc.nitf": {
        source: "iana"
      },
      "text/vnd.latex-z": {
        source: "iana"
      },
      "text/vnd.motorola.reflex": {
        source: "iana"
      },
      "text/vnd.ms-mediapackage": {
        source: "iana"
      },
      "text/vnd.net2phone.commcenter.command": {
        source: "iana"
      },
      "text/vnd.radisys.msml-basic-layout": {
        source: "iana"
      },
      "text/vnd.senx.warpscript": {
        source: "iana"
      },
      "text/vnd.si.uricatalogue": {
        source: "iana"
      },
      "text/vnd.sosi": {
        source: "iana"
      },
      "text/vnd.sun.j2me.app-descriptor": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["jad"]
      },
      "text/vnd.trolltech.linguist": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.wap.si": {
        source: "iana"
      },
      "text/vnd.wap.sl": {
        source: "iana"
      },
      "text/vnd.wap.wml": {
        source: "iana",
        extensions: ["wml"]
      },
      "text/vnd.wap.wmlscript": {
        source: "iana",
        extensions: ["wmls"]
      },
      "text/vtt": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["vtt"]
      },
      "text/x-asm": {
        source: "apache",
        extensions: ["s", "asm"]
      },
      "text/x-c": {
        source: "apache",
        extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
      },
      "text/x-component": {
        source: "nginx",
        extensions: ["htc"]
      },
      "text/x-fortran": {
        source: "apache",
        extensions: ["f", "for", "f77", "f90"]
      },
      "text/x-gwt-rpc": {
        compressible: true
      },
      "text/x-handlebars-template": {
        extensions: ["hbs"]
      },
      "text/x-java-source": {
        source: "apache",
        extensions: ["java"]
      },
      "text/x-jquery-tmpl": {
        compressible: true
      },
      "text/x-lua": {
        extensions: ["lua"]
      },
      "text/x-markdown": {
        compressible: true,
        extensions: ["mkd"]
      },
      "text/x-nfo": {
        source: "apache",
        extensions: ["nfo"]
      },
      "text/x-opml": {
        source: "apache",
        extensions: ["opml"]
      },
      "text/x-org": {
        compressible: true,
        extensions: ["org"]
      },
      "text/x-pascal": {
        source: "apache",
        extensions: ["p", "pas"]
      },
      "text/x-processing": {
        compressible: true,
        extensions: ["pde"]
      },
      "text/x-sass": {
        extensions: ["sass"]
      },
      "text/x-scss": {
        extensions: ["scss"]
      },
      "text/x-setext": {
        source: "apache",
        extensions: ["etx"]
      },
      "text/x-sfv": {
        source: "apache",
        extensions: ["sfv"]
      },
      "text/x-suse-ymp": {
        compressible: true,
        extensions: ["ymp"]
      },
      "text/x-uuencode": {
        source: "apache",
        extensions: ["uu"]
      },
      "text/x-vcalendar": {
        source: "apache",
        extensions: ["vcs"]
      },
      "text/x-vcard": {
        source: "apache",
        extensions: ["vcf"]
      },
      "text/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml"]
      },
      "text/xml-external-parsed-entity": {
        source: "iana"
      },
      "text/yaml": {
        compressible: true,
        extensions: ["yaml", "yml"]
      },
      "video/1d-interleaved-parityfec": {
        source: "iana"
      },
      "video/3gpp": {
        source: "iana",
        extensions: ["3gp", "3gpp"]
      },
      "video/3gpp-tt": {
        source: "iana"
      },
      "video/3gpp2": {
        source: "iana",
        extensions: ["3g2"]
      },
      "video/av1": {
        source: "iana"
      },
      "video/bmpeg": {
        source: "iana"
      },
      "video/bt656": {
        source: "iana"
      },
      "video/celb": {
        source: "iana"
      },
      "video/dv": {
        source: "iana"
      },
      "video/encaprtp": {
        source: "iana"
      },
      "video/ffv1": {
        source: "iana"
      },
      "video/flexfec": {
        source: "iana"
      },
      "video/h261": {
        source: "iana",
        extensions: ["h261"]
      },
      "video/h263": {
        source: "iana",
        extensions: ["h263"]
      },
      "video/h263-1998": {
        source: "iana"
      },
      "video/h263-2000": {
        source: "iana"
      },
      "video/h264": {
        source: "iana",
        extensions: ["h264"]
      },
      "video/h264-rcdo": {
        source: "iana"
      },
      "video/h264-svc": {
        source: "iana"
      },
      "video/h265": {
        source: "iana"
      },
      "video/iso.segment": {
        source: "iana",
        extensions: ["m4s"]
      },
      "video/jpeg": {
        source: "iana",
        extensions: ["jpgv"]
      },
      "video/jpeg2000": {
        source: "iana"
      },
      "video/jpm": {
        source: "apache",
        extensions: ["jpm", "jpgm"]
      },
      "video/jxsv": {
        source: "iana"
      },
      "video/mj2": {
        source: "iana",
        extensions: ["mj2", "mjp2"]
      },
      "video/mp1s": {
        source: "iana"
      },
      "video/mp2p": {
        source: "iana"
      },
      "video/mp2t": {
        source: "iana",
        extensions: ["ts"]
      },
      "video/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["mp4", "mp4v", "mpg4"]
      },
      "video/mp4v-es": {
        source: "iana"
      },
      "video/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
      },
      "video/mpeg4-generic": {
        source: "iana"
      },
      "video/mpv": {
        source: "iana"
      },
      "video/nv": {
        source: "iana"
      },
      "video/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogv"]
      },
      "video/parityfec": {
        source: "iana"
      },
      "video/pointer": {
        source: "iana"
      },
      "video/quicktime": {
        source: "iana",
        compressible: false,
        extensions: ["qt", "mov"]
      },
      "video/raptorfec": {
        source: "iana"
      },
      "video/raw": {
        source: "iana"
      },
      "video/rtp-enc-aescm128": {
        source: "iana"
      },
      "video/rtploopback": {
        source: "iana"
      },
      "video/rtx": {
        source: "iana"
      },
      "video/scip": {
        source: "iana"
      },
      "video/smpte291": {
        source: "iana"
      },
      "video/smpte292m": {
        source: "iana"
      },
      "video/ulpfec": {
        source: "iana"
      },
      "video/vc1": {
        source: "iana"
      },
      "video/vc2": {
        source: "iana"
      },
      "video/vnd.cctv": {
        source: "iana"
      },
      "video/vnd.dece.hd": {
        source: "iana",
        extensions: ["uvh", "uvvh"]
      },
      "video/vnd.dece.mobile": {
        source: "iana",
        extensions: ["uvm", "uvvm"]
      },
      "video/vnd.dece.mp4": {
        source: "iana"
      },
      "video/vnd.dece.pd": {
        source: "iana",
        extensions: ["uvp", "uvvp"]
      },
      "video/vnd.dece.sd": {
        source: "iana",
        extensions: ["uvs", "uvvs"]
      },
      "video/vnd.dece.video": {
        source: "iana",
        extensions: ["uvv", "uvvv"]
      },
      "video/vnd.directv.mpeg": {
        source: "iana"
      },
      "video/vnd.directv.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dlna.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dvb.file": {
        source: "iana",
        extensions: ["dvb"]
      },
      "video/vnd.fvt": {
        source: "iana",
        extensions: ["fvt"]
      },
      "video/vnd.hns.video": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsavc": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsmpeg2": {
        source: "iana"
      },
      "video/vnd.motorola.video": {
        source: "iana"
      },
      "video/vnd.motorola.videop": {
        source: "iana"
      },
      "video/vnd.mpegurl": {
        source: "iana",
        extensions: ["mxu", "m4u"]
      },
      "video/vnd.ms-playready.media.pyv": {
        source: "iana",
        extensions: ["pyv"]
      },
      "video/vnd.nokia.interleaved-multimedia": {
        source: "iana"
      },
      "video/vnd.nokia.mp4vr": {
        source: "iana"
      },
      "video/vnd.nokia.videovoip": {
        source: "iana"
      },
      "video/vnd.objectvideo": {
        source: "iana"
      },
      "video/vnd.radgamettools.bink": {
        source: "iana"
      },
      "video/vnd.radgamettools.smacker": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg1": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg4": {
        source: "iana"
      },
      "video/vnd.sealed.swf": {
        source: "iana"
      },
      "video/vnd.sealedmedia.softseal.mov": {
        source: "iana"
      },
      "video/vnd.uvvu.mp4": {
        source: "iana",
        extensions: ["uvu", "uvvu"]
      },
      "video/vnd.vivo": {
        source: "iana",
        extensions: ["viv"]
      },
      "video/vnd.youtube.yt": {
        source: "iana"
      },
      "video/vp8": {
        source: "iana"
      },
      "video/vp9": {
        source: "iana"
      },
      "video/webm": {
        source: "apache",
        compressible: false,
        extensions: ["webm"]
      },
      "video/x-f4v": {
        source: "apache",
        extensions: ["f4v"]
      },
      "video/x-fli": {
        source: "apache",
        extensions: ["fli"]
      },
      "video/x-flv": {
        source: "apache",
        compressible: false,
        extensions: ["flv"]
      },
      "video/x-m4v": {
        source: "apache",
        extensions: ["m4v"]
      },
      "video/x-matroska": {
        source: "apache",
        compressible: false,
        extensions: ["mkv", "mk3d", "mks"]
      },
      "video/x-mng": {
        source: "apache",
        extensions: ["mng"]
      },
      "video/x-ms-asf": {
        source: "apache",
        extensions: ["asf", "asx"]
      },
      "video/x-ms-vob": {
        source: "apache",
        extensions: ["vob"]
      },
      "video/x-ms-wm": {
        source: "apache",
        extensions: ["wm"]
      },
      "video/x-ms-wmv": {
        source: "apache",
        compressible: false,
        extensions: ["wmv"]
      },
      "video/x-ms-wmx": {
        source: "apache",
        extensions: ["wmx"]
      },
      "video/x-ms-wvx": {
        source: "apache",
        extensions: ["wvx"]
      },
      "video/x-msvideo": {
        source: "apache",
        extensions: ["avi"]
      },
      "video/x-sgi-movie": {
        source: "apache",
        extensions: ["movie"]
      },
      "video/x-smv": {
        source: "apache",
        extensions: ["smv"]
      },
      "x-conference/x-cooltalk": {
        source: "apache",
        extensions: ["ice"]
      },
      "x-shader/x-fragment": {
        compressible: true
      },
      "x-shader/x-vertex": {
        compressible: true
      }
    };
  }
});

// ../../../node_modules/mime-db/index.js
var require_mime_db = __commonJS({
  "../../../node_modules/mime-db/index.js"(exports2, module2) {
    module2.exports = require_db();
  }
});

// ../../../node_modules/path/path.js
var require_path = __commonJS({
  "../../../node_modules/path/path.js"(exports2, module2) {
    "use strict";
    var isWindows = process.platform === "win32";
    var util = require_util();
    function normalizeArray(parts, allowAboveRoot) {
      var res = [];
      for (var i = 0; i < parts.length; i++) {
        var p = parts[i];
        if (!p || p === ".")
          continue;
        if (p === "..") {
          if (res.length && res[res.length - 1] !== "..") {
            res.pop();
          } else if (allowAboveRoot) {
            res.push("..");
          }
        } else {
          res.push(p);
        }
      }
      return res;
    }
    function trimArray(arr) {
      var lastIndex = arr.length - 1;
      var start = 0;
      for (; start <= lastIndex; start++) {
        if (arr[start])
          break;
      }
      var end = lastIndex;
      for (; end >= 0; end--) {
        if (arr[end])
          break;
      }
      if (start === 0 && end === lastIndex)
        return arr;
      if (start > end)
        return [];
      return arr.slice(start, end + 1);
    }
    var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
    var splitTailRe = /^([\s\S]*?)((?:\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))(?:[\\\/]*)$/;
    var win32 = {};
    function win32SplitPath(filename) {
      var result = splitDeviceRe.exec(filename), device = (result[1] || "") + (result[2] || ""), tail = result[3] || "";
      var result2 = splitTailRe.exec(tail), dir = result2[1], basename = result2[2], ext = result2[3];
      return [device, dir, basename, ext];
    }
    function win32StatPath(path) {
      var result = splitDeviceRe.exec(path), device = result[1] || "", isUnc = !!device && device[1] !== ":";
      return {
        device,
        isUnc,
        isAbsolute: isUnc || !!result[2],
        // UNC paths are always absolute
        tail: result[3]
      };
    }
    function normalizeUNCRoot(device) {
      return "\\\\" + device.replace(/^[\\\/]+/, "").replace(/[\\\/]+/g, "\\");
    }
    win32.resolve = function() {
      var resolvedDevice = "", resolvedTail = "", resolvedAbsolute = false;
      for (var i = arguments.length - 1; i >= -1; i--) {
        var path;
        if (i >= 0) {
          path = arguments[i];
        } else if (!resolvedDevice) {
          path = process.cwd();
        } else {
          path = process.env["=" + resolvedDevice];
          if (!path || path.substr(0, 3).toLowerCase() !== resolvedDevice.toLowerCase() + "\\") {
            path = resolvedDevice + "\\";
          }
        }
        if (!util.isString(path)) {
          throw new TypeError("Arguments to path.resolve must be strings");
        } else if (!path) {
          continue;
        }
        var result = win32StatPath(path), device = result.device, isUnc = result.isUnc, isAbsolute = result.isAbsolute, tail = result.tail;
        if (device && resolvedDevice && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
          continue;
        }
        if (!resolvedDevice) {
          resolvedDevice = device;
        }
        if (!resolvedAbsolute) {
          resolvedTail = tail + "\\" + resolvedTail;
          resolvedAbsolute = isAbsolute;
        }
        if (resolvedDevice && resolvedAbsolute) {
          break;
        }
      }
      if (isUnc) {
        resolvedDevice = normalizeUNCRoot(resolvedDevice);
      }
      resolvedTail = normalizeArray(
        resolvedTail.split(/[\\\/]+/),
        !resolvedAbsolute
      ).join("\\");
      return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
    };
    win32.normalize = function(path) {
      var result = win32StatPath(path), device = result.device, isUnc = result.isUnc, isAbsolute = result.isAbsolute, tail = result.tail, trailingSlash = /[\\\/]$/.test(tail);
      tail = normalizeArray(tail.split(/[\\\/]+/), !isAbsolute).join("\\");
      if (!tail && !isAbsolute) {
        tail = ".";
      }
      if (tail && trailingSlash) {
        tail += "\\";
      }
      if (isUnc) {
        device = normalizeUNCRoot(device);
      }
      return device + (isAbsolute ? "\\" : "") + tail;
    };
    win32.isAbsolute = function(path) {
      return win32StatPath(path).isAbsolute;
    };
    win32.join = function() {
      var paths = [];
      for (var i = 0; i < arguments.length; i++) {
        var arg = arguments[i];
        if (!util.isString(arg)) {
          throw new TypeError("Arguments to path.join must be strings");
        }
        if (arg) {
          paths.push(arg);
        }
      }
      var joined = paths.join("\\");
      if (!/^[\\\/]{2}[^\\\/]/.test(paths[0])) {
        joined = joined.replace(/^[\\\/]{2,}/, "\\");
      }
      return win32.normalize(joined);
    };
    win32.relative = function(from, to) {
      from = win32.resolve(from);
      to = win32.resolve(to);
      var lowerFrom = from.toLowerCase();
      var lowerTo = to.toLowerCase();
      var toParts = trimArray(to.split("\\"));
      var lowerFromParts = trimArray(lowerFrom.split("\\"));
      var lowerToParts = trimArray(lowerTo.split("\\"));
      var length = Math.min(lowerFromParts.length, lowerToParts.length);
      var samePartsLength = length;
      for (var i = 0; i < length; i++) {
        if (lowerFromParts[i] !== lowerToParts[i]) {
          samePartsLength = i;
          break;
        }
      }
      if (samePartsLength == 0) {
        return to;
      }
      var outputParts = [];
      for (var i = samePartsLength; i < lowerFromParts.length; i++) {
        outputParts.push("..");
      }
      outputParts = outputParts.concat(toParts.slice(samePartsLength));
      return outputParts.join("\\");
    };
    win32._makeLong = function(path) {
      if (!util.isString(path))
        return path;
      if (!path) {
        return "";
      }
      var resolvedPath = win32.resolve(path);
      if (/^[a-zA-Z]\:\\/.test(resolvedPath)) {
        return "\\\\?\\" + resolvedPath;
      } else if (/^\\\\[^?.]/.test(resolvedPath)) {
        return "\\\\?\\UNC\\" + resolvedPath.substring(2);
      }
      return path;
    };
    win32.dirname = function(path) {
      var result = win32SplitPath(path), root = result[0], dir = result[1];
      if (!root && !dir) {
        return ".";
      }
      if (dir) {
        dir = dir.substr(0, dir.length - 1);
      }
      return root + dir;
    };
    win32.basename = function(path, ext) {
      var f = win32SplitPath(path)[2];
      if (ext && f.substr(-1 * ext.length) === ext) {
        f = f.substr(0, f.length - ext.length);
      }
      return f;
    };
    win32.extname = function(path) {
      return win32SplitPath(path)[3];
    };
    win32.format = function(pathObject) {
      if (!util.isObject(pathObject)) {
        throw new TypeError(
          "Parameter 'pathObject' must be an object, not " + typeof pathObject
        );
      }
      var root = pathObject.root || "";
      if (!util.isString(root)) {
        throw new TypeError(
          "'pathObject.root' must be a string or undefined, not " + typeof pathObject.root
        );
      }
      var dir = pathObject.dir;
      var base = pathObject.base || "";
      if (!dir) {
        return base;
      }
      if (dir[dir.length - 1] === win32.sep) {
        return dir + base;
      }
      return dir + win32.sep + base;
    };
    win32.parse = function(pathString) {
      if (!util.isString(pathString)) {
        throw new TypeError(
          "Parameter 'pathString' must be a string, not " + typeof pathString
        );
      }
      var allParts = win32SplitPath(pathString);
      if (!allParts || allParts.length !== 4) {
        throw new TypeError("Invalid path '" + pathString + "'");
      }
      return {
        root: allParts[0],
        dir: allParts[0] + allParts[1].slice(0, -1),
        base: allParts[2],
        ext: allParts[3],
        name: allParts[2].slice(0, allParts[2].length - allParts[3].length)
      };
    };
    win32.sep = "\\";
    win32.delimiter = ";";
    var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
    var posix = {};
    function posixSplitPath(filename) {
      return splitPathRe.exec(filename).slice(1);
    }
    posix.resolve = function() {
      var resolvedPath = "", resolvedAbsolute = false;
      for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path = i >= 0 ? arguments[i] : process.cwd();
        if (!util.isString(path)) {
          throw new TypeError("Arguments to path.resolve must be strings");
        } else if (!path) {
          continue;
        }
        resolvedPath = path + "/" + resolvedPath;
        resolvedAbsolute = path[0] === "/";
      }
      resolvedPath = normalizeArray(
        resolvedPath.split("/"),
        !resolvedAbsolute
      ).join("/");
      return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
    };
    posix.normalize = function(path) {
      var isAbsolute = posix.isAbsolute(path), trailingSlash = path && path[path.length - 1] === "/";
      path = normalizeArray(path.split("/"), !isAbsolute).join("/");
      if (!path && !isAbsolute) {
        path = ".";
      }
      if (path && trailingSlash) {
        path += "/";
      }
      return (isAbsolute ? "/" : "") + path;
    };
    posix.isAbsolute = function(path) {
      return path.charAt(0) === "/";
    };
    posix.join = function() {
      var path = "";
      for (var i = 0; i < arguments.length; i++) {
        var segment = arguments[i];
        if (!util.isString(segment)) {
          throw new TypeError("Arguments to path.join must be strings");
        }
        if (segment) {
          if (!path) {
            path += segment;
          } else {
            path += "/" + segment;
          }
        }
      }
      return posix.normalize(path);
    };
    posix.relative = function(from, to) {
      from = posix.resolve(from).substr(1);
      to = posix.resolve(to).substr(1);
      var fromParts = trimArray(from.split("/"));
      var toParts = trimArray(to.split("/"));
      var length = Math.min(fromParts.length, toParts.length);
      var samePartsLength = length;
      for (var i = 0; i < length; i++) {
        if (fromParts[i] !== toParts[i]) {
          samePartsLength = i;
          break;
        }
      }
      var outputParts = [];
      for (var i = samePartsLength; i < fromParts.length; i++) {
        outputParts.push("..");
      }
      outputParts = outputParts.concat(toParts.slice(samePartsLength));
      return outputParts.join("/");
    };
    posix._makeLong = function(path) {
      return path;
    };
    posix.dirname = function(path) {
      var result = posixSplitPath(path), root = result[0], dir = result[1];
      if (!root && !dir) {
        return ".";
      }
      if (dir) {
        dir = dir.substr(0, dir.length - 1);
      }
      return root + dir;
    };
    posix.basename = function(path, ext) {
      var f = posixSplitPath(path)[2];
      if (ext && f.substr(-1 * ext.length) === ext) {
        f = f.substr(0, f.length - ext.length);
      }
      return f;
    };
    posix.extname = function(path) {
      return posixSplitPath(path)[3];
    };
    posix.format = function(pathObject) {
      if (!util.isObject(pathObject)) {
        throw new TypeError(
          "Parameter 'pathObject' must be an object, not " + typeof pathObject
        );
      }
      var root = pathObject.root || "";
      if (!util.isString(root)) {
        throw new TypeError(
          "'pathObject.root' must be a string or undefined, not " + typeof pathObject.root
        );
      }
      var dir = pathObject.dir ? pathObject.dir + posix.sep : "";
      var base = pathObject.base || "";
      return dir + base;
    };
    posix.parse = function(pathString) {
      if (!util.isString(pathString)) {
        throw new TypeError(
          "Parameter 'pathString' must be a string, not " + typeof pathString
        );
      }
      var allParts = posixSplitPath(pathString);
      if (!allParts || allParts.length !== 4) {
        throw new TypeError("Invalid path '" + pathString + "'");
      }
      allParts[1] = allParts[1] || "";
      allParts[2] = allParts[2] || "";
      allParts[3] = allParts[3] || "";
      return {
        root: allParts[0],
        dir: allParts[0] + allParts[1].slice(0, -1),
        base: allParts[2],
        ext: allParts[3],
        name: allParts[2].slice(0, allParts[2].length - allParts[3].length)
      };
    };
    posix.sep = "/";
    posix.delimiter = ":";
    if (isWindows)
      module2.exports = win32;
    else
      module2.exports = posix;
    module2.exports.posix = posix;
    module2.exports.win32 = win32;
  }
});

// ../../../node_modules/mime-types/index.js
var require_mime_types = __commonJS({
  "../../../node_modules/mime-types/index.js"(exports2) {
    "use strict";
    var db = require_mime_db();
    var extname = require_path().extname;
    var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
    var TEXT_TYPE_REGEXP = /^text\//i;
    exports2.charset = charset;
    exports2.charsets = { lookup: charset };
    exports2.contentType = contentType;
    exports2.extension = extension;
    exports2.extensions = /* @__PURE__ */ Object.create(null);
    exports2.lookup = lookup;
    exports2.types = /* @__PURE__ */ Object.create(null);
    populateMaps(exports2.extensions, exports2.types);
    function charset(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var mime = match && db[match[1].toLowerCase()];
      if (mime && mime.charset) {
        return mime.charset;
      }
      if (match && TEXT_TYPE_REGEXP.test(match[1])) {
        return "UTF-8";
      }
      return false;
    }
    function contentType(str) {
      if (!str || typeof str !== "string") {
        return false;
      }
      var mime = str.indexOf("/") === -1 ? exports2.lookup(str) : str;
      if (!mime) {
        return false;
      }
      if (mime.indexOf("charset") === -1) {
        var charset2 = exports2.charset(mime);
        if (charset2)
          mime += "; charset=" + charset2.toLowerCase();
      }
      return mime;
    }
    function extension(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var exts = match && exports2.extensions[match[1].toLowerCase()];
      if (!exts || !exts.length) {
        return false;
      }
      return exts[0];
    }
    function lookup(path) {
      if (!path || typeof path !== "string") {
        return false;
      }
      var extension2 = extname("x." + path).toLowerCase().substr(1);
      if (!extension2) {
        return false;
      }
      return exports2.types[extension2] || false;
    }
    function populateMaps(extensions, types) {
      var preference = ["nginx", "apache", void 0, "iana"];
      Object.keys(db).forEach(function forEachMimeType(type) {
        var mime = db[type];
        var exts = mime.extensions;
        if (!exts || !exts.length) {
          return;
        }
        extensions[type] = exts;
        for (var i = 0; i < exts.length; i++) {
          var extension2 = exts[i];
          if (types[extension2]) {
            var from = preference.indexOf(db[types[extension2]].source);
            var to = preference.indexOf(mime.source);
            if (types[extension2] !== "application/octet-stream" && (from > to || from === to && types[extension2].substr(0, 12) === "application/")) {
              continue;
            }
          }
          types[extension2] = type;
        }
      });
    }
  }
});

// ../../../node_modules/type-is/index.js
var require_type_is = __commonJS({
  "../../../node_modules/type-is/index.js"(exports2, module2) {
    "use strict";
    var typer = require_media_typer();
    var mime = require_mime_types();
    module2.exports = typeofrequest;
    module2.exports.is = typeis;
    module2.exports.hasBody = hasbody;
    module2.exports.normalize = normalize2;
    module2.exports.match = mimeMatch;
    function typeis(value, types_) {
      var i;
      var types = types_;
      var val = tryNormalizeType(value);
      if (!val) {
        return false;
      }
      if (types && !Array.isArray(types)) {
        types = new Array(arguments.length - 1);
        for (i = 0; i < types.length; i++) {
          types[i] = arguments[i + 1];
        }
      }
      if (!types || !types.length) {
        return val;
      }
      var type;
      for (i = 0; i < types.length; i++) {
        if (mimeMatch(normalize2(type = types[i]), val)) {
          return type[0] === "+" || type.indexOf("*") !== -1 ? val : type;
        }
      }
      return false;
    }
    function hasbody(req) {
      return req.headers["transfer-encoding"] !== void 0 || !isNaN(req.headers["content-length"]);
    }
    function typeofrequest(req, types_) {
      var types = types_;
      if (!hasbody(req)) {
        return null;
      }
      if (arguments.length > 2) {
        types = new Array(arguments.length - 1);
        for (var i = 0; i < types.length; i++) {
          types[i] = arguments[i + 1];
        }
      }
      var value = req.headers["content-type"];
      return typeis(value, types);
    }
    function normalize2(type) {
      if (typeof type !== "string") {
        return false;
      }
      switch (type) {
        case "urlencoded":
          return "application/x-www-form-urlencoded";
        case "multipart":
          return "multipart/*";
      }
      if (type[0] === "+") {
        return "*/*" + type;
      }
      return type.indexOf("/") === -1 ? mime.lookup(type) : type;
    }
    function mimeMatch(expected, actual) {
      if (expected === false) {
        return false;
      }
      var actualParts = actual.split("/");
      var expectedParts = expected.split("/");
      if (actualParts.length !== 2 || expectedParts.length !== 2) {
        return false;
      }
      if (expectedParts[0] !== "*" && expectedParts[0] !== actualParts[0]) {
        return false;
      }
      if (expectedParts[1].substr(0, 2) === "*+") {
        return expectedParts[1].length <= actualParts[1].length + 1 && expectedParts[1].substr(1) === actualParts[1].substr(1 - expectedParts[1].length);
      }
      if (expectedParts[1] !== "*" && expectedParts[1] !== actualParts[1]) {
        return false;
      }
      return true;
    }
    function normalizeType(value) {
      var type = typer.parse(value);
      type.parameters = void 0;
      return typer.format(type);
    }
    function tryNormalizeType(value) {
      if (!value) {
        return null;
      }
      try {
        return normalizeType(value);
      } catch (err) {
        return null;
      }
    }
  }
});

// ../../../node_modules/express/node_modules/body-parser/lib/types/json.js
var require_json = __commonJS({
  "../../../node_modules/express/node_modules/body-parser/lib/types/json.js"(exports2, module2) {
    "use strict";
    var bytes = require_bytes();
    var contentType = require_content_type();
    var createError = require_http_errors();
    var debug = require_browser3()("body-parser:json");
    var read = require_read();
    var typeis = require_type_is();
    module2.exports = json;
    var FIRST_CHAR_REGEXP = /^[\x20\x09\x0a\x0d]*([^\x20\x09\x0a\x0d])/;
    function json(options) {
      var opts = options || {};
      var limit = typeof opts.limit !== "number" ? bytes.parse(opts.limit || "100kb") : opts.limit;
      var inflate = opts.inflate !== false;
      var reviver = opts.reviver;
      var strict = opts.strict !== false;
      var type = opts.type || "application/json";
      var verify = opts.verify || false;
      if (verify !== false && typeof verify !== "function") {
        throw new TypeError("option verify must be function");
      }
      var shouldParse = typeof type !== "function" ? typeChecker(type) : type;
      function parse2(body) {
        if (body.length === 0) {
          return {};
        }
        if (strict) {
          var first = firstchar(body);
          if (first !== "{" && first !== "[") {
            debug("strict violation");
            throw createStrictSyntaxError(body, first);
          }
        }
        try {
          debug("parse json");
          return JSON.parse(body, reviver);
        } catch (e) {
          throw normalizeJsonSyntaxError(e, {
            message: e.message,
            stack: e.stack
          });
        }
      }
      return function jsonParser(req, res, next) {
        if (req._body) {
          debug("body already parsed");
          next();
          return;
        }
        req.body = req.body || {};
        if (!typeis.hasBody(req)) {
          debug("skip empty body");
          next();
          return;
        }
        debug("content-type %j", req.headers["content-type"]);
        if (!shouldParse(req)) {
          debug("skip parsing");
          next();
          return;
        }
        var charset = getCharset(req) || "utf-8";
        if (charset.slice(0, 4) !== "utf-") {
          debug("invalid charset");
          next(createError(415, 'unsupported charset "' + charset.toUpperCase() + '"', {
            charset,
            type: "charset.unsupported"
          }));
          return;
        }
        read(req, res, next, parse2, debug, {
          encoding: charset,
          inflate,
          limit,
          verify
        });
      };
    }
    function createStrictSyntaxError(str, char) {
      var index = str.indexOf(char);
      var partial = index !== -1 ? str.substring(0, index) + "#" : "";
      try {
        JSON.parse(partial);
        throw new SyntaxError("strict violation");
      } catch (e) {
        return normalizeJsonSyntaxError(e, {
          message: e.message.replace("#", char),
          stack: e.stack
        });
      }
    }
    function firstchar(str) {
      var match = FIRST_CHAR_REGEXP.exec(str);
      return match ? match[1] : void 0;
    }
    function getCharset(req) {
      try {
        return (contentType.parse(req).parameters.charset || "").toLowerCase();
      } catch (e) {
        return void 0;
      }
    }
    function normalizeJsonSyntaxError(error, obj) {
      var keys = Object.getOwnPropertyNames(error);
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (key !== "stack" && key !== "message") {
          delete error[key];
        }
      }
      error.stack = obj.stack.replace(error.message, obj.message);
      error.message = obj.message;
      return error;
    }
    function typeChecker(type) {
      return function checkType(req) {
        return Boolean(typeis(req, type));
      };
    }
  }
});

// ../../../node_modules/express/node_modules/body-parser/lib/types/raw.js
var require_raw = __commonJS({
  "../../../node_modules/express/node_modules/body-parser/lib/types/raw.js"(exports2, module2) {
    "use strict";
    var bytes = require_bytes();
    var debug = require_browser3()("body-parser:raw");
    var read = require_read();
    var typeis = require_type_is();
    module2.exports = raw;
    function raw(options) {
      var opts = options || {};
      var inflate = opts.inflate !== false;
      var limit = typeof opts.limit !== "number" ? bytes.parse(opts.limit || "100kb") : opts.limit;
      var type = opts.type || "application/octet-stream";
      var verify = opts.verify || false;
      if (verify !== false && typeof verify !== "function") {
        throw new TypeError("option verify must be function");
      }
      var shouldParse = typeof type !== "function" ? typeChecker(type) : type;
      function parse2(buf) {
        return buf;
      }
      return function rawParser(req, res, next) {
        if (req._body) {
          debug("body already parsed");
          next();
          return;
        }
        req.body = req.body || {};
        if (!typeis.hasBody(req)) {
          debug("skip empty body");
          next();
          return;
        }
        debug("content-type %j", req.headers["content-type"]);
        if (!shouldParse(req)) {
          debug("skip parsing");
          next();
          return;
        }
        read(req, res, next, parse2, debug, {
          encoding: null,
          inflate,
          limit,
          verify
        });
      };
    }
    function typeChecker(type) {
      return function checkType(req) {
        return Boolean(typeis(req, type));
      };
    }
  }
});

// ../../../node_modules/express/node_modules/body-parser/lib/types/text.js
var require_text = __commonJS({
  "../../../node_modules/express/node_modules/body-parser/lib/types/text.js"(exports2, module2) {
    "use strict";
    var bytes = require_bytes();
    var contentType = require_content_type();
    var debug = require_browser3()("body-parser:text");
    var read = require_read();
    var typeis = require_type_is();
    module2.exports = text;
    function text(options) {
      var opts = options || {};
      var defaultCharset = opts.defaultCharset || "utf-8";
      var inflate = opts.inflate !== false;
      var limit = typeof opts.limit !== "number" ? bytes.parse(opts.limit || "100kb") : opts.limit;
      var type = opts.type || "text/plain";
      var verify = opts.verify || false;
      if (verify !== false && typeof verify !== "function") {
        throw new TypeError("option verify must be function");
      }
      var shouldParse = typeof type !== "function" ? typeChecker(type) : type;
      function parse2(buf) {
        return buf;
      }
      return function textParser(req, res, next) {
        if (req._body) {
          debug("body already parsed");
          next();
          return;
        }
        req.body = req.body || {};
        if (!typeis.hasBody(req)) {
          debug("skip empty body");
          next();
          return;
        }
        debug("content-type %j", req.headers["content-type"]);
        if (!shouldParse(req)) {
          debug("skip parsing");
          next();
          return;
        }
        var charset = getCharset(req) || defaultCharset;
        read(req, res, next, parse2, debug, {
          encoding: charset,
          inflate,
          limit,
          verify
        });
      };
    }
    function getCharset(req) {
      try {
        return (contentType.parse(req).parameters.charset || "").toLowerCase();
      } catch (e) {
        return void 0;
      }
    }
    function typeChecker(type) {
      return function checkType(req) {
        return Boolean(typeis(req, type));
      };
    }
  }
});

// ../../../node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "../../../node_modules/has-symbols/shams.js"(exports2, module2) {
    "use strict";
    module2.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (sym in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// ../../../node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "../../../node_modules/has-symbols/index.js"(exports2, module2) {
    "use strict";
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module2.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// ../../../node_modules/has-proto/index.js
var require_has_proto = __commonJS({
  "../../../node_modules/has-proto/index.js"(exports2, module2) {
    "use strict";
    var test = {
      foo: {}
    };
    var $Object = Object;
    module2.exports = function hasProto() {
      return { __proto__: test }.foo === test.foo && !({ __proto__: null } instanceof $Object);
    };
  }
});

// ../../../node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "../../../node_modules/function-bind/implementation.js"(exports2, module2) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var slice = Array.prototype.slice;
    var toStr = Object.prototype.toString;
    var funcType = "[object Function]";
    module2.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slice.call(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            args.concat(slice.call(arguments))
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        } else {
          return target.apply(
            that,
            args.concat(slice.call(arguments))
          );
        }
      };
      var boundLength = Math.max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs.push("$" + i);
      }
      bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// ../../../node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "../../../node_modules/function-bind/index.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation();
    module2.exports = Function.prototype.bind || implementation;
  }
});

// ../../../node_modules/has/src/index.js
var require_src = __commonJS({
  "../../../node_modules/has/src/index.js"(exports2, module2) {
    "use strict";
    var bind = require_function_bind();
    module2.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
  }
});

// ../../../node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "../../../node_modules/get-intrinsic/index.js"(exports2, module2) {
    "use strict";
    var undefined2;
    var $SyntaxError = SyntaxError;
    var $Function = Function;
    var $TypeError = TypeError;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e) {
      }
    };
    var $gOPD = Object.getOwnPropertyDescriptor;
    if ($gOPD) {
      try {
        $gOPD({}, "");
      } catch (e) {
        $gOPD = null;
      }
    }
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var hasProto = require_has_proto()();
    var getProto = Object.getPrototypeOf || (hasProto ? function(x) {
      return x.__proto__;
    } : null);
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": EvalError,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": Object,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": RangeError,
      "%ReferenceError%": ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
    };
    if (getProto) {
      try {
        null.error;
      } catch (e) {
        errorProto = getProto(getProto(e));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
    }
    var errorProto;
    var doEval = function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen && getProto) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn = require_src();
    var $concat = bind.call(Function.call, Array.prototype.concat);
    var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
    var $replace = bind.call(Function.call, String.prototype.replace);
    var $strSlice = bind.call(Function.call, String.prototype.slice);
    var $exec = bind.call(Function.call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string) {
      var first = $strSlice(string, 0, 1);
      var last = $strSlice(string, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    };
    module2.exports = function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i = 1, isOwn = true; i < parts.length; i += 1) {
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void 0;
          }
          if ($gOPD && i + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// ../../../node_modules/call-bind/index.js
var require_call_bind = __commonJS({
  "../../../node_modules/call-bind/index.js"(exports2, module2) {
    "use strict";
    var bind = require_function_bind();
    var GetIntrinsic = require_get_intrinsic();
    var $apply = GetIntrinsic("%Function.prototype.apply%");
    var $call = GetIntrinsic("%Function.prototype.call%");
    var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
    var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var $max = GetIntrinsic("%Math.max%");
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = null;
      }
    }
    module2.exports = function callBind(originalFunction) {
      var func = $reflectApply(bind, $call, arguments);
      if ($gOPD && $defineProperty) {
        var desc = $gOPD(func, "length");
        if (desc.configurable) {
          $defineProperty(
            func,
            "length",
            { value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
          );
        }
      }
      return func;
    };
    var applyBind = function applyBind2() {
      return $reflectApply(bind, $apply, arguments);
    };
    if ($defineProperty) {
      $defineProperty(module2.exports, "apply", { value: applyBind });
    } else {
      module2.exports.apply = applyBind;
    }
  }
});

// ../../../node_modules/call-bind/callBound.js
var require_callBound = __commonJS({
  "../../../node_modules/call-bind/callBound.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBind = require_call_bind();
    var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
    module2.exports = function callBoundIntrinsic(name, allowMissing) {
      var intrinsic = GetIntrinsic(name, !!allowMissing);
      if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
        return callBind(intrinsic);
      }
      return intrinsic;
    };
  }
});

// (disabled):../../../node_modules/object-inspect/util.inspect
var require_util4 = __commonJS({
  "(disabled):../../../node_modules/object-inspect/util.inspect"() {
  }
});

// ../../../node_modules/object-inspect/index.js
var require_object_inspect = __commonJS({
  "../../../node_modules/object-inspect/index.js"(exports2, module2) {
    var hasMap = typeof Map === "function" && Map.prototype;
    var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
    var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
    var mapForEach = hasMap && Map.prototype.forEach;
    var hasSet = typeof Set === "function" && Set.prototype;
    var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
    var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
    var setForEach = hasSet && Set.prototype.forEach;
    var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
    var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
    var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
    var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
    var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
    var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
    var booleanValueOf = Boolean.prototype.valueOf;
    var objectToString = Object.prototype.toString;
    var functionToString = Function.prototype.toString;
    var $match = String.prototype.match;
    var $slice = String.prototype.slice;
    var $replace = String.prototype.replace;
    var $toUpperCase = String.prototype.toUpperCase;
    var $toLowerCase = String.prototype.toLowerCase;
    var $test = RegExp.prototype.test;
    var $concat = Array.prototype.concat;
    var $join = Array.prototype.join;
    var $arrSlice = Array.prototype.slice;
    var $floor = Math.floor;
    var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
    var gOPS = Object.getOwnPropertySymbols;
    var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
    var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
    var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O) {
      return O.__proto__;
    } : null);
    function addNumericSeparator(num, str) {
      if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
        return str;
      }
      var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
      if (typeof num === "number") {
        var int = num < 0 ? -$floor(-num) : $floor(num);
        if (int !== num) {
          var intStr = String(int);
          var dec = $slice.call(str, intStr.length + 1);
          return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
        }
      }
      return $replace.call(str, sepRegex, "$&_");
    }
    var utilInspect = require_util4();
    var inspectCustom = utilInspect.custom;
    var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
    module2.exports = function inspect_(obj, options, depth, seen) {
      var opts = options || {};
      if (has(opts, "quoteStyle") && (opts.quoteStyle !== "single" && opts.quoteStyle !== "double")) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
      }
      if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
      }
      var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
      if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
        throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
      }
      if (has(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
      }
      if (has(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
      }
      var numericSeparator = opts.numericSeparator;
      if (typeof obj === "undefined") {
        return "undefined";
      }
      if (obj === null) {
        return "null";
      }
      if (typeof obj === "boolean") {
        return obj ? "true" : "false";
      }
      if (typeof obj === "string") {
        return inspectString(obj, opts);
      }
      if (typeof obj === "number") {
        if (obj === 0) {
          return Infinity / obj > 0 ? "0" : "-0";
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
      }
      if (typeof obj === "bigint") {
        var bigIntStr = String(obj) + "n";
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
      }
      var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
      if (typeof depth === "undefined") {
        depth = 0;
      }
      if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
        return isArray(obj) ? "[Array]" : "[Object]";
      }
      var indent2 = getIndent(opts, depth);
      if (typeof seen === "undefined") {
        seen = [];
      } else if (indexOf(seen, obj) >= 0) {
        return "[Circular]";
      }
      function inspect2(value, from, noIndent) {
        if (from) {
          seen = $arrSlice.call(seen);
          seen.push(from);
        }
        if (noIndent) {
          var newOpts = {
            depth: opts.depth
          };
          if (has(opts, "quoteStyle")) {
            newOpts.quoteStyle = opts.quoteStyle;
          }
          return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
      }
      if (typeof obj === "function" && !isRegExp(obj)) {
        var name = nameOf(obj);
        var keys = arrObjKeys(obj, inspect2);
        return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys.length > 0 ? " { " + $join.call(keys, ", ") + " }" : "");
      }
      if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
        return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
      }
      if (isElement(obj)) {
        var s = "<" + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i = 0; i < attrs.length; i++) {
          s += " " + attrs[i].name + "=" + wrapQuotes(quote(attrs[i].value), "double", opts);
        }
        s += ">";
        if (obj.childNodes && obj.childNodes.length) {
          s += "...";
        }
        s += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
        return s;
      }
      if (isArray(obj)) {
        if (obj.length === 0) {
          return "[]";
        }
        var xs = arrObjKeys(obj, inspect2);
        if (indent2 && !singleLineValues(xs)) {
          return "[" + indentedJoin(xs, indent2) + "]";
        }
        return "[ " + $join.call(xs, ", ") + " ]";
      }
      if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect2);
        if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
          return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect2(obj.cause), parts), ", ") + " }";
        }
        if (parts.length === 0) {
          return "[" + String(obj) + "]";
        }
        return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
      }
      if (typeof obj === "object" && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
          return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
          return obj.inspect();
        }
      }
      if (isMap(obj)) {
        var mapParts = [];
        if (mapForEach) {
          mapForEach.call(obj, function(value, key) {
            mapParts.push(inspect2(key, obj, true) + " => " + inspect2(value, obj));
          });
        }
        return collectionOf("Map", mapSize.call(obj), mapParts, indent2);
      }
      if (isSet(obj)) {
        var setParts = [];
        if (setForEach) {
          setForEach.call(obj, function(value) {
            setParts.push(inspect2(value, obj));
          });
        }
        return collectionOf("Set", setSize.call(obj), setParts, indent2);
      }
      if (isWeakMap(obj)) {
        return weakCollectionOf("WeakMap");
      }
      if (isWeakSet(obj)) {
        return weakCollectionOf("WeakSet");
      }
      if (isWeakRef(obj)) {
        return weakCollectionOf("WeakRef");
      }
      if (isNumber(obj)) {
        return markBoxed(inspect2(Number(obj)));
      }
      if (isBigInt(obj)) {
        return markBoxed(inspect2(bigIntValueOf.call(obj)));
      }
      if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
      }
      if (isString(obj)) {
        return markBoxed(inspect2(String(obj)));
      }
      if (!isDate(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect2);
        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? "" : "null prototype";
        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
        var constructorTag = isPlainObject || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
        var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
        if (ys.length === 0) {
          return tag + "{}";
        }
        if (indent2) {
          return tag + "{" + indentedJoin(ys, indent2) + "}";
        }
        return tag + "{ " + $join.call(ys, ", ") + " }";
      }
      return String(obj);
    };
    function wrapQuotes(s, defaultStyle, opts) {
      var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
      return quoteChar + s + quoteChar;
    }
    function quote(s) {
      return $replace.call(String(s), /"/g, "&quot;");
    }
    function isArray(obj) {
      return toStr(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isDate(obj) {
      return toStr(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isRegExp(obj) {
      return toStr(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isError(obj) {
      return toStr(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isString(obj) {
      return toStr(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isNumber(obj) {
      return toStr(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isBoolean(obj) {
      return toStr(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isSymbol(obj) {
      if (hasShammedSymbols) {
        return obj && typeof obj === "object" && obj instanceof Symbol;
      }
      if (typeof obj === "symbol") {
        return true;
      }
      if (!obj || typeof obj !== "object" || !symToString) {
        return false;
      }
      try {
        symToString.call(obj);
        return true;
      } catch (e) {
      }
      return false;
    }
    function isBigInt(obj) {
      if (!obj || typeof obj !== "object" || !bigIntValueOf) {
        return false;
      }
      try {
        bigIntValueOf.call(obj);
        return true;
      } catch (e) {
      }
      return false;
    }
    var hasOwn = Object.prototype.hasOwnProperty || function(key) {
      return key in this;
    };
    function has(obj, key) {
      return hasOwn.call(obj, key);
    }
    function toStr(obj) {
      return objectToString.call(obj);
    }
    function nameOf(f) {
      if (f.name) {
        return f.name;
      }
      var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
      if (m) {
        return m[1];
      }
      return null;
    }
    function indexOf(xs, x) {
      if (xs.indexOf) {
        return xs.indexOf(x);
      }
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) {
          return i;
        }
      }
      return -1;
    }
    function isMap(x) {
      if (!mapSize || !x || typeof x !== "object") {
        return false;
      }
      try {
        mapSize.call(x);
        try {
          setSize.call(x);
        } catch (s) {
          return true;
        }
        return x instanceof Map;
      } catch (e) {
      }
      return false;
    }
    function isWeakMap(x) {
      if (!weakMapHas || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakMapHas.call(x, weakMapHas);
        try {
          weakSetHas.call(x, weakSetHas);
        } catch (s) {
          return true;
        }
        return x instanceof WeakMap;
      } catch (e) {
      }
      return false;
    }
    function isWeakRef(x) {
      if (!weakRefDeref || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakRefDeref.call(x);
        return true;
      } catch (e) {
      }
      return false;
    }
    function isSet(x) {
      if (!setSize || !x || typeof x !== "object") {
        return false;
      }
      try {
        setSize.call(x);
        try {
          mapSize.call(x);
        } catch (m) {
          return true;
        }
        return x instanceof Set;
      } catch (e) {
      }
      return false;
    }
    function isWeakSet(x) {
      if (!weakSetHas || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakSetHas.call(x, weakSetHas);
        try {
          weakMapHas.call(x, weakMapHas);
        } catch (s) {
          return true;
        }
        return x instanceof WeakSet;
      } catch (e) {
      }
      return false;
    }
    function isElement(x) {
      if (!x || typeof x !== "object") {
        return false;
      }
      if (typeof HTMLElement !== "undefined" && x instanceof HTMLElement) {
        return true;
      }
      return typeof x.nodeName === "string" && typeof x.getAttribute === "function";
    }
    function inspectString(str, opts) {
      if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
      }
      var s = $replace.call($replace.call(str, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, lowbyte);
      return wrapQuotes(s, "single", opts);
    }
    function lowbyte(c) {
      var n = c.charCodeAt(0);
      var x = {
        8: "b",
        9: "t",
        10: "n",
        12: "f",
        13: "r"
      }[n];
      if (x) {
        return "\\" + x;
      }
      return "\\x" + (n < 16 ? "0" : "") + $toUpperCase.call(n.toString(16));
    }
    function markBoxed(str) {
      return "Object(" + str + ")";
    }
    function weakCollectionOf(type) {
      return type + " { ? }";
    }
    function collectionOf(type, size, entries, indent2) {
      var joinedEntries = indent2 ? indentedJoin(entries, indent2) : $join.call(entries, ", ");
      return type + " (" + size + ") {" + joinedEntries + "}";
    }
    function singleLineValues(xs) {
      for (var i = 0; i < xs.length; i++) {
        if (indexOf(xs[i], "\n") >= 0) {
          return false;
        }
      }
      return true;
    }
    function getIndent(opts, depth) {
      var baseIndent;
      if (opts.indent === "	") {
        baseIndent = "	";
      } else if (typeof opts.indent === "number" && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), " ");
      } else {
        return null;
      }
      return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
      };
    }
    function indentedJoin(xs, indent2) {
      if (xs.length === 0) {
        return "";
      }
      var lineJoiner = "\n" + indent2.prev + indent2.base;
      return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent2.prev;
    }
    function arrObjKeys(obj, inspect2) {
      var isArr = isArray(obj);
      var xs = [];
      if (isArr) {
        xs.length = obj.length;
        for (var i = 0; i < obj.length; i++) {
          xs[i] = has(obj, i) ? inspect2(obj[i], obj) : "";
        }
      }
      var syms = typeof gOPS === "function" ? gOPS(obj) : [];
      var symMap;
      if (hasShammedSymbols) {
        symMap = {};
        for (var k = 0; k < syms.length; k++) {
          symMap["$" + syms[k]] = syms[k];
        }
      }
      for (var key in obj) {
        if (!has(obj, key)) {
          continue;
        }
        if (isArr && String(Number(key)) === key && key < obj.length) {
          continue;
        }
        if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
          continue;
        } else if ($test.call(/[^\w$]/, key)) {
          xs.push(inspect2(key, obj) + ": " + inspect2(obj[key], obj));
        } else {
          xs.push(key + ": " + inspect2(obj[key], obj));
        }
      }
      if (typeof gOPS === "function") {
        for (var j = 0; j < syms.length; j++) {
          if (isEnumerable.call(obj, syms[j])) {
            xs.push("[" + inspect2(syms[j]) + "]: " + inspect2(obj[syms[j]], obj));
          }
        }
      }
      return xs;
    }
  }
});

// ../../../node_modules/side-channel/index.js
var require_side_channel = __commonJS({
  "../../../node_modules/side-channel/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_callBound();
    var inspect2 = require_object_inspect();
    var $TypeError = GetIntrinsic("%TypeError%");
    var $WeakMap = GetIntrinsic("%WeakMap%", true);
    var $Map = GetIntrinsic("%Map%", true);
    var $weakMapGet = callBound("WeakMap.prototype.get", true);
    var $weakMapSet = callBound("WeakMap.prototype.set", true);
    var $weakMapHas = callBound("WeakMap.prototype.has", true);
    var $mapGet = callBound("Map.prototype.get", true);
    var $mapSet = callBound("Map.prototype.set", true);
    var $mapHas = callBound("Map.prototype.has", true);
    var listGetNode = function(list, key) {
      for (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {
        if (curr.key === key) {
          prev.next = curr.next;
          curr.next = list.next;
          list.next = curr;
          return curr;
        }
      }
    };
    var listGet = function(objects, key) {
      var node = listGetNode(objects, key);
      return node && node.value;
    };
    var listSet = function(objects, key, value) {
      var node = listGetNode(objects, key);
      if (node) {
        node.value = value;
      } else {
        objects.next = {
          // eslint-disable-line no-param-reassign
          key,
          next: objects.next,
          value
        };
      }
    };
    var listHas = function(objects, key) {
      return !!listGetNode(objects, key);
    };
    module2.exports = function getSideChannel() {
      var $wm;
      var $m;
      var $o;
      var channel = {
        assert: function(key) {
          if (!channel.has(key)) {
            throw new $TypeError("Side channel does not contain " + inspect2(key));
          }
        },
        get: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapGet($wm, key);
            }
          } else if ($Map) {
            if ($m) {
              return $mapGet($m, key);
            }
          } else {
            if ($o) {
              return listGet($o, key);
            }
          }
        },
        has: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapHas($wm, key);
            }
          } else if ($Map) {
            if ($m) {
              return $mapHas($m, key);
            }
          } else {
            if ($o) {
              return listHas($o, key);
            }
          }
          return false;
        },
        set: function(key, value) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if (!$wm) {
              $wm = new $WeakMap();
            }
            $weakMapSet($wm, key, value);
          } else if ($Map) {
            if (!$m) {
              $m = new $Map();
            }
            $mapSet($m, key, value);
          } else {
            if (!$o) {
              $o = { key: {}, next: null };
            }
            listSet($o, key, value);
          }
        }
      };
      return channel;
    };
  }
});

// ../../../node_modules/qs/lib/formats.js
var require_formats = __commonJS({
  "../../../node_modules/qs/lib/formats.js"(exports2, module2) {
    "use strict";
    var replace = String.prototype.replace;
    var percentTwenties = /%20/g;
    var Format = {
      RFC1738: "RFC1738",
      RFC3986: "RFC3986"
    };
    module2.exports = {
      "default": Format.RFC3986,
      formatters: {
        RFC1738: function(value) {
          return replace.call(value, percentTwenties, "+");
        },
        RFC3986: function(value) {
          return String(value);
        }
      },
      RFC1738: Format.RFC1738,
      RFC3986: Format.RFC3986
    };
  }
});

// ../../../node_modules/qs/lib/utils.js
var require_utils5 = __commonJS({
  "../../../node_modules/qs/lib/utils.js"(exports2, module2) {
    "use strict";
    var formats = require_formats();
    var has = Object.prototype.hasOwnProperty;
    var isArray = Array.isArray;
    var hexTable = function() {
      var array = [];
      for (var i = 0; i < 256; ++i) {
        array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
      }
      return array;
    }();
    var compactQueue = function compactQueue2(queue) {
      while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];
        if (isArray(obj)) {
          var compacted = [];
          for (var j = 0; j < obj.length; ++j) {
            if (typeof obj[j] !== "undefined") {
              compacted.push(obj[j]);
            }
          }
          item.obj[item.prop] = compacted;
        }
      }
    };
    var arrayToObject = function arrayToObject2(source, options) {
      var obj = options && options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== "undefined") {
          obj[i] = source[i];
        }
      }
      return obj;
    };
    var merge = function merge2(target, source, options) {
      if (!source) {
        return target;
      }
      if (typeof source !== "object") {
        if (isArray(target)) {
          target.push(source);
        } else if (target && typeof target === "object") {
          if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) {
            target[source] = true;
          }
        } else {
          return [target, source];
        }
        return target;
      }
      if (!target || typeof target !== "object") {
        return [target].concat(source);
      }
      var mergeTarget = target;
      if (isArray(target) && !isArray(source)) {
        mergeTarget = arrayToObject(target, options);
      }
      if (isArray(target) && isArray(source)) {
        source.forEach(function(item, i) {
          if (has.call(target, i)) {
            var targetItem = target[i];
            if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
              target[i] = merge2(targetItem, item, options);
            } else {
              target.push(item);
            }
          } else {
            target[i] = item;
          }
        });
        return target;
      }
      return Object.keys(source).reduce(function(acc, key) {
        var value = source[key];
        if (has.call(acc, key)) {
          acc[key] = merge2(acc[key], value, options);
        } else {
          acc[key] = value;
        }
        return acc;
      }, mergeTarget);
    };
    var assign = function assignSingleSource(target, source) {
      return Object.keys(source).reduce(function(acc, key) {
        acc[key] = source[key];
        return acc;
      }, target);
    };
    var decode = function(str, decoder, charset) {
      var strWithoutPlus = str.replace(/\+/g, " ");
      if (charset === "iso-8859-1") {
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
      }
      try {
        return decodeURIComponent(strWithoutPlus);
      } catch (e) {
        return strWithoutPlus;
      }
    };
    var encode = function encode2(str, defaultEncoder, charset, kind, format) {
      if (str.length === 0) {
        return str;
      }
      var string = str;
      if (typeof str === "symbol") {
        string = Symbol.prototype.toString.call(str);
      } else if (typeof str !== "string") {
        string = String(str);
      }
      if (charset === "iso-8859-1") {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
          return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
        });
      }
      var out = "";
      for (var i = 0; i < string.length; ++i) {
        var c = string.charCodeAt(i);
        if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 || format === formats.RFC1738 && (c === 40 || c === 41)) {
          out += string.charAt(i);
          continue;
        }
        if (c < 128) {
          out = out + hexTable[c];
          continue;
        }
        if (c < 2048) {
          out = out + (hexTable[192 | c >> 6] + hexTable[128 | c & 63]);
          continue;
        }
        if (c < 55296 || c >= 57344) {
          out = out + (hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63]);
          continue;
        }
        i += 1;
        c = 65536 + ((c & 1023) << 10 | string.charCodeAt(i) & 1023);
        out += hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
      }
      return out;
    };
    var compact = function compact2(value) {
      var queue = [{ obj: { o: value }, prop: "o" }];
      var refs = [];
      for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];
        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
          var key = keys[j];
          var val = obj[key];
          if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
            queue.push({ obj, prop: key });
            refs.push(val);
          }
        }
      }
      compactQueue(queue);
      return value;
    };
    var isRegExp = function isRegExp2(obj) {
      return Object.prototype.toString.call(obj) === "[object RegExp]";
    };
    var isBuffer = function isBuffer2(obj) {
      if (!obj || typeof obj !== "object") {
        return false;
      }
      return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
    };
    var combine = function combine2(a, b) {
      return [].concat(a, b);
    };
    var maybeMap = function maybeMap2(val, fn) {
      if (isArray(val)) {
        var mapped = [];
        for (var i = 0; i < val.length; i += 1) {
          mapped.push(fn(val[i]));
        }
        return mapped;
      }
      return fn(val);
    };
    module2.exports = {
      arrayToObject,
      assign,
      combine,
      compact,
      decode,
      encode,
      isBuffer,
      isRegExp,
      maybeMap,
      merge
    };
  }
});

// ../../../node_modules/qs/lib/stringify.js
var require_stringify2 = __commonJS({
  "../../../node_modules/qs/lib/stringify.js"(exports2, module2) {
    "use strict";
    var getSideChannel = require_side_channel();
    var utils = require_utils5();
    var formats = require_formats();
    var has = Object.prototype.hasOwnProperty;
    var arrayPrefixGenerators = {
      brackets: function brackets(prefix) {
        return prefix + "[]";
      },
      comma: "comma",
      indices: function indices(prefix, key) {
        return prefix + "[" + key + "]";
      },
      repeat: function repeat(prefix) {
        return prefix;
      }
    };
    var isArray = Array.isArray;
    var split = String.prototype.split;
    var push = Array.prototype.push;
    var pushToArray = function(arr, valueOrArray) {
      push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
    };
    var toISO = Date.prototype.toISOString;
    var defaultFormat = formats["default"];
    var defaults = {
      addQueryPrefix: false,
      allowDots: false,
      charset: "utf-8",
      charsetSentinel: false,
      delimiter: "&",
      encode: true,
      encoder: utils.encode,
      encodeValuesOnly: false,
      format: defaultFormat,
      formatter: formats.formatters[defaultFormat],
      // deprecated
      indices: false,
      serializeDate: function serializeDate(date) {
        return toISO.call(date);
      },
      skipNulls: false,
      strictNullHandling: false
    };
    var isNonNullishPrimitive = function isNonNullishPrimitive2(v) {
      return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
    };
    var sentinel = {};
    var stringify = function stringify2(object, prefix, generateArrayPrefix, commaRoundTrip, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
      var obj = object;
      var tmpSc = sideChannel;
      var step = 0;
      var findFlag = false;
      while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
        var pos = tmpSc.get(object);
        step += 1;
        if (typeof pos !== "undefined") {
          if (pos === step) {
            throw new RangeError("Cyclic object value");
          } else {
            findFlag = true;
          }
        }
        if (typeof tmpSc.get(sentinel) === "undefined") {
          step = 0;
        }
      }
      if (typeof filter === "function") {
        obj = filter(prefix, obj);
      } else if (obj instanceof Date) {
        obj = serializeDate(obj);
      } else if (generateArrayPrefix === "comma" && isArray(obj)) {
        obj = utils.maybeMap(obj, function(value2) {
          if (value2 instanceof Date) {
            return serializeDate(value2);
          }
          return value2;
        });
      }
      if (obj === null) {
        if (strictNullHandling) {
          return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, "key", format) : prefix;
        }
        obj = "";
      }
      if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder) {
          var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, "key", format);
          if (generateArrayPrefix === "comma" && encodeValuesOnly) {
            var valuesArray = split.call(String(obj), ",");
            var valuesJoined = "";
            for (var i = 0; i < valuesArray.length; ++i) {
              valuesJoined += (i === 0 ? "" : ",") + formatter(encoder(valuesArray[i], defaults.encoder, charset, "value", format));
            }
            return [formatter(keyValue) + (commaRoundTrip && isArray(obj) && valuesArray.length === 1 ? "[]" : "") + "=" + valuesJoined];
          }
          return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults.encoder, charset, "value", format))];
        }
        return [formatter(prefix) + "=" + formatter(String(obj))];
      }
      var values = [];
      if (typeof obj === "undefined") {
        return values;
      }
      var objKeys;
      if (generateArrayPrefix === "comma" && isArray(obj)) {
        objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
      } else if (isArray(filter)) {
        objKeys = filter;
      } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
      }
      var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? prefix + "[]" : prefix;
      for (var j = 0; j < objKeys.length; ++j) {
        var key = objKeys[j];
        var value = typeof key === "object" && typeof key.value !== "undefined" ? key.value : obj[key];
        if (skipNulls && value === null) {
          continue;
        }
        var keyPrefix = isArray(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, key) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + key : "[" + key + "]");
        sideChannel.set(object, step);
        var valueSideChannel = getSideChannel();
        valueSideChannel.set(sentinel, sideChannel);
        pushToArray(values, stringify2(
          value,
          keyPrefix,
          generateArrayPrefix,
          commaRoundTrip,
          strictNullHandling,
          skipNulls,
          encoder,
          filter,
          sort,
          allowDots,
          serializeDate,
          format,
          formatter,
          encodeValuesOnly,
          charset,
          valueSideChannel
        ));
      }
      return values;
    };
    var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
        throw new TypeError("Encoder has to be a function.");
      }
      var charset = opts.charset || defaults.charset;
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var format = formats["default"];
      if (typeof opts.format !== "undefined") {
        if (!has.call(formats.formatters, opts.format)) {
          throw new TypeError("Unknown format option provided.");
        }
        format = opts.format;
      }
      var formatter = formats.formatters[format];
      var filter = defaults.filter;
      if (typeof opts.filter === "function" || isArray(opts.filter)) {
        filter = opts.filter;
      }
      return {
        addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots: typeof opts.allowDots === "undefined" ? defaults.allowDots : !!opts.allowDots,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
        encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter,
        format,
        formatter,
        serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === "function" ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
      };
    };
    module2.exports = function(object, opts) {
      var obj = object;
      var options = normalizeStringifyOptions(opts);
      var objKeys;
      var filter;
      if (typeof options.filter === "function") {
        filter = options.filter;
        obj = filter("", obj);
      } else if (isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
      }
      var keys = [];
      if (typeof obj !== "object" || obj === null) {
        return "";
      }
      var arrayFormat;
      if (opts && opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
      } else if (opts && "indices" in opts) {
        arrayFormat = opts.indices ? "indices" : "repeat";
      } else {
        arrayFormat = "indices";
      }
      var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
      if (opts && "commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
        throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
      }
      var commaRoundTrip = generateArrayPrefix === "comma" && opts && opts.commaRoundTrip;
      if (!objKeys) {
        objKeys = Object.keys(obj);
      }
      if (options.sort) {
        objKeys.sort(options.sort);
      }
      var sideChannel = getSideChannel();
      for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];
        if (options.skipNulls && obj[key] === null) {
          continue;
        }
        pushToArray(keys, stringify(
          obj[key],
          key,
          generateArrayPrefix,
          commaRoundTrip,
          options.strictNullHandling,
          options.skipNulls,
          options.encode ? options.encoder : null,
          options.filter,
          options.sort,
          options.allowDots,
          options.serializeDate,
          options.format,
          options.formatter,
          options.encodeValuesOnly,
          options.charset,
          sideChannel
        ));
      }
      var joined = keys.join(options.delimiter);
      var prefix = options.addQueryPrefix === true ? "?" : "";
      if (options.charsetSentinel) {
        if (options.charset === "iso-8859-1") {
          prefix += "utf8=%26%2310003%3B&";
        } else {
          prefix += "utf8=%E2%9C%93&";
        }
      }
      return joined.length > 0 ? prefix + joined : "";
    };
  }
});

// ../../../node_modules/qs/lib/parse.js
var require_parse2 = __commonJS({
  "../../../node_modules/qs/lib/parse.js"(exports2, module2) {
    "use strict";
    var utils = require_utils5();
    var has = Object.prototype.hasOwnProperty;
    var isArray = Array.isArray;
    var defaults = {
      allowDots: false,
      allowPrototypes: false,
      allowSparse: false,
      arrayLimit: 20,
      charset: "utf-8",
      charsetSentinel: false,
      comma: false,
      decoder: utils.decode,
      delimiter: "&",
      depth: 5,
      ignoreQueryPrefix: false,
      interpretNumericEntities: false,
      parameterLimit: 1e3,
      parseArrays: true,
      plainObjects: false,
      strictNullHandling: false
    };
    var interpretNumericEntities = function(str) {
      return str.replace(/&#(\d+);/g, function($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
      });
    };
    var parseArrayValue = function(val, options) {
      if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
        return val.split(",");
      }
      return val;
    };
    var isoSentinel = "utf8=%26%2310003%3B";
    var charsetSentinel = "utf8=%E2%9C%93";
    var parseValues = function parseQueryStringValues(str, options) {
      var obj = {};
      var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
      var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
      var parts = cleanStr.split(options.delimiter, limit);
      var skipIndex = -1;
      var i;
      var charset = options.charset;
      if (options.charsetSentinel) {
        for (i = 0; i < parts.length; ++i) {
          if (parts[i].indexOf("utf8=") === 0) {
            if (parts[i] === charsetSentinel) {
              charset = "utf-8";
            } else if (parts[i] === isoSentinel) {
              charset = "iso-8859-1";
            }
            skipIndex = i;
            i = parts.length;
          }
        }
      }
      for (i = 0; i < parts.length; ++i) {
        if (i === skipIndex) {
          continue;
        }
        var part = parts[i];
        var bracketEqualsPos = part.indexOf("]=");
        var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
        var key, val;
        if (pos === -1) {
          key = options.decoder(part, defaults.decoder, charset, "key");
          val = options.strictNullHandling ? null : "";
        } else {
          key = options.decoder(part.slice(0, pos), defaults.decoder, charset, "key");
          val = utils.maybeMap(
            parseArrayValue(part.slice(pos + 1), options),
            function(encodedVal) {
              return options.decoder(encodedVal, defaults.decoder, charset, "value");
            }
          );
        }
        if (val && options.interpretNumericEntities && charset === "iso-8859-1") {
          val = interpretNumericEntities(val);
        }
        if (part.indexOf("[]=") > -1) {
          val = isArray(val) ? [val] : val;
        }
        if (has.call(obj, key)) {
          obj[key] = utils.combine(obj[key], val);
        } else {
          obj[key] = val;
        }
      }
      return obj;
    };
    var parseObject = function(chain, val, options, valuesParsed) {
      var leaf = valuesParsed ? val : parseArrayValue(val, options);
      for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];
        if (root === "[]" && options.parseArrays) {
          obj = [].concat(leaf);
        } else {
          obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
          var cleanRoot = root.charAt(0) === "[" && root.charAt(root.length - 1) === "]" ? root.slice(1, -1) : root;
          var index = parseInt(cleanRoot, 10);
          if (!options.parseArrays && cleanRoot === "") {
            obj = { 0: leaf };
          } else if (!isNaN(index) && root !== cleanRoot && String(index) === cleanRoot && index >= 0 && (options.parseArrays && index <= options.arrayLimit)) {
            obj = [];
            obj[index] = leaf;
          } else if (cleanRoot !== "__proto__") {
            obj[cleanRoot] = leaf;
          }
        }
        leaf = obj;
      }
      return leaf;
    };
    var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
      if (!givenKey) {
        return;
      }
      var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
      var brackets = /(\[[^[\]]*])/;
      var child = /(\[[^[\]]*])/g;
      var segment = options.depth > 0 && brackets.exec(key);
      var parent = segment ? key.slice(0, segment.index) : key;
      var keys = [];
      if (parent) {
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys.push(parent);
      }
      var i = 0;
      while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys.push(segment[1]);
      }
      if (segment) {
        keys.push("[" + key.slice(segment.index) + "]");
      }
      return parseObject(keys, val, options, valuesParsed);
    };
    var normalizeParseOptions = function normalizeParseOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (opts.decoder !== null && opts.decoder !== void 0 && typeof opts.decoder !== "function") {
        throw new TypeError("Decoder has to be a function.");
      }
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var charset = typeof opts.charset === "undefined" ? defaults.charset : opts.charset;
      return {
        allowDots: typeof opts.allowDots === "undefined" ? defaults.allowDots : !!opts.allowDots,
        allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults.allowPrototypes,
        allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults.allowSparse,
        arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults.arrayLimit,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
        decoder: typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults.depth,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults.plainObjects,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
      };
    };
    module2.exports = function(str, opts) {
      var options = normalizeParseOptions(opts);
      if (str === "" || str === null || typeof str === "undefined") {
        return options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      }
      var tempObj = typeof str === "string" ? parseValues(str, options) : str;
      var obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      var keys = Object.keys(tempObj);
      for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options, typeof str === "string");
        obj = utils.merge(obj, newObj, options);
      }
      if (options.allowSparse === true) {
        return obj;
      }
      return utils.compact(obj);
    };
  }
});

// ../../../node_modules/qs/lib/index.js
var require_lib6 = __commonJS({
  "../../../node_modules/qs/lib/index.js"(exports2, module2) {
    "use strict";
    var stringify = require_stringify2();
    var parse2 = require_parse2();
    var formats = require_formats();
    module2.exports = {
      formats,
      parse: parse2,
      stringify
    };
  }
});

// browser-external:querystring
var require_querystring = __commonJS({
  "browser-external:querystring"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "querystring" has been externalized for browser compatibility. Cannot access "querystring.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// ../../../node_modules/express/node_modules/body-parser/lib/types/urlencoded.js
var require_urlencoded = __commonJS({
  "../../../node_modules/express/node_modules/body-parser/lib/types/urlencoded.js"(exports2, module2) {
    "use strict";
    var bytes = require_bytes();
    var contentType = require_content_type();
    var createError = require_http_errors();
    var debug = require_browser3()("body-parser:urlencoded");
    var deprecate = require_browser2()("body-parser");
    var read = require_read();
    var typeis = require_type_is();
    module2.exports = urlencoded;
    var parsers = /* @__PURE__ */ Object.create(null);
    function urlencoded(options) {
      var opts = options || {};
      if (opts.extended === void 0) {
        deprecate("undefined extended: provide extended option");
      }
      var extended = opts.extended !== false;
      var inflate = opts.inflate !== false;
      var limit = typeof opts.limit !== "number" ? bytes.parse(opts.limit || "100kb") : opts.limit;
      var type = opts.type || "application/x-www-form-urlencoded";
      var verify = opts.verify || false;
      if (verify !== false && typeof verify !== "function") {
        throw new TypeError("option verify must be function");
      }
      var queryparse = extended ? extendedparser(opts) : simpleparser(opts);
      var shouldParse = typeof type !== "function" ? typeChecker(type) : type;
      function parse2(body) {
        return body.length ? queryparse(body) : {};
      }
      return function urlencodedParser(req, res, next) {
        if (req._body) {
          debug("body already parsed");
          next();
          return;
        }
        req.body = req.body || {};
        if (!typeis.hasBody(req)) {
          debug("skip empty body");
          next();
          return;
        }
        debug("content-type %j", req.headers["content-type"]);
        if (!shouldParse(req)) {
          debug("skip parsing");
          next();
          return;
        }
        var charset = getCharset(req) || "utf-8";
        if (charset !== "utf-8") {
          debug("invalid charset");
          next(createError(415, 'unsupported charset "' + charset.toUpperCase() + '"', {
            charset,
            type: "charset.unsupported"
          }));
          return;
        }
        read(req, res, next, parse2, debug, {
          debug,
          encoding: charset,
          inflate,
          limit,
          verify
        });
      };
    }
    function extendedparser(options) {
      var parameterLimit = options.parameterLimit !== void 0 ? options.parameterLimit : 1e3;
      var parse2 = parser("qs");
      if (isNaN(parameterLimit) || parameterLimit < 1) {
        throw new TypeError("option parameterLimit must be a positive number");
      }
      if (isFinite(parameterLimit)) {
        parameterLimit = parameterLimit | 0;
      }
      return function queryparse(body) {
        var paramCount = parameterCount(body, parameterLimit);
        if (paramCount === void 0) {
          debug("too many parameters");
          throw createError(413, "too many parameters", {
            type: "parameters.too.many"
          });
        }
        var arrayLimit = Math.max(100, paramCount);
        debug("parse extended urlencoding");
        return parse2(body, {
          allowPrototypes: true,
          arrayLimit,
          depth: Infinity,
          parameterLimit
        });
      };
    }
    function getCharset(req) {
      try {
        return (contentType.parse(req).parameters.charset || "").toLowerCase();
      } catch (e) {
        return void 0;
      }
    }
    function parameterCount(body, limit) {
      var count = 0;
      var index = 0;
      while ((index = body.indexOf("&", index)) !== -1) {
        count++;
        index++;
        if (count === limit) {
          return void 0;
        }
      }
      return count;
    }
    function parser(name) {
      var mod2 = parsers[name];
      if (mod2 !== void 0) {
        return mod2.parse;
      }
      switch (name) {
        case "qs":
          mod2 = require_lib6();
          break;
        case "querystring":
          mod2 = require_querystring();
          break;
      }
      parsers[name] = mod2;
      return mod2.parse;
    }
    function simpleparser(options) {
      var parameterLimit = options.parameterLimit !== void 0 ? options.parameterLimit : 1e3;
      var parse2 = parser("querystring");
      if (isNaN(parameterLimit) || parameterLimit < 1) {
        throw new TypeError("option parameterLimit must be a positive number");
      }
      if (isFinite(parameterLimit)) {
        parameterLimit = parameterLimit | 0;
      }
      return function queryparse(body) {
        var paramCount = parameterCount(body, parameterLimit);
        if (paramCount === void 0) {
          debug("too many parameters");
          throw createError(413, "too many parameters", {
            type: "parameters.too.many"
          });
        }
        debug("parse urlencoding");
        return parse2(body, void 0, void 0, { maxKeys: parameterLimit });
      };
    }
    function typeChecker(type) {
      return function checkType(req) {
        return Boolean(typeis(req, type));
      };
    }
  }
});

// ../../../node_modules/express/node_modules/body-parser/index.js
var require_body_parser = __commonJS({
  "../../../node_modules/express/node_modules/body-parser/index.js"(exports2, module2) {
    "use strict";
    var deprecate = require_browser2()("body-parser");
    var parsers = /* @__PURE__ */ Object.create(null);
    exports2 = module2.exports = deprecate.function(
      bodyParser,
      "bodyParser: use individual json/urlencoded middlewares"
    );
    Object.defineProperty(exports2, "json", {
      configurable: true,
      enumerable: true,
      get: createParserGetter("json")
    });
    Object.defineProperty(exports2, "raw", {
      configurable: true,
      enumerable: true,
      get: createParserGetter("raw")
    });
    Object.defineProperty(exports2, "text", {
      configurable: true,
      enumerable: true,
      get: createParserGetter("text")
    });
    Object.defineProperty(exports2, "urlencoded", {
      configurable: true,
      enumerable: true,
      get: createParserGetter("urlencoded")
    });
    function bodyParser(options) {
      var opts = Object.create(options || null, {
        type: {
          configurable: true,
          enumerable: true,
          value: void 0,
          writable: true
        }
      });
      var _urlencoded = exports2.urlencoded(opts);
      var _json = exports2.json(opts);
      return function bodyParser2(req, res, next) {
        _json(req, res, function(err) {
          if (err)
            return next(err);
          _urlencoded(req, res, next);
        });
      };
    }
    function createParserGetter(name) {
      return function get() {
        return loadParser(name);
      };
    }
    function loadParser(parserName) {
      var parser = parsers[parserName];
      if (parser !== void 0) {
        return parser;
      }
      switch (parserName) {
        case "json":
          parser = require_json();
          break;
        case "raw":
          parser = require_raw();
          break;
        case "text":
          parser = require_text();
          break;
        case "urlencoded":
          parser = require_urlencoded();
          break;
      }
      return parsers[parserName] = parser;
    }
  }
});

// ../../../node_modules/merge-descriptors/index.js
var require_merge_descriptors = __commonJS({
  "../../../node_modules/merge-descriptors/index.js"(exports2, module2) {
    "use strict";
    module2.exports = merge;
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    function merge(dest, src, redefine) {
      if (!dest) {
        throw new TypeError("argument dest is required");
      }
      if (!src) {
        throw new TypeError("argument src is required");
      }
      if (redefine === void 0) {
        redefine = true;
      }
      Object.getOwnPropertyNames(src).forEach(function forEachOwnPropertyName(name) {
        if (!redefine && hasOwnProperty2.call(dest, name)) {
          return;
        }
        var descriptor = Object.getOwnPropertyDescriptor(src, name);
        Object.defineProperty(dest, name, descriptor);
      });
      return dest;
    }
  }
});

// ../../../node_modules/finalhandler/node_modules/ms/index.js
var require_ms2 = __commonJS({
  "../../../node_modules/finalhandler/node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse2(val);
      } else if (type === "number" && isNaN(val) === false) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse2(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      if (ms >= d) {
        return Math.round(ms / d) + "d";
      }
      if (ms >= h) {
        return Math.round(ms / h) + "h";
      }
      if (ms >= m) {
        return Math.round(ms / m) + "m";
      }
      if (ms >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      return plural(ms, d, "day") || plural(ms, h, "hour") || plural(ms, m, "minute") || plural(ms, s, "second") || ms + " ms";
    }
    function plural(ms, n, name) {
      if (ms < n) {
        return;
      }
      if (ms < n * 1.5) {
        return Math.floor(ms / n) + " " + name;
      }
      return Math.ceil(ms / n) + " " + name + "s";
    }
  }
});

// ../../../node_modules/finalhandler/node_modules/debug/src/debug.js
var require_debug2 = __commonJS({
  "../../../node_modules/finalhandler/node_modules/debug/src/debug.js"(exports2, module2) {
    exports2 = module2.exports = createDebug.debug = createDebug["default"] = createDebug;
    exports2.coerce = coerce;
    exports2.disable = disable;
    exports2.enable = enable;
    exports2.enabled = enabled;
    exports2.humanize = require_ms2();
    exports2.names = [];
    exports2.skips = [];
    exports2.formatters = {};
    var prevTime;
    function selectColor(namespace) {
      var hash = 0, i;
      for (i in namespace) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return exports2.colors[Math.abs(hash) % exports2.colors.length];
    }
    function createDebug(namespace) {
      function debug() {
        if (!debug.enabled)
          return;
        var self2 = debug;
        var curr = +/* @__PURE__ */ new Date();
        var ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        args[0] = exports2.coerce(args[0]);
        if ("string" !== typeof args[0]) {
          args.unshift("%O");
        }
        var index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
          if (match === "%%")
            return match;
          index++;
          var formatter = exports2.formatters[format];
          if ("function" === typeof formatter) {
            var val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        exports2.formatArgs.call(self2, args);
        var logFn = debug.log || exports2.log || console.log.bind(console);
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.enabled = exports2.enabled(namespace);
      debug.useColors = exports2.useColors();
      debug.color = selectColor(namespace);
      if ("function" === typeof exports2.init) {
        exports2.init(debug);
      }
      return debug;
    }
    function enable(namespaces) {
      exports2.save(namespaces);
      exports2.names = [];
      exports2.skips = [];
      var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      var len = split.length;
      for (var i = 0; i < len; i++) {
        if (!split[i])
          continue;
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          exports2.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          exports2.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      exports2.enable("");
    }
    function enabled(name) {
      var i, len;
      for (i = 0, len = exports2.skips.length; i < len; i++) {
        if (exports2.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = exports2.names.length; i < len; i++) {
        if (exports2.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error)
        return val.stack || val.message;
      return val;
    }
  }
});

// ../../../node_modules/finalhandler/node_modules/debug/src/browser.js
var require_browser4 = __commonJS({
  "../../../node_modules/finalhandler/node_modules/debug/src/browser.js"(exports2, module2) {
    exports2 = module2.exports = require_debug2();
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = "undefined" != typeof chrome && "undefined" != typeof chrome.storage ? chrome.storage.local : localstorage();
    exports2.colors = [
      "lightseagreen",
      "forestgreen",
      "goldenrod",
      "dodgerblue",
      "darkorchid",
      "crimson"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
        return true;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    exports2.formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (err) {
        return "[UnexpectedJSONParseError]: " + err.message;
      }
    };
    function formatArgs(args) {
      var useColors2 = this.useColors;
      args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports2.humanize(this.diff);
      if (!useColors2)
        return;
      var c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      var index = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function(match) {
        if ("%%" === match)
          return;
        index++;
        if ("%c" === match) {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    function log() {
      return "object" === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
    }
    function save(namespaces) {
      try {
        if (null == namespaces) {
          exports2.storage.removeItem("debug");
        } else {
          exports2.storage.debug = namespaces;
        }
      } catch (e) {
      }
    }
    function load() {
      var r;
      try {
        r = exports2.storage.debug;
      } catch (e) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    exports2.enable(load());
    function localstorage() {
      try {
        return window.localStorage;
      } catch (e) {
      }
    }
  }
});

// ../../../node_modules/encodeurl/index.js
var require_encodeurl = __commonJS({
  "../../../node_modules/encodeurl/index.js"(exports2, module2) {
    "use strict";
    module2.exports = encodeUrl;
    var ENCODE_CHARS_REGEXP = /(?:[^\x21\x25\x26-\x3B\x3D\x3F-\x5B\x5D\x5F\x61-\x7A\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g;
    var UNMATCHED_SURROGATE_PAIR_REGEXP = /(^|[^\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/g;
    var UNMATCHED_SURROGATE_PAIR_REPLACE = "$1$2";
    function encodeUrl(url) {
      return String(url).replace(UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE).replace(ENCODE_CHARS_REGEXP, encodeURI);
    }
  }
});

// ../../../node_modules/escape-html/index.js
var require_escape_html = __commonJS({
  "../../../node_modules/escape-html/index.js"(exports2, module2) {
    "use strict";
    var matchHtmlRegExp = /["'&<>]/;
    module2.exports = escapeHtml;
    function escapeHtml(string) {
      var str = "" + string;
      var match = matchHtmlRegExp.exec(str);
      if (!match) {
        return str;
      }
      var escape2;
      var html = "";
      var index = 0;
      var lastIndex = 0;
      for (index = match.index; index < str.length; index++) {
        switch (str.charCodeAt(index)) {
          case 34:
            escape2 = "&quot;";
            break;
          case 38:
            escape2 = "&amp;";
            break;
          case 39:
            escape2 = "&#39;";
            break;
          case 60:
            escape2 = "&lt;";
            break;
          case 62:
            escape2 = "&gt;";
            break;
          default:
            continue;
        }
        if (lastIndex !== index) {
          html += str.substring(lastIndex, index);
        }
        lastIndex = index + 1;
        html += escape2;
      }
      return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
    }
  }
});

// browser-external:url
var require_url = __commonJS({
  "browser-external:url"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "url" has been externalized for browser compatibility. Cannot access "url.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// ../../../node_modules/parseurl/index.js
var require_parseurl = __commonJS({
  "../../../node_modules/parseurl/index.js"(exports2, module2) {
    "use strict";
    var url = require_url();
    var parse2 = url.parse;
    var Url = url.Url;
    module2.exports = parseurl;
    module2.exports.original = originalurl;
    function parseurl(req) {
      var url2 = req.url;
      if (url2 === void 0) {
        return void 0;
      }
      var parsed = req._parsedUrl;
      if (fresh(url2, parsed)) {
        return parsed;
      }
      parsed = fastparse(url2);
      parsed._raw = url2;
      return req._parsedUrl = parsed;
    }
    function originalurl(req) {
      var url2 = req.originalUrl;
      if (typeof url2 !== "string") {
        return parseurl(req);
      }
      var parsed = req._parsedOriginalUrl;
      if (fresh(url2, parsed)) {
        return parsed;
      }
      parsed = fastparse(url2);
      parsed._raw = url2;
      return req._parsedOriginalUrl = parsed;
    }
    function fastparse(str) {
      if (typeof str !== "string" || str.charCodeAt(0) !== 47) {
        return parse2(str);
      }
      var pathname = str;
      var query = null;
      var search = null;
      for (var i = 1; i < str.length; i++) {
        switch (str.charCodeAt(i)) {
          case 63:
            if (search === null) {
              pathname = str.substring(0, i);
              query = str.substring(i + 1);
              search = str.substring(i);
            }
            break;
          case 9:
          case 10:
          case 12:
          case 13:
          case 32:
          case 35:
          case 160:
          case 65279:
            return parse2(str);
        }
      }
      var url2 = Url !== void 0 ? new Url() : {};
      url2.path = str;
      url2.href = str;
      url2.pathname = pathname;
      if (search !== null) {
        url2.query = query;
        url2.search = search;
      }
      return url2;
    }
    function fresh(url2, parsedUrl) {
      return typeof parsedUrl === "object" && parsedUrl !== null && (Url === void 0 || parsedUrl instanceof Url) && parsedUrl._raw === url2;
    }
  }
});

// ../../../node_modules/finalhandler/index.js
var require_finalhandler = __commonJS({
  "../../../node_modules/finalhandler/index.js"(exports2, module2) {
    "use strict";
    var debug = require_browser4()("finalhandler");
    var encodeUrl = require_encodeurl();
    var escapeHtml = require_escape_html();
    var onFinished = require_on_finished();
    var parseUrl = require_parseurl();
    var statuses = require_statuses();
    var unpipe = require_unpipe();
    var DOUBLE_SPACE_REGEXP = /\x20{2}/g;
    var NEWLINE_REGEXP = /\n/g;
    var defer = typeof setImmediate === "function" ? setImmediate : function(fn) {
      process.nextTick(fn.bind.apply(fn, arguments));
    };
    var isFinished = onFinished.isFinished;
    function createHtmlDocument(message) {
      var body = escapeHtml(message).replace(NEWLINE_REGEXP, "<br>").replace(DOUBLE_SPACE_REGEXP, " &nbsp;");
      return '<!DOCTYPE html>\n<html lang="en">\n<head>\n<meta charset="utf-8">\n<title>Error</title>\n</head>\n<body>\n<pre>' + body + "</pre>\n</body>\n</html>\n";
    }
    module2.exports = finalhandler;
    function finalhandler(req, res, options) {
      var opts = options || {};
      var env = opts.env || "development";
      var onerror = opts.onerror;
      return function(err) {
        var headers;
        var msg;
        var status;
        if (!err && headersSent(res)) {
          debug("cannot 404 after headers sent");
          return;
        }
        if (err) {
          status = getErrorStatusCode(err);
          if (status === void 0) {
            status = getResponseStatusCode(res);
          } else {
            headers = getErrorHeaders(err);
          }
          msg = getErrorMessage(err, status, env);
        } else {
          status = 404;
          msg = "Cannot " + req.method + " " + encodeUrl(getResourceName(req));
        }
        debug("default %s", status);
        if (err && onerror) {
          defer(onerror, err, req, res);
        }
        if (headersSent(res)) {
          debug("cannot %d after headers sent", status);
          req.socket.destroy();
          return;
        }
        send(req, res, status, headers, msg);
      };
    }
    function getErrorHeaders(err) {
      if (!err.headers || typeof err.headers !== "object") {
        return void 0;
      }
      var headers = /* @__PURE__ */ Object.create(null);
      var keys = Object.keys(err.headers);
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        headers[key] = err.headers[key];
      }
      return headers;
    }
    function getErrorMessage(err, status, env) {
      var msg;
      if (env !== "production") {
        msg = err.stack;
        if (!msg && typeof err.toString === "function") {
          msg = err.toString();
        }
      }
      return msg || statuses.message[status];
    }
    function getErrorStatusCode(err) {
      if (typeof err.status === "number" && err.status >= 400 && err.status < 600) {
        return err.status;
      }
      if (typeof err.statusCode === "number" && err.statusCode >= 400 && err.statusCode < 600) {
        return err.statusCode;
      }
      return void 0;
    }
    function getResourceName(req) {
      try {
        return parseUrl.original(req).pathname;
      } catch (e) {
        return "resource";
      }
    }
    function getResponseStatusCode(res) {
      var status = res.statusCode;
      if (typeof status !== "number" || status < 400 || status > 599) {
        status = 500;
      }
      return status;
    }
    function headersSent(res) {
      return typeof res.headersSent !== "boolean" ? Boolean(res._header) : res.headersSent;
    }
    function send(req, res, status, headers, message) {
      function write() {
        var body = createHtmlDocument(message);
        res.statusCode = status;
        res.statusMessage = statuses.message[status];
        res.removeHeader("Content-Encoding");
        res.removeHeader("Content-Language");
        res.removeHeader("Content-Range");
        setHeaders(res, headers);
        res.setHeader("Content-Security-Policy", "default-src 'none'");
        res.setHeader("X-Content-Type-Options", "nosniff");
        res.setHeader("Content-Type", "text/html; charset=utf-8");
        res.setHeader("Content-Length", Buffer.byteLength(body, "utf8"));
        if (req.method === "HEAD") {
          res.end();
          return;
        }
        res.end(body, "utf8");
      }
      if (isFinished(req)) {
        write();
        return;
      }
      unpipe(req);
      onFinished(req, write);
      req.resume();
    }
    function setHeaders(res, headers) {
      if (!headers) {
        return;
      }
      var keys = Object.keys(headers);
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        res.setHeader(key, headers[key]);
      }
    }
  }
});

// ../../../node_modules/array-flatten/array-flatten.js
var require_array_flatten = __commonJS({
  "../../../node_modules/array-flatten/array-flatten.js"(exports2, module2) {
    "use strict";
    module2.exports = arrayFlatten;
    function flattenWithDepth(array, result, depth) {
      for (var i = 0; i < array.length; i++) {
        var value = array[i];
        if (depth > 0 && Array.isArray(value)) {
          flattenWithDepth(value, result, depth - 1);
        } else {
          result.push(value);
        }
      }
      return result;
    }
    function flattenForever(array, result) {
      for (var i = 0; i < array.length; i++) {
        var value = array[i];
        if (Array.isArray(value)) {
          flattenForever(value, result);
        } else {
          result.push(value);
        }
      }
      return result;
    }
    function arrayFlatten(array, depth) {
      if (depth == null) {
        return flattenForever(array, []);
      }
      return flattenWithDepth(array, [], depth);
    }
  }
});

// ../../../node_modules/express/node_modules/path-to-regexp/index.js
var require_path_to_regexp = __commonJS({
  "../../../node_modules/express/node_modules/path-to-regexp/index.js"(exports2, module2) {
    module2.exports = pathtoRegexp;
    var MATCHING_GROUP_REGEXP = /\((?!\?)/g;
    function pathtoRegexp(path, keys, options) {
      options = options || {};
      keys = keys || [];
      var strict = options.strict;
      var end = options.end !== false;
      var flags = options.sensitive ? "" : "i";
      var extraOffset = 0;
      var keysOffset = keys.length;
      var i = 0;
      var name = 0;
      var m;
      if (path instanceof RegExp) {
        while (m = MATCHING_GROUP_REGEXP.exec(path.source)) {
          keys.push({
            name: name++,
            optional: false,
            offset: m.index
          });
        }
        return path;
      }
      if (Array.isArray(path)) {
        path = path.map(function(value) {
          return pathtoRegexp(value, keys, options).source;
        });
        return new RegExp("(?:" + path.join("|") + ")", flags);
      }
      path = ("^" + path + (strict ? "" : path[path.length - 1] === "/" ? "?" : "/?")).replace(/\/\(/g, "/(?:").replace(/([\/\.])/g, "\\$1").replace(/(\\\/)?(\\\.)?:(\w+)(\(.*?\))?(\*)?(\?)?/g, function(match, slash, format, key, capture, star, optional, offset) {
        slash = slash || "";
        format = format || "";
        capture = capture || "([^\\/" + format + "]+?)";
        optional = optional || "";
        keys.push({
          name: key,
          optional: !!optional,
          offset: offset + extraOffset
        });
        var result = "" + (optional ? "" : slash) + "(?:" + format + (optional ? slash : "") + capture + (star ? "((?:[\\/" + format + "].+?)?)" : "") + ")" + optional;
        extraOffset += result.length - match.length;
        return result;
      }).replace(/\*/g, function(star, index2) {
        var len = keys.length;
        while (len-- > keysOffset && keys[len].offset > index2) {
          keys[len].offset += 3;
        }
        return "(.*)";
      });
      while (m = MATCHING_GROUP_REGEXP.exec(path)) {
        var escapeCount = 0;
        var index = m.index;
        while (path.charAt(--index) === "\\") {
          escapeCount++;
        }
        if (escapeCount % 2 === 1) {
          continue;
        }
        if (keysOffset + i === keys.length || keys[keysOffset + i].offset > m.index) {
          keys.splice(keysOffset + i, 0, {
            name: name++,
            // Unnamed matching groups must be consistently linear.
            optional: false,
            offset: m.index
          });
        }
        i++;
      }
      path += end ? "$" : path[path.length - 1] === "/" ? "" : "(?=\\/|$)";
      return new RegExp(path, flags);
    }
  }
});

// ../../../node_modules/express/lib/router/layer.js
var require_layer = __commonJS({
  "../../../node_modules/express/lib/router/layer.js"(exports2, module2) {
    "use strict";
    var pathRegexp = require_path_to_regexp();
    var debug = require_browser3()("express:router:layer");
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    module2.exports = Layer;
    function Layer(path, options, fn) {
      if (!(this instanceof Layer)) {
        return new Layer(path, options, fn);
      }
      debug("new %o", path);
      var opts = options || {};
      this.handle = fn;
      this.name = fn.name || "<anonymous>";
      this.params = void 0;
      this.path = void 0;
      this.regexp = pathRegexp(path, this.keys = [], opts);
      this.regexp.fast_star = path === "*";
      this.regexp.fast_slash = path === "/" && opts.end === false;
    }
    Layer.prototype.handle_error = function handle_error(error, req, res, next) {
      var fn = this.handle;
      if (fn.length !== 4) {
        return next(error);
      }
      try {
        fn(error, req, res, next);
      } catch (err) {
        next(err);
      }
    };
    Layer.prototype.handle_request = function handle(req, res, next) {
      var fn = this.handle;
      if (fn.length > 3) {
        return next();
      }
      try {
        fn(req, res, next);
      } catch (err) {
        next(err);
      }
    };
    Layer.prototype.match = function match(path) {
      var match2;
      if (path != null) {
        if (this.regexp.fast_slash) {
          this.params = {};
          this.path = "";
          return true;
        }
        if (this.regexp.fast_star) {
          this.params = { "0": decode_param(path) };
          this.path = path;
          return true;
        }
        match2 = this.regexp.exec(path);
      }
      if (!match2) {
        this.params = void 0;
        this.path = void 0;
        return false;
      }
      this.params = {};
      this.path = match2[0];
      var keys = this.keys;
      var params = this.params;
      for (var i = 1; i < match2.length; i++) {
        var key = keys[i - 1];
        var prop = key.name;
        var val = decode_param(match2[i]);
        if (val !== void 0 || !hasOwnProperty2.call(params, prop)) {
          params[prop] = val;
        }
      }
      return true;
    };
    function decode_param(val) {
      if (typeof val !== "string" || val.length === 0) {
        return val;
      }
      try {
        return decodeURIComponent(val);
      } catch (err) {
        if (err instanceof URIError) {
          err.message = "Failed to decode param '" + val + "'";
          err.status = err.statusCode = 400;
        }
        throw err;
      }
    }
  }
});

// browser-external:http
var require_http = __commonJS({
  "browser-external:http"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "http" has been externalized for browser compatibility. Cannot access "http.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// ../../../node_modules/methods/index.js
var require_methods = __commonJS({
  "../../../node_modules/methods/index.js"(exports2, module2) {
    "use strict";
    var http = require_http();
    module2.exports = getCurrentNodeMethods() || getBasicNodeMethods();
    function getCurrentNodeMethods() {
      return http.METHODS && http.METHODS.map(function lowerCaseMethod(method) {
        return method.toLowerCase();
      });
    }
    function getBasicNodeMethods() {
      return [
        "get",
        "post",
        "put",
        "head",
        "delete",
        "options",
        "trace",
        "copy",
        "lock",
        "mkcol",
        "move",
        "purge",
        "propfind",
        "proppatch",
        "unlock",
        "report",
        "mkactivity",
        "checkout",
        "merge",
        "m-search",
        "notify",
        "subscribe",
        "unsubscribe",
        "patch",
        "search",
        "connect"
      ];
    }
  }
});

// ../../../node_modules/express/lib/router/route.js
var require_route = __commonJS({
  "../../../node_modules/express/lib/router/route.js"(exports2, module2) {
    "use strict";
    var debug = require_browser3()("express:router:route");
    var flatten = require_array_flatten();
    var Layer = require_layer();
    var methods = require_methods();
    var slice = Array.prototype.slice;
    var toString = Object.prototype.toString;
    module2.exports = Route;
    function Route(path) {
      this.path = path;
      this.stack = [];
      debug("new %o", path);
      this.methods = {};
    }
    Route.prototype._handles_method = function _handles_method(method) {
      if (this.methods._all) {
        return true;
      }
      var name = method.toLowerCase();
      if (name === "head" && !this.methods["head"]) {
        name = "get";
      }
      return Boolean(this.methods[name]);
    };
    Route.prototype._options = function _options() {
      var methods2 = Object.keys(this.methods);
      if (this.methods.get && !this.methods.head) {
        methods2.push("head");
      }
      for (var i = 0; i < methods2.length; i++) {
        methods2[i] = methods2[i].toUpperCase();
      }
      return methods2;
    };
    Route.prototype.dispatch = function dispatch(req, res, done) {
      var idx = 0;
      var stack = this.stack;
      var sync = 0;
      if (stack.length === 0) {
        return done();
      }
      var method = req.method.toLowerCase();
      if (method === "head" && !this.methods["head"]) {
        method = "get";
      }
      req.route = this;
      next();
      function next(err) {
        if (err && err === "route") {
          return done();
        }
        if (err && err === "router") {
          return done(err);
        }
        if (++sync > 100) {
          return setImmediate(next, err);
        }
        var layer = stack[idx++];
        if (!layer) {
          return done(err);
        }
        if (layer.method && layer.method !== method) {
          next(err);
        } else if (err) {
          layer.handle_error(err, req, res, next);
        } else {
          layer.handle_request(req, res, next);
        }
        sync = 0;
      }
    };
    Route.prototype.all = function all() {
      var handles = flatten(slice.call(arguments));
      for (var i = 0; i < handles.length; i++) {
        var handle = handles[i];
        if (typeof handle !== "function") {
          var type = toString.call(handle);
          var msg = "Route.all() requires a callback function but got a " + type;
          throw new TypeError(msg);
        }
        var layer = Layer("/", {}, handle);
        layer.method = void 0;
        this.methods._all = true;
        this.stack.push(layer);
      }
      return this;
    };
    methods.forEach(function(method) {
      Route.prototype[method] = function() {
        var handles = flatten(slice.call(arguments));
        for (var i = 0; i < handles.length; i++) {
          var handle = handles[i];
          if (typeof handle !== "function") {
            var type = toString.call(handle);
            var msg = "Route." + method + "() requires a callback function but got a " + type;
            throw new Error(msg);
          }
          debug("%s %o", method, this.path);
          var layer = Layer("/", {}, handle);
          layer.method = method;
          this.methods[method] = true;
          this.stack.push(layer);
        }
        return this;
      };
    });
  }
});

// ../../../node_modules/utils-merge/index.js
var require_utils_merge = __commonJS({
  "../../../node_modules/utils-merge/index.js"(exports2, module2) {
    exports2 = module2.exports = function(a, b) {
      if (a && b) {
        for (var key in b) {
          a[key] = b[key];
        }
      }
      return a;
    };
  }
});

// ../../../node_modules/express/lib/router/index.js
var require_router = __commonJS({
  "../../../node_modules/express/lib/router/index.js"(exports2, module2) {
    "use strict";
    var Route = require_route();
    var Layer = require_layer();
    var methods = require_methods();
    var mixin = require_utils_merge();
    var debug = require_browser3()("express:router");
    var deprecate = require_browser2()("express");
    var flatten = require_array_flatten();
    var parseUrl = require_parseurl();
    var setPrototypeOf = require_setprototypeof();
    var objectRegExp = /^\[object (\S+)\]$/;
    var slice = Array.prototype.slice;
    var toString = Object.prototype.toString;
    var proto = module2.exports = function(options) {
      var opts = options || {};
      function router(req, res, next) {
        router.handle(req, res, next);
      }
      setPrototypeOf(router, proto);
      router.params = {};
      router._params = [];
      router.caseSensitive = opts.caseSensitive;
      router.mergeParams = opts.mergeParams;
      router.strict = opts.strict;
      router.stack = [];
      return router;
    };
    proto.param = function param(name, fn) {
      if (typeof name === "function") {
        deprecate("router.param(fn): Refactor to use path params");
        this._params.push(name);
        return;
      }
      var params = this._params;
      var len = params.length;
      var ret;
      if (name[0] === ":") {
        deprecate("router.param(" + JSON.stringify(name) + ", fn): Use router.param(" + JSON.stringify(name.slice(1)) + ", fn) instead");
        name = name.slice(1);
      }
      for (var i = 0; i < len; ++i) {
        if (ret = params[i](name, fn)) {
          fn = ret;
        }
      }
      if ("function" !== typeof fn) {
        throw new Error("invalid param() call for " + name + ", got " + fn);
      }
      (this.params[name] = this.params[name] || []).push(fn);
      return this;
    };
    proto.handle = function handle(req, res, out) {
      var self2 = this;
      debug("dispatching %s %s", req.method, req.url);
      var idx = 0;
      var protohost = getProtohost(req.url) || "";
      var removed = "";
      var slashAdded = false;
      var sync = 0;
      var paramcalled = {};
      var options = [];
      var stack = self2.stack;
      var parentParams = req.params;
      var parentUrl = req.baseUrl || "";
      var done = restore(out, req, "baseUrl", "next", "params");
      req.next = next;
      if (req.method === "OPTIONS") {
        done = wrap2(done, function(old, err) {
          if (err || options.length === 0)
            return old(err);
          sendOptionsResponse(res, options, old);
        });
      }
      req.baseUrl = parentUrl;
      req.originalUrl = req.originalUrl || req.url;
      next();
      function next(err) {
        var layerError = err === "route" ? null : err;
        if (slashAdded) {
          req.url = req.url.slice(1);
          slashAdded = false;
        }
        if (removed.length !== 0) {
          req.baseUrl = parentUrl;
          req.url = protohost + removed + req.url.slice(protohost.length);
          removed = "";
        }
        if (layerError === "router") {
          setImmediate(done, null);
          return;
        }
        if (idx >= stack.length) {
          setImmediate(done, layerError);
          return;
        }
        if (++sync > 100) {
          return setImmediate(next, err);
        }
        var path = getPathname(req);
        if (path == null) {
          return done(layerError);
        }
        var layer;
        var match;
        var route;
        while (match !== true && idx < stack.length) {
          layer = stack[idx++];
          match = matchLayer(layer, path);
          route = layer.route;
          if (typeof match !== "boolean") {
            layerError = layerError || match;
          }
          if (match !== true) {
            continue;
          }
          if (!route) {
            continue;
          }
          if (layerError) {
            match = false;
            continue;
          }
          var method = req.method;
          var has_method = route._handles_method(method);
          if (!has_method && method === "OPTIONS") {
            appendMethods(options, route._options());
          }
          if (!has_method && method !== "HEAD") {
            match = false;
          }
        }
        if (match !== true) {
          return done(layerError);
        }
        if (route) {
          req.route = route;
        }
        req.params = self2.mergeParams ? mergeParams(layer.params, parentParams) : layer.params;
        var layerPath = layer.path;
        self2.process_params(layer, paramcalled, req, res, function(err2) {
          if (err2) {
            next(layerError || err2);
          } else if (route) {
            layer.handle_request(req, res, next);
          } else {
            trim_prefix(layer, layerError, layerPath, path);
          }
          sync = 0;
        });
      }
      function trim_prefix(layer, layerError, layerPath, path) {
        if (layerPath.length !== 0) {
          if (layerPath !== path.slice(0, layerPath.length)) {
            next(layerError);
            return;
          }
          var c = path[layerPath.length];
          if (c && c !== "/" && c !== ".")
            return next(layerError);
          debug("trim prefix (%s) from url %s", layerPath, req.url);
          removed = layerPath;
          req.url = protohost + req.url.slice(protohost.length + removed.length);
          if (!protohost && req.url[0] !== "/") {
            req.url = "/" + req.url;
            slashAdded = true;
          }
          req.baseUrl = parentUrl + (removed[removed.length - 1] === "/" ? removed.substring(0, removed.length - 1) : removed);
        }
        debug("%s %s : %s", layer.name, layerPath, req.originalUrl);
        if (layerError) {
          layer.handle_error(layerError, req, res, next);
        } else {
          layer.handle_request(req, res, next);
        }
      }
    };
    proto.process_params = function process_params(layer, called, req, res, done) {
      var params = this.params;
      var keys = layer.keys;
      if (!keys || keys.length === 0) {
        return done();
      }
      var i = 0;
      var name;
      var paramIndex = 0;
      var key;
      var paramVal;
      var paramCallbacks;
      var paramCalled;
      function param(err) {
        if (err) {
          return done(err);
        }
        if (i >= keys.length) {
          return done();
        }
        paramIndex = 0;
        key = keys[i++];
        name = key.name;
        paramVal = req.params[name];
        paramCallbacks = params[name];
        paramCalled = called[name];
        if (paramVal === void 0 || !paramCallbacks) {
          return param();
        }
        if (paramCalled && (paramCalled.match === paramVal || paramCalled.error && paramCalled.error !== "route")) {
          req.params[name] = paramCalled.value;
          return param(paramCalled.error);
        }
        called[name] = paramCalled = {
          error: null,
          match: paramVal,
          value: paramVal
        };
        paramCallback();
      }
      function paramCallback(err) {
        var fn = paramCallbacks[paramIndex++];
        paramCalled.value = req.params[key.name];
        if (err) {
          paramCalled.error = err;
          param(err);
          return;
        }
        if (!fn)
          return param();
        try {
          fn(req, res, paramCallback, paramVal, key.name);
        } catch (e) {
          paramCallback(e);
        }
      }
      param();
    };
    proto.use = function use(fn) {
      var offset = 0;
      var path = "/";
      if (typeof fn !== "function") {
        var arg = fn;
        while (Array.isArray(arg) && arg.length !== 0) {
          arg = arg[0];
        }
        if (typeof arg !== "function") {
          offset = 1;
          path = fn;
        }
      }
      var callbacks = flatten(slice.call(arguments, offset));
      if (callbacks.length === 0) {
        throw new TypeError("Router.use() requires a middleware function");
      }
      for (var i = 0; i < callbacks.length; i++) {
        var fn = callbacks[i];
        if (typeof fn !== "function") {
          throw new TypeError("Router.use() requires a middleware function but got a " + gettype(fn));
        }
        debug("use %o %s", path, fn.name || "<anonymous>");
        var layer = new Layer(path, {
          sensitive: this.caseSensitive,
          strict: false,
          end: false
        }, fn);
        layer.route = void 0;
        this.stack.push(layer);
      }
      return this;
    };
    proto.route = function route(path) {
      var route2 = new Route(path);
      var layer = new Layer(path, {
        sensitive: this.caseSensitive,
        strict: this.strict,
        end: true
      }, route2.dispatch.bind(route2));
      layer.route = route2;
      this.stack.push(layer);
      return route2;
    };
    methods.concat("all").forEach(function(method) {
      proto[method] = function(path) {
        var route = this.route(path);
        route[method].apply(route, slice.call(arguments, 1));
        return this;
      };
    });
    function appendMethods(list, addition) {
      for (var i = 0; i < addition.length; i++) {
        var method = addition[i];
        if (list.indexOf(method) === -1) {
          list.push(method);
        }
      }
    }
    function getPathname(req) {
      try {
        return parseUrl(req).pathname;
      } catch (err) {
        return void 0;
      }
    }
    function getProtohost(url) {
      if (typeof url !== "string" || url.length === 0 || url[0] === "/") {
        return void 0;
      }
      var searchIndex = url.indexOf("?");
      var pathLength = searchIndex !== -1 ? searchIndex : url.length;
      var fqdnIndex = url.slice(0, pathLength).indexOf("://");
      return fqdnIndex !== -1 ? url.substring(0, url.indexOf("/", 3 + fqdnIndex)) : void 0;
    }
    function gettype(obj) {
      var type = typeof obj;
      if (type !== "object") {
        return type;
      }
      return toString.call(obj).replace(objectRegExp, "$1");
    }
    function matchLayer(layer, path) {
      try {
        return layer.match(path);
      } catch (err) {
        return err;
      }
    }
    function mergeParams(params, parent) {
      if (typeof parent !== "object" || !parent) {
        return params;
      }
      var obj = mixin({}, parent);
      if (!(0 in params) || !(0 in parent)) {
        return mixin(obj, params);
      }
      var i = 0;
      var o = 0;
      while (i in params) {
        i++;
      }
      while (o in parent) {
        o++;
      }
      for (i--; i >= 0; i--) {
        params[i + o] = params[i];
        if (i < o) {
          delete params[i];
        }
      }
      return mixin(obj, params);
    }
    function restore(fn, obj) {
      var props = new Array(arguments.length - 2);
      var vals = new Array(arguments.length - 2);
      for (var i = 0; i < props.length; i++) {
        props[i] = arguments[i + 2];
        vals[i] = obj[props[i]];
      }
      return function() {
        for (var i2 = 0; i2 < props.length; i2++) {
          obj[props[i2]] = vals[i2];
        }
        return fn.apply(this, arguments);
      };
    }
    function sendOptionsResponse(res, options, next) {
      try {
        var body = options.join(",");
        res.set("Allow", body);
        res.send(body);
      } catch (err) {
        next(err);
      }
    }
    function wrap2(old, fn) {
      return function proxy() {
        var args = new Array(arguments.length + 1);
        args[0] = old;
        for (var i = 0, len = arguments.length; i < len; i++) {
          args[i + 1] = arguments[i];
        }
        fn.apply(this, args);
      };
    }
  }
});

// ../../../node_modules/express/lib/middleware/init.js
var require_init = __commonJS({
  "../../../node_modules/express/lib/middleware/init.js"(exports2) {
    "use strict";
    var setPrototypeOf = require_setprototypeof();
    exports2.init = function(app2) {
      return function expressInit(req, res, next) {
        if (app2.enabled("x-powered-by"))
          res.setHeader("X-Powered-By", "Express");
        req.res = res;
        res.req = req;
        req.next = next;
        setPrototypeOf(req, app2.request);
        setPrototypeOf(res, app2.response);
        res.locals = res.locals || /* @__PURE__ */ Object.create(null);
        next();
      };
    };
  }
});

// ../../../node_modules/express/lib/middleware/query.js
var require_query = __commonJS({
  "../../../node_modules/express/lib/middleware/query.js"(exports2, module2) {
    "use strict";
    var merge = require_utils_merge();
    var parseUrl = require_parseurl();
    var qs = require_lib6();
    module2.exports = function query(options) {
      var opts = merge({}, options);
      var queryparse = qs.parse;
      if (typeof options === "function") {
        queryparse = options;
        opts = void 0;
      }
      if (opts !== void 0 && opts.allowPrototypes === void 0) {
        opts.allowPrototypes = true;
      }
      return function query2(req, res, next) {
        if (!req.query) {
          var val = parseUrl(req).query;
          req.query = queryparse(val, opts);
        }
        next();
      };
    };
  }
});

// ../../../node_modules/express/lib/view.js
var require_view = __commonJS({
  "../../../node_modules/express/lib/view.js"(exports2, module2) {
    "use strict";
    var debug = require_browser3()("express:view");
    var path = require_path();
    var fs = require_fs();
    var dirname = path.dirname;
    var basename = path.basename;
    var extname = path.extname;
    var join2 = path.join;
    var resolve = path.resolve;
    module2.exports = View;
    function View(name, options) {
      var opts = options || {};
      this.defaultEngine = opts.defaultEngine;
      this.ext = extname(name);
      this.name = name;
      this.root = opts.root;
      if (!this.ext && !this.defaultEngine) {
        throw new Error("No default engine was specified and no extension was provided.");
      }
      var fileName = name;
      if (!this.ext) {
        this.ext = this.defaultEngine[0] !== "." ? "." + this.defaultEngine : this.defaultEngine;
        fileName += this.ext;
      }
      if (!opts.engines[this.ext]) {
        var mod2 = this.ext.slice(1);
        debug('require "%s"', mod2);
        var fn = __require(mod2).__express;
        if (typeof fn !== "function") {
          throw new Error('Module "' + mod2 + '" does not provide a view engine.');
        }
        opts.engines[this.ext] = fn;
      }
      this.engine = opts.engines[this.ext];
      this.path = this.lookup(fileName);
    }
    View.prototype.lookup = function lookup(name) {
      var path2;
      var roots = [].concat(this.root);
      debug('lookup "%s"', name);
      for (var i = 0; i < roots.length && !path2; i++) {
        var root = roots[i];
        var loc = resolve(root, name);
        var dir = dirname(loc);
        var file = basename(loc);
        path2 = this.resolve(dir, file);
      }
      return path2;
    };
    View.prototype.render = function render(options, callback) {
      debug('render "%s"', this.path);
      this.engine(this.path, options, callback);
    };
    View.prototype.resolve = function resolve2(dir, file) {
      var ext = this.ext;
      var path2 = join2(dir, file);
      var stat = tryStat(path2);
      if (stat && stat.isFile()) {
        return path2;
      }
      path2 = join2(dir, basename(file, ext), "index" + ext);
      stat = tryStat(path2);
      if (stat && stat.isFile()) {
        return path2;
      }
    };
    function tryStat(path2) {
      debug('stat "%s"', path2);
      try {
        return fs.statSync(path2);
      } catch (e) {
        return void 0;
      }
    }
  }
});

// ../../../node_modules/content-disposition/index.js
var require_content_disposition = __commonJS({
  "../../../node_modules/content-disposition/index.js"(exports2, module2) {
    "use strict";
    module2.exports = contentDisposition;
    module2.exports.parse = parse2;
    var basename = require_path().basename;
    var Buffer2 = require_safe_buffer().Buffer;
    var ENCODE_URL_ATTR_CHAR_REGEXP = /[\x00-\x20"'()*,/:;<=>?@[\\\]{}\x7f]/g;
    var HEX_ESCAPE_REGEXP = /%[0-9A-Fa-f]{2}/;
    var HEX_ESCAPE_REPLACE_REGEXP = /%([0-9A-Fa-f]{2})/g;
    var NON_LATIN1_REGEXP = /[^\x20-\x7e\xa0-\xff]/g;
    var QESC_REGEXP = /\\([\u0000-\u007f])/g;
    var QUOTE_REGEXP = /([\\"])/g;
    var PARAM_REGEXP = /;[\x09\x20]*([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*=[\x09\x20]*("(?:[\x20!\x23-\x5b\x5d-\x7e\x80-\xff]|\\[\x20-\x7e])*"|[!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*/g;
    var TEXT_REGEXP = /^[\x20-\x7e\x80-\xff]+$/;
    var TOKEN_REGEXP = /^[!#$%&'*+.0-9A-Z^_`a-z|~-]+$/;
    var EXT_VALUE_REGEXP = /^([A-Za-z0-9!#$%&+\-^_`{}~]+)'(?:[A-Za-z]{2,3}(?:-[A-Za-z]{3}){0,3}|[A-Za-z]{4,8}|)'((?:%[0-9A-Fa-f]{2}|[A-Za-z0-9!#$&+.^_`|~-])+)$/;
    var DISPOSITION_TYPE_REGEXP = /^([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*(?:$|;)/;
    function contentDisposition(filename, options) {
      var opts = options || {};
      var type = opts.type || "attachment";
      var params = createparams(filename, opts.fallback);
      return format(new ContentDisposition(type, params));
    }
    function createparams(filename, fallback) {
      if (filename === void 0) {
        return;
      }
      var params = {};
      if (typeof filename !== "string") {
        throw new TypeError("filename must be a string");
      }
      if (fallback === void 0) {
        fallback = true;
      }
      if (typeof fallback !== "string" && typeof fallback !== "boolean") {
        throw new TypeError("fallback must be a string or boolean");
      }
      if (typeof fallback === "string" && NON_LATIN1_REGEXP.test(fallback)) {
        throw new TypeError("fallback must be ISO-8859-1 string");
      }
      var name = basename(filename);
      var isQuotedString = TEXT_REGEXP.test(name);
      var fallbackName = typeof fallback !== "string" ? fallback && getlatin1(name) : basename(fallback);
      var hasFallback = typeof fallbackName === "string" && fallbackName !== name;
      if (hasFallback || !isQuotedString || HEX_ESCAPE_REGEXP.test(name)) {
        params["filename*"] = name;
      }
      if (isQuotedString || hasFallback) {
        params.filename = hasFallback ? fallbackName : name;
      }
      return params;
    }
    function format(obj) {
      var parameters = obj.parameters;
      var type = obj.type;
      if (!type || typeof type !== "string" || !TOKEN_REGEXP.test(type)) {
        throw new TypeError("invalid type");
      }
      var string = String(type).toLowerCase();
      if (parameters && typeof parameters === "object") {
        var param;
        var params = Object.keys(parameters).sort();
        for (var i = 0; i < params.length; i++) {
          param = params[i];
          var val = param.substr(-1) === "*" ? ustring(parameters[param]) : qstring(parameters[param]);
          string += "; " + param + "=" + val;
        }
      }
      return string;
    }
    function decodefield(str) {
      var match = EXT_VALUE_REGEXP.exec(str);
      if (!match) {
        throw new TypeError("invalid extended field value");
      }
      var charset = match[1].toLowerCase();
      var encoded = match[2];
      var value;
      var binary = encoded.replace(HEX_ESCAPE_REPLACE_REGEXP, pdecode);
      switch (charset) {
        case "iso-8859-1":
          value = getlatin1(binary);
          break;
        case "utf-8":
          value = Buffer2.from(binary, "binary").toString("utf8");
          break;
        default:
          throw new TypeError("unsupported charset in extended field");
      }
      return value;
    }
    function getlatin1(val) {
      return String(val).replace(NON_LATIN1_REGEXP, "?");
    }
    function parse2(string) {
      if (!string || typeof string !== "string") {
        throw new TypeError("argument string is required");
      }
      var match = DISPOSITION_TYPE_REGEXP.exec(string);
      if (!match) {
        throw new TypeError("invalid type format");
      }
      var index = match[0].length;
      var type = match[1].toLowerCase();
      var key;
      var names = [];
      var params = {};
      var value;
      index = PARAM_REGEXP.lastIndex = match[0].substr(-1) === ";" ? index - 1 : index;
      while (match = PARAM_REGEXP.exec(string)) {
        if (match.index !== index) {
          throw new TypeError("invalid parameter format");
        }
        index += match[0].length;
        key = match[1].toLowerCase();
        value = match[2];
        if (names.indexOf(key) !== -1) {
          throw new TypeError("invalid duplicate parameter");
        }
        names.push(key);
        if (key.indexOf("*") + 1 === key.length) {
          key = key.slice(0, -1);
          value = decodefield(value);
          params[key] = value;
          continue;
        }
        if (typeof params[key] === "string") {
          continue;
        }
        if (value[0] === '"') {
          value = value.substr(1, value.length - 2).replace(QESC_REGEXP, "$1");
        }
        params[key] = value;
      }
      if (index !== -1 && index !== string.length) {
        throw new TypeError("invalid parameter format");
      }
      return new ContentDisposition(type, params);
    }
    function pdecode(str, hex) {
      return String.fromCharCode(parseInt(hex, 16));
    }
    function pencode(char) {
      return "%" + String(char).charCodeAt(0).toString(16).toUpperCase();
    }
    function qstring(val) {
      var str = String(val);
      return '"' + str.replace(QUOTE_REGEXP, "\\$1") + '"';
    }
    function ustring(val) {
      var str = String(val);
      var encoded = encodeURIComponent(str).replace(ENCODE_URL_ATTR_CHAR_REGEXP, pencode);
      return "UTF-8''" + encoded;
    }
    function ContentDisposition(type, parameters) {
      this.type = type;
      this.parameters = parameters;
    }
  }
});

// ../../../node_modules/send/node_modules/debug/node_modules/ms/index.js
var require_ms3 = __commonJS({
  "../../../node_modules/send/node_modules/debug/node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse2(val);
      } else if (type === "number" && isNaN(val) === false) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse2(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      if (ms >= d) {
        return Math.round(ms / d) + "d";
      }
      if (ms >= h) {
        return Math.round(ms / h) + "h";
      }
      if (ms >= m) {
        return Math.round(ms / m) + "m";
      }
      if (ms >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      return plural(ms, d, "day") || plural(ms, h, "hour") || plural(ms, m, "minute") || plural(ms, s, "second") || ms + " ms";
    }
    function plural(ms, n, name) {
      if (ms < n) {
        return;
      }
      if (ms < n * 1.5) {
        return Math.floor(ms / n) + " " + name;
      }
      return Math.ceil(ms / n) + " " + name + "s";
    }
  }
});

// ../../../node_modules/send/node_modules/debug/src/debug.js
var require_debug3 = __commonJS({
  "../../../node_modules/send/node_modules/debug/src/debug.js"(exports2, module2) {
    exports2 = module2.exports = createDebug.debug = createDebug["default"] = createDebug;
    exports2.coerce = coerce;
    exports2.disable = disable;
    exports2.enable = enable;
    exports2.enabled = enabled;
    exports2.humanize = require_ms3();
    exports2.names = [];
    exports2.skips = [];
    exports2.formatters = {};
    var prevTime;
    function selectColor(namespace) {
      var hash = 0, i;
      for (i in namespace) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return exports2.colors[Math.abs(hash) % exports2.colors.length];
    }
    function createDebug(namespace) {
      function debug() {
        if (!debug.enabled)
          return;
        var self2 = debug;
        var curr = +/* @__PURE__ */ new Date();
        var ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        args[0] = exports2.coerce(args[0]);
        if ("string" !== typeof args[0]) {
          args.unshift("%O");
        }
        var index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
          if (match === "%%")
            return match;
          index++;
          var formatter = exports2.formatters[format];
          if ("function" === typeof formatter) {
            var val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        exports2.formatArgs.call(self2, args);
        var logFn = debug.log || exports2.log || console.log.bind(console);
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.enabled = exports2.enabled(namespace);
      debug.useColors = exports2.useColors();
      debug.color = selectColor(namespace);
      if ("function" === typeof exports2.init) {
        exports2.init(debug);
      }
      return debug;
    }
    function enable(namespaces) {
      exports2.save(namespaces);
      exports2.names = [];
      exports2.skips = [];
      var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      var len = split.length;
      for (var i = 0; i < len; i++) {
        if (!split[i])
          continue;
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          exports2.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          exports2.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      exports2.enable("");
    }
    function enabled(name) {
      var i, len;
      for (i = 0, len = exports2.skips.length; i < len; i++) {
        if (exports2.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = exports2.names.length; i < len; i++) {
        if (exports2.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error)
        return val.stack || val.message;
      return val;
    }
  }
});

// ../../../node_modules/send/node_modules/debug/src/browser.js
var require_browser5 = __commonJS({
  "../../../node_modules/send/node_modules/debug/src/browser.js"(exports2, module2) {
    exports2 = module2.exports = require_debug3();
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = "undefined" != typeof chrome && "undefined" != typeof chrome.storage ? chrome.storage.local : localstorage();
    exports2.colors = [
      "lightseagreen",
      "forestgreen",
      "goldenrod",
      "dodgerblue",
      "darkorchid",
      "crimson"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
        return true;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    exports2.formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (err) {
        return "[UnexpectedJSONParseError]: " + err.message;
      }
    };
    function formatArgs(args) {
      var useColors2 = this.useColors;
      args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports2.humanize(this.diff);
      if (!useColors2)
        return;
      var c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      var index = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function(match) {
        if ("%%" === match)
          return;
        index++;
        if ("%c" === match) {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    function log() {
      return "object" === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
    }
    function save(namespaces) {
      try {
        if (null == namespaces) {
          exports2.storage.removeItem("debug");
        } else {
          exports2.storage.debug = namespaces;
        }
      } catch (e) {
      }
    }
    function load() {
      var r;
      try {
        r = exports2.storage.debug;
      } catch (e) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    exports2.enable(load());
    function localstorage() {
      try {
        return window.localStorage;
      } catch (e) {
      }
    }
  }
});

// ../../../node_modules/etag/index.js
var require_etag = __commonJS({
  "../../../node_modules/etag/index.js"(exports2, module2) {
    "use strict";
    module2.exports = etag;
    var crypto2 = require_crypto();
    var Stats = require_fs().Stats;
    var toString = Object.prototype.toString;
    function entitytag(entity) {
      if (entity.length === 0) {
        return '"0-2jmj7l5rSw0yVb/vlWAYkK/YBwk"';
      }
      var hash = crypto2.createHash("sha1").update(entity, "utf8").digest("base64").substring(0, 27);
      var len = typeof entity === "string" ? Buffer.byteLength(entity, "utf8") : entity.length;
      return '"' + len.toString(16) + "-" + hash + '"';
    }
    function etag(entity, options) {
      if (entity == null) {
        throw new TypeError("argument entity is required");
      }
      var isStats = isstats(entity);
      var weak = options && typeof options.weak === "boolean" ? options.weak : isStats;
      if (!isStats && typeof entity !== "string" && !Buffer.isBuffer(entity)) {
        throw new TypeError("argument entity must be string, Buffer, or fs.Stats");
      }
      var tag = isStats ? stattag(entity) : entitytag(entity);
      return weak ? "W/" + tag : tag;
    }
    function isstats(obj) {
      if (typeof Stats === "function" && obj instanceof Stats) {
        return true;
      }
      return obj && typeof obj === "object" && "ctime" in obj && toString.call(obj.ctime) === "[object Date]" && "mtime" in obj && toString.call(obj.mtime) === "[object Date]" && "ino" in obj && typeof obj.ino === "number" && "size" in obj && typeof obj.size === "number";
    }
    function stattag(stat) {
      var mtime = stat.mtime.getTime().toString(16);
      var size = stat.size.toString(16);
      return '"' + size + "-" + mtime + '"';
    }
  }
});

// ../../../node_modules/fresh/index.js
var require_fresh = __commonJS({
  "../../../node_modules/fresh/index.js"(exports2, module2) {
    "use strict";
    var CACHE_CONTROL_NO_CACHE_REGEXP = /(?:^|,)\s*?no-cache\s*?(?:,|$)/;
    module2.exports = fresh;
    function fresh(reqHeaders, resHeaders) {
      var modifiedSince = reqHeaders["if-modified-since"];
      var noneMatch = reqHeaders["if-none-match"];
      if (!modifiedSince && !noneMatch) {
        return false;
      }
      var cacheControl = reqHeaders["cache-control"];
      if (cacheControl && CACHE_CONTROL_NO_CACHE_REGEXP.test(cacheControl)) {
        return false;
      }
      if (noneMatch && noneMatch !== "*") {
        var etag = resHeaders["etag"];
        if (!etag) {
          return false;
        }
        var etagStale = true;
        var matches = parseTokenList(noneMatch);
        for (var i = 0; i < matches.length; i++) {
          var match = matches[i];
          if (match === etag || match === "W/" + etag || "W/" + match === etag) {
            etagStale = false;
            break;
          }
        }
        if (etagStale) {
          return false;
        }
      }
      if (modifiedSince) {
        var lastModified = resHeaders["last-modified"];
        var modifiedStale = !lastModified || !(parseHttpDate(lastModified) <= parseHttpDate(modifiedSince));
        if (modifiedStale) {
          return false;
        }
      }
      return true;
    }
    function parseHttpDate(date) {
      var timestamp = date && Date.parse(date);
      return typeof timestamp === "number" ? timestamp : NaN;
    }
    function parseTokenList(str) {
      var end = 0;
      var list = [];
      var start = 0;
      for (var i = 0, len = str.length; i < len; i++) {
        switch (str.charCodeAt(i)) {
          case 32:
            if (start === end) {
              start = end = i + 1;
            }
            break;
          case 44:
            list.push(str.substring(start, end));
            start = end = i + 1;
            break;
          default:
            end = i + 1;
            break;
        }
      }
      list.push(str.substring(start, end));
      return list;
    }
  }
});

// ../../../node_modules/mime/types.json
var require_types8 = __commonJS({
  "../../../node_modules/mime/types.json"(exports2, module2) {
    module2.exports = { "application/andrew-inset": ["ez"], "application/applixware": ["aw"], "application/atom+xml": ["atom"], "application/atomcat+xml": ["atomcat"], "application/atomsvc+xml": ["atomsvc"], "application/bdoc": ["bdoc"], "application/ccxml+xml": ["ccxml"], "application/cdmi-capability": ["cdmia"], "application/cdmi-container": ["cdmic"], "application/cdmi-domain": ["cdmid"], "application/cdmi-object": ["cdmio"], "application/cdmi-queue": ["cdmiq"], "application/cu-seeme": ["cu"], "application/dash+xml": ["mpd"], "application/davmount+xml": ["davmount"], "application/docbook+xml": ["dbk"], "application/dssc+der": ["dssc"], "application/dssc+xml": ["xdssc"], "application/ecmascript": ["ecma"], "application/emma+xml": ["emma"], "application/epub+zip": ["epub"], "application/exi": ["exi"], "application/font-tdpfr": ["pfr"], "application/font-woff": [], "application/font-woff2": [], "application/geo+json": ["geojson"], "application/gml+xml": ["gml"], "application/gpx+xml": ["gpx"], "application/gxf": ["gxf"], "application/gzip": ["gz"], "application/hyperstudio": ["stk"], "application/inkml+xml": ["ink", "inkml"], "application/ipfix": ["ipfix"], "application/java-archive": ["jar", "war", "ear"], "application/java-serialized-object": ["ser"], "application/java-vm": ["class"], "application/javascript": ["js", "mjs"], "application/json": ["json", "map"], "application/json5": ["json5"], "application/jsonml+json": ["jsonml"], "application/ld+json": ["jsonld"], "application/lost+xml": ["lostxml"], "application/mac-binhex40": ["hqx"], "application/mac-compactpro": ["cpt"], "application/mads+xml": ["mads"], "application/manifest+json": ["webmanifest"], "application/marc": ["mrc"], "application/marcxml+xml": ["mrcx"], "application/mathematica": ["ma", "nb", "mb"], "application/mathml+xml": ["mathml"], "application/mbox": ["mbox"], "application/mediaservercontrol+xml": ["mscml"], "application/metalink+xml": ["metalink"], "application/metalink4+xml": ["meta4"], "application/mets+xml": ["mets"], "application/mods+xml": ["mods"], "application/mp21": ["m21", "mp21"], "application/mp4": ["mp4s", "m4p"], "application/msword": ["doc", "dot"], "application/mxf": ["mxf"], "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"], "application/oda": ["oda"], "application/oebps-package+xml": ["opf"], "application/ogg": ["ogx"], "application/omdoc+xml": ["omdoc"], "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"], "application/oxps": ["oxps"], "application/patch-ops-error+xml": ["xer"], "application/pdf": ["pdf"], "application/pgp-encrypted": ["pgp"], "application/pgp-signature": ["asc", "sig"], "application/pics-rules": ["prf"], "application/pkcs10": ["p10"], "application/pkcs7-mime": ["p7m", "p7c"], "application/pkcs7-signature": ["p7s"], "application/pkcs8": ["p8"], "application/pkix-attr-cert": ["ac"], "application/pkix-cert": ["cer"], "application/pkix-crl": ["crl"], "application/pkix-pkipath": ["pkipath"], "application/pkixcmp": ["pki"], "application/pls+xml": ["pls"], "application/postscript": ["ai", "eps", "ps"], "application/prs.cww": ["cww"], "application/pskc+xml": ["pskcxml"], "application/raml+yaml": ["raml"], "application/rdf+xml": ["rdf"], "application/reginfo+xml": ["rif"], "application/relax-ng-compact-syntax": ["rnc"], "application/resource-lists+xml": ["rl"], "application/resource-lists-diff+xml": ["rld"], "application/rls-services+xml": ["rs"], "application/rpki-ghostbusters": ["gbr"], "application/rpki-manifest": ["mft"], "application/rpki-roa": ["roa"], "application/rsd+xml": ["rsd"], "application/rss+xml": ["rss"], "application/rtf": ["rtf"], "application/sbml+xml": ["sbml"], "application/scvp-cv-request": ["scq"], "application/scvp-cv-response": ["scs"], "application/scvp-vp-request": ["spq"], "application/scvp-vp-response": ["spp"], "application/sdp": ["sdp"], "application/set-payment-initiation": ["setpay"], "application/set-registration-initiation": ["setreg"], "application/shf+xml": ["shf"], "application/smil+xml": ["smi", "smil"], "application/sparql-query": ["rq"], "application/sparql-results+xml": ["srx"], "application/srgs": ["gram"], "application/srgs+xml": ["grxml"], "application/sru+xml": ["sru"], "application/ssdl+xml": ["ssdl"], "application/ssml+xml": ["ssml"], "application/tei+xml": ["tei", "teicorpus"], "application/thraud+xml": ["tfi"], "application/timestamped-data": ["tsd"], "application/vnd.3gpp.pic-bw-large": ["plb"], "application/vnd.3gpp.pic-bw-small": ["psb"], "application/vnd.3gpp.pic-bw-var": ["pvb"], "application/vnd.3gpp2.tcap": ["tcap"], "application/vnd.3m.post-it-notes": ["pwn"], "application/vnd.accpac.simply.aso": ["aso"], "application/vnd.accpac.simply.imp": ["imp"], "application/vnd.acucobol": ["acu"], "application/vnd.acucorp": ["atc", "acutc"], "application/vnd.adobe.air-application-installer-package+zip": ["air"], "application/vnd.adobe.formscentral.fcdt": ["fcdt"], "application/vnd.adobe.fxp": ["fxp", "fxpl"], "application/vnd.adobe.xdp+xml": ["xdp"], "application/vnd.adobe.xfdf": ["xfdf"], "application/vnd.ahead.space": ["ahead"], "application/vnd.airzip.filesecure.azf": ["azf"], "application/vnd.airzip.filesecure.azs": ["azs"], "application/vnd.amazon.ebook": ["azw"], "application/vnd.americandynamics.acc": ["acc"], "application/vnd.amiga.ami": ["ami"], "application/vnd.android.package-archive": ["apk"], "application/vnd.anser-web-certificate-issue-initiation": ["cii"], "application/vnd.anser-web-funds-transfer-initiation": ["fti"], "application/vnd.antix.game-component": ["atx"], "application/vnd.apple.installer+xml": ["mpkg"], "application/vnd.apple.mpegurl": ["m3u8"], "application/vnd.apple.pkpass": ["pkpass"], "application/vnd.aristanetworks.swi": ["swi"], "application/vnd.astraea-software.iota": ["iota"], "application/vnd.audiograph": ["aep"], "application/vnd.blueice.multipass": ["mpm"], "application/vnd.bmi": ["bmi"], "application/vnd.businessobjects": ["rep"], "application/vnd.chemdraw+xml": ["cdxml"], "application/vnd.chipnuts.karaoke-mmd": ["mmd"], "application/vnd.cinderella": ["cdy"], "application/vnd.claymore": ["cla"], "application/vnd.cloanto.rp9": ["rp9"], "application/vnd.clonk.c4group": ["c4g", "c4d", "c4f", "c4p", "c4u"], "application/vnd.cluetrust.cartomobile-config": ["c11amc"], "application/vnd.cluetrust.cartomobile-config-pkg": ["c11amz"], "application/vnd.commonspace": ["csp"], "application/vnd.contact.cmsg": ["cdbcmsg"], "application/vnd.cosmocaller": ["cmc"], "application/vnd.crick.clicker": ["clkx"], "application/vnd.crick.clicker.keyboard": ["clkk"], "application/vnd.crick.clicker.palette": ["clkp"], "application/vnd.crick.clicker.template": ["clkt"], "application/vnd.crick.clicker.wordbank": ["clkw"], "application/vnd.criticaltools.wbs+xml": ["wbs"], "application/vnd.ctc-posml": ["pml"], "application/vnd.cups-ppd": ["ppd"], "application/vnd.curl.car": ["car"], "application/vnd.curl.pcurl": ["pcurl"], "application/vnd.dart": ["dart"], "application/vnd.data-vision.rdz": ["rdz"], "application/vnd.dece.data": ["uvf", "uvvf", "uvd", "uvvd"], "application/vnd.dece.ttml+xml": ["uvt", "uvvt"], "application/vnd.dece.unspecified": ["uvx", "uvvx"], "application/vnd.dece.zip": ["uvz", "uvvz"], "application/vnd.denovo.fcselayout-link": ["fe_launch"], "application/vnd.dna": ["dna"], "application/vnd.dolby.mlp": ["mlp"], "application/vnd.dpgraph": ["dpg"], "application/vnd.dreamfactory": ["dfac"], "application/vnd.ds-keypoint": ["kpxx"], "application/vnd.dvb.ait": ["ait"], "application/vnd.dvb.service": ["svc"], "application/vnd.dynageo": ["geo"], "application/vnd.ecowin.chart": ["mag"], "application/vnd.enliven": ["nml"], "application/vnd.epson.esf": ["esf"], "application/vnd.epson.msf": ["msf"], "application/vnd.epson.quickanime": ["qam"], "application/vnd.epson.salt": ["slt"], "application/vnd.epson.ssf": ["ssf"], "application/vnd.eszigno3+xml": ["es3", "et3"], "application/vnd.ezpix-album": ["ez2"], "application/vnd.ezpix-package": ["ez3"], "application/vnd.fdf": ["fdf"], "application/vnd.fdsn.mseed": ["mseed"], "application/vnd.fdsn.seed": ["seed", "dataless"], "application/vnd.flographit": ["gph"], "application/vnd.fluxtime.clip": ["ftc"], "application/vnd.framemaker": ["fm", "frame", "maker", "book"], "application/vnd.frogans.fnc": ["fnc"], "application/vnd.frogans.ltf": ["ltf"], "application/vnd.fsc.weblaunch": ["fsc"], "application/vnd.fujitsu.oasys": ["oas"], "application/vnd.fujitsu.oasys2": ["oa2"], "application/vnd.fujitsu.oasys3": ["oa3"], "application/vnd.fujitsu.oasysgp": ["fg5"], "application/vnd.fujitsu.oasysprs": ["bh2"], "application/vnd.fujixerox.ddd": ["ddd"], "application/vnd.fujixerox.docuworks": ["xdw"], "application/vnd.fujixerox.docuworks.binder": ["xbd"], "application/vnd.fuzzysheet": ["fzs"], "application/vnd.genomatix.tuxedo": ["txd"], "application/vnd.geogebra.file": ["ggb"], "application/vnd.geogebra.tool": ["ggt"], "application/vnd.geometry-explorer": ["gex", "gre"], "application/vnd.geonext": ["gxt"], "application/vnd.geoplan": ["g2w"], "application/vnd.geospace": ["g3w"], "application/vnd.gmx": ["gmx"], "application/vnd.google-apps.document": ["gdoc"], "application/vnd.google-apps.presentation": ["gslides"], "application/vnd.google-apps.spreadsheet": ["gsheet"], "application/vnd.google-earth.kml+xml": ["kml"], "application/vnd.google-earth.kmz": ["kmz"], "application/vnd.grafeq": ["gqf", "gqs"], "application/vnd.groove-account": ["gac"], "application/vnd.groove-help": ["ghf"], "application/vnd.groove-identity-message": ["gim"], "application/vnd.groove-injector": ["grv"], "application/vnd.groove-tool-message": ["gtm"], "application/vnd.groove-tool-template": ["tpl"], "application/vnd.groove-vcard": ["vcg"], "application/vnd.hal+xml": ["hal"], "application/vnd.handheld-entertainment+xml": ["zmm"], "application/vnd.hbci": ["hbci"], "application/vnd.hhe.lesson-player": ["les"], "application/vnd.hp-hpgl": ["hpgl"], "application/vnd.hp-hpid": ["hpid"], "application/vnd.hp-hps": ["hps"], "application/vnd.hp-jlyt": ["jlt"], "application/vnd.hp-pcl": ["pcl"], "application/vnd.hp-pclxl": ["pclxl"], "application/vnd.hydrostatix.sof-data": ["sfd-hdstx"], "application/vnd.ibm.minipay": ["mpy"], "application/vnd.ibm.modcap": ["afp", "listafp", "list3820"], "application/vnd.ibm.rights-management": ["irm"], "application/vnd.ibm.secure-container": ["sc"], "application/vnd.iccprofile": ["icc", "icm"], "application/vnd.igloader": ["igl"], "application/vnd.immervision-ivp": ["ivp"], "application/vnd.immervision-ivu": ["ivu"], "application/vnd.insors.igm": ["igm"], "application/vnd.intercon.formnet": ["xpw", "xpx"], "application/vnd.intergeo": ["i2g"], "application/vnd.intu.qbo": ["qbo"], "application/vnd.intu.qfx": ["qfx"], "application/vnd.ipunplugged.rcprofile": ["rcprofile"], "application/vnd.irepository.package+xml": ["irp"], "application/vnd.is-xpr": ["xpr"], "application/vnd.isac.fcs": ["fcs"], "application/vnd.jam": ["jam"], "application/vnd.jcp.javame.midlet-rms": ["rms"], "application/vnd.jisp": ["jisp"], "application/vnd.joost.joda-archive": ["joda"], "application/vnd.kahootz": ["ktz", "ktr"], "application/vnd.kde.karbon": ["karbon"], "application/vnd.kde.kchart": ["chrt"], "application/vnd.kde.kformula": ["kfo"], "application/vnd.kde.kivio": ["flw"], "application/vnd.kde.kontour": ["kon"], "application/vnd.kde.kpresenter": ["kpr", "kpt"], "application/vnd.kde.kspread": ["ksp"], "application/vnd.kde.kword": ["kwd", "kwt"], "application/vnd.kenameaapp": ["htke"], "application/vnd.kidspiration": ["kia"], "application/vnd.kinar": ["kne", "knp"], "application/vnd.koan": ["skp", "skd", "skt", "skm"], "application/vnd.kodak-descriptor": ["sse"], "application/vnd.las.las+xml": ["lasxml"], "application/vnd.llamagraphics.life-balance.desktop": ["lbd"], "application/vnd.llamagraphics.life-balance.exchange+xml": ["lbe"], "application/vnd.lotus-1-2-3": ["123"], "application/vnd.lotus-approach": ["apr"], "application/vnd.lotus-freelance": ["pre"], "application/vnd.lotus-notes": ["nsf"], "application/vnd.lotus-organizer": ["org"], "application/vnd.lotus-screencam": ["scm"], "application/vnd.lotus-wordpro": ["lwp"], "application/vnd.macports.portpkg": ["portpkg"], "application/vnd.mcd": ["mcd"], "application/vnd.medcalcdata": ["mc1"], "application/vnd.mediastation.cdkey": ["cdkey"], "application/vnd.mfer": ["mwf"], "application/vnd.mfmp": ["mfm"], "application/vnd.micrografx.flo": ["flo"], "application/vnd.micrografx.igx": ["igx"], "application/vnd.mif": ["mif"], "application/vnd.mobius.daf": ["daf"], "application/vnd.mobius.dis": ["dis"], "application/vnd.mobius.mbk": ["mbk"], "application/vnd.mobius.mqy": ["mqy"], "application/vnd.mobius.msl": ["msl"], "application/vnd.mobius.plc": ["plc"], "application/vnd.mobius.txf": ["txf"], "application/vnd.mophun.application": ["mpn"], "application/vnd.mophun.certificate": ["mpc"], "application/vnd.mozilla.xul+xml": ["xul"], "application/vnd.ms-artgalry": ["cil"], "application/vnd.ms-cab-compressed": ["cab"], "application/vnd.ms-excel": ["xls", "xlm", "xla", "xlc", "xlt", "xlw"], "application/vnd.ms-excel.addin.macroenabled.12": ["xlam"], "application/vnd.ms-excel.sheet.binary.macroenabled.12": ["xlsb"], "application/vnd.ms-excel.sheet.macroenabled.12": ["xlsm"], "application/vnd.ms-excel.template.macroenabled.12": ["xltm"], "application/vnd.ms-fontobject": ["eot"], "application/vnd.ms-htmlhelp": ["chm"], "application/vnd.ms-ims": ["ims"], "application/vnd.ms-lrm": ["lrm"], "application/vnd.ms-officetheme": ["thmx"], "application/vnd.ms-outlook": ["msg"], "application/vnd.ms-pki.seccat": ["cat"], "application/vnd.ms-pki.stl": ["stl"], "application/vnd.ms-powerpoint": ["ppt", "pps", "pot"], "application/vnd.ms-powerpoint.addin.macroenabled.12": ["ppam"], "application/vnd.ms-powerpoint.presentation.macroenabled.12": ["pptm"], "application/vnd.ms-powerpoint.slide.macroenabled.12": ["sldm"], "application/vnd.ms-powerpoint.slideshow.macroenabled.12": ["ppsm"], "application/vnd.ms-powerpoint.template.macroenabled.12": ["potm"], "application/vnd.ms-project": ["mpp", "mpt"], "application/vnd.ms-word.document.macroenabled.12": ["docm"], "application/vnd.ms-word.template.macroenabled.12": ["dotm"], "application/vnd.ms-works": ["wps", "wks", "wcm", "wdb"], "application/vnd.ms-wpl": ["wpl"], "application/vnd.ms-xpsdocument": ["xps"], "application/vnd.mseq": ["mseq"], "application/vnd.musician": ["mus"], "application/vnd.muvee.style": ["msty"], "application/vnd.mynfc": ["taglet"], "application/vnd.neurolanguage.nlu": ["nlu"], "application/vnd.nitf": ["ntf", "nitf"], "application/vnd.noblenet-directory": ["nnd"], "application/vnd.noblenet-sealer": ["nns"], "application/vnd.noblenet-web": ["nnw"], "application/vnd.nokia.n-gage.data": ["ngdat"], "application/vnd.nokia.n-gage.symbian.install": ["n-gage"], "application/vnd.nokia.radio-preset": ["rpst"], "application/vnd.nokia.radio-presets": ["rpss"], "application/vnd.novadigm.edm": ["edm"], "application/vnd.novadigm.edx": ["edx"], "application/vnd.novadigm.ext": ["ext"], "application/vnd.oasis.opendocument.chart": ["odc"], "application/vnd.oasis.opendocument.chart-template": ["otc"], "application/vnd.oasis.opendocument.database": ["odb"], "application/vnd.oasis.opendocument.formula": ["odf"], "application/vnd.oasis.opendocument.formula-template": ["odft"], "application/vnd.oasis.opendocument.graphics": ["odg"], "application/vnd.oasis.opendocument.graphics-template": ["otg"], "application/vnd.oasis.opendocument.image": ["odi"], "application/vnd.oasis.opendocument.image-template": ["oti"], "application/vnd.oasis.opendocument.presentation": ["odp"], "application/vnd.oasis.opendocument.presentation-template": ["otp"], "application/vnd.oasis.opendocument.spreadsheet": ["ods"], "application/vnd.oasis.opendocument.spreadsheet-template": ["ots"], "application/vnd.oasis.opendocument.text": ["odt"], "application/vnd.oasis.opendocument.text-master": ["odm"], "application/vnd.oasis.opendocument.text-template": ["ott"], "application/vnd.oasis.opendocument.text-web": ["oth"], "application/vnd.olpc-sugar": ["xo"], "application/vnd.oma.dd2+xml": ["dd2"], "application/vnd.openofficeorg.extension": ["oxt"], "application/vnd.openxmlformats-officedocument.presentationml.presentation": ["pptx"], "application/vnd.openxmlformats-officedocument.presentationml.slide": ["sldx"], "application/vnd.openxmlformats-officedocument.presentationml.slideshow": ["ppsx"], "application/vnd.openxmlformats-officedocument.presentationml.template": ["potx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": ["xlsx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.template": ["xltx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.document": ["docx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.template": ["dotx"], "application/vnd.osgeo.mapguide.package": ["mgp"], "application/vnd.osgi.dp": ["dp"], "application/vnd.osgi.subsystem": ["esa"], "application/vnd.palm": ["pdb", "pqa", "oprc"], "application/vnd.pawaafile": ["paw"], "application/vnd.pg.format": ["str"], "application/vnd.pg.osasli": ["ei6"], "application/vnd.picsel": ["efif"], "application/vnd.pmi.widget": ["wg"], "application/vnd.pocketlearn": ["plf"], "application/vnd.powerbuilder6": ["pbd"], "application/vnd.previewsystems.box": ["box"], "application/vnd.proteus.magazine": ["mgz"], "application/vnd.publishare-delta-tree": ["qps"], "application/vnd.pvi.ptid1": ["ptid"], "application/vnd.quark.quarkxpress": ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"], "application/vnd.realvnc.bed": ["bed"], "application/vnd.recordare.musicxml": ["mxl"], "application/vnd.recordare.musicxml+xml": ["musicxml"], "application/vnd.rig.cryptonote": ["cryptonote"], "application/vnd.rim.cod": ["cod"], "application/vnd.rn-realmedia": ["rm"], "application/vnd.rn-realmedia-vbr": ["rmvb"], "application/vnd.route66.link66+xml": ["link66"], "application/vnd.sailingtracker.track": ["st"], "application/vnd.seemail": ["see"], "application/vnd.sema": ["sema"], "application/vnd.semd": ["semd"], "application/vnd.semf": ["semf"], "application/vnd.shana.informed.formdata": ["ifm"], "application/vnd.shana.informed.formtemplate": ["itp"], "application/vnd.shana.informed.interchange": ["iif"], "application/vnd.shana.informed.package": ["ipk"], "application/vnd.simtech-mindmapper": ["twd", "twds"], "application/vnd.smaf": ["mmf"], "application/vnd.smart.teacher": ["teacher"], "application/vnd.solent.sdkm+xml": ["sdkm", "sdkd"], "application/vnd.spotfire.dxp": ["dxp"], "application/vnd.spotfire.sfs": ["sfs"], "application/vnd.stardivision.calc": ["sdc"], "application/vnd.stardivision.draw": ["sda"], "application/vnd.stardivision.impress": ["sdd"], "application/vnd.stardivision.math": ["smf"], "application/vnd.stardivision.writer": ["sdw", "vor"], "application/vnd.stardivision.writer-global": ["sgl"], "application/vnd.stepmania.package": ["smzip"], "application/vnd.stepmania.stepchart": ["sm"], "application/vnd.sun.wadl+xml": ["wadl"], "application/vnd.sun.xml.calc": ["sxc"], "application/vnd.sun.xml.calc.template": ["stc"], "application/vnd.sun.xml.draw": ["sxd"], "application/vnd.sun.xml.draw.template": ["std"], "application/vnd.sun.xml.impress": ["sxi"], "application/vnd.sun.xml.impress.template": ["sti"], "application/vnd.sun.xml.math": ["sxm"], "application/vnd.sun.xml.writer": ["sxw"], "application/vnd.sun.xml.writer.global": ["sxg"], "application/vnd.sun.xml.writer.template": ["stw"], "application/vnd.sus-calendar": ["sus", "susp"], "application/vnd.svd": ["svd"], "application/vnd.symbian.install": ["sis", "sisx"], "application/vnd.syncml+xml": ["xsm"], "application/vnd.syncml.dm+wbxml": ["bdm"], "application/vnd.syncml.dm+xml": ["xdm"], "application/vnd.tao.intent-module-archive": ["tao"], "application/vnd.tcpdump.pcap": ["pcap", "cap", "dmp"], "application/vnd.tmobile-livetv": ["tmo"], "application/vnd.trid.tpt": ["tpt"], "application/vnd.triscape.mxs": ["mxs"], "application/vnd.trueapp": ["tra"], "application/vnd.ufdl": ["ufd", "ufdl"], "application/vnd.uiq.theme": ["utz"], "application/vnd.umajin": ["umj"], "application/vnd.unity": ["unityweb"], "application/vnd.uoml+xml": ["uoml"], "application/vnd.vcx": ["vcx"], "application/vnd.visio": ["vsd", "vst", "vss", "vsw"], "application/vnd.visionary": ["vis"], "application/vnd.vsf": ["vsf"], "application/vnd.wap.wbxml": ["wbxml"], "application/vnd.wap.wmlc": ["wmlc"], "application/vnd.wap.wmlscriptc": ["wmlsc"], "application/vnd.webturbo": ["wtb"], "application/vnd.wolfram.player": ["nbp"], "application/vnd.wordperfect": ["wpd"], "application/vnd.wqd": ["wqd"], "application/vnd.wt.stf": ["stf"], "application/vnd.xara": ["xar"], "application/vnd.xfdl": ["xfdl"], "application/vnd.yamaha.hv-dic": ["hvd"], "application/vnd.yamaha.hv-script": ["hvs"], "application/vnd.yamaha.hv-voice": ["hvp"], "application/vnd.yamaha.openscoreformat": ["osf"], "application/vnd.yamaha.openscoreformat.osfpvg+xml": ["osfpvg"], "application/vnd.yamaha.smaf-audio": ["saf"], "application/vnd.yamaha.smaf-phrase": ["spf"], "application/vnd.yellowriver-custom-menu": ["cmp"], "application/vnd.zul": ["zir", "zirz"], "application/vnd.zzazz.deck+xml": ["zaz"], "application/voicexml+xml": ["vxml"], "application/wasm": ["wasm"], "application/widget": ["wgt"], "application/winhlp": ["hlp"], "application/wsdl+xml": ["wsdl"], "application/wspolicy+xml": ["wspolicy"], "application/x-7z-compressed": ["7z"], "application/x-abiword": ["abw"], "application/x-ace-compressed": ["ace"], "application/x-apple-diskimage": [], "application/x-arj": ["arj"], "application/x-authorware-bin": ["aab", "x32", "u32", "vox"], "application/x-authorware-map": ["aam"], "application/x-authorware-seg": ["aas"], "application/x-bcpio": ["bcpio"], "application/x-bdoc": [], "application/x-bittorrent": ["torrent"], "application/x-blorb": ["blb", "blorb"], "application/x-bzip": ["bz"], "application/x-bzip2": ["bz2", "boz"], "application/x-cbr": ["cbr", "cba", "cbt", "cbz", "cb7"], "application/x-cdlink": ["vcd"], "application/x-cfs-compressed": ["cfs"], "application/x-chat": ["chat"], "application/x-chess-pgn": ["pgn"], "application/x-chrome-extension": ["crx"], "application/x-cocoa": ["cco"], "application/x-conference": ["nsc"], "application/x-cpio": ["cpio"], "application/x-csh": ["csh"], "application/x-debian-package": ["udeb"], "application/x-dgc-compressed": ["dgc"], "application/x-director": ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"], "application/x-doom": ["wad"], "application/x-dtbncx+xml": ["ncx"], "application/x-dtbook+xml": ["dtb"], "application/x-dtbresource+xml": ["res"], "application/x-dvi": ["dvi"], "application/x-envoy": ["evy"], "application/x-eva": ["eva"], "application/x-font-bdf": ["bdf"], "application/x-font-ghostscript": ["gsf"], "application/x-font-linux-psf": ["psf"], "application/x-font-pcf": ["pcf"], "application/x-font-snf": ["snf"], "application/x-font-type1": ["pfa", "pfb", "pfm", "afm"], "application/x-freearc": ["arc"], "application/x-futuresplash": ["spl"], "application/x-gca-compressed": ["gca"], "application/x-glulx": ["ulx"], "application/x-gnumeric": ["gnumeric"], "application/x-gramps-xml": ["gramps"], "application/x-gtar": ["gtar"], "application/x-hdf": ["hdf"], "application/x-httpd-php": ["php"], "application/x-install-instructions": ["install"], "application/x-iso9660-image": [], "application/x-java-archive-diff": ["jardiff"], "application/x-java-jnlp-file": ["jnlp"], "application/x-latex": ["latex"], "application/x-lua-bytecode": ["luac"], "application/x-lzh-compressed": ["lzh", "lha"], "application/x-makeself": ["run"], "application/x-mie": ["mie"], "application/x-mobipocket-ebook": ["prc", "mobi"], "application/x-ms-application": ["application"], "application/x-ms-shortcut": ["lnk"], "application/x-ms-wmd": ["wmd"], "application/x-ms-wmz": ["wmz"], "application/x-ms-xbap": ["xbap"], "application/x-msaccess": ["mdb"], "application/x-msbinder": ["obd"], "application/x-mscardfile": ["crd"], "application/x-msclip": ["clp"], "application/x-msdos-program": [], "application/x-msdownload": ["com", "bat"], "application/x-msmediaview": ["mvb", "m13", "m14"], "application/x-msmetafile": ["wmf", "emf", "emz"], "application/x-msmoney": ["mny"], "application/x-mspublisher": ["pub"], "application/x-msschedule": ["scd"], "application/x-msterminal": ["trm"], "application/x-mswrite": ["wri"], "application/x-netcdf": ["nc", "cdf"], "application/x-ns-proxy-autoconfig": ["pac"], "application/x-nzb": ["nzb"], "application/x-perl": ["pl", "pm"], "application/x-pilot": [], "application/x-pkcs12": ["p12", "pfx"], "application/x-pkcs7-certificates": ["p7b", "spc"], "application/x-pkcs7-certreqresp": ["p7r"], "application/x-rar-compressed": ["rar"], "application/x-redhat-package-manager": ["rpm"], "application/x-research-info-systems": ["ris"], "application/x-sea": ["sea"], "application/x-sh": ["sh"], "application/x-shar": ["shar"], "application/x-shockwave-flash": ["swf"], "application/x-silverlight-app": ["xap"], "application/x-sql": ["sql"], "application/x-stuffit": ["sit"], "application/x-stuffitx": ["sitx"], "application/x-subrip": ["srt"], "application/x-sv4cpio": ["sv4cpio"], "application/x-sv4crc": ["sv4crc"], "application/x-t3vm-image": ["t3"], "application/x-tads": ["gam"], "application/x-tar": ["tar"], "application/x-tcl": ["tcl", "tk"], "application/x-tex": ["tex"], "application/x-tex-tfm": ["tfm"], "application/x-texinfo": ["texinfo", "texi"], "application/x-tgif": ["obj"], "application/x-ustar": ["ustar"], "application/x-virtualbox-hdd": ["hdd"], "application/x-virtualbox-ova": ["ova"], "application/x-virtualbox-ovf": ["ovf"], "application/x-virtualbox-vbox": ["vbox"], "application/x-virtualbox-vbox-extpack": ["vbox-extpack"], "application/x-virtualbox-vdi": ["vdi"], "application/x-virtualbox-vhd": ["vhd"], "application/x-virtualbox-vmdk": ["vmdk"], "application/x-wais-source": ["src"], "application/x-web-app-manifest+json": ["webapp"], "application/x-x509-ca-cert": ["der", "crt", "pem"], "application/x-xfig": ["fig"], "application/x-xliff+xml": ["xlf"], "application/x-xpinstall": ["xpi"], "application/x-xz": ["xz"], "application/x-zmachine": ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"], "application/xaml+xml": ["xaml"], "application/xcap-diff+xml": ["xdf"], "application/xenc+xml": ["xenc"], "application/xhtml+xml": ["xhtml", "xht"], "application/xml": ["xml", "xsl", "xsd", "rng"], "application/xml-dtd": ["dtd"], "application/xop+xml": ["xop"], "application/xproc+xml": ["xpl"], "application/xslt+xml": ["xslt"], "application/xspf+xml": ["xspf"], "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"], "application/yang": ["yang"], "application/yin+xml": ["yin"], "application/zip": ["zip"], "audio/3gpp": [], "audio/adpcm": ["adp"], "audio/basic": ["au", "snd"], "audio/midi": ["mid", "midi", "kar", "rmi"], "audio/mp3": [], "audio/mp4": ["m4a", "mp4a"], "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"], "audio/ogg": ["oga", "ogg", "spx"], "audio/s3m": ["s3m"], "audio/silk": ["sil"], "audio/vnd.dece.audio": ["uva", "uvva"], "audio/vnd.digital-winds": ["eol"], "audio/vnd.dra": ["dra"], "audio/vnd.dts": ["dts"], "audio/vnd.dts.hd": ["dtshd"], "audio/vnd.lucent.voice": ["lvp"], "audio/vnd.ms-playready.media.pya": ["pya"], "audio/vnd.nuera.ecelp4800": ["ecelp4800"], "audio/vnd.nuera.ecelp7470": ["ecelp7470"], "audio/vnd.nuera.ecelp9600": ["ecelp9600"], "audio/vnd.rip": ["rip"], "audio/wav": ["wav"], "audio/wave": [], "audio/webm": ["weba"], "audio/x-aac": ["aac"], "audio/x-aiff": ["aif", "aiff", "aifc"], "audio/x-caf": ["caf"], "audio/x-flac": ["flac"], "audio/x-m4a": [], "audio/x-matroska": ["mka"], "audio/x-mpegurl": ["m3u"], "audio/x-ms-wax": ["wax"], "audio/x-ms-wma": ["wma"], "audio/x-pn-realaudio": ["ram", "ra"], "audio/x-pn-realaudio-plugin": ["rmp"], "audio/x-realaudio": [], "audio/x-wav": [], "audio/xm": ["xm"], "chemical/x-cdx": ["cdx"], "chemical/x-cif": ["cif"], "chemical/x-cmdf": ["cmdf"], "chemical/x-cml": ["cml"], "chemical/x-csml": ["csml"], "chemical/x-xyz": ["xyz"], "font/collection": ["ttc"], "font/otf": ["otf"], "font/ttf": ["ttf"], "font/woff": ["woff"], "font/woff2": ["woff2"], "image/apng": ["apng"], "image/bmp": ["bmp"], "image/cgm": ["cgm"], "image/g3fax": ["g3"], "image/gif": ["gif"], "image/ief": ["ief"], "image/jp2": ["jp2", "jpg2"], "image/jpeg": ["jpeg", "jpg", "jpe"], "image/jpm": ["jpm"], "image/jpx": ["jpx", "jpf"], "image/ktx": ["ktx"], "image/png": ["png"], "image/prs.btif": ["btif"], "image/sgi": ["sgi"], "image/svg+xml": ["svg", "svgz"], "image/tiff": ["tiff", "tif"], "image/vnd.adobe.photoshop": ["psd"], "image/vnd.dece.graphic": ["uvi", "uvvi", "uvg", "uvvg"], "image/vnd.djvu": ["djvu", "djv"], "image/vnd.dvb.subtitle": [], "image/vnd.dwg": ["dwg"], "image/vnd.dxf": ["dxf"], "image/vnd.fastbidsheet": ["fbs"], "image/vnd.fpx": ["fpx"], "image/vnd.fst": ["fst"], "image/vnd.fujixerox.edmics-mmr": ["mmr"], "image/vnd.fujixerox.edmics-rlc": ["rlc"], "image/vnd.ms-modi": ["mdi"], "image/vnd.ms-photo": ["wdp"], "image/vnd.net-fpx": ["npx"], "image/vnd.wap.wbmp": ["wbmp"], "image/vnd.xiff": ["xif"], "image/webp": ["webp"], "image/x-3ds": ["3ds"], "image/x-cmu-raster": ["ras"], "image/x-cmx": ["cmx"], "image/x-freehand": ["fh", "fhc", "fh4", "fh5", "fh7"], "image/x-icon": ["ico"], "image/x-jng": ["jng"], "image/x-mrsid-image": ["sid"], "image/x-ms-bmp": [], "image/x-pcx": ["pcx"], "image/x-pict": ["pic", "pct"], "image/x-portable-anymap": ["pnm"], "image/x-portable-bitmap": ["pbm"], "image/x-portable-graymap": ["pgm"], "image/x-portable-pixmap": ["ppm"], "image/x-rgb": ["rgb"], "image/x-tga": ["tga"], "image/x-xbitmap": ["xbm"], "image/x-xpixmap": ["xpm"], "image/x-xwindowdump": ["xwd"], "message/rfc822": ["eml", "mime"], "model/gltf+json": ["gltf"], "model/gltf-binary": ["glb"], "model/iges": ["igs", "iges"], "model/mesh": ["msh", "mesh", "silo"], "model/vnd.collada+xml": ["dae"], "model/vnd.dwf": ["dwf"], "model/vnd.gdl": ["gdl"], "model/vnd.gtw": ["gtw"], "model/vnd.mts": ["mts"], "model/vnd.vtu": ["vtu"], "model/vrml": ["wrl", "vrml"], "model/x3d+binary": ["x3db", "x3dbz"], "model/x3d+vrml": ["x3dv", "x3dvz"], "model/x3d+xml": ["x3d", "x3dz"], "text/cache-manifest": ["appcache", "manifest"], "text/calendar": ["ics", "ifb"], "text/coffeescript": ["coffee", "litcoffee"], "text/css": ["css"], "text/csv": ["csv"], "text/hjson": ["hjson"], "text/html": ["html", "htm", "shtml"], "text/jade": ["jade"], "text/jsx": ["jsx"], "text/less": ["less"], "text/markdown": ["markdown", "md"], "text/mathml": ["mml"], "text/n3": ["n3"], "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"], "text/prs.lines.tag": ["dsc"], "text/richtext": ["rtx"], "text/rtf": [], "text/sgml": ["sgml", "sgm"], "text/slim": ["slim", "slm"], "text/stylus": ["stylus", "styl"], "text/tab-separated-values": ["tsv"], "text/troff": ["t", "tr", "roff", "man", "me", "ms"], "text/turtle": ["ttl"], "text/uri-list": ["uri", "uris", "urls"], "text/vcard": ["vcard"], "text/vnd.curl": ["curl"], "text/vnd.curl.dcurl": ["dcurl"], "text/vnd.curl.mcurl": ["mcurl"], "text/vnd.curl.scurl": ["scurl"], "text/vnd.dvb.subtitle": ["sub"], "text/vnd.fly": ["fly"], "text/vnd.fmi.flexstor": ["flx"], "text/vnd.graphviz": ["gv"], "text/vnd.in3d.3dml": ["3dml"], "text/vnd.in3d.spot": ["spot"], "text/vnd.sun.j2me.app-descriptor": ["jad"], "text/vnd.wap.wml": ["wml"], "text/vnd.wap.wmlscript": ["wmls"], "text/vtt": ["vtt"], "text/x-asm": ["s", "asm"], "text/x-c": ["c", "cc", "cxx", "cpp", "h", "hh", "dic"], "text/x-component": ["htc"], "text/x-fortran": ["f", "for", "f77", "f90"], "text/x-handlebars-template": ["hbs"], "text/x-java-source": ["java"], "text/x-lua": ["lua"], "text/x-markdown": ["mkd"], "text/x-nfo": ["nfo"], "text/x-opml": ["opml"], "text/x-org": [], "text/x-pascal": ["p", "pas"], "text/x-processing": ["pde"], "text/x-sass": ["sass"], "text/x-scss": ["scss"], "text/x-setext": ["etx"], "text/x-sfv": ["sfv"], "text/x-suse-ymp": ["ymp"], "text/x-uuencode": ["uu"], "text/x-vcalendar": ["vcs"], "text/x-vcard": ["vcf"], "text/xml": [], "text/yaml": ["yaml", "yml"], "video/3gpp": ["3gp", "3gpp"], "video/3gpp2": ["3g2"], "video/h261": ["h261"], "video/h263": ["h263"], "video/h264": ["h264"], "video/jpeg": ["jpgv"], "video/jpm": ["jpgm"], "video/mj2": ["mj2", "mjp2"], "video/mp2t": ["ts"], "video/mp4": ["mp4", "mp4v", "mpg4"], "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"], "video/ogg": ["ogv"], "video/quicktime": ["qt", "mov"], "video/vnd.dece.hd": ["uvh", "uvvh"], "video/vnd.dece.mobile": ["uvm", "uvvm"], "video/vnd.dece.pd": ["uvp", "uvvp"], "video/vnd.dece.sd": ["uvs", "uvvs"], "video/vnd.dece.video": ["uvv", "uvvv"], "video/vnd.dvb.file": ["dvb"], "video/vnd.fvt": ["fvt"], "video/vnd.mpegurl": ["mxu", "m4u"], "video/vnd.ms-playready.media.pyv": ["pyv"], "video/vnd.uvvu.mp4": ["uvu", "uvvu"], "video/vnd.vivo": ["viv"], "video/webm": ["webm"], "video/x-f4v": ["f4v"], "video/x-fli": ["fli"], "video/x-flv": ["flv"], "video/x-m4v": ["m4v"], "video/x-matroska": ["mkv", "mk3d", "mks"], "video/x-mng": ["mng"], "video/x-ms-asf": ["asf", "asx"], "video/x-ms-vob": ["vob"], "video/x-ms-wm": ["wm"], "video/x-ms-wmv": ["wmv"], "video/x-ms-wmx": ["wmx"], "video/x-ms-wvx": ["wvx"], "video/x-msvideo": ["avi"], "video/x-sgi-movie": ["movie"], "video/x-smv": ["smv"], "x-conference/x-cooltalk": ["ice"] };
  }
});

// ../../../node_modules/mime/mime.js
var require_mime = __commonJS({
  "../../../node_modules/mime/mime.js"(exports2, module2) {
    var path = require_path();
    var fs = require_fs();
    function Mime() {
      this.types = /* @__PURE__ */ Object.create(null);
      this.extensions = /* @__PURE__ */ Object.create(null);
    }
    Mime.prototype.define = function(map) {
      for (var type in map) {
        var exts = map[type];
        for (var i = 0; i < exts.length; i++) {
          if (process.env.DEBUG_MIME && this.types[exts[i]]) {
            console.warn((this._loading || "define()").replace(/.*\//, ""), 'changes "' + exts[i] + '" extension type from ' + this.types[exts[i]] + " to " + type);
          }
          this.types[exts[i]] = type;
        }
        if (!this.extensions[type]) {
          this.extensions[type] = exts[0];
        }
      }
    };
    Mime.prototype.load = function(file) {
      this._loading = file;
      var map = {}, content = fs.readFileSync(file, "ascii"), lines = content.split(/[\r\n]+/);
      lines.forEach(function(line) {
        var fields = line.replace(/\s*#.*|^\s*|\s*$/g, "").split(/\s+/);
        map[fields.shift()] = fields;
      });
      this.define(map);
      this._loading = null;
    };
    Mime.prototype.lookup = function(path2, fallback) {
      var ext = path2.replace(/^.*[\.\/\\]/, "").toLowerCase();
      return this.types[ext] || fallback || this.default_type;
    };
    Mime.prototype.extension = function(mimeType) {
      var type = mimeType.match(/^\s*([^;\s]*)(?:;|\s|$)/)[1].toLowerCase();
      return this.extensions[type];
    };
    var mime = new Mime();
    mime.define(require_types8());
    mime.default_type = mime.lookup("bin");
    mime.Mime = Mime;
    mime.charsets = {
      lookup: function(mimeType, fallback) {
        return /^text\/|^application\/(javascript|json)/.test(mimeType) ? "UTF-8" : fallback;
      }
    };
    module2.exports = mime;
  }
});

// ../../../node_modules/ms/index.js
var require_ms4 = __commonJS({
  "../../../node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse2(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse2(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// ../../../node_modules/range-parser/index.js
var require_range_parser = __commonJS({
  "../../../node_modules/range-parser/index.js"(exports2, module2) {
    "use strict";
    module2.exports = rangeParser;
    function rangeParser(size, str, options) {
      if (typeof str !== "string") {
        throw new TypeError("argument str must be a string");
      }
      var index = str.indexOf("=");
      if (index === -1) {
        return -2;
      }
      var arr = str.slice(index + 1).split(",");
      var ranges = [];
      ranges.type = str.slice(0, index);
      for (var i = 0; i < arr.length; i++) {
        var range = arr[i].split("-");
        var start = parseInt(range[0], 10);
        var end = parseInt(range[1], 10);
        if (isNaN(start)) {
          start = size - end;
          end = size - 1;
        } else if (isNaN(end)) {
          end = size - 1;
        }
        if (end > size - 1) {
          end = size - 1;
        }
        if (isNaN(start) || isNaN(end) || start > end || start < 0) {
          continue;
        }
        ranges.push({
          start,
          end
        });
      }
      if (ranges.length < 1) {
        return -1;
      }
      return options && options.combine ? combineRanges(ranges) : ranges;
    }
    function combineRanges(ranges) {
      var ordered = ranges.map(mapWithIndex).sort(sortByRangeStart);
      for (var j = 0, i = 1; i < ordered.length; i++) {
        var range = ordered[i];
        var current = ordered[j];
        if (range.start > current.end + 1) {
          ordered[++j] = range;
        } else if (range.end > current.end) {
          current.end = range.end;
          current.index = Math.min(current.index, range.index);
        }
      }
      ordered.length = j + 1;
      var combined = ordered.sort(sortByRangeIndex).map(mapWithoutIndex);
      combined.type = ranges.type;
      return combined;
    }
    function mapWithIndex(range, index) {
      return {
        start: range.start,
        end: range.end,
        index
      };
    }
    function mapWithoutIndex(range) {
      return {
        start: range.start,
        end: range.end
      };
    }
    function sortByRangeIndex(a, b) {
      return a.index - b.index;
    }
    function sortByRangeStart(a, b) {
      return a.start - b.start;
    }
  }
});

// ../../../node_modules/send/index.js
var require_send = __commonJS({
  "../../../node_modules/send/index.js"(exports2, module2) {
    "use strict";
    var createError = require_http_errors();
    var debug = require_browser5()("send");
    var deprecate = require_browser2()("send");
    var destroy = require_destroy();
    var encodeUrl = require_encodeurl();
    var escapeHtml = require_escape_html();
    var etag = require_etag();
    var fresh = require_fresh();
    var fs = require_fs();
    var mime = require_mime();
    var ms = require_ms4();
    var onFinished = require_on_finished();
    var parseRange = require_range_parser();
    var path = require_path();
    var statuses = require_statuses();
    var Stream = require_stream();
    var util = require_util();
    var extname = path.extname;
    var join2 = path.join;
    var normalize2 = path.normalize;
    var resolve = path.resolve;
    var sep = path.sep;
    var BYTES_RANGE_REGEXP = /^ *bytes=/;
    var MAX_MAXAGE = 60 * 60 * 24 * 365 * 1e3;
    var UP_PATH_REGEXP = /(?:^|[\\/])\.\.(?:[\\/]|$)/;
    module2.exports = send;
    module2.exports.mime = mime;
    function send(req, path2, options) {
      return new SendStream(req, path2, options);
    }
    function SendStream(req, path2, options) {
      Stream.call(this);
      var opts = options || {};
      this.options = opts;
      this.path = path2;
      this.req = req;
      this._acceptRanges = opts.acceptRanges !== void 0 ? Boolean(opts.acceptRanges) : true;
      this._cacheControl = opts.cacheControl !== void 0 ? Boolean(opts.cacheControl) : true;
      this._etag = opts.etag !== void 0 ? Boolean(opts.etag) : true;
      this._dotfiles = opts.dotfiles !== void 0 ? opts.dotfiles : "ignore";
      if (this._dotfiles !== "ignore" && this._dotfiles !== "allow" && this._dotfiles !== "deny") {
        throw new TypeError('dotfiles option must be "allow", "deny", or "ignore"');
      }
      this._hidden = Boolean(opts.hidden);
      if (opts.hidden !== void 0) {
        deprecate("hidden: use dotfiles: '" + (this._hidden ? "allow" : "ignore") + "' instead");
      }
      if (opts.dotfiles === void 0) {
        this._dotfiles = void 0;
      }
      this._extensions = opts.extensions !== void 0 ? normalizeList(opts.extensions, "extensions option") : [];
      this._immutable = opts.immutable !== void 0 ? Boolean(opts.immutable) : false;
      this._index = opts.index !== void 0 ? normalizeList(opts.index, "index option") : ["index.html"];
      this._lastModified = opts.lastModified !== void 0 ? Boolean(opts.lastModified) : true;
      this._maxage = opts.maxAge || opts.maxage;
      this._maxage = typeof this._maxage === "string" ? ms(this._maxage) : Number(this._maxage);
      this._maxage = !isNaN(this._maxage) ? Math.min(Math.max(0, this._maxage), MAX_MAXAGE) : 0;
      this._root = opts.root ? resolve(opts.root) : null;
      if (!this._root && opts.from) {
        this.from(opts.from);
      }
    }
    util.inherits(SendStream, Stream);
    SendStream.prototype.etag = deprecate.function(function etag2(val) {
      this._etag = Boolean(val);
      debug("etag %s", this._etag);
      return this;
    }, "send.etag: pass etag as option");
    SendStream.prototype.hidden = deprecate.function(function hidden(val) {
      this._hidden = Boolean(val);
      this._dotfiles = void 0;
      debug("hidden %s", this._hidden);
      return this;
    }, "send.hidden: use dotfiles option");
    SendStream.prototype.index = deprecate.function(function index(paths) {
      var index2 = !paths ? [] : normalizeList(paths, "paths argument");
      debug("index %o", paths);
      this._index = index2;
      return this;
    }, "send.index: pass index as option");
    SendStream.prototype.root = function root(path2) {
      this._root = resolve(String(path2));
      debug("root %s", this._root);
      return this;
    };
    SendStream.prototype.from = deprecate.function(
      SendStream.prototype.root,
      "send.from: pass root as option"
    );
    SendStream.prototype.root = deprecate.function(
      SendStream.prototype.root,
      "send.root: pass root as option"
    );
    SendStream.prototype.maxage = deprecate.function(function maxage(maxAge) {
      this._maxage = typeof maxAge === "string" ? ms(maxAge) : Number(maxAge);
      this._maxage = !isNaN(this._maxage) ? Math.min(Math.max(0, this._maxage), MAX_MAXAGE) : 0;
      debug("max-age %d", this._maxage);
      return this;
    }, "send.maxage: pass maxAge as option");
    SendStream.prototype.error = function error(status, err) {
      if (hasListeners(this, "error")) {
        return this.emit("error", createHttpError(status, err));
      }
      var res = this.res;
      var msg = statuses.message[status] || String(status);
      var doc = createHtmlDocument("Error", escapeHtml(msg));
      clearHeaders(res);
      if (err && err.headers) {
        setHeaders(res, err.headers);
      }
      res.statusCode = status;
      res.setHeader("Content-Type", "text/html; charset=UTF-8");
      res.setHeader("Content-Length", Buffer.byteLength(doc));
      res.setHeader("Content-Security-Policy", "default-src 'none'");
      res.setHeader("X-Content-Type-Options", "nosniff");
      res.end(doc);
    };
    SendStream.prototype.hasTrailingSlash = function hasTrailingSlash() {
      return this.path[this.path.length - 1] === "/";
    };
    SendStream.prototype.isConditionalGET = function isConditionalGET() {
      return this.req.headers["if-match"] || this.req.headers["if-unmodified-since"] || this.req.headers["if-none-match"] || this.req.headers["if-modified-since"];
    };
    SendStream.prototype.isPreconditionFailure = function isPreconditionFailure() {
      var req = this.req;
      var res = this.res;
      var match = req.headers["if-match"];
      if (match) {
        var etag2 = res.getHeader("ETag");
        return !etag2 || match !== "*" && parseTokenList(match).every(function(match2) {
          return match2 !== etag2 && match2 !== "W/" + etag2 && "W/" + match2 !== etag2;
        });
      }
      var unmodifiedSince = parseHttpDate(req.headers["if-unmodified-since"]);
      if (!isNaN(unmodifiedSince)) {
        var lastModified = parseHttpDate(res.getHeader("Last-Modified"));
        return isNaN(lastModified) || lastModified > unmodifiedSince;
      }
      return false;
    };
    SendStream.prototype.removeContentHeaderFields = function removeContentHeaderFields() {
      var res = this.res;
      res.removeHeader("Content-Encoding");
      res.removeHeader("Content-Language");
      res.removeHeader("Content-Length");
      res.removeHeader("Content-Range");
      res.removeHeader("Content-Type");
    };
    SendStream.prototype.notModified = function notModified() {
      var res = this.res;
      debug("not modified");
      this.removeContentHeaderFields();
      res.statusCode = 304;
      res.end();
    };
    SendStream.prototype.headersAlreadySent = function headersAlreadySent() {
      var err = new Error("Can't set headers after they are sent.");
      debug("headers already sent");
      this.error(500, err);
    };
    SendStream.prototype.isCachable = function isCachable() {
      var statusCode = this.res.statusCode;
      return statusCode >= 200 && statusCode < 300 || statusCode === 304;
    };
    SendStream.prototype.onStatError = function onStatError(error) {
      switch (error.code) {
        case "ENAMETOOLONG":
        case "ENOENT":
        case "ENOTDIR":
          this.error(404, error);
          break;
        default:
          this.error(500, error);
          break;
      }
    };
    SendStream.prototype.isFresh = function isFresh() {
      return fresh(this.req.headers, {
        etag: this.res.getHeader("ETag"),
        "last-modified": this.res.getHeader("Last-Modified")
      });
    };
    SendStream.prototype.isRangeFresh = function isRangeFresh() {
      var ifRange = this.req.headers["if-range"];
      if (!ifRange) {
        return true;
      }
      if (ifRange.indexOf('"') !== -1) {
        var etag2 = this.res.getHeader("ETag");
        return Boolean(etag2 && ifRange.indexOf(etag2) !== -1);
      }
      var lastModified = this.res.getHeader("Last-Modified");
      return parseHttpDate(lastModified) <= parseHttpDate(ifRange);
    };
    SendStream.prototype.redirect = function redirect(path2) {
      var res = this.res;
      if (hasListeners(this, "directory")) {
        this.emit("directory", res, path2);
        return;
      }
      if (this.hasTrailingSlash()) {
        this.error(403);
        return;
      }
      var loc = encodeUrl(collapseLeadingSlashes(this.path + "/"));
      var doc = createHtmlDocument("Redirecting", 'Redirecting to <a href="' + escapeHtml(loc) + '">' + escapeHtml(loc) + "</a>");
      res.statusCode = 301;
      res.setHeader("Content-Type", "text/html; charset=UTF-8");
      res.setHeader("Content-Length", Buffer.byteLength(doc));
      res.setHeader("Content-Security-Policy", "default-src 'none'");
      res.setHeader("X-Content-Type-Options", "nosniff");
      res.setHeader("Location", loc);
      res.end(doc);
    };
    SendStream.prototype.pipe = function pipe(res) {
      var root = this._root;
      this.res = res;
      var path2 = decode(this.path);
      if (path2 === -1) {
        this.error(400);
        return res;
      }
      if (~path2.indexOf("\0")) {
        this.error(400);
        return res;
      }
      var parts;
      if (root !== null) {
        if (path2) {
          path2 = normalize2("." + sep + path2);
        }
        if (UP_PATH_REGEXP.test(path2)) {
          debug('malicious path "%s"', path2);
          this.error(403);
          return res;
        }
        parts = path2.split(sep);
        path2 = normalize2(join2(root, path2));
      } else {
        if (UP_PATH_REGEXP.test(path2)) {
          debug('malicious path "%s"', path2);
          this.error(403);
          return res;
        }
        parts = normalize2(path2).split(sep);
        path2 = resolve(path2);
      }
      if (containsDotFile(parts)) {
        var access = this._dotfiles;
        if (access === void 0) {
          access = parts[parts.length - 1][0] === "." ? this._hidden ? "allow" : "ignore" : "allow";
        }
        debug('%s dotfile "%s"', access, path2);
        switch (access) {
          case "allow":
            break;
          case "deny":
            this.error(403);
            return res;
          case "ignore":
          default:
            this.error(404);
            return res;
        }
      }
      if (this._index.length && this.hasTrailingSlash()) {
        this.sendIndex(path2);
        return res;
      }
      this.sendFile(path2);
      return res;
    };
    SendStream.prototype.send = function send2(path2, stat) {
      var len = stat.size;
      var options = this.options;
      var opts = {};
      var res = this.res;
      var req = this.req;
      var ranges = req.headers.range;
      var offset = options.start || 0;
      if (headersSent(res)) {
        this.headersAlreadySent();
        return;
      }
      debug('pipe "%s"', path2);
      this.setHeader(path2, stat);
      this.type(path2);
      if (this.isConditionalGET()) {
        if (this.isPreconditionFailure()) {
          this.error(412);
          return;
        }
        if (this.isCachable() && this.isFresh()) {
          this.notModified();
          return;
        }
      }
      len = Math.max(0, len - offset);
      if (options.end !== void 0) {
        var bytes = options.end - offset + 1;
        if (len > bytes)
          len = bytes;
      }
      if (this._acceptRanges && BYTES_RANGE_REGEXP.test(ranges)) {
        ranges = parseRange(len, ranges, {
          combine: true
        });
        if (!this.isRangeFresh()) {
          debug("range stale");
          ranges = -2;
        }
        if (ranges === -1) {
          debug("range unsatisfiable");
          res.setHeader("Content-Range", contentRange("bytes", len));
          return this.error(416, {
            headers: { "Content-Range": res.getHeader("Content-Range") }
          });
        }
        if (ranges !== -2 && ranges.length === 1) {
          debug("range %j", ranges);
          res.statusCode = 206;
          res.setHeader("Content-Range", contentRange("bytes", len, ranges[0]));
          offset += ranges[0].start;
          len = ranges[0].end - ranges[0].start + 1;
        }
      }
      for (var prop in options) {
        opts[prop] = options[prop];
      }
      opts.start = offset;
      opts.end = Math.max(offset, offset + len - 1);
      res.setHeader("Content-Length", len);
      if (req.method === "HEAD") {
        res.end();
        return;
      }
      this.stream(path2, opts);
    };
    SendStream.prototype.sendFile = function sendFile(path2) {
      var i = 0;
      var self2 = this;
      debug('stat "%s"', path2);
      fs.stat(path2, function onstat(err, stat) {
        if (err && err.code === "ENOENT" && !extname(path2) && path2[path2.length - 1] !== sep) {
          return next(err);
        }
        if (err)
          return self2.onStatError(err);
        if (stat.isDirectory())
          return self2.redirect(path2);
        self2.emit("file", path2, stat);
        self2.send(path2, stat);
      });
      function next(err) {
        if (self2._extensions.length <= i) {
          return err ? self2.onStatError(err) : self2.error(404);
        }
        var p = path2 + "." + self2._extensions[i++];
        debug('stat "%s"', p);
        fs.stat(p, function(err2, stat) {
          if (err2)
            return next(err2);
          if (stat.isDirectory())
            return next();
          self2.emit("file", p, stat);
          self2.send(p, stat);
        });
      }
    };
    SendStream.prototype.sendIndex = function sendIndex(path2) {
      var i = -1;
      var self2 = this;
      function next(err) {
        if (++i >= self2._index.length) {
          if (err)
            return self2.onStatError(err);
          return self2.error(404);
        }
        var p = join2(path2, self2._index[i]);
        debug('stat "%s"', p);
        fs.stat(p, function(err2, stat) {
          if (err2)
            return next(err2);
          if (stat.isDirectory())
            return next();
          self2.emit("file", p, stat);
          self2.send(p, stat);
        });
      }
      next();
    };
    SendStream.prototype.stream = function stream(path2, options) {
      var self2 = this;
      var res = this.res;
      var stream2 = fs.createReadStream(path2, options);
      this.emit("stream", stream2);
      stream2.pipe(res);
      function cleanup() {
        destroy(stream2, true);
      }
      onFinished(res, cleanup);
      stream2.on("error", function onerror(err) {
        cleanup();
        self2.onStatError(err);
      });
      stream2.on("end", function onend() {
        self2.emit("end");
      });
    };
    SendStream.prototype.type = function type(path2) {
      var res = this.res;
      if (res.getHeader("Content-Type"))
        return;
      var type2 = mime.lookup(path2);
      if (!type2) {
        debug("no content-type");
        return;
      }
      var charset = mime.charsets.lookup(type2);
      debug("content-type %s", type2);
      res.setHeader("Content-Type", type2 + (charset ? "; charset=" + charset : ""));
    };
    SendStream.prototype.setHeader = function setHeader(path2, stat) {
      var res = this.res;
      this.emit("headers", res, path2, stat);
      if (this._acceptRanges && !res.getHeader("Accept-Ranges")) {
        debug("accept ranges");
        res.setHeader("Accept-Ranges", "bytes");
      }
      if (this._cacheControl && !res.getHeader("Cache-Control")) {
        var cacheControl = "public, max-age=" + Math.floor(this._maxage / 1e3);
        if (this._immutable) {
          cacheControl += ", immutable";
        }
        debug("cache-control %s", cacheControl);
        res.setHeader("Cache-Control", cacheControl);
      }
      if (this._lastModified && !res.getHeader("Last-Modified")) {
        var modified = stat.mtime.toUTCString();
        debug("modified %s", modified);
        res.setHeader("Last-Modified", modified);
      }
      if (this._etag && !res.getHeader("ETag")) {
        var val = etag(stat);
        debug("etag %s", val);
        res.setHeader("ETag", val);
      }
    };
    function clearHeaders(res) {
      var headers = getHeaderNames(res);
      for (var i = 0; i < headers.length; i++) {
        res.removeHeader(headers[i]);
      }
    }
    function collapseLeadingSlashes(str) {
      for (var i = 0; i < str.length; i++) {
        if (str[i] !== "/") {
          break;
        }
      }
      return i > 1 ? "/" + str.substr(i) : str;
    }
    function containsDotFile(parts) {
      for (var i = 0; i < parts.length; i++) {
        var part = parts[i];
        if (part.length > 1 && part[0] === ".") {
          return true;
        }
      }
      return false;
    }
    function contentRange(type, size, range) {
      return type + " " + (range ? range.start + "-" + range.end : "*") + "/" + size;
    }
    function createHtmlDocument(title, body) {
      return '<!DOCTYPE html>\n<html lang="en">\n<head>\n<meta charset="utf-8">\n<title>' + title + "</title>\n</head>\n<body>\n<pre>" + body + "</pre>\n</body>\n</html>\n";
    }
    function createHttpError(status, err) {
      if (!err) {
        return createError(status);
      }
      return err instanceof Error ? createError(status, err, { expose: false }) : createError(status, err);
    }
    function decode(path2) {
      try {
        return decodeURIComponent(path2);
      } catch (err) {
        return -1;
      }
    }
    function getHeaderNames(res) {
      return typeof res.getHeaderNames !== "function" ? Object.keys(res._headers || {}) : res.getHeaderNames();
    }
    function hasListeners(emitter, type) {
      var count = typeof emitter.listenerCount !== "function" ? emitter.listeners(type).length : emitter.listenerCount(type);
      return count > 0;
    }
    function headersSent(res) {
      return typeof res.headersSent !== "boolean" ? Boolean(res._header) : res.headersSent;
    }
    function normalizeList(val, name) {
      var list = [].concat(val || []);
      for (var i = 0; i < list.length; i++) {
        if (typeof list[i] !== "string") {
          throw new TypeError(name + " must be array of strings or false");
        }
      }
      return list;
    }
    function parseHttpDate(date) {
      var timestamp = date && Date.parse(date);
      return typeof timestamp === "number" ? timestamp : NaN;
    }
    function parseTokenList(str) {
      var end = 0;
      var list = [];
      var start = 0;
      for (var i = 0, len = str.length; i < len; i++) {
        switch (str.charCodeAt(i)) {
          case 32:
            if (start === end) {
              start = end = i + 1;
            }
            break;
          case 44:
            if (start !== end) {
              list.push(str.substring(start, end));
            }
            start = end = i + 1;
            break;
          default:
            end = i + 1;
            break;
        }
      }
      if (start !== end) {
        list.push(str.substring(start, end));
      }
      return list;
    }
    function setHeaders(res, headers) {
      var keys = Object.keys(headers);
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        res.setHeader(key, headers[key]);
      }
    }
  }
});

// ../../../node_modules/forwarded/index.js
var require_forwarded = __commonJS({
  "../../../node_modules/forwarded/index.js"(exports2, module2) {
    "use strict";
    module2.exports = forwarded;
    function forwarded(req) {
      if (!req) {
        throw new TypeError("argument req is required");
      }
      var proxyAddrs = parse2(req.headers["x-forwarded-for"] || "");
      var socketAddr = getSocketAddr(req);
      var addrs = [socketAddr].concat(proxyAddrs);
      return addrs;
    }
    function getSocketAddr(req) {
      return req.socket ? req.socket.remoteAddress : req.connection.remoteAddress;
    }
    function parse2(header) {
      var end = header.length;
      var list = [];
      var start = header.length;
      for (var i = header.length - 1; i >= 0; i--) {
        switch (header.charCodeAt(i)) {
          case 32:
            if (start === end) {
              start = end = i;
            }
            break;
          case 44:
            if (start !== end) {
              list.push(header.substring(start, end));
            }
            start = end = i;
            break;
          default:
            start = i;
            break;
        }
      }
      if (start !== end) {
        list.push(header.substring(start, end));
      }
      return list;
    }
  }
});

// ../../../node_modules/ipaddr.js/lib/ipaddr.js
var require_ipaddr = __commonJS({
  "../../../node_modules/ipaddr.js/lib/ipaddr.js"(exports2, module2) {
    (function() {
      var expandIPv6, ipaddr, ipv4Part, ipv4Regexes, ipv6Part, ipv6Regexes, matchCIDR, root, zoneIndex;
      ipaddr = {};
      root = this;
      if (typeof module2 !== "undefined" && module2 !== null && module2.exports) {
        module2.exports = ipaddr;
      } else {
        root["ipaddr"] = ipaddr;
      }
      matchCIDR = function(first, second, partSize, cidrBits) {
        var part, shift;
        if (first.length !== second.length) {
          throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
        }
        part = 0;
        while (cidrBits > 0) {
          shift = partSize - cidrBits;
          if (shift < 0) {
            shift = 0;
          }
          if (first[part] >> shift !== second[part] >> shift) {
            return false;
          }
          cidrBits -= partSize;
          part += 1;
        }
        return true;
      };
      ipaddr.subnetMatch = function(address, rangeList, defaultName) {
        var k, len, rangeName, rangeSubnets, subnet;
        if (defaultName == null) {
          defaultName = "unicast";
        }
        for (rangeName in rangeList) {
          rangeSubnets = rangeList[rangeName];
          if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {
            rangeSubnets = [rangeSubnets];
          }
          for (k = 0, len = rangeSubnets.length; k < len; k++) {
            subnet = rangeSubnets[k];
            if (address.kind() === subnet[0].kind()) {
              if (address.match.apply(address, subnet)) {
                return rangeName;
              }
            }
          }
        }
        return defaultName;
      };
      ipaddr.IPv4 = function() {
        function IPv4(octets) {
          var k, len, octet;
          if (octets.length !== 4) {
            throw new Error("ipaddr: ipv4 octet count should be 4");
          }
          for (k = 0, len = octets.length; k < len; k++) {
            octet = octets[k];
            if (!(0 <= octet && octet <= 255)) {
              throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
            }
          }
          this.octets = octets;
        }
        IPv4.prototype.kind = function() {
          return "ipv4";
        };
        IPv4.prototype.toString = function() {
          return this.octets.join(".");
        };
        IPv4.prototype.toNormalizedString = function() {
          return this.toString();
        };
        IPv4.prototype.toByteArray = function() {
          return this.octets.slice(0);
        };
        IPv4.prototype.match = function(other, cidrRange) {
          var ref;
          if (cidrRange === void 0) {
            ref = other, other = ref[0], cidrRange = ref[1];
          }
          if (other.kind() !== "ipv4") {
            throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
          }
          return matchCIDR(this.octets, other.octets, 8, cidrRange);
        };
        IPv4.prototype.SpecialRanges = {
          unspecified: [[new IPv4([0, 0, 0, 0]), 8]],
          broadcast: [[new IPv4([255, 255, 255, 255]), 32]],
          multicast: [[new IPv4([224, 0, 0, 0]), 4]],
          linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],
          loopback: [[new IPv4([127, 0, 0, 0]), 8]],
          carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],
          "private": [[new IPv4([10, 0, 0, 0]), 8], [new IPv4([172, 16, 0, 0]), 12], [new IPv4([192, 168, 0, 0]), 16]],
          reserved: [[new IPv4([192, 0, 0, 0]), 24], [new IPv4([192, 0, 2, 0]), 24], [new IPv4([192, 88, 99, 0]), 24], [new IPv4([198, 51, 100, 0]), 24], [new IPv4([203, 0, 113, 0]), 24], [new IPv4([240, 0, 0, 0]), 4]]
        };
        IPv4.prototype.range = function() {
          return ipaddr.subnetMatch(this, this.SpecialRanges);
        };
        IPv4.prototype.toIPv4MappedAddress = function() {
          return ipaddr.IPv6.parse("::ffff:" + this.toString());
        };
        IPv4.prototype.prefixLengthFromSubnetMask = function() {
          var cidr, i, k, octet, stop, zeros, zerotable;
          zerotable = {
            0: 8,
            128: 7,
            192: 6,
            224: 5,
            240: 4,
            248: 3,
            252: 2,
            254: 1,
            255: 0
          };
          cidr = 0;
          stop = false;
          for (i = k = 3; k >= 0; i = k += -1) {
            octet = this.octets[i];
            if (octet in zerotable) {
              zeros = zerotable[octet];
              if (stop && zeros !== 0) {
                return null;
              }
              if (zeros !== 8) {
                stop = true;
              }
              cidr += zeros;
            } else {
              return null;
            }
          }
          return 32 - cidr;
        };
        return IPv4;
      }();
      ipv4Part = "(0?\\d+|0x[a-f0-9]+)";
      ipv4Regexes = {
        fourOctet: new RegExp("^" + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "$", "i"),
        longValue: new RegExp("^" + ipv4Part + "$", "i")
      };
      ipaddr.IPv4.parser = function(string) {
        var match, parseIntAuto, part, shift, value;
        parseIntAuto = function(string2) {
          if (string2[0] === "0" && string2[1] !== "x") {
            return parseInt(string2, 8);
          } else {
            return parseInt(string2);
          }
        };
        if (match = string.match(ipv4Regexes.fourOctet)) {
          return function() {
            var k, len, ref, results;
            ref = match.slice(1, 6);
            results = [];
            for (k = 0, len = ref.length; k < len; k++) {
              part = ref[k];
              results.push(parseIntAuto(part));
            }
            return results;
          }();
        } else if (match = string.match(ipv4Regexes.longValue)) {
          value = parseIntAuto(match[1]);
          if (value > 4294967295 || value < 0) {
            throw new Error("ipaddr: address outside defined range");
          }
          return function() {
            var k, results;
            results = [];
            for (shift = k = 0; k <= 24; shift = k += 8) {
              results.push(value >> shift & 255);
            }
            return results;
          }().reverse();
        } else {
          return null;
        }
      };
      ipaddr.IPv6 = function() {
        function IPv6(parts, zoneId) {
          var i, k, l, len, part, ref;
          if (parts.length === 16) {
            this.parts = [];
            for (i = k = 0; k <= 14; i = k += 2) {
              this.parts.push(parts[i] << 8 | parts[i + 1]);
            }
          } else if (parts.length === 8) {
            this.parts = parts;
          } else {
            throw new Error("ipaddr: ipv6 part count should be 8 or 16");
          }
          ref = this.parts;
          for (l = 0, len = ref.length; l < len; l++) {
            part = ref[l];
            if (!(0 <= part && part <= 65535)) {
              throw new Error("ipaddr: ipv6 part should fit in 16 bits");
            }
          }
          if (zoneId) {
            this.zoneId = zoneId;
          }
        }
        IPv6.prototype.kind = function() {
          return "ipv6";
        };
        IPv6.prototype.toString = function() {
          return this.toNormalizedString().replace(/((^|:)(0(:|$))+)/, "::");
        };
        IPv6.prototype.toRFC5952String = function() {
          var bestMatchIndex, bestMatchLength, match, regex, string;
          regex = /((^|:)(0(:|$)){2,})/g;
          string = this.toNormalizedString();
          bestMatchIndex = 0;
          bestMatchLength = -1;
          while (match = regex.exec(string)) {
            if (match[0].length > bestMatchLength) {
              bestMatchIndex = match.index;
              bestMatchLength = match[0].length;
            }
          }
          if (bestMatchLength < 0) {
            return string;
          }
          return string.substring(0, bestMatchIndex) + "::" + string.substring(bestMatchIndex + bestMatchLength);
        };
        IPv6.prototype.toByteArray = function() {
          var bytes, k, len, part, ref;
          bytes = [];
          ref = this.parts;
          for (k = 0, len = ref.length; k < len; k++) {
            part = ref[k];
            bytes.push(part >> 8);
            bytes.push(part & 255);
          }
          return bytes;
        };
        IPv6.prototype.toNormalizedString = function() {
          var addr, part, suffix;
          addr = (function() {
            var k, len, ref, results;
            ref = this.parts;
            results = [];
            for (k = 0, len = ref.length; k < len; k++) {
              part = ref[k];
              results.push(part.toString(16));
            }
            return results;
          }).call(this).join(":");
          suffix = "";
          if (this.zoneId) {
            suffix = "%" + this.zoneId;
          }
          return addr + suffix;
        };
        IPv6.prototype.toFixedLengthString = function() {
          var addr, part, suffix;
          addr = (function() {
            var k, len, ref, results;
            ref = this.parts;
            results = [];
            for (k = 0, len = ref.length; k < len; k++) {
              part = ref[k];
              results.push(part.toString(16).padStart(4, "0"));
            }
            return results;
          }).call(this).join(":");
          suffix = "";
          if (this.zoneId) {
            suffix = "%" + this.zoneId;
          }
          return addr + suffix;
        };
        IPv6.prototype.match = function(other, cidrRange) {
          var ref;
          if (cidrRange === void 0) {
            ref = other, other = ref[0], cidrRange = ref[1];
          }
          if (other.kind() !== "ipv6") {
            throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
          }
          return matchCIDR(this.parts, other.parts, 16, cidrRange);
        };
        IPv6.prototype.SpecialRanges = {
          unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],
          linkLocal: [new IPv6([65152, 0, 0, 0, 0, 0, 0, 0]), 10],
          multicast: [new IPv6([65280, 0, 0, 0, 0, 0, 0, 0]), 8],
          loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],
          uniqueLocal: [new IPv6([64512, 0, 0, 0, 0, 0, 0, 0]), 7],
          ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 65535, 0, 0]), 96],
          rfc6145: [new IPv6([0, 0, 0, 0, 65535, 0, 0, 0]), 96],
          rfc6052: [new IPv6([100, 65435, 0, 0, 0, 0, 0, 0]), 96],
          "6to4": [new IPv6([8194, 0, 0, 0, 0, 0, 0, 0]), 16],
          teredo: [new IPv6([8193, 0, 0, 0, 0, 0, 0, 0]), 32],
          reserved: [[new IPv6([8193, 3512, 0, 0, 0, 0, 0, 0]), 32]]
        };
        IPv6.prototype.range = function() {
          return ipaddr.subnetMatch(this, this.SpecialRanges);
        };
        IPv6.prototype.isIPv4MappedAddress = function() {
          return this.range() === "ipv4Mapped";
        };
        IPv6.prototype.toIPv4Address = function() {
          var high, low, ref;
          if (!this.isIPv4MappedAddress()) {
            throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
          }
          ref = this.parts.slice(-2), high = ref[0], low = ref[1];
          return new ipaddr.IPv4([high >> 8, high & 255, low >> 8, low & 255]);
        };
        IPv6.prototype.prefixLengthFromSubnetMask = function() {
          var cidr, i, k, part, stop, zeros, zerotable;
          zerotable = {
            0: 16,
            32768: 15,
            49152: 14,
            57344: 13,
            61440: 12,
            63488: 11,
            64512: 10,
            65024: 9,
            65280: 8,
            65408: 7,
            65472: 6,
            65504: 5,
            65520: 4,
            65528: 3,
            65532: 2,
            65534: 1,
            65535: 0
          };
          cidr = 0;
          stop = false;
          for (i = k = 7; k >= 0; i = k += -1) {
            part = this.parts[i];
            if (part in zerotable) {
              zeros = zerotable[part];
              if (stop && zeros !== 0) {
                return null;
              }
              if (zeros !== 16) {
                stop = true;
              }
              cidr += zeros;
            } else {
              return null;
            }
          }
          return 128 - cidr;
        };
        return IPv6;
      }();
      ipv6Part = "(?:[0-9a-f]+::?)+";
      zoneIndex = "%[0-9a-z]{1,}";
      ipv6Regexes = {
        zoneIndex: new RegExp(zoneIndex, "i"),
        "native": new RegExp("^(::)?(" + ipv6Part + ")?([0-9a-f]+)?(::)?(" + zoneIndex + ")?$", "i"),
        transitional: new RegExp("^((?:" + ipv6Part + ")|(?:::)(?:" + ipv6Part + ")?)" + (ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part) + ("(" + zoneIndex + ")?$"), "i")
      };
      expandIPv6 = function(string, parts) {
        var colonCount, lastColon, part, replacement, replacementCount, zoneId;
        if (string.indexOf("::") !== string.lastIndexOf("::")) {
          return null;
        }
        zoneId = (string.match(ipv6Regexes["zoneIndex"]) || [])[0];
        if (zoneId) {
          zoneId = zoneId.substring(1);
          string = string.replace(/%.+$/, "");
        }
        colonCount = 0;
        lastColon = -1;
        while ((lastColon = string.indexOf(":", lastColon + 1)) >= 0) {
          colonCount++;
        }
        if (string.substr(0, 2) === "::") {
          colonCount--;
        }
        if (string.substr(-2, 2) === "::") {
          colonCount--;
        }
        if (colonCount > parts) {
          return null;
        }
        replacementCount = parts - colonCount;
        replacement = ":";
        while (replacementCount--) {
          replacement += "0:";
        }
        string = string.replace("::", replacement);
        if (string[0] === ":") {
          string = string.slice(1);
        }
        if (string[string.length - 1] === ":") {
          string = string.slice(0, -1);
        }
        parts = function() {
          var k, len, ref, results;
          ref = string.split(":");
          results = [];
          for (k = 0, len = ref.length; k < len; k++) {
            part = ref[k];
            results.push(parseInt(part, 16));
          }
          return results;
        }();
        return {
          parts,
          zoneId
        };
      };
      ipaddr.IPv6.parser = function(string) {
        var addr, k, len, match, octet, octets, zoneId;
        if (ipv6Regexes["native"].test(string)) {
          return expandIPv6(string, 8);
        } else if (match = string.match(ipv6Regexes["transitional"])) {
          zoneId = match[6] || "";
          addr = expandIPv6(match[1].slice(0, -1) + zoneId, 6);
          if (addr.parts) {
            octets = [parseInt(match[2]), parseInt(match[3]), parseInt(match[4]), parseInt(match[5])];
            for (k = 0, len = octets.length; k < len; k++) {
              octet = octets[k];
              if (!(0 <= octet && octet <= 255)) {
                return null;
              }
            }
            addr.parts.push(octets[0] << 8 | octets[1]);
            addr.parts.push(octets[2] << 8 | octets[3]);
            return {
              parts: addr.parts,
              zoneId: addr.zoneId
            };
          }
        }
        return null;
      };
      ipaddr.IPv4.isIPv4 = ipaddr.IPv6.isIPv6 = function(string) {
        return this.parser(string) !== null;
      };
      ipaddr.IPv4.isValid = function(string) {
        var e;
        try {
          new this(this.parser(string));
          return true;
        } catch (error1) {
          e = error1;
          return false;
        }
      };
      ipaddr.IPv4.isValidFourPartDecimal = function(string) {
        if (ipaddr.IPv4.isValid(string) && string.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/)) {
          return true;
        } else {
          return false;
        }
      };
      ipaddr.IPv6.isValid = function(string) {
        var addr, e;
        if (typeof string === "string" && string.indexOf(":") === -1) {
          return false;
        }
        try {
          addr = this.parser(string);
          new this(addr.parts, addr.zoneId);
          return true;
        } catch (error1) {
          e = error1;
          return false;
        }
      };
      ipaddr.IPv4.parse = function(string) {
        var parts;
        parts = this.parser(string);
        if (parts === null) {
          throw new Error("ipaddr: string is not formatted like ip address");
        }
        return new this(parts);
      };
      ipaddr.IPv6.parse = function(string) {
        var addr;
        addr = this.parser(string);
        if (addr.parts === null) {
          throw new Error("ipaddr: string is not formatted like ip address");
        }
        return new this(addr.parts, addr.zoneId);
      };
      ipaddr.IPv4.parseCIDR = function(string) {
        var maskLength, match, parsed;
        if (match = string.match(/^(.+)\/(\d+)$/)) {
          maskLength = parseInt(match[2]);
          if (maskLength >= 0 && maskLength <= 32) {
            parsed = [this.parse(match[1]), maskLength];
            Object.defineProperty(parsed, "toString", {
              value: function() {
                return this.join("/");
              }
            });
            return parsed;
          }
        }
        throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
      };
      ipaddr.IPv4.subnetMaskFromPrefixLength = function(prefix) {
        var filledOctetCount, j, octets;
        prefix = parseInt(prefix);
        if (prefix < 0 || prefix > 32) {
          throw new Error("ipaddr: invalid IPv4 prefix length");
        }
        octets = [0, 0, 0, 0];
        j = 0;
        filledOctetCount = Math.floor(prefix / 8);
        while (j < filledOctetCount) {
          octets[j] = 255;
          j++;
        }
        if (filledOctetCount < 4) {
          octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
        }
        return new this(octets);
      };
      ipaddr.IPv4.broadcastAddressFromCIDR = function(string) {
        var cidr, error, i, ipInterfaceOctets, octets, subnetMaskOctets;
        try {
          cidr = this.parseCIDR(string);
          ipInterfaceOctets = cidr[0].toByteArray();
          subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          octets = [];
          i = 0;
          while (i < 4) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
            i++;
          }
          return new this(octets);
        } catch (error1) {
          error = error1;
          throw new Error("ipaddr: the address does not have IPv4 CIDR format");
        }
      };
      ipaddr.IPv4.networkAddressFromCIDR = function(string) {
        var cidr, error, i, ipInterfaceOctets, octets, subnetMaskOctets;
        try {
          cidr = this.parseCIDR(string);
          ipInterfaceOctets = cidr[0].toByteArray();
          subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          octets = [];
          i = 0;
          while (i < 4) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
            i++;
          }
          return new this(octets);
        } catch (error1) {
          error = error1;
          throw new Error("ipaddr: the address does not have IPv4 CIDR format");
        }
      };
      ipaddr.IPv6.parseCIDR = function(string) {
        var maskLength, match, parsed;
        if (match = string.match(/^(.+)\/(\d+)$/)) {
          maskLength = parseInt(match[2]);
          if (maskLength >= 0 && maskLength <= 128) {
            parsed = [this.parse(match[1]), maskLength];
            Object.defineProperty(parsed, "toString", {
              value: function() {
                return this.join("/");
              }
            });
            return parsed;
          }
        }
        throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
      };
      ipaddr.isValid = function(string) {
        return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);
      };
      ipaddr.parse = function(string) {
        if (ipaddr.IPv6.isValid(string)) {
          return ipaddr.IPv6.parse(string);
        } else if (ipaddr.IPv4.isValid(string)) {
          return ipaddr.IPv4.parse(string);
        } else {
          throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
        }
      };
      ipaddr.parseCIDR = function(string) {
        var e;
        try {
          return ipaddr.IPv6.parseCIDR(string);
        } catch (error1) {
          e = error1;
          try {
            return ipaddr.IPv4.parseCIDR(string);
          } catch (error12) {
            e = error12;
            throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
          }
        }
      };
      ipaddr.fromByteArray = function(bytes) {
        var length;
        length = bytes.length;
        if (length === 4) {
          return new ipaddr.IPv4(bytes);
        } else if (length === 16) {
          return new ipaddr.IPv6(bytes);
        } else {
          throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
        }
      };
      ipaddr.process = function(string) {
        var addr;
        addr = this.parse(string);
        if (addr.kind() === "ipv6" && addr.isIPv4MappedAddress()) {
          return addr.toIPv4Address();
        } else {
          return addr;
        }
      };
    }).call(exports2);
  }
});

// ../../../node_modules/proxy-addr/index.js
var require_proxy_addr = __commonJS({
  "../../../node_modules/proxy-addr/index.js"(exports2, module2) {
    "use strict";
    module2.exports = proxyaddr;
    module2.exports.all = alladdrs;
    module2.exports.compile = compile;
    var forwarded = require_forwarded();
    var ipaddr = require_ipaddr();
    var DIGIT_REGEXP = /^[0-9]+$/;
    var isip = ipaddr.isValid;
    var parseip = ipaddr.parse;
    var IP_RANGES = {
      linklocal: ["169.254.0.0/16", "fe80::/10"],
      loopback: ["127.0.0.1/8", "::1/128"],
      uniquelocal: ["10.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16", "fc00::/7"]
    };
    function alladdrs(req, trust) {
      var addrs = forwarded(req);
      if (!trust) {
        return addrs;
      }
      if (typeof trust !== "function") {
        trust = compile(trust);
      }
      for (var i = 0; i < addrs.length - 1; i++) {
        if (trust(addrs[i], i))
          continue;
        addrs.length = i + 1;
      }
      return addrs;
    }
    function compile(val) {
      if (!val) {
        throw new TypeError("argument is required");
      }
      var trust;
      if (typeof val === "string") {
        trust = [val];
      } else if (Array.isArray(val)) {
        trust = val.slice();
      } else {
        throw new TypeError("unsupported trust argument");
      }
      for (var i = 0; i < trust.length; i++) {
        val = trust[i];
        if (!Object.prototype.hasOwnProperty.call(IP_RANGES, val)) {
          continue;
        }
        val = IP_RANGES[val];
        trust.splice.apply(trust, [i, 1].concat(val));
        i += val.length - 1;
      }
      return compileTrust(compileRangeSubnets(trust));
    }
    function compileRangeSubnets(arr) {
      var rangeSubnets = new Array(arr.length);
      for (var i = 0; i < arr.length; i++) {
        rangeSubnets[i] = parseipNotation(arr[i]);
      }
      return rangeSubnets;
    }
    function compileTrust(rangeSubnets) {
      var len = rangeSubnets.length;
      return len === 0 ? trustNone : len === 1 ? trustSingle(rangeSubnets[0]) : trustMulti(rangeSubnets);
    }
    function parseipNotation(note) {
      var pos = note.lastIndexOf("/");
      var str = pos !== -1 ? note.substring(0, pos) : note;
      if (!isip(str)) {
        throw new TypeError("invalid IP address: " + str);
      }
      var ip = parseip(str);
      if (pos === -1 && ip.kind() === "ipv6" && ip.isIPv4MappedAddress()) {
        ip = ip.toIPv4Address();
      }
      var max = ip.kind() === "ipv6" ? 128 : 32;
      var range = pos !== -1 ? note.substring(pos + 1, note.length) : null;
      if (range === null) {
        range = max;
      } else if (DIGIT_REGEXP.test(range)) {
        range = parseInt(range, 10);
      } else if (ip.kind() === "ipv4" && isip(range)) {
        range = parseNetmask(range);
      } else {
        range = null;
      }
      if (range <= 0 || range > max) {
        throw new TypeError("invalid range on address: " + note);
      }
      return [ip, range];
    }
    function parseNetmask(netmask) {
      var ip = parseip(netmask);
      var kind = ip.kind();
      return kind === "ipv4" ? ip.prefixLengthFromSubnetMask() : null;
    }
    function proxyaddr(req, trust) {
      if (!req) {
        throw new TypeError("req argument is required");
      }
      if (!trust) {
        throw new TypeError("trust argument is required");
      }
      var addrs = alladdrs(req, trust);
      var addr = addrs[addrs.length - 1];
      return addr;
    }
    function trustNone() {
      return false;
    }
    function trustMulti(subnets) {
      return function trust(addr) {
        if (!isip(addr))
          return false;
        var ip = parseip(addr);
        var ipconv;
        var kind = ip.kind();
        for (var i = 0; i < subnets.length; i++) {
          var subnet = subnets[i];
          var subnetip = subnet[0];
          var subnetkind = subnetip.kind();
          var subnetrange = subnet[1];
          var trusted = ip;
          if (kind !== subnetkind) {
            if (subnetkind === "ipv4" && !ip.isIPv4MappedAddress()) {
              continue;
            }
            if (!ipconv) {
              ipconv = subnetkind === "ipv4" ? ip.toIPv4Address() : ip.toIPv4MappedAddress();
            }
            trusted = ipconv;
          }
          if (trusted.match(subnetip, subnetrange)) {
            return true;
          }
        }
        return false;
      };
    }
    function trustSingle(subnet) {
      var subnetip = subnet[0];
      var subnetkind = subnetip.kind();
      var subnetisipv4 = subnetkind === "ipv4";
      var subnetrange = subnet[1];
      return function trust(addr) {
        if (!isip(addr))
          return false;
        var ip = parseip(addr);
        var kind = ip.kind();
        if (kind !== subnetkind) {
          if (subnetisipv4 && !ip.isIPv4MappedAddress()) {
            return false;
          }
          ip = subnetisipv4 ? ip.toIPv4Address() : ip.toIPv4MappedAddress();
        }
        return ip.match(subnetip, subnetrange);
      };
    }
  }
});

// ../../../node_modules/express/lib/utils.js
var require_utils6 = __commonJS({
  "../../../node_modules/express/lib/utils.js"(exports2) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var contentDisposition = require_content_disposition();
    var contentType = require_content_type();
    var deprecate = require_browser2()("express");
    var flatten = require_array_flatten();
    var mime = require_send().mime;
    var etag = require_etag();
    var proxyaddr = require_proxy_addr();
    var qs = require_lib6();
    var querystring = require_querystring();
    exports2.etag = createETagGenerator({ weak: false });
    exports2.wetag = createETagGenerator({ weak: true });
    exports2.isAbsolute = function(path) {
      if ("/" === path[0])
        return true;
      if (":" === path[1] && ("\\" === path[2] || "/" === path[2]))
        return true;
      if ("\\\\" === path.substring(0, 2))
        return true;
    };
    exports2.flatten = deprecate.function(
      flatten,
      "utils.flatten: use array-flatten npm module instead"
    );
    exports2.normalizeType = function(type) {
      return ~type.indexOf("/") ? acceptParams(type) : { value: mime.lookup(type), params: {} };
    };
    exports2.normalizeTypes = function(types) {
      var ret = [];
      for (var i = 0; i < types.length; ++i) {
        ret.push(exports2.normalizeType(types[i]));
      }
      return ret;
    };
    exports2.contentDisposition = deprecate.function(
      contentDisposition,
      "utils.contentDisposition: use content-disposition npm module instead"
    );
    function acceptParams(str, index) {
      var parts = str.split(/ *; */);
      var ret = { value: parts[0], quality: 1, params: {}, originalIndex: index };
      for (var i = 1; i < parts.length; ++i) {
        var pms = parts[i].split(/ *= */);
        if ("q" === pms[0]) {
          ret.quality = parseFloat(pms[1]);
        } else {
          ret.params[pms[0]] = pms[1];
        }
      }
      return ret;
    }
    exports2.compileETag = function(val) {
      var fn;
      if (typeof val === "function") {
        return val;
      }
      switch (val) {
        case true:
        case "weak":
          fn = exports2.wetag;
          break;
        case false:
          break;
        case "strong":
          fn = exports2.etag;
          break;
        default:
          throw new TypeError("unknown value for etag function: " + val);
      }
      return fn;
    };
    exports2.compileQueryParser = function compileQueryParser(val) {
      var fn;
      if (typeof val === "function") {
        return val;
      }
      switch (val) {
        case true:
        case "simple":
          fn = querystring.parse;
          break;
        case false:
          fn = newObject;
          break;
        case "extended":
          fn = parseExtendedQueryString;
          break;
        default:
          throw new TypeError("unknown value for query parser function: " + val);
      }
      return fn;
    };
    exports2.compileTrust = function(val) {
      if (typeof val === "function")
        return val;
      if (val === true) {
        return function() {
          return true;
        };
      }
      if (typeof val === "number") {
        return function(a, i) {
          return i < val;
        };
      }
      if (typeof val === "string") {
        val = val.split(",").map(function(v) {
          return v.trim();
        });
      }
      return proxyaddr.compile(val || []);
    };
    exports2.setCharset = function setCharset(type, charset) {
      if (!type || !charset) {
        return type;
      }
      var parsed = contentType.parse(type);
      parsed.parameters.charset = charset;
      return contentType.format(parsed);
    };
    function createETagGenerator(options) {
      return function generateETag(body, encoding) {
        var buf = !Buffer2.isBuffer(body) ? Buffer2.from(body, encoding) : body;
        return etag(buf, options);
      };
    }
    function parseExtendedQueryString(str) {
      return qs.parse(str, {
        allowPrototypes: true
      });
    }
    function newObject() {
      return {};
    }
  }
});

// ../../../node_modules/express/lib/application.js
var require_application = __commonJS({
  "../../../node_modules/express/lib/application.js"(exports2, module2) {
    "use strict";
    var finalhandler = require_finalhandler();
    var Router = require_router();
    var methods = require_methods();
    var middleware = require_init();
    var query = require_query();
    var debug = require_browser3()("express:application");
    var View = require_view();
    var http = require_http();
    var compileETag = require_utils6().compileETag;
    var compileQueryParser = require_utils6().compileQueryParser;
    var compileTrust = require_utils6().compileTrust;
    var deprecate = require_browser2()("express");
    var flatten = require_array_flatten();
    var merge = require_utils_merge();
    var resolve = require_path().resolve;
    var setPrototypeOf = require_setprototypeof();
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    var slice = Array.prototype.slice;
    var app2 = exports2 = module2.exports = {};
    var trustProxyDefaultSymbol = "@@symbol:trust_proxy_default";
    app2.init = function init() {
      this.cache = {};
      this.engines = {};
      this.settings = {};
      this.defaultConfiguration();
    };
    app2.defaultConfiguration = function defaultConfiguration() {
      var env = "development";
      this.enable("x-powered-by");
      this.set("etag", "weak");
      this.set("env", env);
      this.set("query parser", "extended");
      this.set("subdomain offset", 2);
      this.set("trust proxy", false);
      Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
        configurable: true,
        value: true
      });
      debug("booting in %s mode", env);
      this.on("mount", function onmount(parent) {
        if (this.settings[trustProxyDefaultSymbol] === true && typeof parent.settings["trust proxy fn"] === "function") {
          delete this.settings["trust proxy"];
          delete this.settings["trust proxy fn"];
        }
        setPrototypeOf(this.request, parent.request);
        setPrototypeOf(this.response, parent.response);
        setPrototypeOf(this.engines, parent.engines);
        setPrototypeOf(this.settings, parent.settings);
      });
      this.locals = /* @__PURE__ */ Object.create(null);
      this.mountpath = "/";
      this.locals.settings = this.settings;
      this.set("view", View);
      this.set("views", resolve("views"));
      this.set("jsonp callback name", "callback");
      if (env === "production") {
        this.enable("view cache");
      }
      Object.defineProperty(this, "router", {
        get: function() {
          throw new Error("'app.router' is deprecated!\nPlease see the 3.x to 4.x migration guide for details on how to update your app.");
        }
      });
    };
    app2.lazyrouter = function lazyrouter() {
      if (!this._router) {
        this._router = new Router({
          caseSensitive: this.enabled("case sensitive routing"),
          strict: this.enabled("strict routing")
        });
        this._router.use(query(this.get("query parser fn")));
        this._router.use(middleware.init(this));
      }
    };
    app2.handle = function handle(req, res, callback) {
      var router = this._router;
      var done = callback || finalhandler(req, res, {
        env: this.get("env"),
        onerror: logerror.bind(this)
      });
      if (!router) {
        debug("no routes defined on app");
        done();
        return;
      }
      router.handle(req, res, done);
    };
    app2.use = function use(fn) {
      var offset = 0;
      var path = "/";
      if (typeof fn !== "function") {
        var arg = fn;
        while (Array.isArray(arg) && arg.length !== 0) {
          arg = arg[0];
        }
        if (typeof arg !== "function") {
          offset = 1;
          path = fn;
        }
      }
      var fns = flatten(slice.call(arguments, offset));
      if (fns.length === 0) {
        throw new TypeError("app.use() requires a middleware function");
      }
      this.lazyrouter();
      var router = this._router;
      fns.forEach(function(fn2) {
        if (!fn2 || !fn2.handle || !fn2.set) {
          return router.use(path, fn2);
        }
        debug(".use app under %s", path);
        fn2.mountpath = path;
        fn2.parent = this;
        router.use(path, function mounted_app(req, res, next) {
          var orig = req.app;
          fn2.handle(req, res, function(err) {
            setPrototypeOf(req, orig.request);
            setPrototypeOf(res, orig.response);
            next(err);
          });
        });
        fn2.emit("mount", this);
      }, this);
      return this;
    };
    app2.route = function route(path) {
      this.lazyrouter();
      return this._router.route(path);
    };
    app2.engine = function engine(ext, fn) {
      if (typeof fn !== "function") {
        throw new Error("callback function required");
      }
      var extension = ext[0] !== "." ? "." + ext : ext;
      this.engines[extension] = fn;
      return this;
    };
    app2.param = function param(name, fn) {
      this.lazyrouter();
      if (Array.isArray(name)) {
        for (var i = 0; i < name.length; i++) {
          this.param(name[i], fn);
        }
        return this;
      }
      this._router.param(name, fn);
      return this;
    };
    app2.set = function set(setting, val) {
      if (arguments.length === 1) {
        var settings = this.settings;
        while (settings && settings !== Object.prototype) {
          if (hasOwnProperty2.call(settings, setting)) {
            return settings[setting];
          }
          settings = Object.getPrototypeOf(settings);
        }
        return void 0;
      }
      debug('set "%s" to %o', setting, val);
      this.settings[setting] = val;
      switch (setting) {
        case "etag":
          this.set("etag fn", compileETag(val));
          break;
        case "query parser":
          this.set("query parser fn", compileQueryParser(val));
          break;
        case "trust proxy":
          this.set("trust proxy fn", compileTrust(val));
          Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
            configurable: true,
            value: false
          });
          break;
      }
      return this;
    };
    app2.path = function path() {
      return this.parent ? this.parent.path() + this.mountpath : "";
    };
    app2.enabled = function enabled(setting) {
      return Boolean(this.set(setting));
    };
    app2.disabled = function disabled(setting) {
      return !this.set(setting);
    };
    app2.enable = function enable(setting) {
      return this.set(setting, true);
    };
    app2.disable = function disable(setting) {
      return this.set(setting, false);
    };
    methods.forEach(function(method) {
      app2[method] = function(path) {
        if (method === "get" && arguments.length === 1) {
          return this.set(path);
        }
        this.lazyrouter();
        var route = this._router.route(path);
        route[method].apply(route, slice.call(arguments, 1));
        return this;
      };
    });
    app2.all = function all(path) {
      this.lazyrouter();
      var route = this._router.route(path);
      var args = slice.call(arguments, 1);
      for (var i = 0; i < methods.length; i++) {
        route[methods[i]].apply(route, args);
      }
      return this;
    };
    app2.del = deprecate.function(app2.delete, "app.del: Use app.delete instead");
    app2.render = function render(name, options, callback) {
      var cache = this.cache;
      var done = callback;
      var engines = this.engines;
      var opts = options;
      var renderOptions = {};
      var view;
      if (typeof options === "function") {
        done = options;
        opts = {};
      }
      merge(renderOptions, this.locals);
      if (opts._locals) {
        merge(renderOptions, opts._locals);
      }
      merge(renderOptions, opts);
      if (renderOptions.cache == null) {
        renderOptions.cache = this.enabled("view cache");
      }
      if (renderOptions.cache) {
        view = cache[name];
      }
      if (!view) {
        var View2 = this.get("view");
        view = new View2(name, {
          defaultEngine: this.get("view engine"),
          root: this.get("views"),
          engines
        });
        if (!view.path) {
          var dirs = Array.isArray(view.root) && view.root.length > 1 ? 'directories "' + view.root.slice(0, -1).join('", "') + '" or "' + view.root[view.root.length - 1] + '"' : 'directory "' + view.root + '"';
          var err = new Error('Failed to lookup view "' + name + '" in views ' + dirs);
          err.view = view;
          return done(err);
        }
        if (renderOptions.cache) {
          cache[name] = view;
        }
      }
      tryRender(view, renderOptions, done);
    };
    app2.listen = function listen() {
      var server = http.createServer(this);
      return server.listen.apply(server, arguments);
    };
    function logerror(err) {
      if (this.get("env") !== "test")
        console.error(err.stack || err.toString());
    }
    function tryRender(view, options, callback) {
      try {
        view.render(options, callback);
      } catch (err) {
        callback(err);
      }
    }
  }
});

// ../../../node_modules/negotiator/lib/charset.js
var require_charset = __commonJS({
  "../../../node_modules/negotiator/lib/charset.js"(exports2, module2) {
    "use strict";
    module2.exports = preferredCharsets;
    module2.exports.preferredCharsets = preferredCharsets;
    var simpleCharsetRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
    function parseAcceptCharset(accept) {
      var accepts = accept.split(",");
      for (var i = 0, j = 0; i < accepts.length; i++) {
        var charset = parseCharset(accepts[i].trim(), i);
        if (charset) {
          accepts[j++] = charset;
        }
      }
      accepts.length = j;
      return accepts;
    }
    function parseCharset(str, i) {
      var match = simpleCharsetRegExp.exec(str);
      if (!match)
        return null;
      var charset = match[1];
      var q = 1;
      if (match[2]) {
        var params = match[2].split(";");
        for (var j = 0; j < params.length; j++) {
          var p = params[j].trim().split("=");
          if (p[0] === "q") {
            q = parseFloat(p[1]);
            break;
          }
        }
      }
      return {
        charset,
        q,
        i
      };
    }
    function getCharsetPriority(charset, accepted, index) {
      var priority = { o: -1, q: 0, s: 0 };
      for (var i = 0; i < accepted.length; i++) {
        var spec = specify(charset, accepted[i], index);
        if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
          priority = spec;
        }
      }
      return priority;
    }
    function specify(charset, spec, index) {
      var s = 0;
      if (spec.charset.toLowerCase() === charset.toLowerCase()) {
        s |= 1;
      } else if (spec.charset !== "*") {
        return null;
      }
      return {
        i: index,
        o: spec.i,
        q: spec.q,
        s
      };
    }
    function preferredCharsets(accept, provided) {
      var accepts = parseAcceptCharset(accept === void 0 ? "*" : accept || "");
      if (!provided) {
        return accepts.filter(isQuality).sort(compareSpecs).map(getFullCharset);
      }
      var priorities = provided.map(function getPriority(type, index) {
        return getCharsetPriority(type, accepts, index);
      });
      return priorities.filter(isQuality).sort(compareSpecs).map(function getCharset(priority) {
        return provided[priorities.indexOf(priority)];
      });
    }
    function compareSpecs(a, b) {
      return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
    }
    function getFullCharset(spec) {
      return spec.charset;
    }
    function isQuality(spec) {
      return spec.q > 0;
    }
  }
});

// ../../../node_modules/negotiator/lib/encoding.js
var require_encoding = __commonJS({
  "../../../node_modules/negotiator/lib/encoding.js"(exports2, module2) {
    "use strict";
    module2.exports = preferredEncodings;
    module2.exports.preferredEncodings = preferredEncodings;
    var simpleEncodingRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
    function parseAcceptEncoding(accept) {
      var accepts = accept.split(",");
      var hasIdentity = false;
      var minQuality = 1;
      for (var i = 0, j = 0; i < accepts.length; i++) {
        var encoding = parseEncoding(accepts[i].trim(), i);
        if (encoding) {
          accepts[j++] = encoding;
          hasIdentity = hasIdentity || specify("identity", encoding);
          minQuality = Math.min(minQuality, encoding.q || 1);
        }
      }
      if (!hasIdentity) {
        accepts[j++] = {
          encoding: "identity",
          q: minQuality,
          i
        };
      }
      accepts.length = j;
      return accepts;
    }
    function parseEncoding(str, i) {
      var match = simpleEncodingRegExp.exec(str);
      if (!match)
        return null;
      var encoding = match[1];
      var q = 1;
      if (match[2]) {
        var params = match[2].split(";");
        for (var j = 0; j < params.length; j++) {
          var p = params[j].trim().split("=");
          if (p[0] === "q") {
            q = parseFloat(p[1]);
            break;
          }
        }
      }
      return {
        encoding,
        q,
        i
      };
    }
    function getEncodingPriority(encoding, accepted, index) {
      var priority = { o: -1, q: 0, s: 0 };
      for (var i = 0; i < accepted.length; i++) {
        var spec = specify(encoding, accepted[i], index);
        if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
          priority = spec;
        }
      }
      return priority;
    }
    function specify(encoding, spec, index) {
      var s = 0;
      if (spec.encoding.toLowerCase() === encoding.toLowerCase()) {
        s |= 1;
      } else if (spec.encoding !== "*") {
        return null;
      }
      return {
        i: index,
        o: spec.i,
        q: spec.q,
        s
      };
    }
    function preferredEncodings(accept, provided) {
      var accepts = parseAcceptEncoding(accept || "");
      if (!provided) {
        return accepts.filter(isQuality).sort(compareSpecs).map(getFullEncoding);
      }
      var priorities = provided.map(function getPriority(type, index) {
        return getEncodingPriority(type, accepts, index);
      });
      return priorities.filter(isQuality).sort(compareSpecs).map(function getEncoding(priority) {
        return provided[priorities.indexOf(priority)];
      });
    }
    function compareSpecs(a, b) {
      return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
    }
    function getFullEncoding(spec) {
      return spec.encoding;
    }
    function isQuality(spec) {
      return spec.q > 0;
    }
  }
});

// ../../../node_modules/negotiator/lib/language.js
var require_language = __commonJS({
  "../../../node_modules/negotiator/lib/language.js"(exports2, module2) {
    "use strict";
    module2.exports = preferredLanguages;
    module2.exports.preferredLanguages = preferredLanguages;
    var simpleLanguageRegExp = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;
    function parseAcceptLanguage(accept) {
      var accepts = accept.split(",");
      for (var i = 0, j = 0; i < accepts.length; i++) {
        var language = parseLanguage(accepts[i].trim(), i);
        if (language) {
          accepts[j++] = language;
        }
      }
      accepts.length = j;
      return accepts;
    }
    function parseLanguage(str, i) {
      var match = simpleLanguageRegExp.exec(str);
      if (!match)
        return null;
      var prefix = match[1];
      var suffix = match[2];
      var full = prefix;
      if (suffix)
        full += "-" + suffix;
      var q = 1;
      if (match[3]) {
        var params = match[3].split(";");
        for (var j = 0; j < params.length; j++) {
          var p = params[j].split("=");
          if (p[0] === "q")
            q = parseFloat(p[1]);
        }
      }
      return {
        prefix,
        suffix,
        q,
        i,
        full
      };
    }
    function getLanguagePriority(language, accepted, index) {
      var priority = { o: -1, q: 0, s: 0 };
      for (var i = 0; i < accepted.length; i++) {
        var spec = specify(language, accepted[i], index);
        if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
          priority = spec;
        }
      }
      return priority;
    }
    function specify(language, spec, index) {
      var p = parseLanguage(language);
      if (!p)
        return null;
      var s = 0;
      if (spec.full.toLowerCase() === p.full.toLowerCase()) {
        s |= 4;
      } else if (spec.prefix.toLowerCase() === p.full.toLowerCase()) {
        s |= 2;
      } else if (spec.full.toLowerCase() === p.prefix.toLowerCase()) {
        s |= 1;
      } else if (spec.full !== "*") {
        return null;
      }
      return {
        i: index,
        o: spec.i,
        q: spec.q,
        s
      };
    }
    function preferredLanguages(accept, provided) {
      var accepts = parseAcceptLanguage(accept === void 0 ? "*" : accept || "");
      if (!provided) {
        return accepts.filter(isQuality).sort(compareSpecs).map(getFullLanguage);
      }
      var priorities = provided.map(function getPriority(type, index) {
        return getLanguagePriority(type, accepts, index);
      });
      return priorities.filter(isQuality).sort(compareSpecs).map(function getLanguage(priority) {
        return provided[priorities.indexOf(priority)];
      });
    }
    function compareSpecs(a, b) {
      return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
    }
    function getFullLanguage(spec) {
      return spec.full;
    }
    function isQuality(spec) {
      return spec.q > 0;
    }
  }
});

// ../../../node_modules/negotiator/lib/mediaType.js
var require_mediaType = __commonJS({
  "../../../node_modules/negotiator/lib/mediaType.js"(exports2, module2) {
    "use strict";
    module2.exports = preferredMediaTypes;
    module2.exports.preferredMediaTypes = preferredMediaTypes;
    var simpleMediaTypeRegExp = /^\s*([^\s\/;]+)\/([^;\s]+)\s*(?:;(.*))?$/;
    function parseAccept(accept) {
      var accepts = splitMediaTypes(accept);
      for (var i = 0, j = 0; i < accepts.length; i++) {
        var mediaType = parseMediaType(accepts[i].trim(), i);
        if (mediaType) {
          accepts[j++] = mediaType;
        }
      }
      accepts.length = j;
      return accepts;
    }
    function parseMediaType(str, i) {
      var match = simpleMediaTypeRegExp.exec(str);
      if (!match)
        return null;
      var params = /* @__PURE__ */ Object.create(null);
      var q = 1;
      var subtype = match[2];
      var type = match[1];
      if (match[3]) {
        var kvps = splitParameters(match[3]).map(splitKeyValuePair);
        for (var j = 0; j < kvps.length; j++) {
          var pair = kvps[j];
          var key = pair[0].toLowerCase();
          var val = pair[1];
          var value = val && val[0] === '"' && val[val.length - 1] === '"' ? val.substr(1, val.length - 2) : val;
          if (key === "q") {
            q = parseFloat(value);
            break;
          }
          params[key] = value;
        }
      }
      return {
        type,
        subtype,
        params,
        q,
        i
      };
    }
    function getMediaTypePriority(type, accepted, index) {
      var priority = { o: -1, q: 0, s: 0 };
      for (var i = 0; i < accepted.length; i++) {
        var spec = specify(type, accepted[i], index);
        if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
          priority = spec;
        }
      }
      return priority;
    }
    function specify(type, spec, index) {
      var p = parseMediaType(type);
      var s = 0;
      if (!p) {
        return null;
      }
      if (spec.type.toLowerCase() == p.type.toLowerCase()) {
        s |= 4;
      } else if (spec.type != "*") {
        return null;
      }
      if (spec.subtype.toLowerCase() == p.subtype.toLowerCase()) {
        s |= 2;
      } else if (spec.subtype != "*") {
        return null;
      }
      var keys = Object.keys(spec.params);
      if (keys.length > 0) {
        if (keys.every(function(k) {
          return spec.params[k] == "*" || (spec.params[k] || "").toLowerCase() == (p.params[k] || "").toLowerCase();
        })) {
          s |= 1;
        } else {
          return null;
        }
      }
      return {
        i: index,
        o: spec.i,
        q: spec.q,
        s
      };
    }
    function preferredMediaTypes(accept, provided) {
      var accepts = parseAccept(accept === void 0 ? "*/*" : accept || "");
      if (!provided) {
        return accepts.filter(isQuality).sort(compareSpecs).map(getFullType);
      }
      var priorities = provided.map(function getPriority(type, index) {
        return getMediaTypePriority(type, accepts, index);
      });
      return priorities.filter(isQuality).sort(compareSpecs).map(function getType(priority) {
        return provided[priorities.indexOf(priority)];
      });
    }
    function compareSpecs(a, b) {
      return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
    }
    function getFullType(spec) {
      return spec.type + "/" + spec.subtype;
    }
    function isQuality(spec) {
      return spec.q > 0;
    }
    function quoteCount(string) {
      var count = 0;
      var index = 0;
      while ((index = string.indexOf('"', index)) !== -1) {
        count++;
        index++;
      }
      return count;
    }
    function splitKeyValuePair(str) {
      var index = str.indexOf("=");
      var key;
      var val;
      if (index === -1) {
        key = str;
      } else {
        key = str.substr(0, index);
        val = str.substr(index + 1);
      }
      return [key, val];
    }
    function splitMediaTypes(accept) {
      var accepts = accept.split(",");
      for (var i = 1, j = 0; i < accepts.length; i++) {
        if (quoteCount(accepts[j]) % 2 == 0) {
          accepts[++j] = accepts[i];
        } else {
          accepts[j] += "," + accepts[i];
        }
      }
      accepts.length = j + 1;
      return accepts;
    }
    function splitParameters(str) {
      var parameters = str.split(";");
      for (var i = 1, j = 0; i < parameters.length; i++) {
        if (quoteCount(parameters[j]) % 2 == 0) {
          parameters[++j] = parameters[i];
        } else {
          parameters[j] += ";" + parameters[i];
        }
      }
      parameters.length = j + 1;
      for (var i = 0; i < parameters.length; i++) {
        parameters[i] = parameters[i].trim();
      }
      return parameters;
    }
  }
});

// ../../../node_modules/negotiator/index.js
var require_negotiator = __commonJS({
  "../../../node_modules/negotiator/index.js"(exports2, module2) {
    "use strict";
    var preferredCharsets = require_charset();
    var preferredEncodings = require_encoding();
    var preferredLanguages = require_language();
    var preferredMediaTypes = require_mediaType();
    module2.exports = Negotiator;
    module2.exports.Negotiator = Negotiator;
    function Negotiator(request) {
      if (!(this instanceof Negotiator)) {
        return new Negotiator(request);
      }
      this.request = request;
    }
    Negotiator.prototype.charset = function charset(available) {
      var set = this.charsets(available);
      return set && set[0];
    };
    Negotiator.prototype.charsets = function charsets(available) {
      return preferredCharsets(this.request.headers["accept-charset"], available);
    };
    Negotiator.prototype.encoding = function encoding(available) {
      var set = this.encodings(available);
      return set && set[0];
    };
    Negotiator.prototype.encodings = function encodings(available) {
      return preferredEncodings(this.request.headers["accept-encoding"], available);
    };
    Negotiator.prototype.language = function language(available) {
      var set = this.languages(available);
      return set && set[0];
    };
    Negotiator.prototype.languages = function languages(available) {
      return preferredLanguages(this.request.headers["accept-language"], available);
    };
    Negotiator.prototype.mediaType = function mediaType(available) {
      var set = this.mediaTypes(available);
      return set && set[0];
    };
    Negotiator.prototype.mediaTypes = function mediaTypes(available) {
      return preferredMediaTypes(this.request.headers.accept, available);
    };
    Negotiator.prototype.preferredCharset = Negotiator.prototype.charset;
    Negotiator.prototype.preferredCharsets = Negotiator.prototype.charsets;
    Negotiator.prototype.preferredEncoding = Negotiator.prototype.encoding;
    Negotiator.prototype.preferredEncodings = Negotiator.prototype.encodings;
    Negotiator.prototype.preferredLanguage = Negotiator.prototype.language;
    Negotiator.prototype.preferredLanguages = Negotiator.prototype.languages;
    Negotiator.prototype.preferredMediaType = Negotiator.prototype.mediaType;
    Negotiator.prototype.preferredMediaTypes = Negotiator.prototype.mediaTypes;
  }
});

// ../../../node_modules/accepts/index.js
var require_accepts = __commonJS({
  "../../../node_modules/accepts/index.js"(exports2, module2) {
    "use strict";
    var Negotiator = require_negotiator();
    var mime = require_mime_types();
    module2.exports = Accepts;
    function Accepts(req) {
      if (!(this instanceof Accepts)) {
        return new Accepts(req);
      }
      this.headers = req.headers;
      this.negotiator = new Negotiator(req);
    }
    Accepts.prototype.type = Accepts.prototype.types = function(types_) {
      var types = types_;
      if (types && !Array.isArray(types)) {
        types = new Array(arguments.length);
        for (var i = 0; i < types.length; i++) {
          types[i] = arguments[i];
        }
      }
      if (!types || types.length === 0) {
        return this.negotiator.mediaTypes();
      }
      if (!this.headers.accept) {
        return types[0];
      }
      var mimes = types.map(extToMime);
      var accepts = this.negotiator.mediaTypes(mimes.filter(validMime));
      var first = accepts[0];
      return first ? types[mimes.indexOf(first)] : false;
    };
    Accepts.prototype.encoding = Accepts.prototype.encodings = function(encodings_) {
      var encodings = encodings_;
      if (encodings && !Array.isArray(encodings)) {
        encodings = new Array(arguments.length);
        for (var i = 0; i < encodings.length; i++) {
          encodings[i] = arguments[i];
        }
      }
      if (!encodings || encodings.length === 0) {
        return this.negotiator.encodings();
      }
      return this.negotiator.encodings(encodings)[0] || false;
    };
    Accepts.prototype.charset = Accepts.prototype.charsets = function(charsets_) {
      var charsets = charsets_;
      if (charsets && !Array.isArray(charsets)) {
        charsets = new Array(arguments.length);
        for (var i = 0; i < charsets.length; i++) {
          charsets[i] = arguments[i];
        }
      }
      if (!charsets || charsets.length === 0) {
        return this.negotiator.charsets();
      }
      return this.negotiator.charsets(charsets)[0] || false;
    };
    Accepts.prototype.lang = Accepts.prototype.langs = Accepts.prototype.language = Accepts.prototype.languages = function(languages_) {
      var languages = languages_;
      if (languages && !Array.isArray(languages)) {
        languages = new Array(arguments.length);
        for (var i = 0; i < languages.length; i++) {
          languages[i] = arguments[i];
        }
      }
      if (!languages || languages.length === 0) {
        return this.negotiator.languages();
      }
      return this.negotiator.languages(languages)[0] || false;
    };
    function extToMime(type) {
      return type.indexOf("/") === -1 ? mime.lookup(type) : type;
    }
    function validMime(type) {
      return typeof type === "string";
    }
  }
});

// browser-external:net
var require_net = __commonJS({
  "browser-external:net"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "net" has been externalized for browser compatibility. Cannot access "net.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// ../../../node_modules/express/lib/request.js
var require_request = __commonJS({
  "../../../node_modules/express/lib/request.js"(exports2, module2) {
    "use strict";
    var accepts = require_accepts();
    var deprecate = require_browser2()("express");
    var isIP = require_net().isIP;
    var typeis = require_type_is();
    var http = require_http();
    var fresh = require_fresh();
    var parseRange = require_range_parser();
    var parse2 = require_parseurl();
    var proxyaddr = require_proxy_addr();
    var req = Object.create(http.IncomingMessage.prototype);
    module2.exports = req;
    req.get = req.header = function header(name) {
      if (!name) {
        throw new TypeError("name argument is required to req.get");
      }
      if (typeof name !== "string") {
        throw new TypeError("name must be a string to req.get");
      }
      var lc = name.toLowerCase();
      switch (lc) {
        case "referer":
        case "referrer":
          return this.headers.referrer || this.headers.referer;
        default:
          return this.headers[lc];
      }
    };
    req.accepts = function() {
      var accept = accepts(this);
      return accept.types.apply(accept, arguments);
    };
    req.acceptsEncodings = function() {
      var accept = accepts(this);
      return accept.encodings.apply(accept, arguments);
    };
    req.acceptsEncoding = deprecate.function(
      req.acceptsEncodings,
      "req.acceptsEncoding: Use acceptsEncodings instead"
    );
    req.acceptsCharsets = function() {
      var accept = accepts(this);
      return accept.charsets.apply(accept, arguments);
    };
    req.acceptsCharset = deprecate.function(
      req.acceptsCharsets,
      "req.acceptsCharset: Use acceptsCharsets instead"
    );
    req.acceptsLanguages = function() {
      var accept = accepts(this);
      return accept.languages.apply(accept, arguments);
    };
    req.acceptsLanguage = deprecate.function(
      req.acceptsLanguages,
      "req.acceptsLanguage: Use acceptsLanguages instead"
    );
    req.range = function range(size, options) {
      var range2 = this.get("Range");
      if (!range2)
        return;
      return parseRange(size, range2, options);
    };
    req.param = function param(name, defaultValue) {
      var params = this.params || {};
      var body = this.body || {};
      var query = this.query || {};
      var args = arguments.length === 1 ? "name" : "name, default";
      deprecate("req.param(" + args + "): Use req.params, req.body, or req.query instead");
      if (null != params[name] && params.hasOwnProperty(name))
        return params[name];
      if (null != body[name])
        return body[name];
      if (null != query[name])
        return query[name];
      return defaultValue;
    };
    req.is = function is(types) {
      var arr = types;
      if (!Array.isArray(types)) {
        arr = new Array(arguments.length);
        for (var i = 0; i < arr.length; i++) {
          arr[i] = arguments[i];
        }
      }
      return typeis(this, arr);
    };
    defineGetter(req, "protocol", function protocol() {
      var proto = this.connection.encrypted ? "https" : "http";
      var trust = this.app.get("trust proxy fn");
      if (!trust(this.connection.remoteAddress, 0)) {
        return proto;
      }
      var header = this.get("X-Forwarded-Proto") || proto;
      var index = header.indexOf(",");
      return index !== -1 ? header.substring(0, index).trim() : header.trim();
    });
    defineGetter(req, "secure", function secure() {
      return this.protocol === "https";
    });
    defineGetter(req, "ip", function ip() {
      var trust = this.app.get("trust proxy fn");
      return proxyaddr(this, trust);
    });
    defineGetter(req, "ips", function ips() {
      var trust = this.app.get("trust proxy fn");
      var addrs = proxyaddr.all(this, trust);
      addrs.reverse().pop();
      return addrs;
    });
    defineGetter(req, "subdomains", function subdomains() {
      var hostname = this.hostname;
      if (!hostname)
        return [];
      var offset = this.app.get("subdomain offset");
      var subdomains2 = !isIP(hostname) ? hostname.split(".").reverse() : [hostname];
      return subdomains2.slice(offset);
    });
    defineGetter(req, "path", function path() {
      return parse2(this).pathname;
    });
    defineGetter(req, "hostname", function hostname() {
      var trust = this.app.get("trust proxy fn");
      var host = this.get("X-Forwarded-Host");
      if (!host || !trust(this.connection.remoteAddress, 0)) {
        host = this.get("Host");
      } else if (host.indexOf(",") !== -1) {
        host = host.substring(0, host.indexOf(",")).trimRight();
      }
      if (!host)
        return;
      var offset = host[0] === "[" ? host.indexOf("]") + 1 : 0;
      var index = host.indexOf(":", offset);
      return index !== -1 ? host.substring(0, index) : host;
    });
    defineGetter(req, "host", deprecate.function(function host() {
      return this.hostname;
    }, "req.host: Use req.hostname instead"));
    defineGetter(req, "fresh", function() {
      var method = this.method;
      var res = this.res;
      var status = res.statusCode;
      if ("GET" !== method && "HEAD" !== method)
        return false;
      if (status >= 200 && status < 300 || 304 === status) {
        return fresh(this.headers, {
          "etag": res.get("ETag"),
          "last-modified": res.get("Last-Modified")
        });
      }
      return false;
    });
    defineGetter(req, "stale", function stale() {
      return !this.fresh;
    });
    defineGetter(req, "xhr", function xhr() {
      var val = this.get("X-Requested-With") || "";
      return val.toLowerCase() === "xmlhttprequest";
    });
    function defineGetter(obj, name, getter) {
      Object.defineProperty(obj, name, {
        configurable: true,
        enumerable: true,
        get: getter
      });
    }
  }
});

// ../../../node_modules/cookie-signature/index.js
var require_cookie_signature = __commonJS({
  "../../../node_modules/cookie-signature/index.js"(exports2) {
    var crypto2 = require_crypto();
    exports2.sign = function(val, secret) {
      if ("string" != typeof val)
        throw new TypeError("Cookie value must be provided as a string.");
      if ("string" != typeof secret)
        throw new TypeError("Secret string must be provided.");
      return val + "." + crypto2.createHmac("sha256", secret).update(val).digest("base64").replace(/\=+$/, "");
    };
    exports2.unsign = function(val, secret) {
      if ("string" != typeof val)
        throw new TypeError("Signed cookie string must be provided.");
      if ("string" != typeof secret)
        throw new TypeError("Secret string must be provided.");
      var str = val.slice(0, val.lastIndexOf(".")), mac = exports2.sign(str, secret);
      return sha1(mac) == sha1(val) ? str : false;
    };
    function sha1(str) {
      return crypto2.createHash("sha1").update(str).digest("hex");
    }
  }
});

// ../../../node_modules/cookie/index.js
var require_cookie = __commonJS({
  "../../../node_modules/cookie/index.js"(exports2) {
    "use strict";
    exports2.parse = parse2;
    exports2.serialize = serialize;
    var __toString = Object.prototype.toString;
    var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
    function parse2(str, options) {
      if (typeof str !== "string") {
        throw new TypeError("argument str must be a string");
      }
      var obj = {};
      var opt = options || {};
      var dec = opt.decode || decode;
      var index = 0;
      while (index < str.length) {
        var eqIdx = str.indexOf("=", index);
        if (eqIdx === -1) {
          break;
        }
        var endIdx = str.indexOf(";", index);
        if (endIdx === -1) {
          endIdx = str.length;
        } else if (endIdx < eqIdx) {
          index = str.lastIndexOf(";", eqIdx - 1) + 1;
          continue;
        }
        var key = str.slice(index, eqIdx).trim();
        if (void 0 === obj[key]) {
          var val = str.slice(eqIdx + 1, endIdx).trim();
          if (val.charCodeAt(0) === 34) {
            val = val.slice(1, -1);
          }
          obj[key] = tryDecode(val, dec);
        }
        index = endIdx + 1;
      }
      return obj;
    }
    function serialize(name, val, options) {
      var opt = options || {};
      var enc = opt.encode || encode;
      if (typeof enc !== "function") {
        throw new TypeError("option encode is invalid");
      }
      if (!fieldContentRegExp.test(name)) {
        throw new TypeError("argument name is invalid");
      }
      var value = enc(val);
      if (value && !fieldContentRegExp.test(value)) {
        throw new TypeError("argument val is invalid");
      }
      var str = name + "=" + value;
      if (null != opt.maxAge) {
        var maxAge = opt.maxAge - 0;
        if (isNaN(maxAge) || !isFinite(maxAge)) {
          throw new TypeError("option maxAge is invalid");
        }
        str += "; Max-Age=" + Math.floor(maxAge);
      }
      if (opt.domain) {
        if (!fieldContentRegExp.test(opt.domain)) {
          throw new TypeError("option domain is invalid");
        }
        str += "; Domain=" + opt.domain;
      }
      if (opt.path) {
        if (!fieldContentRegExp.test(opt.path)) {
          throw new TypeError("option path is invalid");
        }
        str += "; Path=" + opt.path;
      }
      if (opt.expires) {
        var expires = opt.expires;
        if (!isDate(expires) || isNaN(expires.valueOf())) {
          throw new TypeError("option expires is invalid");
        }
        str += "; Expires=" + expires.toUTCString();
      }
      if (opt.httpOnly) {
        str += "; HttpOnly";
      }
      if (opt.secure) {
        str += "; Secure";
      }
      if (opt.priority) {
        var priority = typeof opt.priority === "string" ? opt.priority.toLowerCase() : opt.priority;
        switch (priority) {
          case "low":
            str += "; Priority=Low";
            break;
          case "medium":
            str += "; Priority=Medium";
            break;
          case "high":
            str += "; Priority=High";
            break;
          default:
            throw new TypeError("option priority is invalid");
        }
      }
      if (opt.sameSite) {
        var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
        switch (sameSite) {
          case true:
            str += "; SameSite=Strict";
            break;
          case "lax":
            str += "; SameSite=Lax";
            break;
          case "strict":
            str += "; SameSite=Strict";
            break;
          case "none":
            str += "; SameSite=None";
            break;
          default:
            throw new TypeError("option sameSite is invalid");
        }
      }
      return str;
    }
    function decode(str) {
      return str.indexOf("%") !== -1 ? decodeURIComponent(str) : str;
    }
    function encode(val) {
      return encodeURIComponent(val);
    }
    function isDate(val) {
      return __toString.call(val) === "[object Date]" || val instanceof Date;
    }
    function tryDecode(str, decode2) {
      try {
        return decode2(str);
      } catch (e) {
        return str;
      }
    }
  }
});

// ../../../node_modules/vary/index.js
var require_vary = __commonJS({
  "../../../node_modules/vary/index.js"(exports2, module2) {
    "use strict";
    module2.exports = vary;
    module2.exports.append = append;
    var FIELD_NAME_REGEXP = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
    function append(header, field) {
      if (typeof header !== "string") {
        throw new TypeError("header argument is required");
      }
      if (!field) {
        throw new TypeError("field argument is required");
      }
      var fields = !Array.isArray(field) ? parse2(String(field)) : field;
      for (var j = 0; j < fields.length; j++) {
        if (!FIELD_NAME_REGEXP.test(fields[j])) {
          throw new TypeError("field argument contains an invalid header name");
        }
      }
      if (header === "*") {
        return header;
      }
      var val = header;
      var vals = parse2(header.toLowerCase());
      if (fields.indexOf("*") !== -1 || vals.indexOf("*") !== -1) {
        return "*";
      }
      for (var i = 0; i < fields.length; i++) {
        var fld = fields[i].toLowerCase();
        if (vals.indexOf(fld) === -1) {
          vals.push(fld);
          val = val ? val + ", " + fields[i] : fields[i];
        }
      }
      return val;
    }
    function parse2(header) {
      var end = 0;
      var list = [];
      var start = 0;
      for (var i = 0, len = header.length; i < len; i++) {
        switch (header.charCodeAt(i)) {
          case 32:
            if (start === end) {
              start = end = i + 1;
            }
            break;
          case 44:
            list.push(header.substring(start, end));
            start = end = i + 1;
            break;
          default:
            end = i + 1;
            break;
        }
      }
      list.push(header.substring(start, end));
      return list;
    }
    function vary(res, field) {
      if (!res || !res.getHeader || !res.setHeader) {
        throw new TypeError("res argument is required");
      }
      var val = res.getHeader("Vary") || "";
      var header = Array.isArray(val) ? val.join(", ") : String(val);
      if (val = append(header, field)) {
        res.setHeader("Vary", val);
      }
    }
  }
});

// ../../../node_modules/express/lib/response.js
var require_response = __commonJS({
  "../../../node_modules/express/lib/response.js"(exports2, module2) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var contentDisposition = require_content_disposition();
    var createError = require_http_errors();
    var deprecate = require_browser2()("express");
    var encodeUrl = require_encodeurl();
    var escapeHtml = require_escape_html();
    var http = require_http();
    var isAbsolute = require_utils6().isAbsolute;
    var onFinished = require_on_finished();
    var path = require_path();
    var statuses = require_statuses();
    var merge = require_utils_merge();
    var sign = require_cookie_signature().sign;
    var normalizeType = require_utils6().normalizeType;
    var normalizeTypes = require_utils6().normalizeTypes;
    var setCharset = require_utils6().setCharset;
    var cookie = require_cookie();
    var send = require_send();
    var extname = path.extname;
    var mime = send.mime;
    var resolve = path.resolve;
    var vary = require_vary();
    var res = Object.create(http.ServerResponse.prototype);
    module2.exports = res;
    var charsetRegExp = /;\s*charset\s*=/;
    res.status = function status(code) {
      if ((typeof code === "string" || Math.floor(code) !== code) && code > 99 && code < 1e3) {
        deprecate("res.status(" + JSON.stringify(code) + "): use res.status(" + Math.floor(code) + ") instead");
      }
      this.statusCode = code;
      return this;
    };
    res.links = function(links) {
      var link = this.get("Link") || "";
      if (link)
        link += ", ";
      return this.set("Link", link + Object.keys(links).map(function(rel) {
        return "<" + links[rel] + '>; rel="' + rel + '"';
      }).join(", "));
    };
    res.send = function send2(body) {
      var chunk = body;
      var encoding;
      var req = this.req;
      var type;
      var app2 = this.app;
      if (arguments.length === 2) {
        if (typeof arguments[0] !== "number" && typeof arguments[1] === "number") {
          deprecate("res.send(body, status): Use res.status(status).send(body) instead");
          this.statusCode = arguments[1];
        } else {
          deprecate("res.send(status, body): Use res.status(status).send(body) instead");
          this.statusCode = arguments[0];
          chunk = arguments[1];
        }
      }
      if (typeof chunk === "number" && arguments.length === 1) {
        if (!this.get("Content-Type")) {
          this.type("txt");
        }
        deprecate("res.send(status): Use res.sendStatus(status) instead");
        this.statusCode = chunk;
        chunk = statuses.message[chunk];
      }
      switch (typeof chunk) {
        case "string":
          if (!this.get("Content-Type")) {
            this.type("html");
          }
          break;
        case "boolean":
        case "number":
        case "object":
          if (chunk === null) {
            chunk = "";
          } else if (Buffer2.isBuffer(chunk)) {
            if (!this.get("Content-Type")) {
              this.type("bin");
            }
          } else {
            return this.json(chunk);
          }
          break;
      }
      if (typeof chunk === "string") {
        encoding = "utf8";
        type = this.get("Content-Type");
        if (typeof type === "string") {
          this.set("Content-Type", setCharset(type, "utf-8"));
        }
      }
      var etagFn = app2.get("etag fn");
      var generateETag = !this.get("ETag") && typeof etagFn === "function";
      var len;
      if (chunk !== void 0) {
        if (Buffer2.isBuffer(chunk)) {
          len = chunk.length;
        } else if (!generateETag && chunk.length < 1e3) {
          len = Buffer2.byteLength(chunk, encoding);
        } else {
          chunk = Buffer2.from(chunk, encoding);
          encoding = void 0;
          len = chunk.length;
        }
        this.set("Content-Length", len);
      }
      var etag;
      if (generateETag && len !== void 0) {
        if (etag = etagFn(chunk, encoding)) {
          this.set("ETag", etag);
        }
      }
      if (req.fresh)
        this.statusCode = 304;
      if (204 === this.statusCode || 304 === this.statusCode) {
        this.removeHeader("Content-Type");
        this.removeHeader("Content-Length");
        this.removeHeader("Transfer-Encoding");
        chunk = "";
      }
      if (this.statusCode === 205) {
        this.set("Content-Length", "0");
        this.removeHeader("Transfer-Encoding");
        chunk = "";
      }
      if (req.method === "HEAD") {
        this.end();
      } else {
        this.end(chunk, encoding);
      }
      return this;
    };
    res.json = function json(obj) {
      var val = obj;
      if (arguments.length === 2) {
        if (typeof arguments[1] === "number") {
          deprecate("res.json(obj, status): Use res.status(status).json(obj) instead");
          this.statusCode = arguments[1];
        } else {
          deprecate("res.json(status, obj): Use res.status(status).json(obj) instead");
          this.statusCode = arguments[0];
          val = arguments[1];
        }
      }
      var app2 = this.app;
      var escape2 = app2.get("json escape");
      var replacer = app2.get("json replacer");
      var spaces = app2.get("json spaces");
      var body = stringify(val, replacer, spaces, escape2);
      if (!this.get("Content-Type")) {
        this.set("Content-Type", "application/json");
      }
      return this.send(body);
    };
    res.jsonp = function jsonp(obj) {
      var val = obj;
      if (arguments.length === 2) {
        if (typeof arguments[1] === "number") {
          deprecate("res.jsonp(obj, status): Use res.status(status).jsonp(obj) instead");
          this.statusCode = arguments[1];
        } else {
          deprecate("res.jsonp(status, obj): Use res.status(status).jsonp(obj) instead");
          this.statusCode = arguments[0];
          val = arguments[1];
        }
      }
      var app2 = this.app;
      var escape2 = app2.get("json escape");
      var replacer = app2.get("json replacer");
      var spaces = app2.get("json spaces");
      var body = stringify(val, replacer, spaces, escape2);
      var callback = this.req.query[app2.get("jsonp callback name")];
      if (!this.get("Content-Type")) {
        this.set("X-Content-Type-Options", "nosniff");
        this.set("Content-Type", "application/json");
      }
      if (Array.isArray(callback)) {
        callback = callback[0];
      }
      if (typeof callback === "string" && callback.length !== 0) {
        this.set("X-Content-Type-Options", "nosniff");
        this.set("Content-Type", "text/javascript");
        callback = callback.replace(/[^\[\]\w$.]/g, "");
        if (body === void 0) {
          body = "";
        } else if (typeof body === "string") {
          body = body.replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
        }
        body = "/**/ typeof " + callback + " === 'function' && " + callback + "(" + body + ");";
      }
      return this.send(body);
    };
    res.sendStatus = function sendStatus(statusCode) {
      var body = statuses.message[statusCode] || String(statusCode);
      this.statusCode = statusCode;
      this.type("txt");
      return this.send(body);
    };
    res.sendFile = function sendFile(path2, options, callback) {
      var done = callback;
      var req = this.req;
      var res2 = this;
      var next = req.next;
      var opts = options || {};
      if (!path2) {
        throw new TypeError("path argument is required to res.sendFile");
      }
      if (typeof path2 !== "string") {
        throw new TypeError("path must be a string to res.sendFile");
      }
      if (typeof options === "function") {
        done = options;
        opts = {};
      }
      if (!opts.root && !isAbsolute(path2)) {
        throw new TypeError("path must be absolute or specify root to res.sendFile");
      }
      var pathname = encodeURI(path2);
      var file = send(req, pathname, opts);
      sendfile(res2, file, opts, function(err) {
        if (done)
          return done(err);
        if (err && err.code === "EISDIR")
          return next();
        if (err && err.code !== "ECONNABORTED" && err.syscall !== "write") {
          next(err);
        }
      });
    };
    res.sendfile = function(path2, options, callback) {
      var done = callback;
      var req = this.req;
      var res2 = this;
      var next = req.next;
      var opts = options || {};
      if (typeof options === "function") {
        done = options;
        opts = {};
      }
      var file = send(req, path2, opts);
      sendfile(res2, file, opts, function(err) {
        if (done)
          return done(err);
        if (err && err.code === "EISDIR")
          return next();
        if (err && err.code !== "ECONNABORTED" && err.syscall !== "write") {
          next(err);
        }
      });
    };
    res.sendfile = deprecate.function(
      res.sendfile,
      "res.sendfile: Use res.sendFile instead"
    );
    res.download = function download(path2, filename, options, callback) {
      var done = callback;
      var name = filename;
      var opts = options || null;
      if (typeof filename === "function") {
        done = filename;
        name = null;
        opts = null;
      } else if (typeof options === "function") {
        done = options;
        opts = null;
      }
      if (typeof filename === "object" && (typeof options === "function" || options === void 0)) {
        name = null;
        opts = filename;
      }
      var headers = {
        "Content-Disposition": contentDisposition(name || path2)
      };
      if (opts && opts.headers) {
        var keys = Object.keys(opts.headers);
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          if (key.toLowerCase() !== "content-disposition") {
            headers[key] = opts.headers[key];
          }
        }
      }
      opts = Object.create(opts);
      opts.headers = headers;
      var fullPath = !opts.root ? resolve(path2) : path2;
      return this.sendFile(fullPath, opts, done);
    };
    res.contentType = res.type = function contentType(type) {
      var ct = type.indexOf("/") === -1 ? mime.lookup(type) : type;
      return this.set("Content-Type", ct);
    };
    res.format = function(obj) {
      var req = this.req;
      var next = req.next;
      var keys = Object.keys(obj).filter(function(v) {
        return v !== "default";
      });
      var key = keys.length > 0 ? req.accepts(keys) : false;
      this.vary("Accept");
      if (key) {
        this.set("Content-Type", normalizeType(key).value);
        obj[key](req, this, next);
      } else if (obj.default) {
        obj.default(req, this, next);
      } else {
        next(createError(406, {
          types: normalizeTypes(keys).map(function(o) {
            return o.value;
          })
        }));
      }
      return this;
    };
    res.attachment = function attachment(filename) {
      if (filename) {
        this.type(extname(filename));
      }
      this.set("Content-Disposition", contentDisposition(filename));
      return this;
    };
    res.append = function append(field, val) {
      var prev = this.get(field);
      var value = val;
      if (prev) {
        value = Array.isArray(prev) ? prev.concat(val) : Array.isArray(val) ? [prev].concat(val) : [prev, val];
      }
      return this.set(field, value);
    };
    res.set = res.header = function header(field, val) {
      if (arguments.length === 2) {
        var value = Array.isArray(val) ? val.map(String) : String(val);
        if (field.toLowerCase() === "content-type") {
          if (Array.isArray(value)) {
            throw new TypeError("Content-Type cannot be set to an Array");
          }
          if (!charsetRegExp.test(value)) {
            var charset = mime.charsets.lookup(value.split(";")[0]);
            if (charset)
              value += "; charset=" + charset.toLowerCase();
          }
        }
        this.setHeader(field, value);
      } else {
        for (var key in field) {
          this.set(key, field[key]);
        }
      }
      return this;
    };
    res.get = function(field) {
      return this.getHeader(field);
    };
    res.clearCookie = function clearCookie(name, options) {
      var opts = merge({ expires: /* @__PURE__ */ new Date(1), path: "/" }, options);
      return this.cookie(name, "", opts);
    };
    res.cookie = function(name, value, options) {
      var opts = merge({}, options);
      var secret = this.req.secret;
      var signed = opts.signed;
      if (signed && !secret) {
        throw new Error('cookieParser("secret") required for signed cookies');
      }
      var val = typeof value === "object" ? "j:" + JSON.stringify(value) : String(value);
      if (signed) {
        val = "s:" + sign(val, secret);
      }
      if (opts.maxAge != null) {
        var maxAge = opts.maxAge - 0;
        if (!isNaN(maxAge)) {
          opts.expires = new Date(Date.now() + maxAge);
          opts.maxAge = Math.floor(maxAge / 1e3);
        }
      }
      if (opts.path == null) {
        opts.path = "/";
      }
      this.append("Set-Cookie", cookie.serialize(name, String(val), opts));
      return this;
    };
    res.location = function location(url) {
      var loc = url;
      if (url === "back") {
        loc = this.req.get("Referrer") || "/";
      }
      return this.set("Location", encodeUrl(loc));
    };
    res.redirect = function redirect(url) {
      var address = url;
      var body;
      var status = 302;
      if (arguments.length === 2) {
        if (typeof arguments[0] === "number") {
          status = arguments[0];
          address = arguments[1];
        } else {
          deprecate("res.redirect(url, status): Use res.redirect(status, url) instead");
          status = arguments[1];
        }
      }
      address = this.location(address).get("Location");
      this.format({
        text: function() {
          body = statuses.message[status] + ". Redirecting to " + address;
        },
        html: function() {
          var u = escapeHtml(address);
          body = "<p>" + statuses.message[status] + '. Redirecting to <a href="' + u + '">' + u + "</a></p>";
        },
        default: function() {
          body = "";
        }
      });
      this.statusCode = status;
      this.set("Content-Length", Buffer2.byteLength(body));
      if (this.req.method === "HEAD") {
        this.end();
      } else {
        this.end(body);
      }
    };
    res.vary = function(field) {
      if (!field || Array.isArray(field) && !field.length) {
        deprecate("res.vary(): Provide a field name");
        return this;
      }
      vary(this, field);
      return this;
    };
    res.render = function render(view, options, callback) {
      var app2 = this.req.app;
      var done = callback;
      var opts = options || {};
      var req = this.req;
      var self2 = this;
      if (typeof options === "function") {
        done = options;
        opts = {};
      }
      opts._locals = self2.locals;
      done = done || function(err, str) {
        if (err)
          return req.next(err);
        self2.send(str);
      };
      app2.render(view, opts, done);
    };
    function sendfile(res2, file, options, callback) {
      var done = false;
      var streaming;
      function onaborted() {
        if (done)
          return;
        done = true;
        var err = new Error("Request aborted");
        err.code = "ECONNABORTED";
        callback(err);
      }
      function ondirectory() {
        if (done)
          return;
        done = true;
        var err = new Error("EISDIR, read");
        err.code = "EISDIR";
        callback(err);
      }
      function onerror(err) {
        if (done)
          return;
        done = true;
        callback(err);
      }
      function onend() {
        if (done)
          return;
        done = true;
        callback();
      }
      function onfile() {
        streaming = false;
      }
      function onfinish(err) {
        if (err && err.code === "ECONNRESET")
          return onaborted();
        if (err)
          return onerror(err);
        if (done)
          return;
        setImmediate(function() {
          if (streaming !== false && !done) {
            onaborted();
            return;
          }
          if (done)
            return;
          done = true;
          callback();
        });
      }
      function onstream() {
        streaming = true;
      }
      file.on("directory", ondirectory);
      file.on("end", onend);
      file.on("error", onerror);
      file.on("file", onfile);
      file.on("stream", onstream);
      onFinished(res2, onfinish);
      if (options.headers) {
        file.on("headers", function headers(res3) {
          var obj = options.headers;
          var keys = Object.keys(obj);
          for (var i = 0; i < keys.length; i++) {
            var k = keys[i];
            res3.setHeader(k, obj[k]);
          }
        });
      }
      file.pipe(res2);
    }
    function stringify(value, replacer, spaces, escape2) {
      var json = replacer || spaces ? JSON.stringify(value, replacer, spaces) : JSON.stringify(value);
      if (escape2 && typeof json === "string") {
        json = json.replace(/[<>&]/g, function(c) {
          switch (c.charCodeAt(0)) {
            case 60:
              return "\\u003c";
            case 62:
              return "\\u003e";
            case 38:
              return "\\u0026";
            default:
              return c;
          }
        });
      }
      return json;
    }
  }
});

// ../../../node_modules/serve-static/index.js
var require_serve_static = __commonJS({
  "../../../node_modules/serve-static/index.js"(exports2, module2) {
    "use strict";
    var encodeUrl = require_encodeurl();
    var escapeHtml = require_escape_html();
    var parseUrl = require_parseurl();
    var resolve = require_path().resolve;
    var send = require_send();
    var url = require_url();
    module2.exports = serveStatic;
    module2.exports.mime = send.mime;
    function serveStatic(root, options) {
      if (!root) {
        throw new TypeError("root path required");
      }
      if (typeof root !== "string") {
        throw new TypeError("root path must be a string");
      }
      var opts = Object.create(options || null);
      var fallthrough = opts.fallthrough !== false;
      var redirect = opts.redirect !== false;
      var setHeaders = opts.setHeaders;
      if (setHeaders && typeof setHeaders !== "function") {
        throw new TypeError("option setHeaders must be function");
      }
      opts.maxage = opts.maxage || opts.maxAge || 0;
      opts.root = resolve(root);
      var onDirectory = redirect ? createRedirectDirectoryListener() : createNotFoundDirectoryListener();
      return function serveStatic2(req, res, next) {
        if (req.method !== "GET" && req.method !== "HEAD") {
          if (fallthrough) {
            return next();
          }
          res.statusCode = 405;
          res.setHeader("Allow", "GET, HEAD");
          res.setHeader("Content-Length", "0");
          res.end();
          return;
        }
        var forwardError = !fallthrough;
        var originalUrl = parseUrl.original(req);
        var path = parseUrl(req).pathname;
        if (path === "/" && originalUrl.pathname.substr(-1) !== "/") {
          path = "";
        }
        var stream = send(req, path, opts);
        stream.on("directory", onDirectory);
        if (setHeaders) {
          stream.on("headers", setHeaders);
        }
        if (fallthrough) {
          stream.on("file", function onFile() {
            forwardError = true;
          });
        }
        stream.on("error", function error(err) {
          if (forwardError || !(err.statusCode < 500)) {
            next(err);
            return;
          }
          next();
        });
        stream.pipe(res);
      };
    }
    function collapseLeadingSlashes(str) {
      for (var i = 0; i < str.length; i++) {
        if (str.charCodeAt(i) !== 47) {
          break;
        }
      }
      return i > 1 ? "/" + str.substr(i) : str;
    }
    function createHtmlDocument(title, body) {
      return '<!DOCTYPE html>\n<html lang="en">\n<head>\n<meta charset="utf-8">\n<title>' + title + "</title>\n</head>\n<body>\n<pre>" + body + "</pre>\n</body>\n</html>\n";
    }
    function createNotFoundDirectoryListener() {
      return function notFound() {
        this.error(404);
      };
    }
    function createRedirectDirectoryListener() {
      return function redirect(res) {
        if (this.hasTrailingSlash()) {
          this.error(404);
          return;
        }
        var originalUrl = parseUrl.original(this.req);
        originalUrl.path = null;
        originalUrl.pathname = collapseLeadingSlashes(originalUrl.pathname + "/");
        var loc = encodeUrl(url.format(originalUrl));
        var doc = createHtmlDocument("Redirecting", 'Redirecting to <a href="' + escapeHtml(loc) + '">' + escapeHtml(loc) + "</a>");
        res.statusCode = 301;
        res.setHeader("Content-Type", "text/html; charset=UTF-8");
        res.setHeader("Content-Length", Buffer.byteLength(doc));
        res.setHeader("Content-Security-Policy", "default-src 'none'");
        res.setHeader("X-Content-Type-Options", "nosniff");
        res.setHeader("Location", loc);
        res.end(doc);
      };
    }
  }
});

// ../../../node_modules/express/lib/express.js
var require_express = __commonJS({
  "../../../node_modules/express/lib/express.js"(exports2, module2) {
    "use strict";
    var bodyParser = require_body_parser();
    var EventEmitter = require_events().EventEmitter;
    var mixin = require_merge_descriptors();
    var proto = require_application();
    var Route = require_route();
    var Router = require_router();
    var req = require_request();
    var res = require_response();
    exports2 = module2.exports = createApplication;
    function createApplication() {
      var app2 = function(req2, res2, next) {
        app2.handle(req2, res2, next);
      };
      mixin(app2, EventEmitter.prototype, false);
      mixin(app2, proto, false);
      app2.request = Object.create(req, {
        app: { configurable: true, enumerable: true, writable: true, value: app2 }
      });
      app2.response = Object.create(res, {
        app: { configurable: true, enumerable: true, writable: true, value: app2 }
      });
      app2.init();
      return app2;
    }
    exports2.application = proto;
    exports2.request = req;
    exports2.response = res;
    exports2.Route = Route;
    exports2.Router = Router;
    exports2.json = bodyParser.json;
    exports2.query = require_query();
    exports2.raw = bodyParser.raw;
    exports2.static = require_serve_static();
    exports2.text = bodyParser.text;
    exports2.urlencoded = bodyParser.urlencoded;
    var removedMiddlewares = [
      "bodyParser",
      "compress",
      "cookieSession",
      "session",
      "logger",
      "cookieParser",
      "favicon",
      "responseTime",
      "errorHandler",
      "timeout",
      "methodOverride",
      "vhost",
      "csrf",
      "directory",
      "limit",
      "multipart",
      "staticCache"
    ];
    removedMiddlewares.forEach(function(name) {
      Object.defineProperty(exports2, name, {
        get: function() {
          throw new Error("Most middleware (like " + name + ") is no longer bundled with Express and must be installed separately. Please see https://github.com/senchalabs/connect#middleware.");
        },
        configurable: true
      });
    });
  }
});

// ../../../node_modules/express/index.js
var require_express2 = __commonJS({
  "../../../node_modules/express/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_express();
  }
});

// ../../../node_modules/object-assign/index.js
var require_object_assign = __commonJS({
  "../../../node_modules/object-assign/index.js"(exports2, module2) {
    "use strict";
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i = 0; i < 10; i++) {
          test2["_" + String.fromCharCode(i)] = i;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
          return test2[n];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    module2.exports = shouldUseNative() ? Object.assign : function(target, source) {
      var from;
      var to = toObject(target);
      var symbols;
      for (var s = 1; s < arguments.length; s++) {
        from = Object(arguments[s]);
        for (var key in from) {
          if (hasOwnProperty2.call(from, key)) {
            to[key] = from[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from);
          for (var i = 0; i < symbols.length; i++) {
            if (propIsEnumerable.call(from, symbols[i])) {
              to[symbols[i]] = from[symbols[i]];
            }
          }
        }
      }
      return to;
    };
  }
});

// ../../../node_modules/cors/lib/index.js
var require_lib7 = __commonJS({
  "../../../node_modules/cors/lib/index.js"(exports2, module2) {
    (function() {
      "use strict";
      var assign = require_object_assign();
      var vary = require_vary();
      var defaults = {
        origin: "*",
        methods: "GET,HEAD,PUT,PATCH,POST,DELETE",
        preflightContinue: false,
        optionsSuccessStatus: 204
      };
      function isString(s) {
        return typeof s === "string" || s instanceof String;
      }
      function isOriginAllowed(origin, allowedOrigin) {
        if (Array.isArray(allowedOrigin)) {
          for (var i = 0; i < allowedOrigin.length; ++i) {
            if (isOriginAllowed(origin, allowedOrigin[i])) {
              return true;
            }
          }
          return false;
        } else if (isString(allowedOrigin)) {
          return origin === allowedOrigin;
        } else if (allowedOrigin instanceof RegExp) {
          return allowedOrigin.test(origin);
        } else {
          return !!allowedOrigin;
        }
      }
      function configureOrigin(options, req) {
        var requestOrigin = req.headers.origin, headers = [], isAllowed;
        if (!options.origin || options.origin === "*") {
          headers.push([{
            key: "Access-Control-Allow-Origin",
            value: "*"
          }]);
        } else if (isString(options.origin)) {
          headers.push([{
            key: "Access-Control-Allow-Origin",
            value: options.origin
          }]);
          headers.push([{
            key: "Vary",
            value: "Origin"
          }]);
        } else {
          isAllowed = isOriginAllowed(requestOrigin, options.origin);
          headers.push([{
            key: "Access-Control-Allow-Origin",
            value: isAllowed ? requestOrigin : false
          }]);
          headers.push([{
            key: "Vary",
            value: "Origin"
          }]);
        }
        return headers;
      }
      function configureMethods(options) {
        var methods = options.methods;
        if (methods.join) {
          methods = options.methods.join(",");
        }
        return {
          key: "Access-Control-Allow-Methods",
          value: methods
        };
      }
      function configureCredentials(options) {
        if (options.credentials === true) {
          return {
            key: "Access-Control-Allow-Credentials",
            value: "true"
          };
        }
        return null;
      }
      function configureAllowedHeaders(options, req) {
        var allowedHeaders = options.allowedHeaders || options.headers;
        var headers = [];
        if (!allowedHeaders) {
          allowedHeaders = req.headers["access-control-request-headers"];
          headers.push([{
            key: "Vary",
            value: "Access-Control-Request-Headers"
          }]);
        } else if (allowedHeaders.join) {
          allowedHeaders = allowedHeaders.join(",");
        }
        if (allowedHeaders && allowedHeaders.length) {
          headers.push([{
            key: "Access-Control-Allow-Headers",
            value: allowedHeaders
          }]);
        }
        return headers;
      }
      function configureExposedHeaders(options) {
        var headers = options.exposedHeaders;
        if (!headers) {
          return null;
        } else if (headers.join) {
          headers = headers.join(",");
        }
        if (headers && headers.length) {
          return {
            key: "Access-Control-Expose-Headers",
            value: headers
          };
        }
        return null;
      }
      function configureMaxAge(options) {
        var maxAge = (typeof options.maxAge === "number" || options.maxAge) && options.maxAge.toString();
        if (maxAge && maxAge.length) {
          return {
            key: "Access-Control-Max-Age",
            value: maxAge
          };
        }
        return null;
      }
      function applyHeaders(headers, res) {
        for (var i = 0, n = headers.length; i < n; i++) {
          var header = headers[i];
          if (header) {
            if (Array.isArray(header)) {
              applyHeaders(header, res);
            } else if (header.key === "Vary" && header.value) {
              vary(res, header.value);
            } else if (header.value) {
              res.setHeader(header.key, header.value);
            }
          }
        }
      }
      function cors(options, req, res, next) {
        var headers = [], method = req.method && req.method.toUpperCase && req.method.toUpperCase();
        if (method === "OPTIONS") {
          headers.push(configureOrigin(options, req));
          headers.push(configureCredentials(options, req));
          headers.push(configureMethods(options, req));
          headers.push(configureAllowedHeaders(options, req));
          headers.push(configureMaxAge(options, req));
          headers.push(configureExposedHeaders(options, req));
          applyHeaders(headers, res);
          if (options.preflightContinue) {
            next();
          } else {
            res.statusCode = options.optionsSuccessStatus;
            res.setHeader("Content-Length", "0");
            res.end();
          }
        } else {
          headers.push(configureOrigin(options, req));
          headers.push(configureCredentials(options, req));
          headers.push(configureExposedHeaders(options, req));
          applyHeaders(headers, res);
          next();
        }
      }
      function middlewareWrapper(o) {
        var optionsCallback = null;
        if (typeof o === "function") {
          optionsCallback = o;
        } else {
          optionsCallback = function(req, cb) {
            cb(null, o);
          };
        }
        return function corsMiddleware(req, res, next) {
          optionsCallback(req, function(err, options) {
            if (err) {
              next(err);
            } else {
              var corsOptions = assign({}, defaults, options);
              var originCallback = null;
              if (corsOptions.origin && typeof corsOptions.origin === "function") {
                originCallback = corsOptions.origin;
              } else if (corsOptions.origin) {
                originCallback = function(origin, cb) {
                  cb(null, corsOptions.origin);
                };
              }
              if (originCallback) {
                originCallback(req.headers.origin, function(err2, origin) {
                  if (err2 || !origin) {
                    next(err2);
                  } else {
                    corsOptions.origin = origin;
                    cors(corsOptions, req, res, next);
                  }
                });
              } else {
                next();
              }
            }
          });
        };
      }
      module2.exports = middlewareWrapper;
    })();
  }
});

// ../../../node_modules/body-parser/node_modules/ms/index.js
var require_ms5 = __commonJS({
  "../../../node_modules/body-parser/node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse2(val);
      } else if (type === "number" && isNaN(val) === false) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse2(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      if (ms >= d) {
        return Math.round(ms / d) + "d";
      }
      if (ms >= h) {
        return Math.round(ms / h) + "h";
      }
      if (ms >= m) {
        return Math.round(ms / m) + "m";
      }
      if (ms >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      return plural(ms, d, "day") || plural(ms, h, "hour") || plural(ms, m, "minute") || plural(ms, s, "second") || ms + " ms";
    }
    function plural(ms, n, name) {
      if (ms < n) {
        return;
      }
      if (ms < n * 1.5) {
        return Math.floor(ms / n) + " " + name;
      }
      return Math.ceil(ms / n) + " " + name + "s";
    }
  }
});

// ../../../node_modules/body-parser/node_modules/debug/src/debug.js
var require_debug4 = __commonJS({
  "../../../node_modules/body-parser/node_modules/debug/src/debug.js"(exports2, module2) {
    exports2 = module2.exports = createDebug.debug = createDebug["default"] = createDebug;
    exports2.coerce = coerce;
    exports2.disable = disable;
    exports2.enable = enable;
    exports2.enabled = enabled;
    exports2.humanize = require_ms5();
    exports2.names = [];
    exports2.skips = [];
    exports2.formatters = {};
    var prevTime;
    function selectColor(namespace) {
      var hash = 0, i;
      for (i in namespace) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return exports2.colors[Math.abs(hash) % exports2.colors.length];
    }
    function createDebug(namespace) {
      function debug() {
        if (!debug.enabled)
          return;
        var self2 = debug;
        var curr = +/* @__PURE__ */ new Date();
        var ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        args[0] = exports2.coerce(args[0]);
        if ("string" !== typeof args[0]) {
          args.unshift("%O");
        }
        var index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
          if (match === "%%")
            return match;
          index++;
          var formatter = exports2.formatters[format];
          if ("function" === typeof formatter) {
            var val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        exports2.formatArgs.call(self2, args);
        var logFn = debug.log || exports2.log || console.log.bind(console);
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.enabled = exports2.enabled(namespace);
      debug.useColors = exports2.useColors();
      debug.color = selectColor(namespace);
      if ("function" === typeof exports2.init) {
        exports2.init(debug);
      }
      return debug;
    }
    function enable(namespaces) {
      exports2.save(namespaces);
      exports2.names = [];
      exports2.skips = [];
      var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      var len = split.length;
      for (var i = 0; i < len; i++) {
        if (!split[i])
          continue;
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          exports2.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          exports2.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      exports2.enable("");
    }
    function enabled(name) {
      var i, len;
      for (i = 0, len = exports2.skips.length; i < len; i++) {
        if (exports2.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = exports2.names.length; i < len; i++) {
        if (exports2.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error)
        return val.stack || val.message;
      return val;
    }
  }
});

// ../../../node_modules/body-parser/node_modules/debug/src/browser.js
var require_browser6 = __commonJS({
  "../../../node_modules/body-parser/node_modules/debug/src/browser.js"(exports2, module2) {
    exports2 = module2.exports = require_debug4();
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = "undefined" != typeof chrome && "undefined" != typeof chrome.storage ? chrome.storage.local : localstorage();
    exports2.colors = [
      "lightseagreen",
      "forestgreen",
      "goldenrod",
      "dodgerblue",
      "darkorchid",
      "crimson"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
        return true;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    exports2.formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (err) {
        return "[UnexpectedJSONParseError]: " + err.message;
      }
    };
    function formatArgs(args) {
      var useColors2 = this.useColors;
      args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports2.humanize(this.diff);
      if (!useColors2)
        return;
      var c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      var index = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function(match) {
        if ("%%" === match)
          return;
        index++;
        if ("%c" === match) {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    function log() {
      return "object" === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
    }
    function save(namespaces) {
      try {
        if (null == namespaces) {
          exports2.storage.removeItem("debug");
        } else {
          exports2.storage.debug = namespaces;
        }
      } catch (e) {
      }
    }
    function load() {
      var r;
      try {
        r = exports2.storage.debug;
      } catch (e) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    exports2.enable(load());
    function localstorage() {
      try {
        return window.localStorage;
      } catch (e) {
      }
    }
  }
});

// ../../../node_modules/raw-body/index.js
var require_raw_body2 = __commonJS({
  "../../../node_modules/raw-body/index.js"(exports2, module2) {
    "use strict";
    var asyncHooks = tryRequireAsyncHooks();
    var bytes = require_bytes();
    var createError = require_http_errors();
    var iconv = require_lib5();
    var unpipe = require_unpipe();
    module2.exports = getRawBody;
    var ICONV_ENCODING_MESSAGE_REGEXP = /^Encoding not recognized: /;
    function getDecoder(encoding) {
      if (!encoding)
        return null;
      try {
        return iconv.getDecoder(encoding);
      } catch (e) {
        if (!ICONV_ENCODING_MESSAGE_REGEXP.test(e.message))
          throw e;
        throw createError(415, "specified encoding unsupported", {
          encoding,
          type: "encoding.unsupported"
        });
      }
    }
    function getRawBody(stream, options, callback) {
      var done = callback;
      var opts = options || {};
      if (stream === void 0) {
        throw new TypeError("argument stream is required");
      } else if (typeof stream !== "object" || stream === null || typeof stream.on !== "function") {
        throw new TypeError("argument stream must be a stream");
      }
      if (options === true || typeof options === "string") {
        opts = {
          encoding: options
        };
      }
      if (typeof options === "function") {
        done = options;
        opts = {};
      }
      if (done !== void 0 && typeof done !== "function") {
        throw new TypeError("argument callback must be a function");
      }
      if (!done && !global.Promise) {
        throw new TypeError("argument callback is required");
      }
      var encoding = opts.encoding !== true ? opts.encoding : "utf-8";
      var limit = bytes.parse(opts.limit);
      var length = opts.length != null && !isNaN(opts.length) ? parseInt(opts.length, 10) : null;
      if (done) {
        return readStream(stream, encoding, length, limit, wrap2(done));
      }
      return new Promise(function executor(resolve, reject) {
        readStream(stream, encoding, length, limit, function onRead(err, buf) {
          if (err)
            return reject(err);
          resolve(buf);
        });
      });
    }
    function halt(stream) {
      unpipe(stream);
      if (typeof stream.pause === "function") {
        stream.pause();
      }
    }
    function readStream(stream, encoding, length, limit, callback) {
      var complete = false;
      var sync = true;
      if (limit !== null && length !== null && length > limit) {
        return done(createError(413, "request entity too large", {
          expected: length,
          length,
          limit,
          type: "entity.too.large"
        }));
      }
      var state = stream._readableState;
      if (stream._decoder || state && (state.encoding || state.decoder)) {
        return done(createError(500, "stream encoding should not be set", {
          type: "stream.encoding.set"
        }));
      }
      if (typeof stream.readable !== "undefined" && !stream.readable) {
        return done(createError(500, "stream is not readable", {
          type: "stream.not.readable"
        }));
      }
      var received = 0;
      var decoder;
      try {
        decoder = getDecoder(encoding);
      } catch (err) {
        return done(err);
      }
      var buffer = decoder ? "" : [];
      stream.on("aborted", onAborted);
      stream.on("close", cleanup);
      stream.on("data", onData);
      stream.on("end", onEnd);
      stream.on("error", onEnd);
      sync = false;
      function done() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        complete = true;
        if (sync) {
          process.nextTick(invokeCallback);
        } else {
          invokeCallback();
        }
        function invokeCallback() {
          cleanup();
          if (args[0]) {
            halt(stream);
          }
          callback.apply(null, args);
        }
      }
      function onAborted() {
        if (complete)
          return;
        done(createError(400, "request aborted", {
          code: "ECONNABORTED",
          expected: length,
          length,
          received,
          type: "request.aborted"
        }));
      }
      function onData(chunk) {
        if (complete)
          return;
        received += chunk.length;
        if (limit !== null && received > limit) {
          done(createError(413, "request entity too large", {
            limit,
            received,
            type: "entity.too.large"
          }));
        } else if (decoder) {
          buffer += decoder.write(chunk);
        } else {
          buffer.push(chunk);
        }
      }
      function onEnd(err) {
        if (complete)
          return;
        if (err)
          return done(err);
        if (length !== null && received !== length) {
          done(createError(400, "request size did not match content length", {
            expected: length,
            length,
            received,
            type: "request.size.invalid"
          }));
        } else {
          var string = decoder ? buffer + (decoder.end() || "") : Buffer.concat(buffer);
          done(null, string);
        }
      }
      function cleanup() {
        buffer = null;
        stream.removeListener("aborted", onAborted);
        stream.removeListener("data", onData);
        stream.removeListener("end", onEnd);
        stream.removeListener("error", onEnd);
        stream.removeListener("close", cleanup);
      }
    }
    function tryRequireAsyncHooks() {
      try {
        return require_async_hooks();
      } catch (e) {
        return {};
      }
    }
    function wrap2(fn) {
      var res;
      if (asyncHooks.AsyncResource) {
        res = new asyncHooks.AsyncResource(fn.name || "bound-anonymous-fn");
      }
      if (!res || !res.runInAsyncScope) {
        return fn;
      }
      return res.runInAsyncScope.bind(res, fn, null);
    }
  }
});

// ../../../node_modules/body-parser/lib/read.js
var require_read2 = __commonJS({
  "../../../node_modules/body-parser/lib/read.js"(exports2, module2) {
    "use strict";
    var createError = require_http_errors();
    var destroy = require_destroy();
    var getBody = require_raw_body2();
    var iconv = require_lib5();
    var onFinished = require_on_finished();
    var unpipe = require_unpipe();
    var zlib = require_zlib();
    module2.exports = read;
    function read(req, res, next, parse2, debug, options) {
      var length;
      var opts = options;
      var stream;
      req._body = true;
      var encoding = opts.encoding !== null ? opts.encoding : null;
      var verify = opts.verify;
      try {
        stream = contentstream(req, debug, opts.inflate);
        length = stream.length;
        stream.length = void 0;
      } catch (err) {
        return next(err);
      }
      opts.length = length;
      opts.encoding = verify ? null : encoding;
      if (opts.encoding === null && encoding !== null && !iconv.encodingExists(encoding)) {
        return next(createError(415, 'unsupported charset "' + encoding.toUpperCase() + '"', {
          charset: encoding.toLowerCase(),
          type: "charset.unsupported"
        }));
      }
      debug("read body");
      getBody(stream, opts, function(error, body) {
        if (error) {
          var _error;
          if (error.type === "encoding.unsupported") {
            _error = createError(415, 'unsupported charset "' + encoding.toUpperCase() + '"', {
              charset: encoding.toLowerCase(),
              type: "charset.unsupported"
            });
          } else {
            _error = createError(400, error);
          }
          if (stream !== req) {
            unpipe(req);
            destroy(stream, true);
          }
          dump(req, function onfinished() {
            next(createError(400, _error));
          });
          return;
        }
        if (verify) {
          try {
            debug("verify body");
            verify(req, res, body, encoding);
          } catch (err) {
            next(createError(403, err, {
              body,
              type: err.type || "entity.verify.failed"
            }));
            return;
          }
        }
        var str = body;
        try {
          debug("parse body");
          str = typeof body !== "string" && encoding !== null ? iconv.decode(body, encoding) : body;
          req.body = parse2(str);
        } catch (err) {
          next(createError(400, err, {
            body: str,
            type: err.type || "entity.parse.failed"
          }));
          return;
        }
        next();
      });
    }
    function contentstream(req, debug, inflate) {
      var encoding = (req.headers["content-encoding"] || "identity").toLowerCase();
      var length = req.headers["content-length"];
      var stream;
      debug('content-encoding "%s"', encoding);
      if (inflate === false && encoding !== "identity") {
        throw createError(415, "content encoding unsupported", {
          encoding,
          type: "encoding.unsupported"
        });
      }
      switch (encoding) {
        case "deflate":
          stream = zlib.createInflate();
          debug("inflate body");
          req.pipe(stream);
          break;
        case "gzip":
          stream = zlib.createGunzip();
          debug("gunzip body");
          req.pipe(stream);
          break;
        case "identity":
          stream = req;
          stream.length = length;
          break;
        default:
          throw createError(415, 'unsupported content encoding "' + encoding + '"', {
            encoding,
            type: "encoding.unsupported"
          });
      }
      return stream;
    }
    function dump(req, callback) {
      if (onFinished.isFinished(req)) {
        callback(null);
      } else {
        onFinished(req, callback);
        req.resume();
      }
    }
  }
});

// ../../../node_modules/body-parser/lib/types/json.js
var require_json2 = __commonJS({
  "../../../node_modules/body-parser/lib/types/json.js"(exports2, module2) {
    "use strict";
    var bytes = require_bytes();
    var contentType = require_content_type();
    var createError = require_http_errors();
    var debug = require_browser6()("body-parser:json");
    var read = require_read2();
    var typeis = require_type_is();
    module2.exports = json;
    var FIRST_CHAR_REGEXP = /^[\x20\x09\x0a\x0d]*([^\x20\x09\x0a\x0d])/;
    var JSON_SYNTAX_CHAR = "#";
    var JSON_SYNTAX_REGEXP = /#+/g;
    function json(options) {
      var opts = options || {};
      var limit = typeof opts.limit !== "number" ? bytes.parse(opts.limit || "100kb") : opts.limit;
      var inflate = opts.inflate !== false;
      var reviver = opts.reviver;
      var strict = opts.strict !== false;
      var type = opts.type || "application/json";
      var verify = opts.verify || false;
      if (verify !== false && typeof verify !== "function") {
        throw new TypeError("option verify must be function");
      }
      var shouldParse = typeof type !== "function" ? typeChecker(type) : type;
      function parse2(body) {
        if (body.length === 0) {
          return {};
        }
        if (strict) {
          var first = firstchar(body);
          if (first !== "{" && first !== "[") {
            debug("strict violation");
            throw createStrictSyntaxError(body, first);
          }
        }
        try {
          debug("parse json");
          return JSON.parse(body, reviver);
        } catch (e) {
          throw normalizeJsonSyntaxError(e, {
            message: e.message,
            stack: e.stack
          });
        }
      }
      return function jsonParser(req, res, next) {
        if (req._body) {
          debug("body already parsed");
          next();
          return;
        }
        req.body = req.body || {};
        if (!typeis.hasBody(req)) {
          debug("skip empty body");
          next();
          return;
        }
        debug("content-type %j", req.headers["content-type"]);
        if (!shouldParse(req)) {
          debug("skip parsing");
          next();
          return;
        }
        var charset = getCharset(req) || "utf-8";
        if (charset.slice(0, 4) !== "utf-") {
          debug("invalid charset");
          next(createError(415, 'unsupported charset "' + charset.toUpperCase() + '"', {
            charset,
            type: "charset.unsupported"
          }));
          return;
        }
        read(req, res, next, parse2, debug, {
          encoding: charset,
          inflate,
          limit,
          verify
        });
      };
    }
    function createStrictSyntaxError(str, char) {
      var index = str.indexOf(char);
      var partial = "";
      if (index !== -1) {
        partial = str.substring(0, index) + JSON_SYNTAX_CHAR;
        for (var i = index + 1; i < str.length; i++) {
          partial += JSON_SYNTAX_CHAR;
        }
      }
      try {
        JSON.parse(partial);
        throw new SyntaxError("strict violation");
      } catch (e) {
        return normalizeJsonSyntaxError(e, {
          message: e.message.replace(JSON_SYNTAX_REGEXP, function(placeholder) {
            return str.substring(index, index + placeholder.length);
          }),
          stack: e.stack
        });
      }
    }
    function firstchar(str) {
      var match = FIRST_CHAR_REGEXP.exec(str);
      return match ? match[1] : void 0;
    }
    function getCharset(req) {
      try {
        return (contentType.parse(req).parameters.charset || "").toLowerCase();
      } catch (e) {
        return void 0;
      }
    }
    function normalizeJsonSyntaxError(error, obj) {
      var keys = Object.getOwnPropertyNames(error);
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (key !== "stack" && key !== "message") {
          delete error[key];
        }
      }
      error.stack = obj.stack.replace(error.message, obj.message);
      error.message = obj.message;
      return error;
    }
    function typeChecker(type) {
      return function checkType(req) {
        return Boolean(typeis(req, type));
      };
    }
  }
});

// ../../../node_modules/body-parser/lib/types/raw.js
var require_raw2 = __commonJS({
  "../../../node_modules/body-parser/lib/types/raw.js"(exports2, module2) {
    "use strict";
    var bytes = require_bytes();
    var debug = require_browser6()("body-parser:raw");
    var read = require_read2();
    var typeis = require_type_is();
    module2.exports = raw;
    function raw(options) {
      var opts = options || {};
      var inflate = opts.inflate !== false;
      var limit = typeof opts.limit !== "number" ? bytes.parse(opts.limit || "100kb") : opts.limit;
      var type = opts.type || "application/octet-stream";
      var verify = opts.verify || false;
      if (verify !== false && typeof verify !== "function") {
        throw new TypeError("option verify must be function");
      }
      var shouldParse = typeof type !== "function" ? typeChecker(type) : type;
      function parse2(buf) {
        return buf;
      }
      return function rawParser(req, res, next) {
        if (req._body) {
          debug("body already parsed");
          next();
          return;
        }
        req.body = req.body || {};
        if (!typeis.hasBody(req)) {
          debug("skip empty body");
          next();
          return;
        }
        debug("content-type %j", req.headers["content-type"]);
        if (!shouldParse(req)) {
          debug("skip parsing");
          next();
          return;
        }
        read(req, res, next, parse2, debug, {
          encoding: null,
          inflate,
          limit,
          verify
        });
      };
    }
    function typeChecker(type) {
      return function checkType(req) {
        return Boolean(typeis(req, type));
      };
    }
  }
});

// ../../../node_modules/body-parser/lib/types/text.js
var require_text2 = __commonJS({
  "../../../node_modules/body-parser/lib/types/text.js"(exports2, module2) {
    "use strict";
    var bytes = require_bytes();
    var contentType = require_content_type();
    var debug = require_browser6()("body-parser:text");
    var read = require_read2();
    var typeis = require_type_is();
    module2.exports = text;
    function text(options) {
      var opts = options || {};
      var defaultCharset = opts.defaultCharset || "utf-8";
      var inflate = opts.inflate !== false;
      var limit = typeof opts.limit !== "number" ? bytes.parse(opts.limit || "100kb") : opts.limit;
      var type = opts.type || "text/plain";
      var verify = opts.verify || false;
      if (verify !== false && typeof verify !== "function") {
        throw new TypeError("option verify must be function");
      }
      var shouldParse = typeof type !== "function" ? typeChecker(type) : type;
      function parse2(buf) {
        return buf;
      }
      return function textParser(req, res, next) {
        if (req._body) {
          debug("body already parsed");
          next();
          return;
        }
        req.body = req.body || {};
        if (!typeis.hasBody(req)) {
          debug("skip empty body");
          next();
          return;
        }
        debug("content-type %j", req.headers["content-type"]);
        if (!shouldParse(req)) {
          debug("skip parsing");
          next();
          return;
        }
        var charset = getCharset(req) || defaultCharset;
        read(req, res, next, parse2, debug, {
          encoding: charset,
          inflate,
          limit,
          verify
        });
      };
    }
    function getCharset(req) {
      try {
        return (contentType.parse(req).parameters.charset || "").toLowerCase();
      } catch (e) {
        return void 0;
      }
    }
    function typeChecker(type) {
      return function checkType(req) {
        return Boolean(typeis(req, type));
      };
    }
  }
});

// ../../../node_modules/body-parser/lib/types/urlencoded.js
var require_urlencoded2 = __commonJS({
  "../../../node_modules/body-parser/lib/types/urlencoded.js"(exports2, module2) {
    "use strict";
    var bytes = require_bytes();
    var contentType = require_content_type();
    var createError = require_http_errors();
    var debug = require_browser6()("body-parser:urlencoded");
    var deprecate = require_browser2()("body-parser");
    var read = require_read2();
    var typeis = require_type_is();
    module2.exports = urlencoded;
    var parsers = /* @__PURE__ */ Object.create(null);
    function urlencoded(options) {
      var opts = options || {};
      if (opts.extended === void 0) {
        deprecate("undefined extended: provide extended option");
      }
      var extended = opts.extended !== false;
      var inflate = opts.inflate !== false;
      var limit = typeof opts.limit !== "number" ? bytes.parse(opts.limit || "100kb") : opts.limit;
      var type = opts.type || "application/x-www-form-urlencoded";
      var verify = opts.verify || false;
      if (verify !== false && typeof verify !== "function") {
        throw new TypeError("option verify must be function");
      }
      var queryparse = extended ? extendedparser(opts) : simpleparser(opts);
      var shouldParse = typeof type !== "function" ? typeChecker(type) : type;
      function parse2(body) {
        return body.length ? queryparse(body) : {};
      }
      return function urlencodedParser(req, res, next) {
        if (req._body) {
          debug("body already parsed");
          next();
          return;
        }
        req.body = req.body || {};
        if (!typeis.hasBody(req)) {
          debug("skip empty body");
          next();
          return;
        }
        debug("content-type %j", req.headers["content-type"]);
        if (!shouldParse(req)) {
          debug("skip parsing");
          next();
          return;
        }
        var charset = getCharset(req) || "utf-8";
        if (charset !== "utf-8") {
          debug("invalid charset");
          next(createError(415, 'unsupported charset "' + charset.toUpperCase() + '"', {
            charset,
            type: "charset.unsupported"
          }));
          return;
        }
        read(req, res, next, parse2, debug, {
          debug,
          encoding: charset,
          inflate,
          limit,
          verify
        });
      };
    }
    function extendedparser(options) {
      var parameterLimit = options.parameterLimit !== void 0 ? options.parameterLimit : 1e3;
      var parse2 = parser("qs");
      if (isNaN(parameterLimit) || parameterLimit < 1) {
        throw new TypeError("option parameterLimit must be a positive number");
      }
      if (isFinite(parameterLimit)) {
        parameterLimit = parameterLimit | 0;
      }
      return function queryparse(body) {
        var paramCount = parameterCount(body, parameterLimit);
        if (paramCount === void 0) {
          debug("too many parameters");
          throw createError(413, "too many parameters", {
            type: "parameters.too.many"
          });
        }
        var arrayLimit = Math.max(100, paramCount);
        debug("parse extended urlencoding");
        return parse2(body, {
          allowPrototypes: true,
          arrayLimit,
          depth: Infinity,
          parameterLimit
        });
      };
    }
    function getCharset(req) {
      try {
        return (contentType.parse(req).parameters.charset || "").toLowerCase();
      } catch (e) {
        return void 0;
      }
    }
    function parameterCount(body, limit) {
      var count = 0;
      var index = 0;
      while ((index = body.indexOf("&", index)) !== -1) {
        count++;
        index++;
        if (count === limit) {
          return void 0;
        }
      }
      return count;
    }
    function parser(name) {
      var mod2 = parsers[name];
      if (mod2 !== void 0) {
        return mod2.parse;
      }
      switch (name) {
        case "qs":
          mod2 = require_lib6();
          break;
        case "querystring":
          mod2 = require_querystring();
          break;
      }
      parsers[name] = mod2;
      return mod2.parse;
    }
    function simpleparser(options) {
      var parameterLimit = options.parameterLimit !== void 0 ? options.parameterLimit : 1e3;
      var parse2 = parser("querystring");
      if (isNaN(parameterLimit) || parameterLimit < 1) {
        throw new TypeError("option parameterLimit must be a positive number");
      }
      if (isFinite(parameterLimit)) {
        parameterLimit = parameterLimit | 0;
      }
      return function queryparse(body) {
        var paramCount = parameterCount(body, parameterLimit);
        if (paramCount === void 0) {
          debug("too many parameters");
          throw createError(413, "too many parameters", {
            type: "parameters.too.many"
          });
        }
        debug("parse urlencoding");
        return parse2(body, void 0, void 0, { maxKeys: parameterLimit });
      };
    }
    function typeChecker(type) {
      return function checkType(req) {
        return Boolean(typeis(req, type));
      };
    }
  }
});

// ../../../node_modules/body-parser/index.js
var require_body_parser2 = __commonJS({
  "../../../node_modules/body-parser/index.js"(exports2, module2) {
    "use strict";
    var deprecate = require_browser2()("body-parser");
    var parsers = /* @__PURE__ */ Object.create(null);
    exports2 = module2.exports = deprecate.function(
      bodyParser,
      "bodyParser: use individual json/urlencoded middlewares"
    );
    Object.defineProperty(exports2, "json", {
      configurable: true,
      enumerable: true,
      get: createParserGetter("json")
    });
    Object.defineProperty(exports2, "raw", {
      configurable: true,
      enumerable: true,
      get: createParserGetter("raw")
    });
    Object.defineProperty(exports2, "text", {
      configurable: true,
      enumerable: true,
      get: createParserGetter("text")
    });
    Object.defineProperty(exports2, "urlencoded", {
      configurable: true,
      enumerable: true,
      get: createParserGetter("urlencoded")
    });
    function bodyParser(options) {
      var opts = Object.create(options || null, {
        type: {
          configurable: true,
          enumerable: true,
          value: void 0,
          writable: true
        }
      });
      var _urlencoded = exports2.urlencoded(opts);
      var _json = exports2.json(opts);
      return function bodyParser2(req, res, next) {
        _json(req, res, function(err) {
          if (err)
            return next(err);
          _urlencoded(req, res, next);
        });
      };
    }
    function createParserGetter(name) {
      return function get() {
        return loadParser(name);
      };
    }
    function loadParser(parserName) {
      var parser = parsers[parserName];
      if (parser !== void 0) {
        return parser;
      }
      switch (parserName) {
        case "json":
          parser = require_json2();
          break;
        case "raw":
          parser = require_raw2();
          break;
        case "text":
          parser = require_text2();
          break;
        case "urlencoded":
          parser = require_urlencoded2();
          break;
      }
      return parsers[parserName] = parser;
    }
  }
});

// ../../../node_modules/apollo-server-express/dist/ApolloServer.js
var require_ApolloServer2 = __commonJS({
  "../../../node_modules/apollo-server-express/dist/ApolloServer.js"(exports2) {
    "use strict";
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApolloServer = void 0;
    var express_1 = __importDefault2(require_express2());
    var cors_1 = __importDefault2(require_lib7());
    var body_parser_1 = require_body_parser2();
    var apollo_server_core_1 = require_dist11();
    var accepts_1 = __importDefault2(require_accepts());
    var apollo_server_core_2 = require_dist11();
    var ApolloServer = class extends apollo_server_core_1.ApolloServerBase {
      async createGraphQLServerOptions(req, res) {
        const contextParams = { req, res };
        return super.graphQLServerOptions(contextParams);
      }
      applyMiddleware({ app: app2, ...rest }) {
        this.assertStarted("applyMiddleware");
        app2.use(this.getMiddleware(rest));
      }
      getMiddleware({ path, cors, bodyParserConfig, disableHealthCheck, onHealthCheck, __internal_healthCheckPath } = {}) {
        if (!path)
          path = "/graphql";
        this.assertStarted("getMiddleware");
        const router = express_1.default.Router();
        if (!disableHealthCheck && __internal_healthCheckPath !== null) {
          router.use(__internal_healthCheckPath !== null && __internal_healthCheckPath !== void 0 ? __internal_healthCheckPath : "/.well-known/apollo/server-health", (req, res) => {
            res.type("application/health+json");
            if (onHealthCheck) {
              onHealthCheck(req).then(() => {
                res.json({ status: "pass" });
              }).catch(() => {
                res.status(503).json({ status: "fail" });
              });
            } else {
              res.json({ status: "pass" });
            }
          });
        }
        this.graphqlPath = path;
        if (cors === true) {
          router.use(path, (0, cors_1.default)());
        } else if (cors !== false) {
          router.use(path, (0, cors_1.default)(cors));
        }
        if (bodyParserConfig === true) {
          router.use(path, (0, body_parser_1.json)());
        } else if (bodyParserConfig !== false) {
          router.use(path, (0, body_parser_1.json)(bodyParserConfig));
        }
        const landingPage = this.getLandingPage();
        router.use(path, (req, res, next) => {
          if (landingPage && prefersHtml(req)) {
            res.setHeader("Content-Type", "text/html");
            res.write(landingPage.html);
            res.end();
            return;
          }
          if (!req.body) {
            res.status(500);
            if (bodyParserConfig === false) {
              res.send("`res.body` is not set; you passed `bodyParserConfig: false`, but you still need to use `body-parser` middleware yourself.");
            } else {
              res.send("`res.body` is not set even though Apollo Server installed `body-parser` middleware; this shouldn't happen!");
            }
            return;
          }
          (0, apollo_server_core_1.runHttpQuery)([], {
            method: req.method,
            options: () => this.createGraphQLServerOptions(req, res),
            query: req.method === "POST" ? req.body : req.query,
            request: (0, apollo_server_core_1.convertNodeHttpToRequest)(req)
          }, this.csrfPreventionRequestHeaders).then(({ graphqlResponse, responseInit }) => {
            if (responseInit.headers) {
              for (const [name, value] of Object.entries(responseInit.headers)) {
                res.setHeader(name, value);
              }
            }
            res.statusCode = responseInit.status || 200;
            if (typeof res.send === "function") {
              res.send(graphqlResponse);
            } else {
              res.end(graphqlResponse);
            }
          }, (error) => {
            if (!(0, apollo_server_core_1.isHttpQueryError)(error)) {
              return next(error);
            }
            if (error.headers) {
              for (const [name, value] of Object.entries(error.headers)) {
                res.setHeader(name, value);
              }
            }
            res.statusCode = error.statusCode;
            if (typeof res.send === "function") {
              res.send(error.message);
            } else {
              res.end(error.message);
            }
          });
        });
        return router;
      }
    };
    exports2.ApolloServer = ApolloServer;
    function prefersHtml(req) {
      if (req.method !== "GET") {
        return false;
      }
      const accept = (0, accepts_1.default)(req);
      const types = accept.types();
      return types.find((x) => x === "text/html" || x === "application/json") === "text/html";
    }
  }
});

// ../../../node_modules/apollo-server-express/dist/index.js
var require_dist12 = __commonJS({
  "../../../node_modules/apollo-server-express/dist/index.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApolloServer = exports2.UserInputError = exports2.ForbiddenError = exports2.AuthenticationError = exports2.ValidationError = exports2.SyntaxError = exports2.toApolloError = exports2.ApolloError = exports2.gql = void 0;
    var apollo_server_core_1 = require_dist11();
    Object.defineProperty(exports2, "gql", { enumerable: true, get: function() {
      return apollo_server_core_1.gql;
    } });
    Object.defineProperty(exports2, "ApolloError", { enumerable: true, get: function() {
      return apollo_server_core_1.ApolloError;
    } });
    Object.defineProperty(exports2, "toApolloError", { enumerable: true, get: function() {
      return apollo_server_core_1.toApolloError;
    } });
    Object.defineProperty(exports2, "SyntaxError", { enumerable: true, get: function() {
      return apollo_server_core_1.SyntaxError;
    } });
    Object.defineProperty(exports2, "ValidationError", { enumerable: true, get: function() {
      return apollo_server_core_1.ValidationError;
    } });
    Object.defineProperty(exports2, "AuthenticationError", { enumerable: true, get: function() {
      return apollo_server_core_1.AuthenticationError;
    } });
    Object.defineProperty(exports2, "ForbiddenError", { enumerable: true, get: function() {
      return apollo_server_core_1.ForbiddenError;
    } });
    Object.defineProperty(exports2, "UserInputError", { enumerable: true, get: function() {
      return apollo_server_core_1.UserInputError;
    } });
    var ApolloServer_1 = require_ApolloServer2();
    Object.defineProperty(exports2, "ApolloServer", { enumerable: true, get: function() {
      return ApolloServer_1.ApolloServer;
    } });
    var cors_1 = require_lib7();
    var body_parser_1 = require_body_parser2();
  }
});
export default require_dist12();
/*! Bundled license information:

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

depd/lib/browser/index.js:
  (*!
   * depd
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

bytes/index.js:
  (*!
   * bytes
   * Copyright(c) 2012-2014 TJ Holowaychuk
   * Copyright(c) 2015 Jed Watson
   * MIT Licensed
   *)

content-type/index.js:
  (*!
   * content-type
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

statuses/index.js:
  (*!
   * statuses
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2016 Douglas Christopher Wilson
   * MIT Licensed
   *)

toidentifier/index.js:
  (*!
   * toidentifier
   * Copyright(c) 2016 Douglas Christopher Wilson
   * MIT Licensed
   *)

http-errors/index.js:
  (*!
   * http-errors
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2016 Douglas Christopher Wilson
   * MIT Licensed
   *)

destroy/index.js:
  (*!
   * destroy
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015-2022 Douglas Christopher Wilson
   * MIT Licensed
   *)

unpipe/index.js:
  (*!
   * unpipe
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

raw-body/index.js:
  (*!
   * raw-body
   * Copyright(c) 2013-2014 Jonathan Ong
   * Copyright(c) 2014-2022 Douglas Christopher Wilson
   * MIT Licensed
   *)

ee-first/index.js:
  (*!
   * ee-first
   * Copyright(c) 2014 Jonathan Ong
   * MIT Licensed
   *)

on-finished/index.js:
  (*!
   * on-finished
   * Copyright(c) 2013 Jonathan Ong
   * Copyright(c) 2014 Douglas Christopher Wilson
   * MIT Licensed
   *)

body-parser/lib/read.js:
  (*!
   * body-parser
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

media-typer/index.js:
  (*!
   * media-typer
   * Copyright(c) 2014 Douglas Christopher Wilson
   * MIT Licensed
   *)

mime-db/index.js:
  (*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015-2022 Douglas Christopher Wilson
   * MIT Licensed
   *)

mime-types/index.js:
  (*!
   * mime-types
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

type-is/index.js:
  (*!
   * type-is
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

body-parser/lib/types/json.js:
  (*!
   * body-parser
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

body-parser/lib/types/raw.js:
  (*!
   * body-parser
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

body-parser/lib/types/text.js:
  (*!
   * body-parser
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

body-parser/lib/types/urlencoded.js:
  (*!
   * body-parser
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

body-parser/index.js:
  (*!
   * body-parser
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

merge-descriptors/index.js:
  (*!
   * merge-descriptors
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

encodeurl/index.js:
  (*!
   * encodeurl
   * Copyright(c) 2016 Douglas Christopher Wilson
   * MIT Licensed
   *)

escape-html/index.js:
  (*!
   * escape-html
   * Copyright(c) 2012-2013 TJ Holowaychuk
   * Copyright(c) 2015 Andreas Lubbe
   * Copyright(c) 2015 Tiancheng "Timothy" Gu
   * MIT Licensed
   *)

parseurl/index.js:
  (*!
   * parseurl
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2014-2017 Douglas Christopher Wilson
   * MIT Licensed
   *)

finalhandler/index.js:
  (*!
   * finalhandler
   * Copyright(c) 2014-2022 Douglas Christopher Wilson
   * MIT Licensed
   *)

express/lib/router/layer.js:
  (*!
   * express
   * Copyright(c) 2009-2013 TJ Holowaychuk
   * Copyright(c) 2013 Roman Shtylman
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

methods/index.js:
  (*!
   * methods
   * Copyright(c) 2013-2014 TJ Holowaychuk
   * Copyright(c) 2015-2016 Douglas Christopher Wilson
   * MIT Licensed
   *)

express/lib/router/route.js:
  (*!
   * express
   * Copyright(c) 2009-2013 TJ Holowaychuk
   * Copyright(c) 2013 Roman Shtylman
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

express/lib/router/index.js:
  (*!
   * express
   * Copyright(c) 2009-2013 TJ Holowaychuk
   * Copyright(c) 2013 Roman Shtylman
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

express/lib/middleware/init.js:
  (*!
   * express
   * Copyright(c) 2009-2013 TJ Holowaychuk
   * Copyright(c) 2013 Roman Shtylman
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

express/lib/middleware/query.js:
  (*!
   * express
   * Copyright(c) 2009-2013 TJ Holowaychuk
   * Copyright(c) 2013 Roman Shtylman
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

express/lib/view.js:
  (*!
   * express
   * Copyright(c) 2009-2013 TJ Holowaychuk
   * Copyright(c) 2013 Roman Shtylman
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

content-disposition/index.js:
  (*!
   * content-disposition
   * Copyright(c) 2014-2017 Douglas Christopher Wilson
   * MIT Licensed
   *)

etag/index.js:
  (*!
   * etag
   * Copyright(c) 2014-2016 Douglas Christopher Wilson
   * MIT Licensed
   *)

fresh/index.js:
  (*!
   * fresh
   * Copyright(c) 2012 TJ Holowaychuk
   * Copyright(c) 2016-2017 Douglas Christopher Wilson
   * MIT Licensed
   *)

range-parser/index.js:
  (*!
   * range-parser
   * Copyright(c) 2012-2014 TJ Holowaychuk
   * Copyright(c) 2015-2016 Douglas Christopher Wilson
   * MIT Licensed
   *)

send/index.js:
  (*!
   * send
   * Copyright(c) 2012 TJ Holowaychuk
   * Copyright(c) 2014-2022 Douglas Christopher Wilson
   * MIT Licensed
   *)

forwarded/index.js:
  (*!
   * forwarded
   * Copyright(c) 2014-2017 Douglas Christopher Wilson
   * MIT Licensed
   *)

proxy-addr/index.js:
  (*!
   * proxy-addr
   * Copyright(c) 2014-2016 Douglas Christopher Wilson
   * MIT Licensed
   *)

express/lib/utils.js:
  (*!
   * express
   * Copyright(c) 2009-2013 TJ Holowaychuk
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

express/lib/application.js:
  (*!
   * express
   * Copyright(c) 2009-2013 TJ Holowaychuk
   * Copyright(c) 2013 Roman Shtylman
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

negotiator/index.js:
  (*!
   * negotiator
   * Copyright(c) 2012 Federico Romero
   * Copyright(c) 2012-2014 Isaac Z. Schlueter
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

accepts/index.js:
  (*!
   * accepts
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

express/lib/request.js:
  (*!
   * express
   * Copyright(c) 2009-2013 TJ Holowaychuk
   * Copyright(c) 2013 Roman Shtylman
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

cookie/index.js:
  (*!
   * cookie
   * Copyright(c) 2012-2014 Roman Shtylman
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

vary/index.js:
  (*!
   * vary
   * Copyright(c) 2014-2017 Douglas Christopher Wilson
   * MIT Licensed
   *)

express/lib/response.js:
  (*!
   * express
   * Copyright(c) 2009-2013 TJ Holowaychuk
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

serve-static/index.js:
  (*!
   * serve-static
   * Copyright(c) 2010 Sencha Inc.
   * Copyright(c) 2011 TJ Holowaychuk
   * Copyright(c) 2014-2016 Douglas Christopher Wilson
   * MIT Licensed
   *)

express/lib/express.js:
  (*!
   * express
   * Copyright(c) 2009-2013 TJ Holowaychuk
   * Copyright(c) 2013 Roman Shtylman
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

express/index.js:
  (*!
   * express
   * Copyright(c) 2009-2013 TJ Holowaychuk
   * Copyright(c) 2013 Roman Shtylman
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

object-assign/index.js:
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)

raw-body/index.js:
  (*!
   * raw-body
   * Copyright(c) 2013-2014 Jonathan Ong
   * Copyright(c) 2014-2022 Douglas Christopher Wilson
   * MIT Licensed
   *)

body-parser/lib/read.js:
  (*!
   * body-parser
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

body-parser/lib/types/json.js:
  (*!
   * body-parser
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

body-parser/lib/types/raw.js:
  (*!
   * body-parser
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

body-parser/lib/types/text.js:
  (*!
   * body-parser
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

body-parser/lib/types/urlencoded.js:
  (*!
   * body-parser
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

body-parser/index.js:
  (*!
   * body-parser
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   *)
*/
//# sourceMappingURL=apollo-server-express.js.map
